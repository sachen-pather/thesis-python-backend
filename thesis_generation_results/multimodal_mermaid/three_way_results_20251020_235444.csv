circuit_name,category,complexity,original_prompt,model,prompt_only_verilog,prompt_only_generation_success,prompt_only_lines_of_code,prompt_only_has_testbench,prompt_only_compilation_success,prompt_only_simulation_success,prompt_only_vae_verdict,prompt_only_vae_confidence,prompt_only_consensus_anomalous,prompt_only_generation_time,prompt_only_simulation_time,mermaid_only_mermaid,mermaid_only_verilog,mermaid_only_generation_success,mermaid_only_lines_of_code,mermaid_only_has_testbench,mermaid_only_compilation_success,mermaid_only_simulation_success,mermaid_only_vae_verdict,mermaid_only_vae_confidence,mermaid_only_consensus_anomalous,mermaid_only_generation_time,mermaid_only_simulation_time,combined_prompt,combined_verilog,combined_generation_success,combined_lines_of_code,combined_has_testbench,combined_compilation_success,combined_simulation_success,combined_vae_verdict,combined_vae_confidence,combined_consensus_anomalous,combined_generation_time,combined_simulation_time,best_approach,correctness_ranking,simulation_ranking
combined,Combinational,simple,"Design a 2-to-1 multiplexer with inputs a, b, select sel, and output out. Include testbench testing all combinations.",claude,"`timescale 1ns/1ps

module mux2to1 (
    input wire a,
    input wire b,
    input wire sel,
    output reg out
);

always @(*) begin
    case (sel)
        1'b0: out = a;
        1'b1: out = b;
        default: out = a;
    endcase
end

endmodule

module testbench;
    reg a, b, sel;
    wire out;
    
    mux2to1 dut (
        .a(a),
        .b(b),
        .sel(sel),
        .out(out)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        // Test all combinations
        a = 0; b = 0; sel = 0; #10;
        a = 0; b = 0; sel = 1; #10;
        a = 0; b = 1; sel = 0; #10;
        a = 0; b = 1; sel = 1; #10;
        a = 1; b = 0; sel = 0; #10;
        a = 1; b = 0; sel = 1; #10;
        a = 1; b = 1; sel = 0; #10;
        a = 1; b = 1; sel = 1; #10;
        
        $finish;
    end
    
    initial begin
        $monitor(""Time=%0t a=%b b=%b sel=%b out=%b"",
                 $time, a, b, sel, out);
    end
endmodule",True,52,True,True,True,False,0.4,False,5.066791534423828,7.126291751861572,"graph LR
    A[Input A] --> MUX{2:1 MUX}
    B[Input B] --> MUX
    SEL[Select] --> MUX
    MUX --> OUT[Output]
    TB[[Testbench]]
    TB --> |Test A=0,B=0,SEL=0|MUX
    TB --> |Test A=0,B=1,SEL=0|MUX
    TB --> |Test A=1,B=0,SEL=0|MUX
    TB --> |Test A=1,B=1,SEL=0|MUX
    TB --> |Test A=0,B=0,SEL=1|MUX
    TB --> |Test A=0,B=1,SEL=1|MUX
    TB --> |Test A=1,B=0,SEL=1|MUX
    TB --> |Test A=1,B=1,SEL=1|MUX","`timescale 1ns/1ps

module mux2to1(
    input wire a,
    input wire b,
    input wire sel,
    output reg y
);

always @(a or b or sel) begin
    case(sel)
        1'b0: y = a;
        1'b1: y = b;
        default: y = 1'bx;
    endcase
end

endmodule

module testbench;
    reg a, b, sel;
    wire y;
    
    mux2to1 dut(
        .a(a),
        .b(b),
        .sel(sel),
        .y(y)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        // Test cases
        a = 0; b = 0; sel = 0; #10;
        a = 0; b = 1; sel = 0; #10;
        a = 1; b = 0; sel = 0; #10;
        a = 1; b = 1; sel = 0; #10;
        a = 0; b = 0; sel = 1; #10;
        a = 0; b = 1; sel = 1; #10;
        a = 1; b = 0; sel = 1; #10;
        a = 1; b = 1; sel = 1; #10;
        
        $finish;
    end
    
    initial begin
        $monitor(""Time=%0t a=%b b=%b sel=%b y=%b"", 
                 $time, a, b, sel, y);
    end
endmodule",True,52,True,True,True,False,0.4,False,8.622993230819702,6.298154354095459,"Design a 2-to-1 multiplexer with inputs a, b, select sel, and output out. Include testbench testing all combinations.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph LR
    A[Input A] --> MUX{2:1 MUX}
    B[Input B] --> MUX
    SEL[Select] --> MUX
    MUX --> OUT[Output]
    TB[[Testbench]]
    TB --> |Test A=0,B=0,SEL=0|MUX
    TB --> |Test A=0,B=1,SEL=0|MUX
    TB --> |Test A=1,B=0,SEL=0|MUX
    TB --> |Test A=1,B=1,SEL=0|MUX
    TB --> |Test A=0,B=0,SEL=1|MUX
    TB --> |Test A=0,B=1,SEL=1|MUX
    TB --> |Test A=1,B=0,SEL=1|MUX
    TB --> |Test A=1,B=1,SEL=1|MUX
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module mux2to1(
    input wire a,
    input wire b,
    input wire sel,
    output reg out
);

always @(*) begin
    if (sel)
        out = b;
    else
        out = a;
end

endmodule

module testbench;
    reg a, b, sel;
    wire out;
    
    mux2to1 dut (
        .a(a),
        .b(b),
        .sel(sel),
        .out(out)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        // Test all input combinations
        {a, b, sel} = 3'b000; #10;
        {a, b, sel} = 3'b001; #10;
        {a, b, sel} = 3'b010; #10;
        {a, b, sel} = 3'b011; #10;
        {a, b, sel} = 3'b100; #10;
        {a, b, sel} = 3'b101; #10;
        {a, b, sel} = 3'b110; #10;
        {a, b, sel} = 3'b111; #10;
        
        $finish;
    end
    
    initial begin
        $monitor(""Time=%0t a=%b b=%b sel=%b out=%b"",
                 $time, a, b, sel, out);
    end
endmodule",True,51,True,True,True,False,0.4,False,5.656926393508911,6.650712013244629,tie,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,Combinational,simple,"Design a 2-to-1 multiplexer with inputs a, b, select sel, and output out. Include testbench testing all combinations.",gpt-4o,"`timescale 1ns/1ps

module mux_2to1(
    input wire a,
    input wire b,
    input wire sel,
    output reg out
);

always @(*) begin
    if (sel)
        out = b;
    else
        out = a;
end

endmodule

module testbench;
    reg a, b, sel;
    wire out;
    
    mux_2to1 dut (
        .a(a),
        .b(b),
        .sel(sel),
        .out(out)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        a = 0; b = 0; sel = 0;
        #10 a = 0; b = 1; sel = 0;
        #10 a = 1; b = 0; sel = 0;
        #10 a = 1; b = 1; sel = 0;
        #10 a = 0; b = 0; sel = 1;
        #10 a = 0; b = 1; sel = 1;
        #10 a = 1; b = 0; sel = 1;
        #10 a = 1; b = 1; sel = 1;
        #10 $finish;
    end
    
    initial begin
        $monitor(""Time=%0t a=%b b=%b sel=%b out=%b"", 
                 $time, a, b, sel, out);
    end
endmodule",True,49,True,True,True,False,0.4,False,8.791026592254639,8.0978262424469,"graph LR
    SEL[Select (sel)] --> MUX{2-to-1 MUX}
    A[Input a] --> MUX
    B[Input b] --> MUX
    MUX --> OUT[Output (out)]

    subgraph Testbench
        direction TB
        TB_CLK[Clock] --> TB_CTRL[Control Logic]
        TB_RST[Reset] --> TB_CTRL
        TB_CTRL --> TB_SEL[Select Signal]
        TB_CTRL --> TB_A[Test Input a]
        TB_CTRL --> TB_B[Test Input b]
        TB_SEL --> MUX
        TB_A --> MUX
        TB_B --> MUX
    end","`timescale 1ns/1ps

module mux_2to1(
    input wire sel,
    input wire a,
    input wire b,
    output wire out
);

assign out = sel ? b : a;

endmodule

module testbench;
    reg clk, rst, sel, a, b;
    wire out;
    
    mux_2to1 dut (
        .sel(sel),
        .a(a),
        .b(b),
        .out(out)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst = 1'b0;
        sel = 1'b0;
        a = 1'b0;
        b = 1'b0;
        
        #20 rst = 1'b1;
        #10 sel = 1'b0; a = 1'b1; b = 1'b0;
        #10 sel = 1'b1; a = 1'b0; b = 1'b1;
        #10 sel = 1'b0; a = 1'b1; b = 1'b1;
        #10 sel = 1'b1; a = 1'b0; b = 1'b0;
        #50 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t clk=%b rst=%b sel=%b a=%b b=%b out=%b"", 
                 $time, clk, rst, sel, a, b, out);
    end
endmodule",True,49,True,True,True,False,0.4,False,8.526753187179565,10.644543409347534,"Design a 2-to-1 multiplexer with inputs a, b, select sel, and output out. Include testbench testing all combinations.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph LR
    SEL[Select (sel)] --> MUX{2-to-1 MUX}
    A[Input a] --> MUX
    B[Input b] --> MUX
    MUX --> OUT[Output (out)]

    subgraph Testbench
        direction TB
        TB_CLK[Clock] --> TB_CTRL[Control Logic]
        TB_RST[Reset] --> TB_CTRL
        TB_CTRL --> TB_SEL[Select Signal]
        TB_CTRL --> TB_A[Test Input a]
        TB_CTRL --> TB_B[Test Input b]
        TB_SEL --> MUX
        TB_A --> MUX
        TB_B --> MUX
    end
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module mux_2to1(
    input wire a,
    input wire b,
    input wire sel,
    output reg out
);

always @(*) begin
    if (sel)
        out = b;
    else
        out = a;
end

endmodule

module testbench;
    reg clk, rst;
    reg a, b, sel;
    wire out;

    // Instantiate the 2-to-1 MUX
    mux_2to1 dut (
        .a(a),
        .b(b),
        .sel(sel),
        .out(out)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 1'b0;
        rst = 1'b0;
        a = 1'b0;
        b = 1'b0;
        sel = 1'b0;

        #20 rst = 1'b1;
        #10 sel = 1'b0; a = 1'b0; b = 1'b0;
        #10 sel = 1'b0; a = 1'b1; b = 1'b0;
        #10 sel = 1'b1; a = 1'b0; b = 1'b1;
        #10 sel = 1'b1; a = 1'b1; b = 1'b1;
        #50 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t clk=%b rst=%b sel=%b a=%b b=%b out=%b"", 
                 $time, clk, rst, sel, a, b, out);
    end
endmodule",True,56,True,True,True,False,0.4,False,4.90863037109375,24.805418729782104,tie,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,Sequential,simple,"Create a D flip-flop with clock, reset, input d, and output q. Include testbench with timing verification.",claude,"`timescale 1ns/1ps

module dff(
    input wire clk,
    input wire rst_n,
    input wire d,
    output reg q
);

always @(posedge clk or negedge rst_n) begin
    if (!rst_n)
        q <= 1'b0;
    else
        q <= d;
end

endmodule

module testbench;
    reg clk, rst_n, d;
    wire q;
    
    dff dut (
        .clk(clk),
        .rst_n(rst_n),
        .d(d),
        .q(q)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst_n = 1'b0;
        d = 1'b0;
        
        #20 rst_n = 1'b1;
        #10 d = 1'b1;
        #10 d = 1'b0;
        #10 d = 1'b1;
        #20 rst_n = 1'b0;
        #20 rst_n = 1'b1;
        #50 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b d=%b q=%b"", 
                 $time, clk, rst_n, d, q);
    end
endmodule",True,53,True,True,True,True,0.7,True,4.870795726776123,9.591895818710327,"graph LR
    CLK[Clock] --> DFF[[D Flip-Flop]]
    RST[Reset] --> DFF
    D[Input D] --> DFF
    DFF --> Q[Output Q]
    CLK --> TB(Testbench)
    RST --> TB
    D --> TB
    Q --> TB
    TB --> TV{Timing Verify}
    TV --> PASS[Pass/Fail]
    subgraph TestEnv[Test Environment]
    TB
    TV
    PASS
    end","`timescale 1ns/1ps

module dff(
    input wire clk,
    input wire rst,
    input wire d,
    output reg q
);

always @(posedge clk or posedge rst) begin
    if (rst)
        q <= 1'b0;
    else
        q <= d;
end

endmodule

module testbench;
    reg clk, rst, d;
    wire q;
    reg [31:0] errors;
    
    dff dut (
        .clk(clk),
        .rst(rst),
        .d(d),
        .q(q)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        errors = 0;
        clk = 0;
        rst = 1;
        d = 0;
        
        #10 rst = 0;
        
        // Test case 1: Simple pass-through
        #10 d = 1;
        #10 if (q !== 1) errors = errors + 1;
        
        #10 d = 0;
        #10 if (q !== 0) errors = errors + 1;
        
        // Test case 2: Reset behavior
        #10 d = 1;
        #5 rst = 1;
        #10 if (q !== 0) errors = errors + 1;
        
        #10 rst = 0;
        #20 if (q !== 1) errors = errors + 1;
        
        #10;
        if (errors == 0)
            $display(""PASS: All tests passed"");
        else
            $display(""FAIL: %d errors found"", errors);
            
        $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t rst=%b d=%b q=%b"", $time, rst, d, q);
    end
endmodule",True,71,True,True,True,False,0.4,False,9.336771726608276,7.580486059188843,"Create a D flip-flop with clock, reset, input d, and output q. Include testbench with timing verification.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph LR
    CLK[Clock] --> DFF[[D Flip-Flop]]
    RST[Reset] --> DFF
    D[Input D] --> DFF
    DFF --> Q[Output Q]
    CLK --> TB(Testbench)
    RST --> TB
    D --> TB
    Q --> TB
    TB --> TV{Timing Verify}
    TV --> PASS[Pass/Fail]
    subgraph TestEnv[Test Environment]
    TB
    TV
    PASS
    end
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module dff (
    input wire clk,
    input wire rst,
    input wire d,
    output reg q
);

always @(posedge clk or posedge rst) begin
    if (rst)
        q <= 1'b0;
    else
        q <= d;
end

endmodule

module testbench;
    reg clk, rst, d;
    wire q;
    reg test_passed;
    
    dff dut (
        .clk(clk),
        .rst(rst),
        .d(d),
        .q(q)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        test_passed = 1'b1;
        clk = 1'b0;
        rst = 1'b1;
        d = 1'b0;
        
        #10 rst = 1'b0;
        
        // Test case 1: D=1
        #10 d = 1'b1;
        #10 if (q !== 1'b1) test_passed = 1'b0;
        
        // Test case 2: D=0
        #10 d = 1'b0;
        #10 if (q !== 1'b0) test_passed = 1'b0;
        
        // Test reset
        #10 rst = 1'b1;
        #10 if (q !== 1'b0) test_passed = 1'b0;
        
        #10;
        if (test_passed)
            $display(""TEST PASSED"");
        else
            $display(""TEST FAILED"");
            
        $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t rst=%b d=%b q=%b"", $time, rst, d, q);
    end
endmodule",True,68,True,True,True,False,0.4,False,6.319487571716309,7.710464715957642,tie,mermaid_only > combined > prompt_only,prompt_only > mermaid_only > combined
combined,Sequential,simple,"Create a D flip-flop with clock, reset, input d, and output q. Include testbench with timing verification.",gpt-4o,"`timescale 1ns/1ps

module d_flip_flop(
    input wire clk,
    input wire rst_n,
    input wire d,
    output reg q
);

always @(posedge clk or negedge rst_n) begin
    if (!rst_n)
        q <= 1'b0;
    else
        q <= d;
end

endmodule

module testbench;
    reg clk, rst_n, d;
    wire q;
    
    d_flip_flop dut (
        .clk(clk),
        .rst_n(rst_n),
        .d(d),
        .q(q)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst_n = 1'b0;
        d = 1'b0;
        
        #20 rst_n = 1'b1;
        #10 d = 1'b1;
        #10 d = 1'b0;
        #10 d = 1'b1;
        #10 d = 1'b0;
        #20 rst_n = 1'b0;
        #20 rst_n = 1'b1;
        #50 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b d=%b q=%b"", 
                 $time, clk, rst_n, d, q);
    end
endmodule",True,54,True,True,True,True,0.7,True,4.308662414550781,9.998142004013062,"graph TD
    CLK[Clock] --> DFF(D Flip-Flop)
    RST[Reset] --> DFF
    D_IN[D Input] --> DFF
    DFF --> Q_OUT[Q Output]
    
    subgraph Testbench
        CLK_TB[Clock] --> TB[Timing Verification]
        RST_TB[Reset] --> TB
        D_IN_TB[D Input] --> TB
        TB --> Q_OUT_TB[Q Output]
    end
    
    CLK --> CLK_TB
    RST --> RST_TB
    D_IN --> D_IN_TB
    Q_OUT --> Q_OUT_TB","`timescale 1ns/1ps

module d_flip_flop(
    input wire clk,
    input wire rst,
    input wire d_in,
    output reg q_out
);

always @(posedge clk or posedge rst) begin
    if (rst)
        q_out <= 1'b0;
    else
        q_out <= d_in;
end

endmodule

module testbench;
    reg clk_tb, rst_tb, d_in_tb;
    wire q_out_tb;
    
    d_flip_flop dut (
        .clk(clk_tb),
        .rst(rst_tb),
        .d_in(d_in_tb),
        .q_out(q_out_tb)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk_tb = 1'b0;
        rst_tb = 1'b0;
        d_in_tb = 1'b0;
        
        #15 rst_tb = 1'b1;
        #15 rst_tb = 1'b0;
        #10 d_in_tb = 1'b1;
        #20 d_in_tb = 1'b0;
        #30 d_in_tb = 1'b1;
        #40 $finish;
    end
    
    always #5 clk_tb = ~clk_tb;
    
    initial begin
        $monitor(""Time=%0t clk_tb=%b rst_tb=%b d_in_tb=%b q_out_tb=%b"", 
                 $time, clk_tb, rst_tb, d_in_tb, q_out_tb);
    end
endmodule",True,52,True,True,True,True,0.7,True,7.988988161087036,11.98458456993103,"Create a D flip-flop with clock, reset, input d, and output q. Include testbench with timing verification.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph TD
    CLK[Clock] --> DFF(D Flip-Flop)
    RST[Reset] --> DFF
    D_IN[D Input] --> DFF
    DFF --> Q_OUT[Q Output]
    
    subgraph Testbench
        CLK_TB[Clock] --> TB[Timing Verification]
        RST_TB[Reset] --> TB
        D_IN_TB[D Input] --> TB
        TB --> Q_OUT_TB[Q Output]
    end
    
    CLK --> CLK_TB
    RST --> RST_TB
    D_IN --> D_IN_TB
    Q_OUT --> Q_OUT_TB
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module d_flip_flop(
    input wire clk,
    input wire rst,
    input wire d,
    output reg q
);

always @(posedge clk or posedge rst) begin
    if (rst)
        q <= 1'b0;
    else
        q <= d;
end

endmodule

module testbench;
    reg clk, rst, d;
    wire q;

    d_flip_flop dut (
        .clk(clk),
        .rst(rst),
        .d(d),
        .q(q)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 1'b0;
        rst = 1'b0;
        d = 1'b0;

        #10 rst = 1'b1;
        #10 rst = 1'b0;
        #10 d = 1'b1;
        #20 d = 1'b0;
        #30 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t clk=%b rst=%b d=%b q=%b"", 
                 $time, clk, rst, d, q);
    end
endmodule",True,51,True,True,True,False,0.3,False,3.4253902435302734,11.359720468521118,combined,combined > prompt_only > mermaid_only,prompt_only > mermaid_only > combined
combined,Sequential,simple,"Design a 4-bit synchronous counter with clock, reset, enable, and count[3:0]. Include testbench.",claude,"`timescale 1ns/1ps

module counter(
    input wire clk,
    input wire rst_n,
    input wire enable,
    output reg [3:0] count
);

always @(posedge clk or negedge rst_n) begin
    if (!rst_n)
        count <= 4'b0000;
    else if (enable)
        count <= count + 1'b1;
end

endmodule

module testbench;
    reg clk, rst_n, enable;
    wire [3:0] count;
    
    counter dut (
        .clk(clk),
        .rst_n(rst_n),
        .enable(enable),
        .count(count)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst_n = 1'b0;
        enable = 1'b0;
        
        #20 rst_n = 1'b1;
        #10 enable = 1'b1;
        #100 enable = 1'b0;
        #20 rst_n = 1'b0;
        #20 rst_n = 1'b1;
        #50 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b enable=%b count=%d"", 
                 $time, clk, rst_n, enable, count);
    end
endmodule",True,52,True,True,True,False,0.3,False,4.498709201812744,8.98731780052185,"graph TD
    CLK[Clock] --> Counter[[4-bit Counter]]
    RST[Reset] --> Counter
    EN[Enable] --> Counter
    Counter --> COUNT[Count[3:0]]
    Counter --> TB[[Testbench]]
    CLK --> TB
    RST --> TB
    EN --> TB
    TB --> EXPECTED[Expected Count]
    TB --> COMPARE(Compare Values)
    COUNT --> COMPARE
    EXPECTED --> COMPARE
    COMPARE --> RESULT{Pass/Fail}
    Counter --> WAVES[[Waveform Display]]
    CLK --> WAVES
    RST --> WAVES
    EN --> WAVES
    COUNT --> WAVES","`timescale 1ns/1ps

module counter(
    input wire clk,
    input wire rst_n,
    input wire enable,
    output reg [3:0] count
);

always @(posedge clk or negedge rst_n) begin
    if (!rst_n)
        count <= 4'b0000;
    else if (enable)
        count <= count + 1'b1;
end

endmodule

module testbench;
    reg clk, rst_n, enable;
    wire [3:0] count;
    reg [3:0] expected;
    
    counter dut (
        .clk(clk),
        .rst_n(rst_n),
        .enable(enable),
        .count(count)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst_n = 1'b0;
        enable = 1'b0;
        expected = 4'b0000;
        
        #20 rst_n = 1'b1;
        #10 enable = 1'b1;
        
        repeat(16) begin
            @(posedge clk);
            expected = expected + (enable ? 1'b1 : 1'b0);
            if (count !== expected)
                $display(""Error at time %0t: count=%h expected=%h"", $time, count, expected);
        end
        
        #100 enable = 1'b0;
        #20 rst_n = 1'b0;
        #20 rst_n = 1'b1;
        #50 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b enable=%b count=%d expected=%d"", 
                 $time, clk, rst_n, enable, count, expected);
    end
endmodule",True,62,True,True,True,False,0.3,False,8.998669147491455,6.918918609619141,"Design a 4-bit synchronous counter with clock, reset, enable, and count[3:0]. Include testbench.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph TD
    CLK[Clock] --> Counter[[4-bit Counter]]
    RST[Reset] --> Counter
    EN[Enable] --> Counter
    Counter --> COUNT[Count[3:0]]
    Counter --> TB[[Testbench]]
    CLK --> TB
    RST --> TB
    EN --> TB
    TB --> EXPECTED[Expected Count]
    TB --> COMPARE(Compare Values)
    COUNT --> COMPARE
    EXPECTED --> COMPARE
    COMPARE --> RESULT{Pass/Fail}
    Counter --> WAVES[[Waveform Display]]
    CLK --> WAVES
    RST --> WAVES
    EN --> WAVES
    COUNT --> WAVES
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module counter(
    input wire clk,
    input wire rst_n,
    input wire enable,
    output reg [3:0] count
);

always @(posedge clk or negedge rst_n) begin
    if (!rst_n)
        count <= 4'b0000;
    else if (enable)
        count <= count + 1'b1;
end

endmodule

module testbench;
    reg clk, rst_n, enable;
    wire [3:0] count;
    reg [3:0] expected;
    reg pass_fail;
    
    counter dut (
        .clk(clk),
        .rst_n(rst_n),
        .enable(enable),
        .count(count)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst_n = 1'b0;
        enable = 1'b0;
        expected = 4'b0000;
        pass_fail = 1'b1;
        
        #20 rst_n = 1'b1;
        #10 enable = 1'b1;
        
        repeat(16) begin
            @(posedge clk);
            expected = expected + enable;
            if (count !== expected) begin
                $display(""Error: Expected %d, Got %d"", expected, count);
                pass_fail = 1'b0;
            end
        end
        
        #20 enable = 1'b0;
        #20 rst_n = 1'b0;
        #20 rst_n = 1'b1;
        
        if (pass_fail)
            $display(""TEST PASSED"");
        else
            $display(""TEST FAILED"");
            
        #50 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b enable=%b count=%d expected=%d"", 
                 $time, clk, rst_n, enable, count, expected);
    end
endmodule",True,72,True,True,True,False,0.3,False,6.632660865783691,6.634808540344238,tie,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,Sequential,simple,"Design a 4-bit synchronous counter with clock, reset, enable, and count[3:0]. Include testbench.",gpt-4o,"`timescale 1ns/1ps

module counter(
    input wire clk,
    input wire rst_n,
    input wire enable,
    output reg [3:0] count
);

always @(posedge clk or negedge rst_n) begin
    if (!rst_n)
        count <= 4'b0000;
    else if (enable)
        count <= count + 1'b1;
end

endmodule

module testbench;
    reg clk, rst_n, enable;
    wire [3:0] count;
    
    counter dut (
        .clk(clk),
        .rst_n(rst_n),
        .enable(enable),
        .count(count)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst_n = 1'b0;
        enable = 1'b0;
        
        #20 rst_n = 1'b1;
        #10 enable = 1'b1;
        #100 enable = 1'b0;
        #20 rst_n = 1'b0;
        #20 rst_n = 1'b1;
        #50 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b enable=%b count=%d"", 
                 $time, clk, rst_n, enable, count);
    end
endmodule",True,52,True,True,True,False,0.3,False,3.666902542114258,14.60481572151184,"graph TD
    CLK[Clock] --> COUNTER(4-bit Counter)
    RST[Reset] --> COUNTER
    EN[Enable] --> COUNTER
    COUNTER --> COUNT[[Count[3:0]]]
    subgraph Testbench
        CLK_TB[Clock] --> COUNTER_TB(4-bit Counter)
        RST_TB[Reset] --> COUNTER_TB
        EN_TB[Enable] --> COUNTER_TB
        COUNTER_TB --> COUNT_TB[[Count[3:0]]]
    end","`timescale 1ns/1ps

module counter(
    input wire clk,
    input wire rst_n,
    input wire enable,
    output reg [3:0] count
);

always @(posedge clk or negedge rst_n) begin
    if (!rst_n)
        count <= 4'b0000;
    else if (enable)
        count <= count + 1'b1;
end

endmodule

module testbench;
    reg clk, rst_n, enable;
    wire [3:0] count;
    
    counter dut (
        .clk(clk),
        .rst_n(rst_n),
        .enable(enable),
        .count(count)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst_n = 1'b0;
        enable = 1'b0;
        
        #20 rst_n = 1'b1;
        #10 enable = 1'b1;
        #100 enable = 1'b0;
        #20 rst_n = 1'b0;
        #20 rst_n = 1'b1;
        #50 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b enable=%b count=%d"", 
                 $time, clk, rst_n, enable, count);
    end
endmodule",True,52,True,True,True,False,0.3,False,9.01046085357666,11.692678213119507,"Design a 4-bit synchronous counter with clock, reset, enable, and count[3:0]. Include testbench.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph TD
    CLK[Clock] --> COUNTER(4-bit Counter)
    RST[Reset] --> COUNTER
    EN[Enable] --> COUNTER
    COUNTER --> COUNT[[Count[3:0]]]
    subgraph Testbench
        CLK_TB[Clock] --> COUNTER_TB(4-bit Counter)
        RST_TB[Reset] --> COUNTER_TB
        EN_TB[Enable] --> COUNTER_TB
        COUNTER_TB --> COUNT_TB[[Count[3:0]]]
    end
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module counter(
    input wire clk,
    input wire rst_n,
    input wire enable,
    output reg [3:0] count
);

always @(posedge clk or negedge rst_n) begin
    if (!rst_n)
        count <= 4'b0000;
    else if (enable)
        count <= count + 1'b1;
end

endmodule

module testbench;
    reg clk, rst_n, enable;
    wire [3:0] count;
    
    counter dut (
        .clk(clk),
        .rst_n(rst_n),
        .enable(enable),
        .count(count)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst_n = 1'b0;
        enable = 1'b0;
        
        #20 rst_n = 1'b1;
        #10 enable = 1'b1;
        #100 enable = 1'b0;
        #20 rst_n = 1'b0;
        #20 rst_n = 1'b1;
        #50 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b enable=%b count=%d"", 
                 $time, clk, rst_n, enable, count);
    end
endmodule",True,52,True,True,True,False,0.3,False,3.5881686210632324,14.959833860397339,tie,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,Combinational,simple,"Create a full adder with inputs a, b, cin and outputs sum, cout. Include testbench with all 8 cases.",claude,"`timescale 1ns/1ps

module full_adder(
    input wire a,
    input wire b, 
    input wire cin,
    output wire sum,
    output wire cout
);

assign sum = a ^ b ^ cin;
assign cout = (a & b) | (b & cin) | (a & cin);

endmodule

module testbench;
    reg a, b, cin;
    wire sum, cout;
    
    full_adder dut(
        .a(a),
        .b(b),
        .cin(cin),
        .sum(sum),
        .cout(cout)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        // Test all 8 cases
        a=0; b=0; cin=0; #10;
        a=0; b=0; cin=1; #10;
        a=0; b=1; cin=0; #10;
        a=0; b=1; cin=1; #10;
        a=1; b=0; cin=0; #10;
        a=1; b=0; cin=1; #10;
        a=1; b=1; cin=0; #10;
        a=1; b=1; cin=1; #10;
        
        $finish;
    end
    
    initial begin
        $monitor(""Time=%0t a=%b b=%b cin=%b sum=%b cout=%b"",
                 $time, a, b, cin, sum, cout);
    end
endmodule",True,49,True,True,True,False,0.4,False,5.007539510726929,7.524077653884888,"graph LR
    A[Input A] --> FA(Full Adder)
    B[Input B] --> FA
    CIN[Carry In] --> FA
    FA --> SUM[Sum Output]
    FA --> COUT[Carry Out]
    TB[Test Cases] --> |Case 1: 000|TEST[[Test Vector]]
    TB --> |Case 2: 001|TEST
    TB --> |Case 3: 010|TEST
    TB --> |Case 4: 011|TEST
    TB --> |Case 5: 100|TEST
    TB --> |Case 6: 101|TEST
    TB --> |Case 7: 110|TEST
    TB --> |Case 8: 111|TEST
    TEST --> |Expected Sum|EXP[[Expected Results]]
    TEST --> |Expected Cout|EXP
    FA --> |Actual Results|CMP{Compare}
    EXP --> CMP","`timescale 1ns/1ps

module full_adder(
    input wire A,
    input wire B, 
    input wire CIN,
    output reg SUM,
    output reg COUT
);

always @(*) begin
    SUM = A ^ B ^ CIN;
    COUT = (A & B) | (B & CIN) | (A & CIN);
end

endmodule

module testbench;
    reg A, B, CIN;
    wire SUM, COUT;
    reg [2:0] test_vector;
    reg [1:0] expected_result;
    integer i;
    
    full_adder dut(
        .A(A),
        .B(B),
        .CIN(CIN),
        .SUM(SUM),
        .COUT(COUT)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        for(i = 0; i < 8; i = i + 1) begin
            test_vector = i;
            A = test_vector[2];
            B = test_vector[1];
            CIN = test_vector[0];
            expected_result[0] = A ^ B ^ CIN;
            expected_result[1] = (A & B) | (B & CIN) | (A & CIN);
            #10;
            
            if(SUM !== expected_result[0] || COUT !== expected_result[1])
                $display(""Error at test case %d: Expected {%b,%b}, Got {%b,%b}"", 
                    i, expected_result[1], expected_result[0], COUT, SUM);
            else
                $display(""Test case %d passed: {%b,%b}"", i, COUT, SUM);
        end
        
        #10 $finish;
    end
    
    initial begin
        $monitor(""Time=%0t A=%b B=%b CIN=%b SUM=%b COUT=%b"", 
                 $time, A, B, CIN, SUM, COUT);
    end
endmodule",True,60,True,True,True,False,0.4,False,10.620567798614502,6.8274195194244385,"Create a full adder with inputs a, b, cin and outputs sum, cout. Include testbench with all 8 cases.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph LR
    A[Input A] --> FA(Full Adder)
    B[Input B] --> FA
    CIN[Carry In] --> FA
    FA --> SUM[Sum Output]
    FA --> COUT[Carry Out]
    TB[Test Cases] --> |Case 1: 000|TEST[[Test Vector]]
    TB --> |Case 2: 001|TEST
    TB --> |Case 3: 010|TEST
    TB --> |Case 4: 011|TEST
    TB --> |Case 5: 100|TEST
    TB --> |Case 6: 101|TEST
    TB --> |Case 7: 110|TEST
    TB --> |Case 8: 111|TEST
    TEST --> |Expected Sum|EXP[[Expected Results]]
    TEST --> |Expected Cout|EXP
    FA --> |Actual Results|CMP{Compare}
    EXP --> CMP
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module full_adder (
    input wire a,
    input wire b,
    input wire cin,
    output wire sum,
    output wire cout
);

assign sum = a ^ b ^ cin;
assign cout = (a & b) | (b & cin) | (a & cin);

endmodule

module testbench;
    reg a, b, cin;
    wire sum, cout;
    reg [2:0] test_vector;
    reg expected_sum, expected_cout;
    integer i;
    
    full_adder dut (
        .a(a),
        .b(b),
        .cin(cin),
        .sum(sum),
        .cout(cout)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        for (i = 0; i < 8; i = i + 1) begin
            test_vector = i;
            a = test_vector[2];
            b = test_vector[1];
            cin = test_vector[0];
            
            expected_sum = a ^ b ^ cin;
            expected_cout = (a & b) | (b & cin) | (a & cin);
            
            #10;
            
            if (sum !== expected_sum || cout !== expected_cout) begin
                $display(""Error at test case %b: Expected sum=%b cout=%b, Got sum=%b cout=%b"",
                    test_vector, expected_sum, expected_cout, sum, cout);
            end
        end
        
        $display(""Test completed"");
        $finish;
    end
    
    initial begin
        $monitor(""Time=%0t a=%b b=%b cin=%b sum=%b cout=%b"",
                 $time, a, b, cin, sum, cout);
    end
endmodule",True,60,True,True,True,False,0.4,False,5.749156951904297,7.176040410995483,tie,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,Combinational,simple,"Create a full adder with inputs a, b, cin and outputs sum, cout. Include testbench with all 8 cases.",gpt-4o,"`timescale 1ns/1ps

module full_adder(
    input wire a,
    input wire b,
    input wire cin,
    output wire sum,
    output wire cout
);

assign sum = a ^ b ^ cin;
assign cout = (a & b) | (b & cin) | (a & cin);

endmodule

module testbench;
    reg a, b, cin;
    wire sum, cout;
    
    full_adder dut (
        .a(a),
        .b(b),
        .cin(cin),
        .sum(sum),
        .cout(cout)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        a = 1'b0; b = 1'b0; cin = 1'b0;
        #10 a = 1'b0; b = 1'b0; cin = 1'b1;
        #10 a = 1'b0; b = 1'b1; cin = 1'b0;
        #10 a = 1'b0; b = 1'b1; cin = 1'b1;
        #10 a = 1'b1; b = 1'b0; cin = 1'b0;
        #10 a = 1'b1; b = 1'b0; cin = 1'b1;
        #10 a = 1'b1; b = 1'b1; cin = 1'b0;
        #10 a = 1'b1; b = 1'b1; cin = 1'b1;
        #10 $finish;
    end
    
    initial begin
        $monitor(""Time=%0t a=%b b=%b cin=%b sum=%b cout=%b"", 
                 $time, a, b, cin, sum, cout);
    end
endmodule",True,47,True,True,True,False,0.4,False,4.989121198654175,17.202634811401367,"graph LR
    A[a] --> FA(Full Adder)
    B[b] --> FA
    CIN[cin] --> FA
    FA --> SUM[sum]
    FA --> COUT[cout]
    
    subgraph TB[Testbench]
        A1[a=0] --> FA1(Full Adder)
        B1[b=0] --> FA1
        CIN1[cin=0] --> FA1
        FA1 --> SUM1[sum=0]
        FA1 --> COUT1[cout=0]
        
        A2[a=0] --> FA2(Full Adder)
        B2[b=0] --> FA2
        CIN2[cin=1] --> FA2
        FA2 --> SUM2[sum=1]
        FA2 --> COUT2[cout=0]
        
        A3[a=0] --> FA3(Full Adder)
        B3[b=1] --> FA3
        CIN3[cin=0] --> FA3
        FA3 --> SUM3[sum=1]
        FA3 --> COUT3[cout=0]
        
        A4[a=0] --> FA4(Full Adder)
        B4[b=1] --> FA4
        CIN4[cin=1] --> FA4
        FA4 --> SUM4[sum=0]
        FA4 --> COUT4[cout=1]
        
        A5[a=1] --> FA5(Full Adder)
        B5[b=0] --> FA5
        CIN5[cin=0] --> FA5
        FA5 --> SUM5[sum=1]
        FA5 --> COUT5[cout=0]
        
        A6[a=1] --> FA6(Full Adder)
        B6[b=0] --> FA6
        CIN6[cin=1] --> FA6
        FA6 --> SUM6[sum=0]
        FA6 --> COUT6[cout=1]
        
        A7[a=1] --> FA7(Full Adder)
        B7[b=1] --> FA7
        CIN7[cin=0] --> FA7
        FA7 --> SUM7[sum=0]
        FA7 --> COUT7[cout=1]
        
        A8[a=1] --> FA8(Full Adder)
        B8[b=1] --> FA8
        CIN8[cin=1] --> FA8
        FA8 --> SUM8[sum=1]
        FA8 --> COUT8[cout=1]
    end","`timescale 1ns/1ps

module full_adder(
    input wire a,
    input wire b,
    input wire cin,
    output wire sum,
    output wire cout
);
    assign sum = a ^ b ^ cin;
    assign cout = (a & b) | (b & cin) | (a & cin);
endmodule

module testbench;
    reg a, b, cin;
    wire sum, cout;

    full_adder FA(
        .a(a),
        .b(b),
        .cin(cin),
        .sum(sum),
        .cout(cout)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        // Test cases
        a = 0; b = 0; cin = 0;
        #10 $display(""a=%b b=%b cin=%b => sum=%b cout=%b"", a, b, cin, sum, cout);

        a = 0; b = 0; cin = 1;
        #10 $display(""a=%b b=%b cin=%b => sum=%b cout=%b"", a, b, cin, sum, cout);

        a = 0; b = 1; cin = 0;
        #10 $display(""a=%b b=%b cin=%b => sum=%b cout=%b"", a, b, cin, sum, cout);

        a = 0; b = 1; cin = 1;
        #10 $display(""a=%b b=%b cin=%b => sum=%b cout=%b"", a, b, cin, sum, cout);

        a = 1; b = 0; cin = 0;
        #10 $display(""a=%b b=%b cin=%b => sum=%b cout=%b"", a, b, cin, sum, cout);

        a = 1; b = 0; cin = 1;
        #10 $display(""a=%b b=%b cin=%b => sum=%b cout=%b"", a, b, cin, sum, cout);

        a = 1; b = 1; cin = 0;
        #10 $display(""a=%b b=%b cin=%b => sum=%b cout=%b"", a, b, cin, sum, cout);

        a = 1; b = 1; cin = 1;
        #10 $display(""a=%b b=%b cin=%b => sum=%b cout=%b"", a, b, cin, sum, cout);

        #10 $finish;
    end
endmodule",True,57,True,True,True,True,1.0,True,13.600093126296997,0.07116913795471191,"Create a full adder with inputs a, b, cin and outputs sum, cout. Include testbench with all 8 cases.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph LR
    A[a] --> FA(Full Adder)
    B[b] --> FA
    CIN[cin] --> FA
    FA --> SUM[sum]
    FA --> COUT[cout]
    
    subgraph TB[Testbench]
        A1[a=0] --> FA1(Full Adder)
        B1[b=0] --> FA1
        CIN1[cin=0] --> FA1
        FA1 --> SUM1[sum=0]
        FA1 --> COUT1[cout=0]
        
        A2[a=0] --> FA2(Full Adder)
        B2[b=0] --> FA2
        CIN2[cin=1] --> FA2
        FA2 --> SUM2[sum=1]
        FA2 --> COUT2[cout=0]
        
        A3[a=0] --> FA3(Full Adder)
        B3[b=1] --> FA3
        CIN3[cin=0] --> FA3
        FA3 --> SUM3[sum=1]
        FA3 --> COUT3[cout=0]
        
        A4[a=0] --> FA4(Full Adder)
        B4[b=1] --> FA4
        CIN4[cin=1] --> FA4
        FA4 --> SUM4[sum=0]
        FA4 --> COUT4[cout=1]
        
        A5[a=1] --> FA5(Full Adder)
        B5[b=0] --> FA5
        CIN5[cin=0] --> FA5
        FA5 --> SUM5[sum=1]
        FA5 --> COUT5[cout=0]
        
        A6[a=1] --> FA6(Full Adder)
        B6[b=0] --> FA6
        CIN6[cin=1] --> FA6
        FA6 --> SUM6[sum=0]
        FA6 --> COUT6[cout=1]
        
        A7[a=1] --> FA7(Full Adder)
        B7[b=1] --> FA7
        CIN7[cin=0] --> FA7
        FA7 --> SUM7[sum=0]
        FA7 --> COUT7[cout=1]
        
        A8[a=1] --> FA8(Full Adder)
        B8[b=1] --> FA8
        CIN8[cin=1] --> FA8
        FA8 --> SUM8[sum=1]
        FA8 --> COUT8[cout=1]
    end
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module full_adder(
    input wire a,
    input wire b,
    input wire cin,
    output wire sum,
    output wire cout
);
    assign sum = a ^ b ^ cin;
    assign cout = (a & b) | (b & cin) | (cin & a);
endmodule

module testbench;
    reg a, b, cin;
    wire sum, cout;

    full_adder dut (
        .a(a),
        .b(b),
        .cin(cin),
        .sum(sum),
        .cout(cout)
    );

    initial begin
        $dumpfile(""full_adder_test.vcd"");
        $dumpvars(0, testbench);

        // Test case 1: a=0, b=0, cin=0
        a = 0; b = 0; cin = 0;
        #10;
        $display(""TC1: a=%b, b=%b, cin=%b => sum=%b, cout=%b"", a, b, cin, sum, cout);

        // Test case 2: a=0, b=0, cin=1
        a = 0; b = 0; cin = 1;
        #10;
        $display(""TC2: a=%b, b=%b, cin=%b => sum=%b, cout=%b"", a, b, cin, sum, cout);

        // Test case 3: a=0, b=1, cin=0
        a = 0; b = 1; cin = 0;
        #10;
        $display(""TC3: a=%b, b=%b, cin=%b => sum=%b, cout=%b"", a, b, cin, sum, cout);

        // Test case 4: a=0, b=1, cin=1
        a = 0; b = 1; cin = 1;
        #10;
        $display(""TC4: a=%b, b=%b, cin=%b => sum=%b, cout=%b"", a, b, cin, sum, cout);

        // Test case 5: a=1, b=0, cin=0
        a = 1; b = 0; cin = 0;
        #10;
        $display(""TC5: a=%b, b=%b, cin=%b => sum=%b, cout=%b"", a, b, cin, sum, cout);

        // Test case 6: a=1, b=0, cin=1
        a = 1; b = 0; cin = 1;
        #10;
        $display(""TC6: a=%b, b=%b, cin=%b => sum=%b, cout=%b"", a, b, cin, sum, cout);

        // Test case 7: a=1, b=1, cin=0
        a = 1; b = 1; cin = 0;
        #10;
        $display(""TC7: a=%b, b=%b, cin=%b => sum=%b, cout=%b"", a, b, cin, sum, cout);

        // Test case 8: a=1, b=1, cin=1
        a = 1; b = 1; cin = 1;
        #10;
        $display(""TC8: a=%b, b=%b, cin=%b => sum=%b, cout=%b"", a, b, cin, sum, cout);
        
        $finish;
    end
endmodule",True,72,True,True,True,,0.0,,12.32037091255188,0.029322147369384766,prompt_only,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,Combinational,simple,"Design a 2-bit comparator with inputs a[1:0], b[1:0] and outputs eq, gt, lt. Include testbench.",claude,"`timescale 1ns/1ps

module comparator(
    input wire [1:0] a,
    input wire [1:0] b,
    output reg eq,
    output reg gt,
    output reg lt
);

always @(a or b) begin
    eq = (a == b);
    gt = (a > b);
    lt = (a < b);
end

endmodule

module testbench;
    reg [1:0] a, b;
    wire eq, gt, lt;
    
    comparator dut (
        .a(a),
        .b(b),
        .eq(eq),
        .gt(gt),
        .lt(lt)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        // Test all combinations
        a = 2'b00; b = 2'b00; #10;
        a = 2'b00; b = 2'b01; #10;
        a = 2'b00; b = 2'b10; #10;
        a = 2'b00; b = 2'b11; #10;
        a = 2'b01; b = 2'b00; #10;
        a = 2'b01; b = 2'b01; #10;
        a = 2'b01; b = 2'b10; #10;
        a = 2'b01; b = 2'b11; #10;
        a = 2'b10; b = 2'b00; #10;
        a = 2'b10; b = 2'b01; #10;
        a = 2'b10; b = 2'b10; #10;
        a = 2'b10; b = 2'b11; #10;
        a = 2'b11; b = 2'b00; #10;
        a = 2'b11; b = 2'b01; #10;
        a = 2'b11; b = 2'b10; #10;
        a = 2'b11; b = 2'b11; #10;
        
        #10 $finish;
    end
    
    initial begin
        $monitor(""Time=%0t a=%b b=%b eq=%b gt=%b lt=%b"",
                 $time, a, b, eq, gt, lt);
    end
endmodule",True,60,True,True,True,False,0.4,False,6.853978395462036,6.91787576675415,"graph LR
    A1[a1] --> C1((Compare MSB))
    A0[a0] --> C2((Compare LSB))
    B1[b1] --> C1
    B0[b0] --> C2
    
    C1 --> L1{Logic Block 1}
    C2 --> L1
    C1 --> L2{Logic Block 2}
    C2 --> L2
    C1 --> L3{Logic Block 3}
    C2 --> L3
    
    L1 --> EQ[eq]
    L2 --> GT[gt]
    L3 --> LT[lt]
    
    TB[Testbench] --> |Test Vectors| A1
    TB --> |Test Vectors| A0
    TB --> |Test Vectors| B1
    TB --> |Test Vectors| B0
    EQ --> |Verify| TB
    GT --> |Verify| TB
    LT --> |Verify| TB","`timescale 1ns/1ps

module comparator(
    input wire clk,
    input wire rst_n,
    input wire a1,
    input wire a0,
    input wire b1,
    input wire b0,
    output reg eq,
    output reg gt,
    output reg lt
);

wire msb_comp = a1 ~^ b1;
wire lsb_comp = a0 ~^ b0;

always @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
        eq <= 1'b0;
        gt <= 1'b0;
        lt <= 1'b0;
    end
    else begin
        eq <= (a1 == b1) && (a0 == b0);
        gt <= (a1 > b1) || ((a1 == b1) && (a0 > b0));
        lt <= (a1 < b1) || ((a1 == b1) && (a0 < b0));
    end
end

endmodule

module testbench;
    reg clk, rst_n;
    reg a1, a0, b1, b0;
    wire eq, gt, lt;

    comparator dut (
        .clk(clk),
        .rst_n(rst_n),
        .a1(a1),
        .a0(a0),
        .b1(b1),
        .b0(b0),
        .eq(eq),
        .gt(gt),
        .lt(lt)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 0;
        rst_n = 0;
        a1 = 0; a0 = 0;
        b1 = 0; b0 = 0;
        
        #10 rst_n = 1;
        
        // Test case 1: Equal
        #10 a1 = 0; a0 = 1; b1 = 0; b0 = 1;
        
        // Test case 2: Greater than
        #10 a1 = 1; a0 = 1; b1 = 0; b0 = 1;
        
        // Test case 3: Less than
        #10 a1 = 0; a0 = 0; b1 = 1; b0 = 0;
        
        #10 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t a=%b%b b=%b%b eq=%b gt=%b lt=%b"",
                 $time, a1, a0, b1, b0, eq, gt, lt);
    end
endmodule",True,79,True,True,True,False,0.4,False,12.579882621765137,7.1069135665893555,"Design a 2-bit comparator with inputs a[1:0], b[1:0] and outputs eq, gt, lt. Include testbench.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph LR
    A1[a1] --> C1((Compare MSB))
    A0[a0] --> C2((Compare LSB))
    B1[b1] --> C1
    B0[b0] --> C2
    
    C1 --> L1{Logic Block 1}
    C2 --> L1
    C1 --> L2{Logic Block 2}
    C2 --> L2
    C1 --> L3{Logic Block 3}
    C2 --> L3
    
    L1 --> EQ[eq]
    L2 --> GT[gt]
    L3 --> LT[lt]
    
    TB[Testbench] --> |Test Vectors| A1
    TB --> |Test Vectors| A0
    TB --> |Test Vectors| B1
    TB --> |Test Vectors| B0
    EQ --> |Verify| TB
    GT --> |Verify| TB
    LT --> |Verify| TB
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module comparator_2bit(
    input wire [1:0] a,
    input wire [1:0] b,
    output wire eq,
    output wire gt,
    output wire lt
);

wire msb_eq = (a[1] == b[1]);
wire lsb_eq = (a[0] == b[0]);
wire msb_gt = (a[1] > b[1]);
wire lsb_gt = (a[0] > b[0]);

assign eq = msb_eq && lsb_eq;
assign gt = msb_gt || (msb_eq && lsb_gt);
assign lt = !eq && !gt;

endmodule

module testbench;
    reg [1:0] a;
    reg [1:0] b;
    wire eq, gt, lt;

    comparator_2bit dut(
        .a(a),
        .b(b),
        .eq(eq),
        .gt(gt),
        .lt(lt)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        // Test all combinations
        a = 2'b00; b = 2'b00; #10;
        a = 2'b00; b = 2'b01; #10;
        a = 2'b00; b = 2'b10; #10;
        a = 2'b00; b = 2'b11; #10;
        a = 2'b01; b = 2'b00; #10;
        a = 2'b01; b = 2'b01; #10;
        a = 2'b01; b = 2'b10; #10;
        a = 2'b01; b = 2'b11; #10;
        a = 2'b10; b = 2'b00; #10;
        a = 2'b10; b = 2'b01; #10;
        a = 2'b10; b = 2'b10; #10;
        a = 2'b10; b = 2'b11; #10;
        a = 2'b11; b = 2'b00; #10;
        a = 2'b11; b = 2'b01; #10;
        a = 2'b11; b = 2'b10; #10;
        a = 2'b11; b = 2'b11; #10;

        $finish;
    end

    initial begin
        $monitor(""Time=%0t a=%b b=%b eq=%b gt=%b lt=%b"", 
                 $time, a, b, eq, gt, lt);
    end
endmodule",True,64,True,True,True,False,0.4,False,7.960996389389038,7.965484857559204,tie,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,Combinational,simple,"Design a 2-bit comparator with inputs a[1:0], b[1:0] and outputs eq, gt, lt. Include testbench.",gpt-4o,"`timescale 1ns/1ps

module comparator_2bit(
    input wire [1:0] a,
    input wire [1:0] b,
    output reg eq,
    output reg gt,
    output reg lt
);

always @(*) begin
    if (a == b) begin
        eq = 1'b1;
        gt = 1'b0;
        lt = 1'b0;
    end else if (a > b) begin
        eq = 1'b0;
        gt = 1'b1;
        lt = 1'b0;
    end else begin
        eq = 1'b0;
        gt = 1'b0;
        lt = 1'b1;
    end
end

endmodule

module testbench;
    reg [1:0] a, b;
    wire eq, gt, lt;
    
    comparator_2bit dut (
        .a(a),
        .b(b),
        .eq(eq),
        .gt(gt),
        .lt(lt)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        a = 2'b00; b = 2'b00;
        #10 a = 2'b01; b = 2'b00;
        #10 a = 2'b10; b = 2'b11;
        #10 a = 2'b11; b = 2'b11;
        #10 a = 2'b10; b = 2'b01;
        #10 $finish;
    end
    
    initial begin
        $monitor(""Time=%0t a=%b b=%b eq=%b gt=%b lt=%b"", 
                 $time, a, b, eq, gt, lt);
    end
endmodule",True,57,True,True,True,False,0.4,False,6.941043376922607,12.454368829727173,"graph LR
    A1[[a[1]]] --> CMP(Comparator)
    A0[[a[0]]] --> CMP
    B1[[b[1]]] --> CMP
    B0[[b[0]]] --> CMP

    CMP --> EQ[eq]
    CMP --> GT[gt]
    CMP --> LT[lt]

    subgraph Testbench
        A1_TB[[a[1] Test]] --> A1
        A0_TB[[a[0] Test]] --> A0
        B1_TB[[b[1] Test]] --> B1
        B0_TB[[b[0] Test]] --> B0
        
        EQ --> EQ_TB[eq Test]
        GT --> GT_TB[gt Test]
        LT --> LT_TB[lt Test]
    end","`timescale 1ns/1ps

module comparator(
    input wire clk,
    input wire [1:0] a,
    input wire [1:0] b,
    output reg eq,
    output reg gt,
    output reg lt
);

always @(posedge clk) begin
    eq <= (a == b);
    gt <= (a > b);
    lt <= (a < b);
end

endmodule

module testbench;
    reg clk;
    reg [1:0] a;
    reg [1:0] b;
    wire eq;
    wire gt;
    wire lt;
    
    comparator dut (
        .clk(clk),
        .a(a),
        .b(b),
        .eq(eq),
        .gt(gt),
        .lt(lt)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        a = 2'b00;
        b = 2'b00;
        
        #10 a = 2'b01; b = 2'b00;
        #10 a = 2'b01; b = 2'b01;
        #10 a = 2'b10; b = 2'b01;
        #10 a = 2'b11; b = 2'b10;
        #10 a = 2'b11; b = 2'b11;
        #10 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t clk=%b a=%b b=%b eq=%b gt=%b lt=%b"", 
                 $time, clk, a, b, eq, gt, lt);
    end
endmodule",True,59,True,True,True,True,0.7,True,7.946230411529541,12.533265113830566,"Design a 2-bit comparator with inputs a[1:0], b[1:0] and outputs eq, gt, lt. Include testbench.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph LR
    A1[[a[1]]] --> CMP(Comparator)
    A0[[a[0]]] --> CMP
    B1[[b[1]]] --> CMP
    B0[[b[0]]] --> CMP

    CMP --> EQ[eq]
    CMP --> GT[gt]
    CMP --> LT[lt]

    subgraph Testbench
        A1_TB[[a[1] Test]] --> A1
        A0_TB[[a[0] Test]] --> A0
        B1_TB[[b[1] Test]] --> B1
        B0_TB[[b[0] Test]] --> B0
        
        EQ --> EQ_TB[eq Test]
        GT --> GT_TB[gt Test]
        LT --> LT_TB[lt Test]
    end
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module comparator (
    input wire [1:0] a,
    input wire [1:0] b,
    output reg eq,
    output reg gt,
    output reg lt
);

always @(*) begin
    if (a == b) begin
        eq = 1'b1;
        gt = 1'b0;
        lt = 1'b0;
    end else if (a > b) begin
        eq = 1'b0;
        gt = 1'b1;
        lt = 1'b0;
    end else begin
        eq = 1'b0;
        gt = 1'b0;
        lt = 1'b1;
    end
end

endmodule

module testbench;
    reg [1:0] a;
    reg [1:0] b;
    wire eq;
    wire gt;
    wire lt;
    
    comparator dut (
        .a(a),
        .b(b),
        .eq(eq),
        .gt(gt),
        .lt(lt)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        a = 2'b00; b = 2'b00; #10;
        a = 2'b01; b = 2'b00; #10;
        a = 2'b10; b = 2'b00; #10;
        a = 2'b11; b = 2'b00; #10;
        a = 2'b00; b = 2'b01; #10;
        a = 2'b01; b = 2'b01; #10;
        a = 2'b10; b = 2'b01; #10;
        a = 2'b11; b = 2'b01; #10;
        a = 2'b00; b = 2'b10; #10;
        a = 2'b01; b = 2'b10; #10;
        a = 2'b10; b = 2'b10; #10;
        a = 2'b11; b = 2'b10; #10;
        a = 2'b00; b = 2'b11; #10;
        a = 2'b01; b = 2'b11; #10;
        a = 2'b10; b = 2'b11; #10;
        a = 2'b11; b = 2'b11; #10;
        $finish;
    end

    initial begin
        $monitor(""Time=%0t a=%b b=%b eq=%b gt=%b lt=%b"", $time, a, b, eq, gt, lt);
    end
endmodule",True,70,True,True,True,False,0.4,False,5.720609664916992,13.075530767440796,tie,prompt_only > combined > mermaid_only,prompt_only > mermaid_only > combined
combined,Arithmetic,medium,"Design a 4-bit ALU supporting ADD, SUB, AND, OR operations. Inputs: a[3:0], b[3:0], op[1:0]. Outputs: result[3:0], zero. Include testbench.",claude,"`timescale 1ns/1ps

module alu(
    input wire [3:0] a,
    input wire [3:0] b,
    input wire [1:0] op,
    output reg [3:0] result,
    output wire zero
);

assign zero = (result == 4'b0000);

always @(*) begin
    case(op)
        2'b00: result = a + b;    // ADD
        2'b01: result = a - b;    // SUB
        2'b10: result = a & b;    // AND
        2'b11: result = a | b;    // OR
        default: result = 4'b0000;
    endcase
end

endmodule

module testbench;
    reg [3:0] a, b;
    reg [1:0] op;
    wire [3:0] result;
    wire zero;

    alu dut(
        .a(a),
        .b(b),
        .op(op),
        .result(result),
        .zero(zero)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        // Test ADD
        a = 4'b0011; b = 4'b0010; op = 2'b00;
        #10;

        // Test SUB
        a = 4'b0111; b = 4'b0011; op = 2'b01;
        #10;

        // Test AND
        a = 4'b1100; b = 4'b1010; op = 2'b10;
        #10;

        // Test OR
        a = 4'b1100; b = 4'b0011; op = 2'b11;
        #10;

        // Test zero flag
        a = 4'b0011; b = 4'b0011; op = 2'b01;
        #10;

        $finish;
    end

    initial begin
        $monitor(""Time=%0t a=%b b=%b op=%b result=%b zero=%b"",
                 $time, a, b, op, result, zero);
    end
endmodule",True,70,True,True,True,False,0.4,False,6.600262880325317,6.611107587814331,"graph TD
    A[a3:0 Input] --> ALU((4-bit ALU))
    B[b3:0 Input] --> ALU
    OP[op1:0] --> ALU
    CLK[Clock] --> TB[[Testbench]]
    RST[Reset] --> TB

    ALU --> RES[result3:0]
    ALU --> Z[zero]

    subgraph Operations
        ADD((Addition))
        SUB((Subtraction))
        AND((Bitwise AND))
        OR((Bitwise OR))
    end

    Operations --> ALU

    TB --> A
    TB --> B
    TB --> OP
    RES --> TB
    Z --> TB

    subgraph Control
        OP --> |00|ADD
        OP --> |01|SUB
        OP --> |10|AND
        OP --> |11|OR
    end","`timescale 1ns/1ps

module alu (
    input wire [3:0] a,
    input wire [3:0] b,
    input wire [1:0] op,
    output reg [3:0] result,
    output wire zero
);

assign zero = (result == 4'b0000);

always @(*) begin
    case (op)
        2'b00: result = a + b;
        2'b01: result = a - b;
        2'b10: result = a & b;
        2'b11: result = a | b;
        default: result = 4'b0000;
    endcase
end

endmodule

module testbench;
    reg clk;
    reg rst_n;
    reg [3:0] a;
    reg [3:0] b;
    reg [1:0] op;
    wire [3:0] result;
    wire zero;

    alu dut (
        .a(a),
        .b(b),
        .op(op),
        .result(result),
        .zero(zero)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 0;
        rst_n = 0;
        a = 0;
        b = 0;
        op = 0;

        #10 rst_n = 1;

        // Test Addition
        #10 a = 4'h3; b = 4'h4; op = 2'b00;
        
        // Test Subtraction
        #10 a = 4'h5; b = 4'h2; op = 2'b01;
        
        // Test AND
        #10 a = 4'hF; b = 4'h3; op = 2'b10;
        
        // Test OR
        #10 a = 4'hA; b = 4'h5; op = 2'b11;

        #10 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t a=%h b=%h op=%b result=%h zero=%b"",
                 $time, a, b, op, result, zero);
    end
endmodule",True,75,True,True,True,False,0.4,False,10.49893307685852,6.267195463180542,"Design a 4-bit ALU supporting ADD, SUB, AND, OR operations. Inputs: a[3:0], b[3:0], op[1:0]. Outputs: result[3:0], zero. Include testbench.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph TD
    A[a3:0 Input] --> ALU((4-bit ALU))
    B[b3:0 Input] --> ALU
    OP[op1:0] --> ALU
    CLK[Clock] --> TB[[Testbench]]
    RST[Reset] --> TB

    ALU --> RES[result3:0]
    ALU --> Z[zero]

    subgraph Operations
        ADD((Addition))
        SUB((Subtraction))
        AND((Bitwise AND))
        OR((Bitwise OR))
    end

    Operations --> ALU

    TB --> A
    TB --> B
    TB --> OP
    RES --> TB
    Z --> TB

    subgraph Control
        OP --> |00|ADD
        OP --> |01|SUB
        OP --> |10|AND
        OP --> |11|OR
    end
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module alu(
    input wire [3:0] a,
    input wire [3:0] b,
    input wire [1:0] op,
    output reg [3:0] result,
    output wire zero
);

always @(*) begin
    case (op)
        2'b00: result = a + b;    // ADD
        2'b01: result = a - b;    // SUB
        2'b10: result = a & b;    // AND
        2'b11: result = a | b;    // OR
        default: result = 4'b0000;
    endcase
end

assign zero = (result == 4'b0000);

endmodule

module testbench;
    reg [3:0] a, b;
    reg [1:0] op;
    reg clk, rst;
    wire [3:0] result;
    wire zero;

    alu dut (
        .a(a),
        .b(b),
        .op(op),
        .result(result),
        .zero(zero)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 0;
        rst = 1;
        a = 0;
        b = 0;
        op = 0;

        #10 rst = 0;

        // Test ADD
        #10;
        a = 4'b0011;
        b = 4'b0010;
        op = 2'b00;

        // Test SUB
        #10;
        a = 4'b0111;
        b = 4'b0011;
        op = 2'b01;

        // Test AND
        #10;
        a = 4'b1100;
        b = 4'b1010;
        op = 2'b10;

        // Test OR
        #10;
        a = 4'b1100;
        b = 4'b0011;
        op = 2'b11;

        // Test zero flag
        #10;
        a = 4'b0011;
        b = 4'b0011;
        op = 2'b01;

        #10;
        $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t a=%b b=%b op=%b result=%b zero=%b"",
                 $time, a, b, op, result, zero);
    end
endmodule",True,92,True,True,True,False,0.4,False,7.675432205200195,6.2909698486328125,tie,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,Arithmetic,medium,"Design a 4-bit ALU supporting ADD, SUB, AND, OR operations. Inputs: a[3:0], b[3:0], op[1:0]. Outputs: result[3:0], zero. Include testbench.",gpt-4o,"`timescale 1ns/1ps

module alu(
    input wire [3:0] a,
    input wire [3:0] b,
    input wire [1:0] op,
    output reg [3:0] result,
    output wire zero
);

always @(*) begin
    case (op)
        2'b00: result = a + b;     // ADD
        2'b01: result = a - b;     // SUB
        2'b10: result = a & b;     // AND
        2'b11: result = a | b;     // OR
        default: result = 4'b0000;
    endcase
end

assign zero = (result == 4'b0000);

endmodule

module testbench;
    reg [3:0] a, b;
    reg [1:0] op;
    wire [3:0] result;
    wire zero;
    
    alu dut (
        .a(a),
        .b(b),
        .op(op),
        .result(result),
        .zero(zero)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        a = 4'b0000; b = 4'b0000; op = 2'b00;
        #10 a = 4'b0011; b = 4'b0001; op = 2'b00;  // ADD
        #10 a = 4'b0100; b = 4'b0011; op = 2'b01;  // SUB
        #10 a = 4'b1100; b = 4'b1010; op = 2'b10;  // AND
        #10 a = 4'b1100; b = 4'b1010; op = 2'b11;  // OR
        #10 a = 4'b0000; b = 4'b0000; op = 2'b00;  // Check zero flag
        #10 $finish;
    end
    
    initial begin
        $monitor(""Time=%0t a=%b b=%b op=%b result=%b zero=%b"", 
                 $time, a, b, op, result, zero);
    end
endmodule",True,56,True,True,True,False,0.4,False,6.309532165527344,12.033818244934082,"graph LR
    a[a[3:0]] --> ALU
    b[b[3:0]] --> ALU
    op[op[1:0]] --> ALU
    ALU(4-bit ALU) --> result[result[3:0]]
    ALU --> zero[zero]
    
    subgraph Testbench
        testInputs[Test Inputs] --> a
        testInputs --> b
        testInputs --> op
        result --> testOutputs[Test Outputs]
        zero --> testOutputs
    end","`timescale 1ns/1ps

module alu(
    input wire [3:0] a,
    input wire [3:0] b,
    input wire [1:0] op,
    output reg [3:0] result,
    output reg zero
);
    always @(*) begin
        case (op)
            2'b00: result = a + b; // ADD
            2'b01: result = a - b; // SUB
            2'b10: result = a & b; // AND
            2'b11: result = a | b; // OR
            default: result = 4'b0000;
        endcase
        zero = (result == 4'b0000);
    end
endmodule

module testbench;
    reg [3:0] a;
    reg [3:0] b;
    reg [1:0] op;
    wire [3:0] result;
    wire zero;

    alu dut (
        .a(a),
        .b(b),
        .op(op),
        .result(result),
        .zero(zero)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        a = 4'b0000;
        b = 4'b0000;
        op = 2'b00;

        #10 a = 4'b0011; b = 4'b0001; op = 2'b00; // ADD
        #10 a = 4'b0100; b = 4'b0011; op = 2'b01; // SUB
        #10 a = 4'b1100; b = 4'b1010; op = 2'b10; // AND
        #10 a = 4'b1010; b = 4'b0101; op = 2'b11; // OR
        #10 $finish;
    end

    initial begin
        $monitor(""Time=%0t a=%b b=%b op=%b result=%b zero=%b"", 
                 $time, a, b, op, result, zero);
    end
endmodule",True,56,True,True,True,False,0.4,False,10.2255699634552,10.118974685668945,"Design a 4-bit ALU supporting ADD, SUB, AND, OR operations. Inputs: a[3:0], b[3:0], op[1:0]. Outputs: result[3:0], zero. Include testbench.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph LR
    a[a[3:0]] --> ALU
    b[b[3:0]] --> ALU
    op[op[1:0]] --> ALU
    ALU(4-bit ALU) --> result[result[3:0]]
    ALU --> zero[zero]
    
    subgraph Testbench
        testInputs[Test Inputs] --> a
        testInputs --> b
        testInputs --> op
        result --> testOutputs[Test Outputs]
        zero --> testOutputs
    end
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module alu(
    input wire [3:0] a,
    input wire [3:0] b,
    input wire [1:0] op,
    output reg [3:0] result,
    output wire zero
);
    
    always @(*) begin
        case (op)
            2'b00: result = a + b;   // ADD
            2'b01: result = a - b;   // SUB
            2'b10: result = a & b;   // AND
            2'b11: result = a | b;   // OR
            default: result = 4'b0000;
        endcase
    end

    assign zero = (result == 4'b0000);

endmodule

module testbench;
    reg [3:0] a;
    reg [3:0] b;
    reg [1:0] op;
    wire [3:0] result;
    wire zero;

    alu dut (
        .a(a),
        .b(b),
        .op(op),
        .result(result),
        .zero(zero)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        a = 4'b0000;
        b = 4'b0000;
        op = 2'b00;

        #10 a = 4'b0011; b = 4'b0001; op = 2'b00;  // ADD
        #10 a = 4'b0100; b = 4'b0010; op = 2'b01;  // SUB
        #10 a = 4'b1100; b = 4'b1010; op = 2'b10;  // AND
        #10 a = 4'b1100; b = 4'b1010; op = 2'b11;  // OR
        #10 a = 4'b0000; b = 4'b0000; op = 2'b00;  // Result should be zero

        #10 $finish;
    end

    initial begin
        $monitor(""Time=%0t a=%b b=%b op=%b result=%b zero=%b"", 
                 $time, a, b, op, result, zero);
    end
endmodule",True,61,True,True,True,False,0.4,False,5.213032960891724,19.4400532245636,tie,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,Combinational,medium,"Create an 8:1 multiplexer with input data[7:0], select sel[2:0], and output out. Include testbench.",claude,"`timescale 1ns/1ps

module mux8to1(
    input wire [7:0] data,
    input wire [2:0] sel,
    output reg out
);

always @(*) begin
    case(sel)
        3'b000: out = data[0];
        3'b001: out = data[1];
        3'b010: out = data[2];
        3'b011: out = data[3];
        3'b100: out = data[4];
        3'b101: out = data[5];
        3'b110: out = data[6];
        3'b111: out = data[7];
        default: out = 1'b0;
    endcase
end

endmodule

module testbench;
    reg [7:0] data;
    reg [2:0] sel;
    wire out;

    mux8to1 dut (
        .data(data),
        .sel(sel),
        .out(out)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        data = 8'b10101010;
        sel = 3'b000;
        #10;
        
        repeat(8) begin
            #10 sel = sel + 1'b1;
        end

        data = 8'b11001100;
        sel = 3'b000;
        #10;
        
        repeat(8) begin
            #10 sel = sel + 1'b1;
        end

        #10 $finish;
    end

    initial begin
        $monitor(""Time=%0t data=%b sel=%b out=%b"", 
                 $time, data, sel, out);
    end
endmodule",True,63,True,True,True,False,0.4,False,5.47569465637207,7.6112589836120605,"graph LR
    D0[Data0] --> MUX{8:1 MUX}
    D1[Data1] --> MUX
    D2[Data2] --> MUX
    D3[Data3] --> MUX
    D4[Data4] --> MUX
    D5[Data5] --> MUX
    D6[Data6] --> MUX
    D7[Data7] --> MUX
    SEL0[Sel0] --> CTRL((Select<br/>Control))
    SEL1[Sel1] --> CTRL
    SEL2[Sel2] --> CTRL
    CTRL --> MUX
    MUX --> OUT[Output]
    TB[[Testbench]]
    TB -.-> D0
    TB -.-> D1
    TB -.-> D2
    TB -.-> D3
    TB -.-> D4
    TB -.-> D5
    TB -.-> D6
    TB -.-> D7
    TB -.-> SEL0
    TB -.-> SEL1
    TB -.-> SEL2
    OUT -.-> TB","`timescale 1ns/1ps

module mux8to1(
    input wire clk,
    input wire rst_n,
    input wire [7:0] data_in_0,
    input wire [7:0] data_in_1,
    input wire [7:0] data_in_2,
    input wire [7:0] data_in_3,
    input wire [7:0] data_in_4,
    input wire [7:0] data_in_5,
    input wire [7:0] data_in_6,
    input wire [7:0] data_in_7,
    input wire [2:0] sel,
    output reg [7:0] data_out
);

always @(posedge clk or negedge rst_n) begin
    if (!rst_n)
        data_out <= 8'h00;
    else
        case (sel)
            3'b000: data_out <= data_in_0;
            3'b001: data_out <= data_in_1;
            3'b010: data_out <= data_in_2;
            3'b011: data_out <= data_in_3;
            3'b100: data_out <= data_in_4;
            3'b101: data_out <= data_in_5;
            3'b110: data_out <= data_in_6;
            3'b111: data_out <= data_in_7;
            default: data_out <= 8'h00;
        endcase
end

endmodule

module testbench;
    reg clk, rst_n;
    reg [7:0] data_in_0, data_in_1, data_in_2, data_in_3;
    reg [7:0] data_in_4, data_in_5, data_in_6, data_in_7;
    reg [2:0] sel;
    wire [7:0] data_out;

    mux8to1 dut (
        .clk(clk),
        .rst_n(rst_n),
        .data_in_0(data_in_0),
        .data_in_1(data_in_1),
        .data_in_2(data_in_2),
        .data_in_3(data_in_3),
        .data_in_4(data_in_4),
        .data_in_5(data_in_5),
        .data_in_6(data_in_6),
        .data_in_7(data_in_7),
        .sel(sel),
        .data_out(data_out)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 0;
        rst_n = 0;
        data_in_0 = 8'h11;
        data_in_1 = 8'h22;
        data_in_2 = 8'h33;
        data_in_3 = 8'h44;
        data_in_4 = 8'h55;
        data_in_5 = 8'h66;
        data_in_6 = 8'h77;
        data_in_7 = 8'h88;
        sel = 3'b000;

        #20 rst_n = 1;
        
        #20 sel = 3'b001;
        #20 sel = 3'b010;
        #20 sel = 3'b011;
        #20 sel = 3'b100;
        #20 sel = 3'b101;
        #20 sel = 3'b110;
        #20 sel = 3'b111;
        
        #20 $finish;
    end

    always #10 clk = ~clk;

    initial begin
        $monitor(""Time=%0t rst_n=%b sel=%b data_out=%h"",
                 $time, rst_n, sel, data_out);
    end
endmodule",True,94,True,True,True,False,0.4,False,16.166566133499146,8.570587396621704,"Create an 8:1 multiplexer with input data[7:0], select sel[2:0], and output out. Include testbench.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph LR
    D0[Data0] --> MUX{8:1 MUX}
    D1[Data1] --> MUX
    D2[Data2] --> MUX
    D3[Data3] --> MUX
    D4[Data4] --> MUX
    D5[Data5] --> MUX
    D6[Data6] --> MUX
    D7[Data7] --> MUX
    SEL0[Sel0] --> CTRL((Select<br/>Control))
    SEL1[Sel1] --> CTRL
    SEL2[Sel2] --> CTRL
    CTRL --> MUX
    MUX --> OUT[Output]
    TB[[Testbench]]
    TB -.-> D0
    TB -.-> D1
    TB -.-> D2
    TB -.-> D3
    TB -.-> D4
    TB -.-> D5
    TB -.-> D6
    TB -.-> D7
    TB -.-> SEL0
    TB -.-> SEL1
    TB -.-> SEL2
    OUT -.-> TB
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module mux8to1(
    input wire [7:0] data,
    input wire [2:0] sel,
    output reg out
);

always @(*) begin
    case (sel)
        3'b000: out = data[0];
        3'b001: out = data[1];
        3'b010: out = data[2];
        3'b011: out = data[3];
        3'b100: out = data[4];
        3'b101: out = data[5];
        3'b110: out = data[6];
        3'b111: out = data[7];
        default: out = 1'b0;
    endcase
end

endmodule

module testbench;
    reg [7:0] data;
    reg [2:0] sel;
    wire out;

    mux8to1 dut (
        .data(data),
        .sel(sel),
        .out(out)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        data = 8'b00000000;
        sel = 3'b000;

        #10 data = 8'b10101010;
        
        #10;
        sel = 3'b000; #10;
        sel = 3'b001; #10;
        sel = 3'b010; #10;
        sel = 3'b011; #10;
        sel = 3'b100; #10;
        sel = 3'b101; #10;
        sel = 3'b110; #10;
        sel = 3'b111; #10;

        data = 8'b11110000;
        
        #10;
        sel = 3'b000; #10;
        sel = 3'b001; #10;
        sel = 3'b010; #10;
        sel = 3'b011; #10;
        sel = 3'b100; #10;
        sel = 3'b101; #10;
        sel = 3'b110; #10;
        sel = 3'b111; #10;

        $finish;
    end

    initial begin
        $monitor(""Time=%0t data=%b sel=%b out=%b"", 
                 $time, data, sel, out);
    end
endmodule",True,74,True,True,True,False,0.4,False,7.1146769523620605,7.055801630020142,tie,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,Combinational,medium,"Create an 8:1 multiplexer with input data[7:0], select sel[2:0], and output out. Include testbench.",gpt-4o,"`timescale 1ns/1ps

module mux_8to1(
    input wire [7:0] data,
    input wire [2:0] sel,
    output reg out
);

always @(*) begin
    case (sel)
        3'b000: out = data[0];
        3'b001: out = data[1];
        3'b010: out = data[2];
        3'b011: out = data[3];
        3'b100: out = data[4];
        3'b101: out = data[5];
        3'b110: out = data[6];
        3'b111: out = data[7];
        default: out = 1'b0;
    endcase
end

endmodule

module testbench;
    reg [7:0] data;
    reg [2:0] sel;
    wire out;

    mux_8to1 dut (
        .data(data),
        .sel(sel),
        .out(out)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        data = 8'b10101010;
        sel = 3'b000;
        #10 sel = 3'b001;
        #10 sel = 3'b010;
        #10 sel = 3'b011;
        #10 sel = 3'b100;
        #10 sel = 3'b101;
        #10 sel = 3'b110;
        #10 sel = 3'b111;
        #10 $finish;
    end

    initial begin
        $monitor(""Time=%0t data=%b sel=%b out=%b"", 
                 $time, data, sel, out);
    end
endmodule",True,56,True,True,True,False,0.4,False,3.7897396087646484,18.66519784927368,"graph LR
    data0[data[0]] --> MUX{8:1 MUX}
    data1[data[1]] --> MUX
    data2[data[2]] --> MUX
    data3[data[3]] --> MUX
    data4[data[4]] --> MUX
    data5[data[5]] --> MUX
    data6[data[6]] --> MUX
    data7[data[7]] --> MUX
    sel[sel[2:0]] --> MUX
    MUX --> out[out]
    TB[Testbench] --> data0
    TB --> data1
    TB --> data2
    TB --> data3
    TB --> data4
    TB --> data5
    TB --> data6
    TB --> data7
    TB --> sel
    out --> TB","`timescale 1ns/1ps

module mux_8to1(
    input wire [7:0] data,
    input wire [2:0] sel,
    output reg out,
    input wire clk
);

always @(posedge clk) begin
    case (sel)
        3'b000: out <= data[0];
        3'b001: out <= data[1];
        3'b010: out <= data[2];
        3'b011: out <= data[3];
        3'b100: out <= data[4];
        3'b101: out <= data[5];
        3'b110: out <= data[6];
        3'b111: out <= data[7];
    endcase
end

endmodule

module testbench;
    reg [7:0] data;
    reg [2:0] sel;
    wire out;
    reg clk;
    
    mux_8to1 dut (
        .data(data),
        .sel(sel),
        .out(out),
        .clk(clk)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        data = 8'b00000000;
        sel = 3'b000;
        
        #10 data = 8'b10101010;
        #10 sel = 3'b001;
        #10 sel = 3'b010;
        #10 sel = 3'b011;
        #10 sel = 3'b100;
        #10 sel = 3'b101;
        #10 sel = 3'b110;
        #10 sel = 3'b111;
        #50 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t clk=%b data=%b sel=%b out=%b"", 
                 $time, clk, data, sel, out);
    end
endmodule",True,63,True,True,True,True,0.7,True,6.362616777420044,16.936704635620117,"Create an 8:1 multiplexer with input data[7:0], select sel[2:0], and output out. Include testbench.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph LR
    data0[data[0]] --> MUX{8:1 MUX}
    data1[data[1]] --> MUX
    data2[data[2]] --> MUX
    data3[data[3]] --> MUX
    data4[data[4]] --> MUX
    data5[data[5]] --> MUX
    data6[data[6]] --> MUX
    data7[data[7]] --> MUX
    sel[sel[2:0]] --> MUX
    MUX --> out[out]
    TB[Testbench] --> data0
    TB --> data1
    TB --> data2
    TB --> data3
    TB --> data4
    TB --> data5
    TB --> data6
    TB --> data7
    TB --> sel
    out --> TB
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module mux8to1(
    input wire [7:0] data,
    input wire [2:0] sel,
    output reg out
);

always @(*) begin
    case (sel)
        3'b000: out = data[0];
        3'b001: out = data[1];
        3'b010: out = data[2];
        3'b011: out = data[3];
        3'b100: out = data[4];
        3'b101: out = data[5];
        3'b110: out = data[6];
        3'b111: out = data[7];
        default: out = 1'b0;
    endcase
end

endmodule

module testbench;
    reg [7:0] data;
    reg [2:0] sel;
    wire out;
    
    mux8to1 dut (
        .data(data),
        .sel(sel),
        .out(out)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        data = 8'b10101010;
        sel = 3'b000;
        
        #10 sel = 3'b001;
        #10 sel = 3'b010;
        #10 sel = 3'b011;
        #10 sel = 3'b100;
        #10 sel = 3'b101;
        #10 sel = 3'b110;
        #10 sel = 3'b111;
        #10 $finish;
    end
    
    initial begin
        $monitor(""Time=%0t data=%b sel=%b out=%b"", $time, data, sel, out);
    end
endmodule",True,56,True,True,True,False,0.4,False,6.4793171882629395,15.278836250305176,tie,prompt_only > combined > mermaid_only,prompt_only > mermaid_only > combined
combined,State Machine,medium,Design an FSM detecting pattern 1011 in serial input with overlapping detection. Include testbench with sequence: 10110111011.,claude,"`timescale 1ns/1ps

module pattern_detect (
    input wire clk,
    input wire rst_n,
    input wire data_in,
    output reg detected
);

reg [2:0] state;
reg [2:0] next_state;

parameter S0 = 3'd0;
parameter S1 = 3'd1;
parameter S2 = 3'd2;
parameter S3 = 3'd3;
parameter S4 = 3'd4;

always @(posedge clk or negedge rst_n) begin
    if (!rst_n)
        state <= S0;
    else
        state <= next_state;
end

always @(*) begin
    next_state = state;
    case (state)
        S0: next_state = (data_in) ? S1 : S0;
        S1: next_state = (data_in) ? S1 : S2;
        S2: next_state = (data_in) ? S3 : S0;
        S3: next_state = (data_in) ? S4 : S2;
        S4: next_state = (data_in) ? S1 : S2;
        default: next_state = S0;
    endcase
end

always @(posedge clk or negedge rst_n) begin
    if (!rst_n)
        detected <= 1'b0;
    else
        detected <= (state == S3 && data_in == 1'b1);
end

endmodule

module testbench;
    reg clk;
    reg rst_n;
    reg data_in;
    wire detected;

    pattern_detect dut (
        .clk(clk),
        .rst_n(rst_n),
        .data_in(data_in),
        .detected(detected)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 0;
        rst_n = 0;
        data_in = 0;

        #10 rst_n = 1;

        // Test sequence: 10110111011
        #10 data_in = 1;
        #10 data_in = 0;
        #10 data_in = 1;
        #10 data_in = 1;
        #10 data_in = 0;
        #10 data_in = 1;
        #10 data_in = 1;
        #10 data_in = 1;
        #10 data_in = 0;
        #10 data_in = 1;
        #10 data_in = 1;

        #20 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t rst_n=%b data_in=%b detected=%b"", 
                 $time, rst_n, data_in, detected);
    end
endmodule",True,92,True,True,True,False,0.3,False,8.689399242401123,8.123987913131714,"graph LR
    CLK[Clock] --> FSM((FSM Core))
    RST[Reset] --> FSM
    DIN[Serial Input] --> FSM
    FSM --> DETECT[Pattern Detected]
    FSM --> STATE[[Current State]]

    TB[Testbench] --> |10110111011| DIN
    CLK --> TB
    RST --> TB

    FSM --> |S0| IDLE((Idle))
    FSM --> |S1| GOT1((Got 1))
    FSM --> |S2| GOT10((Got 10))
    FSM --> |S3| GOT101((Got 101))
    FSM --> |S4| GOT1011((Got 1011))

    IDLE --> |1| GOT1
    GOT1 --> |0| GOT10
    GOT10 --> |1| GOT101
    GOT101 --> |1| GOT1011
    GOT1011 --> |1| GOT1

    STATE --> |State Feedback| FSM","`timescale 1ns/1ps

module pattern_detector(
    input wire clk,
    input wire rst,
    input wire din,
    output reg detect,
    output reg [2:0] state
);

parameter S0 = 3'b000;  // IDLE
parameter S1 = 3'b001;  // GOT1
parameter S2 = 3'b010;  // GOT10
parameter S3 = 3'b011;  // GOT101
parameter S4 = 3'b100;  // GOT1011

always @(posedge clk or posedge rst) begin
    if (rst) begin
        state <= S0;
        detect <= 1'b0;
    end else begin
        case (state)
            S0: begin
                state <= (din) ? S1 : S0;
                detect <= 1'b0;
            end
            S1: begin
                state <= (din) ? S1 : S2;
                detect <= 1'b0;
            end
            S2: begin
                state <= (din) ? S3 : S0;
                detect <= 1'b0;
            end
            S3: begin
                state <= (din) ? S4 : S0;
                detect <= 1'b0;
            end
            S4: begin
                state <= (din) ? S1 : S0;
                detect <= din;
            end
            default: begin
                state <= S0;
                detect <= 1'b0;
            end
        endcase
    end
end

endmodule

module testbench;
    reg clk, rst, din;
    wire detect;
    wire [2:0] state;

    pattern_detector dut (
        .clk(clk),
        .rst(rst),
        .din(din),
        .detect(detect),
        .state(state)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 1'b0;
        rst = 1'b1;
        din = 1'b0;

        #10 rst = 1'b0;

        // Test pattern: 10110111011
        #10 din = 1'b1;
        #10 din = 1'b0;
        #10 din = 1'b1;
        #10 din = 1'b1;
        #10 din = 1'b0;
        #10 din = 1'b1;
        #10 din = 1'b1;
        #10 din = 1'b1;
        #10 din = 1'b0;
        #10 din = 1'b1;
        #10 din = 1'b1;

        #20 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t rst=%b din=%b state=%b detect=%b"",
                 $time, rst, din, state, detect);
    end
endmodule",True,98,True,True,True,False,0.4,False,12.500663042068481,8.085106611251831,"Design an FSM detecting pattern 1011 in serial input with overlapping detection. Include testbench with sequence: 10110111011.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph LR
    CLK[Clock] --> FSM((FSM Core))
    RST[Reset] --> FSM
    DIN[Serial Input] --> FSM
    FSM --> DETECT[Pattern Detected]
    FSM --> STATE[[Current State]]

    TB[Testbench] --> |10110111011| DIN
    CLK --> TB
    RST --> TB

    FSM --> |S0| IDLE((Idle))
    FSM --> |S1| GOT1((Got 1))
    FSM --> |S2| GOT10((Got 10))
    FSM --> |S3| GOT101((Got 101))
    FSM --> |S4| GOT1011((Got 1011))

    IDLE --> |1| GOT1
    GOT1 --> |0| GOT10
    GOT10 --> |1| GOT101
    GOT101 --> |1| GOT1011
    GOT1011 --> |1| GOT1

    STATE --> |State Feedback| FSM
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module pattern_detector(
    input wire clk,
    input wire rst,
    input wire din,
    output reg detect,
    output reg [2:0] state
);

parameter S0 = 3'b000;  // IDLE
parameter S1 = 3'b001;  // GOT1
parameter S2 = 3'b010;  // GOT10
parameter S3 = 3'b011;  // GOT101
parameter S4 = 3'b100;  // GOT1011

always @(posedge clk or posedge rst) begin
    if (rst) begin
        state <= S0;
        detect <= 1'b0;
    end
    else begin
        case (state)
            S0: begin
                state <= (din) ? S1 : S0;
                detect <= 1'b0;
            end
            S1: begin
                state <= (din) ? S1 : S2;
                detect <= 1'b0;
            end
            S2: begin
                state <= (din) ? S3 : S0;
                detect <= 1'b0;
            end
            S3: begin
                state <= (din) ? S4 : S0;
                detect <= 1'b0;
            end
            S4: begin
                state <= (din) ? S1 : S2;
                detect <= 1'b1;
            end
            default: state <= S0;
        endcase
    end
end

endmodule

module testbench;
    reg clk;
    reg rst;
    reg din;
    wire detect;
    wire [2:0] state;
    
    pattern_detector dut (
        .clk(clk),
        .rst(rst),
        .din(din),
        .detect(detect),
        .state(state)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 0;
        rst = 1;
        din = 0;
        
        #10 rst = 0;
        
        // Test pattern: 10110111011
        #10 din = 1;
        #10 din = 0;
        #10 din = 1;
        #10 din = 1;
        #10 din = 0;
        #10 din = 1;
        #10 din = 1;
        #10 din = 1;
        #10 din = 0;
        #10 din = 1;
        #10 din = 1;
        
        #20 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t rst=%b din=%b state=%b detect=%b"", 
                 $time, rst, din, state, detect);
    end
endmodule",True,98,True,True,True,False,0.4,False,8.584948539733887,8.948730945587158,tie,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,State Machine,medium,Design an FSM detecting pattern 1011 in serial input with overlapping detection. Include testbench with sequence: 10110111011.,gpt-4o,"`timescale 1ns/1ps

module fsm_1011_detector(
    input wire clk,
    input wire rst_n,
    input wire serial_in,
    output reg pattern_detected
);

    typedef enum reg [2:0] {
        S0 = 3'b000,
        S1 = 3'b001,
        S10 = 3'b010,
        S101 = 3'b011,
        S1011 = 3'b100
    } state_t;

    reg [2:0] state, next_state;

    always @(posedge clk or negedge rst_n) begin
        if (!rst_n)
            state <= S0;
        else
            state <= next_state;
    end
    
    always @(*) begin
        pattern_detected = 1'b0;
        case (state)
            S0: begin
                if (serial_in)
                    next_state = S1;
                else
                    next_state = S0;
            end
            S1: begin
                if (serial_in)
                    next_state = S1;
                else
                    next_state = S10;
            end
            S10: begin
                if (serial_in)
                    next_state = S101;
                else
                    next_state = S0;
            end
            S101: begin
                if (serial_in) begin
                    next_state = S1011;
                    pattern_detected = 1'b1;
                end else
                    next_state = S10;
            end
            S1011: begin
                if (serial_in)
                    next_state = S1;
                else
                    next_state = S10;
            end
            default: next_state = S0;
        endcase
    end

endmodule

module testbench;
    reg clk, rst_n, serial_in;
    wire pattern_detected;
    
    fsm_1011_detector dut (
        .clk(clk),
        .rst_n(rst_n),
        .serial_in(serial_in),
        .pattern_detected(pattern_detected)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst_n = 1'b0;
        serial_in = 1'b0;
        
        #20 rst_n = 1'b1;
        
        // Sequence: 10110111011
        #10 serial_in = 1'b1;
        #10 serial_in = 1'b0;
        #10 serial_in = 1'b1;
        #10 serial_in = 1'b1;
        #10 serial_in = 1'b0;
        #10 serial_in = 1'b1;
        #10 serial_in = 1'b1;
        #10 serial_in = 1'b1;
        #10 serial_in = 1'b0;
        #10 serial_in = 1'b1;
        #10 serial_in = 1'b1;
        #10 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b serial_in=%b pattern_detected=%b"", 
                 $time, clk, rst_n, serial_in, pattern_detected);
    end
endmodule",True,109,True,True,True,True,0.7,True,25.369576930999756,72.4218864440918,"graph LR
    CLK[Clock] --> S0((S0))
    RST[Reset] --> S0
    IN[Serial Input] --> S0
    S0 -->|0| S0
    S0 -->|1| S1((S1))
    S1 -->|0| S2((S2))
    S1 -->|1| S1
    S2 -->|1| S3((S3))
    S2 -->|0| S0
    S3 -->|1| S4((S4))
    S3 -->|0| S2
    S4 -->|1| S1
    S4 -->|0| S2
    S4 --> DETECTED[Pattern Detected]
    DETECTED --> OUT[Output Signal]

    TESTBENCH[Testbench Sequence: 10110111011] --> IN","`timescale 1ns/1ps

module fsm(
    input wire clk,
    input wire rst,
    input wire serial_in,
    output reg pattern_detected
);

    typedef enum reg [2:0] {
        S0 = 3'b000,
        S1 = 3'b001,
        S2 = 3'b010,
        S3 = 3'b011,
        S4 = 3'b100
    } state_t;

    reg [2:0] state, next_state;

    always @(posedge clk or posedge rst) begin
        if (rst)
            state <= S0;
        else
            state <= next_state;
    end

    always @(*) begin
        next_state = state;
        pattern_detected = 1'b0;
        case (state)
            S0: begin
                if (serial_in)
                    next_state = S1;
            end
            S1: begin
                if (serial_in)
                    next_state = S1;
                else
                    next_state = S2;
            end
            S2: begin
                if (serial_in)
                    next_state = S3;
                else
                    next_state = S0;
            end
            S3: begin
                if (serial_in)
                    next_state = S4;
                else
                    next_state = S2;
            end
            S4: begin
                pattern_detected = 1'b1;
                if (serial_in)
                    next_state = S1;
                else
                    next_state = S2;
            end
        endcase
    end

endmodule

module testbench;
    reg clk, rst, serial_in;
    wire pattern_detected;

    fsm dut (
        .clk(clk),
        .rst(rst),
        .serial_in(serial_in),
        .pattern_detected(pattern_detected)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 1'b0;
        rst = 1'b1;
        serial_in = 1'b0;

        #10 rst = 1'b0;
        #10 serial_in = 1'b1; // 1
        #10 serial_in = 1'b0; // 10
        #10 serial_in = 1'b1; // 101
        #10 serial_in = 1'b1; // 1011
        #10 serial_in = 1'b0; // 10110
        #10 serial_in = 1'b1; // 101101
        #10 serial_in = 1'b1; // 1011011
        #10 serial_in = 1'b1; // 10110111
        #10 serial_in = 1'b0; // 101101110
        #10 serial_in = 1'b1; // 1011011101
        #10 serial_in = 1'b1; // 10110111011

        #20 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t clk=%b rst=%b serial_in=%b pattern_detected=%b"",
                 $time, clk, rst, serial_in, pattern_detected);
    end
endmodule",True,106,True,True,True,True,0.7,True,30.712503671646118,11.725090026855469,"Design an FSM detecting pattern 1011 in serial input with overlapping detection. Include testbench with sequence: 10110111011.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph LR
    CLK[Clock] --> S0((S0))
    RST[Reset] --> S0
    IN[Serial Input] --> S0
    S0 -->|0| S0
    S0 -->|1| S1((S1))
    S1 -->|0| S2((S2))
    S1 -->|1| S1
    S2 -->|1| S3((S3))
    S2 -->|0| S0
    S3 -->|1| S4((S4))
    S3 -->|0| S2
    S4 -->|1| S1
    S4 -->|0| S2
    S4 --> DETECTED[Pattern Detected]
    DETECTED --> OUT[Output Signal]

    TESTBENCH[Testbench Sequence: 10110111011] --> IN
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module fsm_pattern_detector(
    input wire clk,
    input wire rst,
    input wire serial_in,
    output reg detected
);

    reg [2:0] state, next_state;
    
    localparam S0 = 3'b000,
               S1 = 3'b001,
               S2 = 3'b010,
               S3 = 3'b011,
               S4 = 3'b100;

    always @(posedge clk or posedge rst) begin
        if (rst)
            state <= S0;
        else
            state <= next_state;
    end

    always @(*) begin
        next_state = state;
        detected = 1'b0;
        case (state)
            S0: if (serial_in) next_state = S1;
            S1: if (serial_in) next_state = S1; else next_state = S2;
            S2: if (serial_in) next_state = S3; else next_state = S0;
            S3: if (serial_in) next_state = S4; else next_state = S2;
            S4: begin
                    if (serial_in) next_state = S1; else next_state = S2;
                    detected = 1'b1;
                end
            default: next_state = S0;
        endcase
    end

endmodule

module testbench;
    reg clk, rst, serial_in;
    wire detected;
    
    fsm_pattern_detector dut (
        .clk(clk),
        .rst(rst),
        .serial_in(serial_in),
        .detected(detected)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 1'b0;
        rst = 1'b1;
        serial_in = 1'b0;
        
        #10 rst = 1'b0;
        #10 serial_in = 1'b1; // 1
        #10 serial_in = 1'b0; // 0
        #10 serial_in = 1'b1; // 1
        #10 serial_in = 1'b1; // 1 (Pattern Detected)
        #10 serial_in = 1'b0; // 0
        #10 serial_in = 1'b1; // 1
        #10 serial_in = 1'b1; // 1
        #10 serial_in = 1'b1; // 1
        #10 serial_in = 1'b0; // 0
        #10 serial_in = 1'b1; // 1 (Pattern Detected)
        #10 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t clk=%b rst=%b serial_in=%b detected=%b"", 
                 $time, clk, rst, serial_in, detected);
    end
endmodule",True,82,True,True,True,True,0.7,True,24.36171317100525,59.07193970680237,prompt_only,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,Sequential,medium,"Create a 4-bit PISO shift register with clock, reset, load, parallel input[3:0], and serial output. Include testbench.",claude,"`timescale 1ns/1ps

module piso_shift_reg (
    input wire clk,
    input wire rst_n,
    input wire load,
    input wire [3:0] parallel_in,
    output reg serial_out
);

reg [3:0] shift_reg;

always @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
        shift_reg <= 4'b0000;
        serial_out <= 1'b0;
    end
    else if (load) begin
        shift_reg <= parallel_in;
        serial_out <= parallel_in[3];
    end
    else begin
        shift_reg <= {shift_reg[2:0], 1'b0};
        serial_out <= shift_reg[3];
    end
end

endmodule

module testbench;
    reg clk, rst_n, load;
    reg [3:0] parallel_in;
    wire serial_out;

    piso_shift_reg dut (
        .clk(clk),
        .rst_n(rst_n),
        .load(load),
        .parallel_in(parallel_in),
        .serial_out(serial_out)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 0;
        rst_n = 0;
        load = 0;
        parallel_in = 4'b0000;

        #10 rst_n = 1;
        #10 parallel_in = 4'b1101;
        #10 load = 1;
        #10 load = 0;
        #40 parallel_in = 4'b1011;
        #10 load = 1;
        #10 load = 0;
        #40 rst_n = 0;
        #10 rst_n = 1;
        #20 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t rst_n=%b load=%b parallel_in=%b serial_out=%b"", 
                 $time, rst_n, load, parallel_in, serial_out);
    end
endmodule",True,70,True,True,True,True,0.7,True,6.472585678100586,8.63707971572876,"graph LR
    CLK[Clock] --> REG[[4-bit Register]]
    RST[Reset] --> REG
    LOAD[Load] --> MUX{MUX}
    D3[D3] --> REG
    D2[D2] --> REG
    D1[D1] --> REG
    D0[D0] --> REG
    REG --> FB(Feedback)
    FB --> MUX
    MUX --> REG
    REG --> SO[Serial Out]
    
    TB1[Testbench Signals]
    TB1 --> |Stimulus|CLK
    TB1 --> |Stimulus|RST
    TB1 --> |Stimulus|LOAD
    TB1 --> |Stimulus|D3
    TB1 --> |Stimulus|D2
    TB1 --> |Stimulus|D1
    TB1 --> |Stimulus|D0
    SO --> |Monitor|TB2[Testbench Monitor]","`timescale 1ns/1ps

module shift_reg(
    input wire clk,
    input wire rst,
    input wire load,
    input wire [3:0] d,
    output wire serial_out
);

reg [3:0] reg_data;
wire feedback;

assign feedback = reg_data[3];
assign serial_out = feedback;

always @(posedge clk or posedge rst) begin
    if (rst)
        reg_data <= 4'b0000;
    else if (load)
        reg_data <= d;
    else
        reg_data <= {reg_data[2:0], feedback};
end

endmodule

module testbench;
    reg clk;
    reg rst;
    reg load;
    reg [3:0] d;
    wire serial_out;

    shift_reg dut (
        .clk(clk),
        .rst(rst),
        .load(load),
        .d(d),
        .serial_out(serial_out)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 0;
        rst = 1;
        load = 0;
        d = 4'b0000;

        #10 rst = 0;
        #10 d = 4'b1010;
        #10 load = 1;
        #10 load = 0;
        #50 rst = 1;
        #10 rst = 0;
        #50 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t rst=%b load=%b d=%b serial_out=%b"",
                 $time, rst, load, d, serial_out);
    end
endmodule",True,67,True,True,True,False,0.4,False,10.784496307373047,7.7403576374053955,"Create a 4-bit PISO shift register with clock, reset, load, parallel input[3:0], and serial output. Include testbench.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph LR
    CLK[Clock] --> REG[[4-bit Register]]
    RST[Reset] --> REG
    LOAD[Load] --> MUX{MUX}
    D3[D3] --> REG
    D2[D2] --> REG
    D1[D1] --> REG
    D0[D0] --> REG
    REG --> FB(Feedback)
    FB --> MUX
    MUX --> REG
    REG --> SO[Serial Out]
    
    TB1[Testbench Signals]
    TB1 --> |Stimulus|CLK
    TB1 --> |Stimulus|RST
    TB1 --> |Stimulus|LOAD
    TB1 --> |Stimulus|D3
    TB1 --> |Stimulus|D2
    TB1 --> |Stimulus|D1
    TB1 --> |Stimulus|D0
    SO --> |Monitor|TB2[Testbench Monitor]
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module piso_shift_reg (
    input wire clk,
    input wire rst,
    input wire load,
    input wire [3:0] parallel_in,
    output wire serial_out
);

reg [3:0] shift_reg;

always @(posedge clk or posedge rst) begin
    if (rst)
        shift_reg <= 4'b0000;
    else if (load)
        shift_reg <= parallel_in;
    else
        shift_reg <= {shift_reg[2:0], 1'b0};
end

assign serial_out = shift_reg[3];

endmodule

module testbench;
    reg clk;
    reg rst;
    reg load;
    reg [3:0] parallel_in;
    wire serial_out;

    piso_shift_reg dut (
        .clk(clk),
        .rst(rst),
        .load(load),
        .parallel_in(parallel_in),
        .serial_out(serial_out)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 0;
        rst = 1;
        load = 0;
        parallel_in = 4'b0000;

        #10 rst = 0;
        
        #10 parallel_in = 4'b1101;
        load = 1;
        #10 load = 0;
        
        #40 parallel_in = 4'b0110;
        load = 1;
        #10 load = 0;
        
        #40 rst = 1;
        #10 rst = 0;
        
        #50 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t rst=%b load=%b parallel_in=%b serial_out=%b shift_reg=%b"",
                 $time, rst, load, parallel_in, serial_out, dut.shift_reg);
    end
endmodule",True,72,True,True,True,False,0.4,False,6.272522926330566,7.879508972167969,tie,mermaid_only > combined > prompt_only,prompt_only > mermaid_only > combined
combined,Sequential,medium,"Create a 4-bit PISO shift register with clock, reset, load, parallel input[3:0], and serial output. Include testbench.",gpt-4o,"`timescale 1ns/1ps

module piso_shift_register(
    input wire clk,
    input wire rst_n,
    input wire load,
    input wire [3:0] parallel_in,
    output reg serial_out
);

reg [3:0] shift_reg;

always @(posedge clk or negedge rst_n) begin
    if (!rst_n)
        shift_reg <= 4'b0000;
    else if (load)
        shift_reg <= parallel_in;
    else
        shift_reg <= {shift_reg[2:0], 1'b0};
end

always @(shift_reg) begin
    serial_out = shift_reg[3];
end

endmodule

module testbench;
    reg clk, rst_n, load;
    reg [3:0] parallel_in;
    wire serial_out;
    
    piso_shift_register dut (
        .clk(clk),
        .rst_n(rst_n),
        .load(load),
        .parallel_in(parallel_in),
        .serial_out(serial_out)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst_n = 1'b0;
        load = 1'b0;
        parallel_in = 4'b1010;
        
        #20 rst_n = 1'b1;
        #10 load = 1'b1;
        #10 load = 1'b0;
        #100 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b load=%b parallel_in=%b serial_out=%b"", 
                 $time, clk, rst_n, load, parallel_in, serial_out);
    end
endmodule",True,62,True,True,True,True,0.7,True,7.590178966522217,10.341279029846191,"graph LR
    CLK[Clock] --> SHIFT(Shift Register Logic)
    RST[Reset] --> SHIFT
    LOAD[Load] --> SHIFT
    PI[Parallel Input[3:0]] --> SHIFT
    SHIFT --> SO[Serial Output]
    
    subgraph Testbench
        CLK --> TB[TB Logic]
        RST --> TB
        LOAD --> TB
        PI --> TB
        TB --> SO
    end","`timescale 1ns/1ps

module shift_register(
    input wire clk,
    input wire rst_n,
    input wire load,
    input wire [3:0] parallel_in,
    output reg serial_out
);

    reg [3:0] shift_reg;

    always @(posedge clk or negedge rst_n) begin
        if (!rst_n)
            shift_reg <= 4'b0000;
        else if (load)
            shift_reg <= parallel_in;
        else
            shift_reg <= {shift_reg[2:0], 1'b0};
    end

    always @(posedge clk or negedge rst_n) begin
        if (!rst_n)
            serial_out <= 1'b0;
        else
            serial_out <= shift_reg[3];
    end

endmodule

module testbench;
    reg clk, rst_n, load;
    reg [3:0] parallel_in;
    wire serial_out;

    shift_register dut (
        .clk(clk),
        .rst_n(rst_n),
        .load(load),
        .parallel_in(parallel_in),
        .serial_out(serial_out)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 1'b0;
        rst_n = 1'b0;
        load = 1'b0;
        parallel_in = 4'b0000;

        #20 rst_n = 1'b1;
        #10 load = 1'b1; parallel_in = 4'b1010;
        #10 load = 1'b0;
        #100 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b load=%b parallel_in=%b serial_out=%b"", 
                 $time, clk, rst_n, load, parallel_in, serial_out);
    end
endmodule",True,65,True,True,True,True,0.7,True,9.85631775856018,45.18332076072693,"Create a 4-bit PISO shift register with clock, reset, load, parallel input[3:0], and serial output. Include testbench.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph LR
    CLK[Clock] --> SHIFT(Shift Register Logic)
    RST[Reset] --> SHIFT
    LOAD[Load] --> SHIFT
    PI[Parallel Input[3:0]] --> SHIFT
    SHIFT --> SO[Serial Output]
    
    subgraph Testbench
        CLK --> TB[TB Logic]
        RST --> TB
        LOAD --> TB
        PI --> TB
        TB --> SO
    end
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module piso_shift_register(
    input wire clk,
    input wire rst,
    input wire load,
    input wire [3:0] parallel_in,
    output reg serial_out
);

reg [3:0] shift_reg;

always @(posedge clk or posedge rst) begin
    if (rst)
        shift_reg <= 4'b0000;
    else if (load)
        shift_reg <= parallel_in;
    else
        shift_reg <= {shift_reg[2:0], 1'b0};
end

always @(posedge clk or posedge rst) begin
    if (rst)
        serial_out <= 1'b0;
    else
        serial_out <= shift_reg[3];
end

endmodule

module testbench;
    reg clk, rst, load;
    reg [3:0] parallel_in;
    wire serial_out;
    
    piso_shift_register dut (
        .clk(clk),
        .rst(rst),
        .load(load),
        .parallel_in(parallel_in),
        .serial_out(serial_out)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst = 1'b0;
        load = 1'b0;
        parallel_in = 4'b0000;
        
        #20 rst = 1'b1;
        #10 rst = 1'b0;
        #10 load = 1'b1;
        parallel_in = 4'b1010;
        #10 load = 1'b0;
        #80 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t clk=%b rst=%b load=%b parallel_in=%b serial_out=%b"", 
                 $time, clk, rst, load, parallel_in, serial_out);
    end
endmodule",True,67,True,True,True,True,0.7,True,5.737976551055908,12.228055953979492,prompt_only,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,Combinational,medium,"Design a 4-to-2 priority encoder with input in[3:0], output out[1:0], and valid bit. Highest bit has priority. Include testbench.",claude,"`timescale 1ns/1ps

module priority_encoder(
    input wire [3:0] in,
    output reg [1:0] out,
    output reg valid
);

always @(*) begin
    if (in[3]) begin
        out = 2'b11;
        valid = 1'b1;
    end
    else if (in[2]) begin
        out = 2'b10;
        valid = 1'b1;
    end
    else if (in[1]) begin
        out = 2'b01;
        valid = 1'b1;
    end
    else if (in[0]) begin
        out = 2'b00;
        valid = 1'b1;
    end
    else begin
        out = 2'b00;
        valid = 1'b0;
    end
end

endmodule

module testbench;
    reg [3:0] in;
    wire [1:0] out;
    wire valid;

    priority_encoder dut (
        .in(in),
        .out(out),
        .valid(valid)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        in = 4'b0000;
        #10 in = 4'b0001;
        #10 in = 4'b0010;
        #10 in = 4'b0100;
        #10 in = 4'b1000;
        #10 in = 4'b1100;
        #10 in = 4'b1110;
        #10 in = 4'b1111;
        #10 in = 4'b0000;
        #10 $finish;
    end

    initial begin
        $monitor(""Time=%0t in=%b out=%b valid=%b"", 
                 $time, in, out, valid);
    end
endmodule",True,65,True,True,True,False,0.4,False,5.677011966705322,7.440570116043091,"graph LR
    IN0[in[0]] --> PE[Priority Encoder Logic]
    IN1[in[1]] --> PE
    IN2[in[2]] --> PE
    IN3[in[3]] --> PE
    PE --> OUT[out[1:0]]
    PE --> VALID[valid]
    TB[Testbench] -.-> IN0
    TB -.-> IN1
    TB -.-> IN2
    TB -.-> IN3
    TB -.-> CHECK{Verification}
    OUT --> CHECK
    VALID --> CHECK
    subgraph Priority_Logic
    PE --> |if in[3]=1| ENC3((out=3))
    PE --> |if in[2]=1| ENC2((out=2))
    PE --> |if in[1]=1| ENC1((out=1))
    PE --> |if in[0]=1| ENC0((out=0))
    end","`timescale 1ns/1ps

module priority_encoder(
    input wire [3:0] in,
    input wire clk,
    input wire rst_n,
    output reg [1:0] out,
    output reg valid
);

always @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
        out <= 2'b00;
        valid <= 1'b0;
    end
    else begin
        valid <= |in;
        if (in[3])
            out <= 2'b11;
        else if (in[2])
            out <= 2'b10;
        else if (in[1])
            out <= 2'b01;
        else if (in[0])
            out <= 2'b00;
        else
            out <= 2'b00;
    end
end

endmodule

module testbench;
    reg [3:0] in;
    reg clk, rst_n;
    wire [1:0] out;
    wire valid;

    priority_encoder dut (
        .in(in),
        .clk(clk),
        .rst_n(rst_n),
        .out(out),
        .valid(valid)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 0;
        rst_n = 0;
        in = 4'b0000;
        
        #10 rst_n = 1;
        
        #10 in = 4'b0001;
        #10 in = 4'b0010;
        #10 in = 4'b0100;
        #10 in = 4'b1000;
        #10 in = 4'b1100;
        #10 in = 4'b0011;
        #10 in = 4'b1111;
        #10 in = 4'b0000;
        
        #10 rst_n = 0;
        #10 rst_n = 1;
        
        #10 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t rst_n=%b in=%b out=%b valid=%b"", 
                 $time, rst_n, in, out, valid);
    end
endmodule",True,78,True,True,True,True,0.8,True,11.108482599258423,8.52374005317688,"Design a 4-to-2 priority encoder with input in[3:0], output out[1:0], and valid bit. Highest bit has priority. Include testbench.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph LR
    IN0[in[0]] --> PE[Priority Encoder Logic]
    IN1[in[1]] --> PE
    IN2[in[2]] --> PE
    IN3[in[3]] --> PE
    PE --> OUT[out[1:0]]
    PE --> VALID[valid]
    TB[Testbench] -.-> IN0
    TB -.-> IN1
    TB -.-> IN2
    TB -.-> IN3
    TB -.-> CHECK{Verification}
    OUT --> CHECK
    VALID --> CHECK
    subgraph Priority_Logic
    PE --> |if in[3]=1| ENC3((out=3))
    PE --> |if in[2]=1| ENC2((out=2))
    PE --> |if in[1]=1| ENC1((out=1))
    PE --> |if in[0]=1| ENC0((out=0))
    end
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module priority_encoder(
    input wire [3:0] in,
    output reg [1:0] out,
    output reg valid
);

always @(*) begin
    valid = |in;
    if (in[3])
        out = 2'd3;
    else if (in[2])
        out = 2'd2;
    else if (in[1]) 
        out = 2'd1;
    else if (in[0])
        out = 2'd0;
    else
        out = 2'd0;
end

endmodule

module testbench;
    reg [3:0] in;
    wire [1:0] out;
    wire valid;

    priority_encoder dut (
        .in(in),
        .out(out),
        .valid(valid)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        in = 4'b0000;
        #10 in = 4'b0001;
        #10 in = 4'b0010;
        #10 in = 4'b0100;
        #10 in = 4'b1000;
        #10 in = 4'b1111;
        #10 in = 4'b0011;
        #10 in = 4'b0101;
        #10 in = 4'b1010;
        #10 $finish;
    end

    initial begin
        $monitor(""Time=%0t in=%b out=%b valid=%b"", 
                 $time, in, out, valid);
    end
endmodule",True,56,True,True,True,False,0.4,False,5.262120962142944,7.235066175460815,tie,prompt_only > combined > mermaid_only,prompt_only > mermaid_only > combined
combined,Combinational,medium,"Design a 4-to-2 priority encoder with input in[3:0], output out[1:0], and valid bit. Highest bit has priority. Include testbench.",gpt-4o,"`timescale 1ns/1ps

module priority_encoder(
    input wire [3:0] in,
    output reg [1:0] out,
    output reg valid
);

always @(in) begin
    valid = 1'b0;
    out = 2'b00;
    if (in[3]) begin
        valid = 1'b1;
        out = 2'b11;
    end else if (in[2]) begin
        valid = 1'b1;
        out = 2'b10;
    end else if (in[1]) begin
        valid = 1'b1;
        out = 2'b01;
    end else if (in[0]) begin
        valid = 1'b1;
        out = 2'b00;
    end
end

endmodule

module testbench;
    reg [3:0] in;
    wire [1:0] out;
    wire valid;

    priority_encoder dut (
        .in(in),
        .out(out),
        .valid(valid)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        in = 4'b0000; #10;
        in = 4'b0001; #10;
        in = 4'b0010; #10;
        in = 4'b0100; #10;
        in = 4'b1000; #10;
        in = 4'b0011; #10;
        in = 4'b0110; #10;
        in = 4'b1111; #10;
        $finish;
    end

    initial begin
        $monitor(""Time=%0t in=%b out=%b valid=%b"", 
                 $time, in, out, valid);
    end
endmodule",True,59,True,True,True,False,0.4,False,4.918736696243286,13.63542127609253,"graph TD
    CLK[Clock] --> ENC(Encoder Logic)
    RST[Reset] --> ENC
    IN0[in[0]] --> ENC
    IN1[in[1]] --> ENC
    IN2[in[2]] --> ENC
    IN3[in[3]] --> ENC
    ENC --> OUT0[out[0]]
    ENC --> OUT1[out[1]]
    ENC --> VALID[Valid Bit]
    
    subgraph TESTBENCH[ ]
        TB_CLK[Clock] --> TB
        TB_RST[Reset] --> TB
        TB --> IN0
        TB --> IN1
        TB --> IN2
        TB --> IN3
        TB <-- OUT0
        TB <-- OUT1
        TB <-- VALID
    end","`timescale 1ns/1ps

module encoder(
    input wire clk,
    input wire rst,
    input wire [3:0] in,
    output reg [1:0] out,
    output reg valid
);

always @(posedge clk or posedge rst) begin
    if (rst) begin
        out <= 2'b00;
        valid <= 1'b0;
    end else begin
        out <= in[1:0];
        valid <= 1'b1;
    end
end

endmodule

module testbench;
    reg clk, rst;
    reg [3:0] in;
    wire [1:0] out;
    wire valid;
    
    encoder dut (
        .clk(clk),
        .rst(rst),
        .in(in),
        .out(out),
        .valid(valid)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst = 1'b0;
        in = 4'b0000;
        
        #15 rst = 1'b1;
        #10 rst = 1'b0;
        #10 in = 4'b1010;
        #10 in = 4'b1100;
        #10 in = 4'b1111;
        #50 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t clk=%b rst=%b in=%b out=%b valid=%b"", 
                 $time, clk, rst, in, out, valid);
    end
endmodule",True,59,True,True,True,True,0.7,True,12.596927642822266,11.97544264793396,"Design a 4-to-2 priority encoder with input in[3:0], output out[1:0], and valid bit. Highest bit has priority. Include testbench.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph TD
    CLK[Clock] --> ENC(Encoder Logic)
    RST[Reset] --> ENC
    IN0[in[0]] --> ENC
    IN1[in[1]] --> ENC
    IN2[in[2]] --> ENC
    IN3[in[3]] --> ENC
    ENC --> OUT0[out[0]]
    ENC --> OUT1[out[1]]
    ENC --> VALID[Valid Bit]
    
    subgraph TESTBENCH[ ]
        TB_CLK[Clock] --> TB
        TB_RST[Reset] --> TB
        TB --> IN0
        TB --> IN1
        TB --> IN2
        TB --> IN3
        TB <-- OUT0
        TB <-- OUT1
        TB <-- VALID
    end
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module encoder(
    input wire clk,
    input wire rst,
    input wire [3:0] in,
    output reg [1:0] out,
    output reg valid
);

always @(posedge clk or posedge rst) begin
    if (rst) begin
        out <= 2'b00;
        valid <= 1'b0;
    end else begin
        valid <= 1'b1; // Assume valid unless proven otherwise
        casex (in)
            4'b1xxx: out <= 2'b11;
            4'b01xx: out <= 2'b10;
            4'b001x: out <= 2'b01;
            4'b0001: out <= 2'b00;
            default: begin
                out <= 2'b00;
                valid <= 1'b0; // No valid input detected
            end
        endcase
    end
end

endmodule

module testbench;
    reg clk, rst;
    reg [3:0] in;
    wire [1:0] out;
    wire valid;

    encoder dut (
        .clk(clk),
        .rst(rst),
        .in(in),
        .out(out),
        .valid(valid)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst = 1'b0;
        in = 4'b0000;
        
        #10 rst = 1'b1;
        #10 rst = 1'b0;
        
        #10 in = 4'b0001;
        #10 in = 4'b0010;
        #10 in = 4'b0100;
        #10 in = 4'b1000;
        #10 in = 4'b1010;
        #10 in = 4'b1111;
        #10 in = 4'b0000; // Invalid case
        
        #50 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t clk=%b rst=%b in=%b out=%b valid=%b"", 
                 $time, clk, rst, in, out, valid);
    end
endmodule",True,74,True,True,True,True,0.7,True,8.960248947143555,16.911696195602417,prompt_only,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,State Machine,complex,"Design a traffic light FSM with 4 states: NS_GREEN, NS_YELLOW, EW_GREEN, EW_YELLOW. Inputs: clk, rst, emergency. Outputs: ns_light[1:0], ew_light[1:0]. Timing: GREEN=8 cycles, YELLOW=2 cycles. Emergency makes both RED. Include testbench.",claude,"`timescale 1ns/1ps

module traffic_light(
    input wire clk,
    input wire rst,
    input wire emergency,
    output reg [1:0] ns_light,
    output reg [1:0] ew_light
);

parameter [1:0] RED = 2'b00;
parameter [1:0] YELLOW = 2'b01;
parameter [1:0] GREEN = 2'b10;

parameter [1:0] NS_GREEN = 2'b00;
parameter [1:0] NS_YELLOW = 2'b01;
parameter [1:0] EW_GREEN = 2'b10;
parameter [1:0] EW_YELLOW = 2'b11;

reg [1:0] state;
reg [3:0] timer;

always @(posedge clk or posedge rst) begin
    if (rst) begin
        state <= NS_GREEN;
        timer <= 4'd0;
        ns_light <= GREEN;
        ew_light <= RED;
    end
    else if (emergency) begin
        ns_light <= RED;
        ew_light <= RED;
        state <= NS_GREEN;
        timer <= 4'd0;
    end
    else begin
        case (state)
            NS_GREEN: begin
                if (timer >= 4'd7) begin
                    state <= NS_YELLOW;
                    timer <= 4'd0;
                    ns_light <= YELLOW;
                end
                else begin
                    timer <= timer + 1'b1;
                    ns_light <= GREEN;
                    ew_light <= RED;
                end
            end
            
            NS_YELLOW: begin
                if (timer >= 4'd1) begin
                    state <= EW_GREEN;
                    timer <= 4'd0;
                    ns_light <= RED;
                    ew_light <= GREEN;
                end
                else begin
                    timer <= timer + 1'b1;
                    ns_light <= YELLOW;
                    ew_light <= RED;
                end
            end
            
            EW_GREEN: begin
                if (timer >= 4'd7) begin
                    state <= EW_YELLOW;
                    timer <= 4'd0;
                    ew_light <= YELLOW;
                end
                else begin
                    timer <= timer + 1'b1;
                    ns_light <= RED;
                    ew_light <= GREEN;
                end
            end
            
            EW_YELLOW: begin
                if (timer >= 4'd1) begin
                    state <= NS_GREEN;
                    timer <= 4'd0;
                    ns_light <= GREEN;
                    ew_light <= RED;
                end
                else begin
                    timer <= timer + 1'b1;
                    ns_light <= RED;
                    ew_light <= YELLOW;
                end
            end
        endcase
    end
end

endmodule

module testbench;
    reg clk;
    reg rst;
    reg emergency;
    wire [1:0] ns_light;
    wire [1:0] ew_light;

    traffic_light dut (
        .clk(clk),
        .rst(rst),
        .emergency(emergency),
        .ns_light(ns_light),
        .ew_light(ew_light)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 0;
        rst = 1;
        emergency = 0;
        
        #10 rst = 0;
        
        #100 emergency = 1;
        #20 emergency = 0;
        
        #200 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t rst=%b emergency=%b ns_light=%b ew_light=%b"", 
                 $time, rst, emergency, ns_light, ew_light);
    end
endmodule",True,134,True,True,True,False,0.4,False,11.339369773864746,7.376417875289917,"graph LR
    CLK[Clock] --> FSM((Traffic Light FSM))
    RST[Reset] --> FSM
    EMERG[Emergency] --> FSM
    FSM --> TIMER[[Timer Counter<br>GREEN=8<br>YELLOW=2]]
    TIMER --> FSM
    FSM --> NS_OUT[NS_Light[1:0]]
    FSM --> EW_OUT[EW_Light[1:0]]
    STATE[[Current State<br>NS_GREEN<br>NS_YELLOW<br>EW_GREEN<br>EW_YELLOW]] --> FSM
    FSM --> STATE
    TB[Testbench] --> CLK
    TB --> RST
    TB --> EMERG
    NS_OUT --> TB
    EW_OUT --> TB","`timescale 1ns/1ps

module traffic_light_fsm (
    input wire clk,
    input wire rst,
    input wire emergency,
    output reg [1:0] ns_light,
    output reg [1:0] ew_light
);

reg [2:0] current_state;
reg [3:0] timer;

parameter NS_GREEN = 3'b000;
parameter NS_YELLOW = 3'b001;
parameter EW_GREEN = 3'b010;
parameter EW_YELLOW = 3'b011;

parameter GREEN = 2'b01;
parameter YELLOW = 2'b10;
parameter RED = 2'b11;

parameter GREEN_TIME = 8;
parameter YELLOW_TIME = 2;

always @(posedge clk or posedge rst) begin
    if (rst) begin
        current_state <= NS_GREEN;
        timer <= GREEN_TIME;
        ns_light <= GREEN;
        ew_light <= RED;
    end
    else begin
        case (current_state)
            NS_GREEN: begin
                if (emergency || timer == 0) begin
                    current_state <= NS_YELLOW;
                    timer <= YELLOW_TIME;
                    ns_light <= YELLOW;
                    ew_light <= RED;
                end
                else
                    timer <= timer - 1;
            end
            
            NS_YELLOW: begin
                if (timer == 0) begin
                    current_state <= EW_GREEN;
                    timer <= GREEN_TIME;
                    ns_light <= RED;
                    ew_light <= GREEN;
                end
                else
                    timer <= timer - 1;
            end
            
            EW_GREEN: begin
                if (emergency || timer == 0) begin
                    current_state <= EW_YELLOW;
                    timer <= YELLOW_TIME;
                    ns_light <= RED;
                    ew_light <= YELLOW;
                end
                else
                    timer <= timer - 1;
            end
            
            EW_YELLOW: begin
                if (timer == 0) begin
                    current_state <= NS_GREEN;
                    timer <= GREEN_TIME;
                    ns_light <= GREEN;
                    ew_light <= RED;
                end
                else
                    timer <= timer - 1;
            end
            
            default: begin
                current_state <= NS_GREEN;
                timer <= GREEN_TIME;
                ns_light <= GREEN;
                ew_light <= RED;
            end
        endcase
    end
end

endmodule

module testbench;
    reg clk, rst, emergency;
    wire [1:0] ns_light, ew_light;
    
    traffic_light_fsm dut (
        .clk(clk),
        .rst(rst),
        .emergency(emergency),
        .ns_light(ns_light),
        .ew_light(ew_light)
    );
    
    initial begin
        $dumpfile(""traffic.vcd"");
        $dumpvars(0, testbench);
        
        clk = 0;
        rst = 1;
        emergency = 0;
        
        #10 rst = 0;
        
        #100 emergency = 1;
        #10 emergency = 0;
        
        #200 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t rst=%b emergency=%b ns_light=%b ew_light=%b"",
                 $time, rst, emergency, ns_light, ew_light);
    end
endmodule",True,125,True,True,True,,0.0,,13.895205736160278,0.01404261589050293,"Design a traffic light FSM with 4 states: NS_GREEN, NS_YELLOW, EW_GREEN, EW_YELLOW. Inputs: clk, rst, emergency. Outputs: ns_light[1:0], ew_light[1:0]. Timing: GREEN=8 cycles, YELLOW=2 cycles. Emergency makes both RED. Include testbench.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph LR
    CLK[Clock] --> FSM((Traffic Light FSM))
    RST[Reset] --> FSM
    EMERG[Emergency] --> FSM
    FSM --> TIMER[[Timer Counter<br>GREEN=8<br>YELLOW=2]]
    TIMER --> FSM
    FSM --> NS_OUT[NS_Light[1:0]]
    FSM --> EW_OUT[EW_Light[1:0]]
    STATE[[Current State<br>NS_GREEN<br>NS_YELLOW<br>EW_GREEN<br>EW_YELLOW]] --> FSM
    FSM --> STATE
    TB[Testbench] --> CLK
    TB --> RST
    TB --> EMERG
    NS_OUT --> TB
    EW_OUT --> TB
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module traffic_fsm(
    input wire clk,
    input wire rst,
    input wire emergency,
    output reg [1:0] ns_light,
    output reg [1:0] ew_light
);

parameter [1:0] RED = 2'b00;
parameter [1:0] YELLOW = 2'b01;
parameter [1:0] GREEN = 2'b10;

parameter [1:0] NS_GREEN_STATE = 2'b00;
parameter [1:0] NS_YELLOW_STATE = 2'b01;
parameter [1:0] EW_GREEN_STATE = 2'b10;
parameter [1:0] EW_YELLOW_STATE = 2'b11;

reg [1:0] state, next_state;
reg [3:0] timer;

always @(posedge clk or posedge rst) begin
    if (rst) begin
        state <= NS_GREEN_STATE;
        timer <= 4'd0;
    end
    else begin
        state <= next_state;
        if (emergency)
            timer <= 4'd0;
        else if (timer > 0)
            timer <= timer - 1'b1;
        else begin
            case (state)
                NS_GREEN_STATE, EW_GREEN_STATE: timer <= 4'd8;
                NS_YELLOW_STATE, EW_YELLOW_STATE: timer <= 4'd2;
                default: timer <= 4'd0;
            endcase
        end
    end
end

always @(*) begin
    if (emergency) begin
        next_state = state;
        ns_light = RED;
        ew_light = RED;
    end
    else begin
        case (state)
            NS_GREEN_STATE: begin
                ns_light = GREEN;
                ew_light = RED;
                if (timer == 0)
                    next_state = NS_YELLOW_STATE;
                else
                    next_state = NS_GREEN_STATE;
            end
            NS_YELLOW_STATE: begin
                ns_light = YELLOW;
                ew_light = RED;
                if (timer == 0)
                    next_state = EW_GREEN_STATE;
                else
                    next_state = NS_YELLOW_STATE;
            end
            EW_GREEN_STATE: begin
                ns_light = RED;
                ew_light = GREEN;
                if (timer == 0)
                    next_state = EW_YELLOW_STATE;
                else
                    next_state = EW_GREEN_STATE;
            end
            EW_YELLOW_STATE: begin
                ns_light = RED;
                ew_light = YELLOW;
                if (timer == 0)
                    next_state = NS_GREEN_STATE;
                else
                    next_state = EW_YELLOW_STATE;
            end
            default: begin
                next_state = NS_GREEN_STATE;
                ns_light = RED;
                ew_light = RED;
            end
        endcase
    end
end

endmodule

module testbench;
    reg clk, rst, emergency;
    wire [1:0] ns_light, ew_light;
    
    traffic_fsm dut (
        .clk(clk),
        .rst(rst),
        .emergency(emergency),
        .ns_light(ns_light),
        .ew_light(ew_light)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 0;
        rst = 1;
        emergency = 0;
        
        #10 rst = 0;
        
        #100 emergency = 1;
        #20 emergency = 0;
        
        #200 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t rst=%b emergency=%b ns_light=%b ew_light=%b"",
                 $time, rst, emergency, ns_light, ew_light);
    end
endmodule",True,129,True,True,True,False,0.4,False,11.941253900527954,7.552655935287476,tie,prompt_only > combined > mermaid_only,prompt_only > mermaid_only > combined
combined,State Machine,complex,"Design a traffic light FSM with 4 states: NS_GREEN, NS_YELLOW, EW_GREEN, EW_YELLOW. Inputs: clk, rst, emergency. Outputs: ns_light[1:0], ew_light[1:0]. Timing: GREEN=8 cycles, YELLOW=2 cycles. Emergency makes both RED. Include testbench.",gpt-4o,"`timescale 1ns/1ps

module traffic_light_fsm(
    input wire clk,
    input wire rst,
    input wire emergency,
    output reg [1:0] ns_light,
    output reg [1:0] ew_light
);

    // State encoding
    parameter NS_GREEN = 2'b00;
    parameter NS_YELLOW = 2'b01;
    parameter EW_GREEN = 2'b10;
    parameter EW_YELLOW = 2'b11;

    // Light encoding
    parameter RED = 2'b00;
    parameter GREEN = 2'b01;
    parameter YELLOW = 2'b10;

    reg [1:0] current_state, next_state;
    reg [3:0] timer;

    always @(posedge clk or posedge rst) begin
        if (rst) begin
            current_state <= NS_GREEN;
            timer <= 4'd0;
        end else if (emergency) begin
            current_state <= NS_GREEN;
            timer <= 4'd0;
        end else begin
            current_state <= next_state;
            if (timer == 4'd8 || timer == 4'd2)
                timer <= 4'd0;
            else
                timer <= timer + 1'b1;
        end
    end

    always @(*) begin
        case (current_state)
            NS_GREEN: begin
                ns_light = GREEN;
                ew_light = RED;
                if (timer == 4'd8)
                    next_state = NS_YELLOW;
                else
                    next_state = NS_GREEN;
            end
            NS_YELLOW: begin
                ns_light = YELLOW;
                ew_light = RED;
                if (timer == 4'd2)
                    next_state = EW_GREEN;
                else
                    next_state = NS_YELLOW;
            end
            EW_GREEN: begin
                ns_light = RED;
                ew_light = GREEN;
                if (timer == 4'd8)
                    next_state = EW_YELLOW;
                else
                    next_state = EW_GREEN;
            end
            EW_YELLOW: begin
                ns_light = RED;
                ew_light = YELLOW;
                if (timer == 4'd2)
                    next_state = NS_GREEN;
                else
                    next_state = EW_YELLOW;
            end
            default: begin
                ns_light = RED;
                ew_light = RED;
                next_state = NS_GREEN;
            end
        endcase
    end

endmodule

module testbench;
    reg clk, rst, emergency;
    wire [1:0] ns_light, ew_light;

    traffic_light_fsm dut (
        .clk(clk),
        .rst(rst),
        .emergency(emergency),
        .ns_light(ns_light),
        .ew_light(ew_light)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 1'b0;
        rst = 1'b1;
        emergency = 1'b0;

        #20 rst = 1'b0;
        #200 emergency = 1'b1;
        #20 emergency = 1'b0;
        #400 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t clk=%b rst=%b emergency=%b ns_light=%b ew_light=%b"", 
                 $time, clk, rst, emergency, ns_light, ew_light);
    end
endmodule",True,117,True,True,True,True,0.9,True,8.82890248298645,12.981991529464722,"graph TD
    CLK[clk] --> FSM((Traffic Light FSM))
    RST[rst] --> FSM
    EMERGENCY[emergency] --> DECISION{{Emergency?}}
    FSM --> DECISION
    DECISION -- Yes --> RED_STATE((Both RED))
    DECISION -- No --> NS_GREEN_STATE((NS_GREEN))
    DECISION -- No --> EW_GREEN_STATE((EW_GREEN))
    NS_GREEN_STATE -->|8 cycles| NS_YELLOW_STATE((NS_YELLOW))
    NS_YELLOW_STATE -->|2 cycles| EW_GREEN_STATE
    EW_GREEN_STATE -->|8 cycles| EW_YELLOW_STATE((EW_YELLOW))
    EW_YELLOW_STATE -->|2 cycles| NS_GREEN_STATE
    NS_GREEN_STATE --> NS_LIGHT[ns_light[1:0] = GREEN]
    NS_YELLOW_STATE --> NS_LIGHT[ns_light[1:0] = YELLOW]
    EW_GREEN_STATE --> EW_LIGHT[ew_light[1:0] = GREEN]
    EW_YELLOW_STATE --> EW_LIGHT[ew_light[1:0] = YELLOW]
    RED_STATE --> NS_LIGHT[ns_light[1:0] = RED]
    RED_STATE --> EW_LIGHT[ew_light[1:0] = RED]
    NS_GREEN_STATE --> EW_LIGHT[ew_light[1:0] = RED]
    EW_GREEN_STATE --> NS_LIGHT[ns_light[1:0] = RED]
    FSM --> TESTBENCH[[Testbench]]","`timescale 1ns/1ps

module traffic_light_fsm(
    input wire clk,
    input wire rst,
    input wire emergency,
    output reg [1:0] ns_light,
    output reg [1:0] ew_light
);

    typedef enum reg [2:0] {
        RED_STATE = 3'b000,
        NS_GREEN_STATE = 3'b001,
        NS_YELLOW_STATE = 3'b010,
        EW_GREEN_STATE = 3'b011,
        EW_YELLOW_STATE = 3'b100
    } state_t;
    
    reg [3:0] cycle_count;
    reg [2:0] state, next_state;

    always @(posedge clk or posedge rst) begin
        if (rst) begin
            state <= RED_STATE;
            cycle_count <= 4'b0000;
        end else begin
            state <= next_state;
            if (state == NS_GREEN_STATE || state == EW_GREEN_STATE ||
                state == NS_YELLOW_STATE || state == EW_YELLOW_STATE)
                cycle_count <= cycle_count + 1'b1;
            else
                cycle_count <= 4'b0000;
        end
    end

    always @(*) begin
        case (state)
            RED_STATE: begin
                ns_light = 2'b00; // RED
                ew_light = 2'b00; // RED
                if (emergency)
                    next_state = RED_STATE;
                else
                    next_state = NS_GREEN_STATE;
            end

            NS_GREEN_STATE: begin
                ns_light = 2'b01; // GREEN
                ew_light = 2'b00; // RED
                if (emergency)
                    next_state = RED_STATE;
                else if (cycle_count == 4'b1000) // 8 cycles
                    next_state = NS_YELLOW_STATE;
                else
                    next_state = NS_GREEN_STATE;
            end

            NS_YELLOW_STATE: begin
                ns_light = 2'b10; // YELLOW
                ew_light = 2'b00; // RED
                if (emergency)
                    next_state = RED_STATE;
                else if (cycle_count == 4'b0010) // 2 cycles
                    next_state = EW_GREEN_STATE;
                else
                    next_state = NS_YELLOW_STATE;
            end

            EW_GREEN_STATE: begin
                ns_light = 2'b00; // RED
                ew_light = 2'b01; // GREEN
                if (emergency)
                    next_state = RED_STATE;
                else if (cycle_count == 4'b1000) // 8 cycles
                    next_state = EW_YELLOW_STATE;
                else
                    next_state = EW_GREEN_STATE;
            end

            EW_YELLOW_STATE: begin
                ns_light = 2'b00; // RED
                ew_light = 2'b10; // YELLOW
                if (emergency)
                    next_state = RED_STATE;
                else if (cycle_count == 4'b0010) // 2 cycles
                    next_state = NS_GREEN_STATE;
                else
                    next_state = EW_YELLOW_STATE;
            end

            default: begin
                ns_light = 2'b00; // RED
                ew_light = 2'b00; // RED
                next_state = RED_STATE;
            end
        endcase
    end

endmodule

module testbench;
    reg clk, rst, emergency;
    wire [1:0] ns_light, ew_light;
    
    traffic_light_fsm dut (
        .clk(clk),
        .rst(rst),
        .emergency(emergency),
        .ns_light(ns_light),
        .ew_light(ew_light)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst = 1'b1;
        emergency = 1'b0;
        
        #20 rst = 1'b0;
        #200 emergency = 1'b1;
        #30 emergency = 1'b0;
        #200 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t clk=%b rst=%b emergency=%b ns_light=%b ew_light=%b"", 
                 $time, clk, rst, emergency, ns_light, ew_light);
    end
endmodule",True,133,True,True,True,False,0.3,False,20.472044229507446,11.007217168807983,"Design a traffic light FSM with 4 states: NS_GREEN, NS_YELLOW, EW_GREEN, EW_YELLOW. Inputs: clk, rst, emergency. Outputs: ns_light[1:0], ew_light[1:0]. Timing: GREEN=8 cycles, YELLOW=2 cycles. Emergency makes both RED. Include testbench.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph TD
    CLK[clk] --> FSM((Traffic Light FSM))
    RST[rst] --> FSM
    EMERGENCY[emergency] --> DECISION{{Emergency?}}
    FSM --> DECISION
    DECISION -- Yes --> RED_STATE((Both RED))
    DECISION -- No --> NS_GREEN_STATE((NS_GREEN))
    DECISION -- No --> EW_GREEN_STATE((EW_GREEN))
    NS_GREEN_STATE -->|8 cycles| NS_YELLOW_STATE((NS_YELLOW))
    NS_YELLOW_STATE -->|2 cycles| EW_GREEN_STATE
    EW_GREEN_STATE -->|8 cycles| EW_YELLOW_STATE((EW_YELLOW))
    EW_YELLOW_STATE -->|2 cycles| NS_GREEN_STATE
    NS_GREEN_STATE --> NS_LIGHT[ns_light[1:0] = GREEN]
    NS_YELLOW_STATE --> NS_LIGHT[ns_light[1:0] = YELLOW]
    EW_GREEN_STATE --> EW_LIGHT[ew_light[1:0] = GREEN]
    EW_YELLOW_STATE --> EW_LIGHT[ew_light[1:0] = YELLOW]
    RED_STATE --> NS_LIGHT[ns_light[1:0] = RED]
    RED_STATE --> EW_LIGHT[ew_light[1:0] = RED]
    NS_GREEN_STATE --> EW_LIGHT[ew_light[1:0] = RED]
    EW_GREEN_STATE --> NS_LIGHT[ns_light[1:0] = RED]
    FSM --> TESTBENCH[[Testbench]]
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module traffic_light_fsm(
    input wire clk,
    input wire rst,
    input wire emergency,
    output reg [1:0] ns_light,
    output reg [1:0] ew_light
);

    // State Encoding
    localparam NS_GREEN = 2'b00,
               NS_YELLOW = 2'b01,
               EW_GREEN = 2'b10,
               EW_YELLOW = 2'b11,
               BOTH_RED = 2'b00;
               
    localparam GREEN_TIME = 8,
               YELLOW_TIME = 2;

    reg [1:0] state, next_state;
    reg [3:0] timer;

    always @(posedge clk or posedge rst) begin
        if (rst) begin
            state <= NS_GREEN;
            timer <= 4'b0000;
        end else if (emergency) begin
            state <= BOTH_RED;
            timer <= 4'b0000;
        end else begin
            state <= next_state;
            if (state == next_state)
                timer <= timer + 1'b1;
            else
                timer <= 4'b0000;
        end
    end

    always @(*) begin
        case (state)
            NS_GREEN: begin
                if (timer < GREEN_TIME)
                    next_state = NS_GREEN;
                else
                    next_state = NS_YELLOW;
            end
            NS_YELLOW: begin
                if (timer < YELLOW_TIME)
                    next_state = NS_YELLOW;
                else
                    next_state = EW_GREEN;
            end
            EW_GREEN: begin
                if (timer < GREEN_TIME)
                    next_state = EW_GREEN;
                else
                    next_state = EW_YELLOW;
            end
            EW_YELLOW: begin
                if (timer < YELLOW_TIME)
                    next_state = EW_YELLOW;
                else
                    next_state = NS_GREEN;
            end
            default: begin
                next_state = NS_GREEN;
            end
        endcase
    end

    always @(*) begin
        case (state)
            NS_GREEN: begin
                ns_light = 2'b10; // GREEN
                ew_light = 2'b00; // RED
            end
            NS_YELLOW: begin
                ns_light = 2'b01; // YELLOW
                ew_light = 2'b00; // RED
            end
            EW_GREEN: begin
                ns_light = 2'b00; // RED
                ew_light = 2'b10; // GREEN
            end
            EW_YELLOW: begin
                ns_light = 2'b00; // RED
                ew_light = 2'b01; // YELLOW
            end
            BOTH_RED: begin
                ns_light = 2'b00; // RED
                ew_light = 2'b00; // RED
            end
            default: begin
                ns_light = 2'b00; // RED
                ew_light = 2'b00; // RED
            end
        endcase
    end

endmodule

module testbench;
    reg clk, rst, emergency;
    wire [1:0] ns_light, ew_light;

    traffic_light_fsm dut (
        .clk(clk),
        .rst(rst),
        .emergency(emergency),
        .ns_light(ns_light),
        .ew_light(ew_light)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 1'b0;
        rst = 1'b1;
        emergency = 1'b0;

        #10 rst = 1'b0;
        #200 emergency = 1'b1;
        #20 emergency = 1'b0;
        #200 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t clk=%b rst=%b emergency=%b ns_light=%b ew_light=%b"", 
                 $time, clk, rst, emergency, ns_light, ew_light);
    end
endmodule",True,135,True,True,True,True,0.7,True,12.420869588851929,14.291424751281738,mermaid_only,mermaid_only > prompt_only > combined,prompt_only > mermaid_only > combined
combined,State Machine,complex,"Design UART transmitter with states: IDLE, START, DATA, STOP. Protocol: START(0), 8 data bits LSB-first, STOP(1). Baud rate divider. Include testbench.",claude,"`timescale 1ns/1ps

module uart_tx (
    input wire clk,
    input wire rst_n,
    input wire tx_start,
    input wire [7:0] tx_data,
    output reg tx_busy,
    output reg tx_line
);

parameter BAUD_DIV = 16'd434; // For 115200 baud at 50MHz clock

reg [15:0] baud_counter;
reg [3:0] bit_counter;
reg [7:0] tx_shift_reg;

localparam IDLE = 2'b00;
localparam START = 2'b01;
localparam DATA = 2'b10;
localparam STOP = 2'b11;

reg [1:0] state;

always @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
        state <= IDLE;
        tx_line <= 1'b1;
        tx_busy <= 1'b0;
        baud_counter <= 16'd0;
        bit_counter <= 4'd0;
        tx_shift_reg <= 8'd0;
    end else begin
        case (state)
            IDLE: begin
                if (tx_start) begin
                    state <= START;
                    tx_busy <= 1'b1;
                    tx_shift_reg <= tx_data;
                    baud_counter <= 16'd0;
                end else begin
                    tx_line <= 1'b1;
                    tx_busy <= 1'b0;
                end
            end

            START: begin
                tx_line <= 1'b0;
                if (baud_counter == BAUD_DIV - 1) begin
                    state <= DATA;
                    baud_counter <= 16'd0;
                    bit_counter <= 4'd0;
                end else begin
                    baud_counter <= baud_counter + 1'b1;
                end
            end

            DATA: begin
                tx_line <= tx_shift_reg[0];
                if (baud_counter == BAUD_DIV - 1) begin
                    baud_counter <= 16'd0;
                    if (bit_counter == 4'd7) begin
                        state <= STOP;
                    end else begin
                        bit_counter <= bit_counter + 1'b1;
                        tx_shift_reg <= {1'b0, tx_shift_reg[7:1]};
                    end
                end else begin
                    baud_counter <= baud_counter + 1'b1;
                end
            end

            STOP: begin
                tx_line <= 1'b1;
                if (baud_counter == BAUD_DIV - 1) begin
                    state <= IDLE;
                    baud_counter <= 16'd0;
                end else begin
                    baud_counter <= baud_counter + 1'b1;
                end
            end
        endcase
    end
end

endmodule

module testbench;
    reg clk;
    reg rst_n;
    reg tx_start;
    reg [7:0] tx_data;
    wire tx_busy;
    wire tx_line;

    uart_tx dut (
        .clk(clk),
        .rst_n(rst_n),
        .tx_start(tx_start),
        .tx_data(tx_data),
        .tx_busy(tx_busy),
        .tx_line(tx_line)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 1'b0;
        rst_n = 1'b0;
        tx_start = 1'b0;
        tx_data = 8'h00;

        #20 rst_n = 1'b1;
        #20 tx_data = 8'hA5;
        #10 tx_start = 1'b1;
        #10 tx_start = 1'b0;
        
        #100000 tx_data = 8'h3C;
        #10 tx_start = 1'b1;
        #10 tx_start = 1'b0;
        
        #100000 $finish;
    end

    always #10 clk = ~clk;

    initial begin
        $monitor(""Time=%0t tx_line=%b tx_busy=%b"", $time, tx_line, tx_busy);
    end
endmodule",True,131,True,True,True,False,0.3,False,13.398771047592163,9.259984493255615,"graph TD
    CLK[Clock] --> BAUD(Baud Rate Generator)
    CLK --> FSM(State Machine)
    RST[Reset] --> FSM
    RST --> BAUD
    
    TX_START[TX Start] --> FSM
    TX_DATA[TX Data<7:0>] --> SHIFT[[Shift Register]]
    
    FSM --> |State|SHIFT
    BAUD --> |Tick|FSM
    
    FSM --> {MUX}
    SHIFT --> {MUX}
    
    {MUX} --> TX_OUT[TX Output]
    
    FSM --> |States|STATES[[IDLE START DATA STOP]]
    
    TB_CLK[Test Clock] -.-> TB[[Testbench]]
    TB_RST[Test Reset] -.-> TB
    TB -.-> TX_START
    TB -.-> TX_DATA
    TB -.-> |Verify|TX_OUT","`timescale 1ns/1ps

module uart_tx (
    input wire clk,
    input wire rst,
    input wire tx_start,
    input wire [7:0] tx_data,
    input wire baud_tick,
    output reg tx_out
);

// State definitions
localparam IDLE = 2'b00;
localparam START = 2'b01;
localparam DATA = 2'b10;
localparam STOP = 2'b11;

reg [1:0] state;
reg [2:0] bit_count;
reg [7:0] shift_reg;

always @(posedge clk or posedge rst) begin
    if (rst) begin
        state <= IDLE;
        bit_count <= 3'd0;
        shift_reg <= 8'd0;
        tx_out <= 1'b1;
    end
    else begin
        case (state)
            IDLE: begin
                tx_out <= 1'b1;
                if (tx_start) begin
                    state <= START;
                    shift_reg <= tx_data;
                end
            end
            
            START: begin
                if (baud_tick) begin
                    tx_out <= 1'b0;
                    state <= DATA;
                    bit_count <= 3'd0;
                end
            end
            
            DATA: begin
                if (baud_tick) begin
                    tx_out <= shift_reg[0];
                    shift_reg <= {1'b0, shift_reg[7:1]};
                    if (bit_count == 3'd7)
                        state <= STOP;
                    else
                        bit_count <= bit_count + 1'b1;
                end
            end
            
            STOP: begin
                if (baud_tick) begin
                    tx_out <= 1'b1;
                    state <= IDLE;
                end
            end
        endcase
    end
end

endmodule

module baud_gen (
    input wire clk,
    input wire rst,
    output reg baud_tick
);

reg [3:0] count;

always @(posedge clk or posedge rst) begin
    if (rst) begin
        count <= 4'd0;
        baud_tick <= 1'b0;
    end
    else begin
        if (count == 4'd15) begin
            count <= 4'd0;
            baud_tick <= 1'b1;
        end
        else begin
            count <= count + 1'b1;
            baud_tick <= 1'b0;
        end
    end
end

endmodule

module testbench;
    reg clk, rst, tx_start;
    reg [7:0] tx_data;
    wire tx_out;
    wire baud_tick;

    baud_gen baud_generator (
        .clk(clk),
        .rst(rst),
        .baud_tick(baud_tick)
    );

    uart_tx uart_transmitter (
        .clk(clk),
        .rst(rst),
        .tx_start(tx_start),
        .tx_data(tx_data),
        .baud_tick(baud_tick),
        .tx_out(tx_out)
    );

    initial begin
        $dumpfile(""uart_tx.vcd"");
        $dumpvars(0, testbench);
        
        clk = 0;
        rst = 1;
        tx_start = 0;
        tx_data = 8'h00;
        
        #20 rst = 0;
        #20 tx_data = 8'h55;
        #10 tx_start = 1;
        #10 tx_start = 0;
        
        #1000 tx_data = 8'hAA;
        #10 tx_start = 1;
        #10 tx_start = 0;
        
        #1000 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t rst=%b tx_start=%b tx_data=%h tx_out=%b"",
                 $time, rst, tx_start, tx_data, tx_out);
    end
endmodule",True,145,True,True,True,,0.0,,17.16592836380005,0.013874292373657227,"Design UART transmitter with states: IDLE, START, DATA, STOP. Protocol: START(0), 8 data bits LSB-first, STOP(1). Baud rate divider. Include testbench.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph TD
    CLK[Clock] --> BAUD(Baud Rate Generator)
    CLK --> FSM(State Machine)
    RST[Reset] --> FSM
    RST --> BAUD
    
    TX_START[TX Start] --> FSM
    TX_DATA[TX Data<7:0>] --> SHIFT[[Shift Register]]
    
    FSM --> |State|SHIFT
    BAUD --> |Tick|FSM
    
    FSM --> {MUX}
    SHIFT --> {MUX}
    
    {MUX} --> TX_OUT[TX Output]
    
    FSM --> |States|STATES[[IDLE START DATA STOP]]
    
    TB_CLK[Test Clock] -.-> TB[[Testbench]]
    TB_RST[Test Reset] -.-> TB
    TB -.-> TX_START
    TB -.-> TX_DATA
    TB -.-> |Verify|TX_OUT
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module uart_tx(
    input wire clk,
    input wire rst,
    input wire tx_start,
    input wire [7:0] tx_data,
    output reg tx_out
);

parameter IDLE = 2'b00;
parameter START = 2'b01;
parameter DATA = 2'b10;
parameter STOP = 2'b11;

reg [1:0] state;
reg [2:0] bit_count;
reg [7:0] shift_reg;
reg baud_tick;
reg [15:0] baud_count;

parameter BAUD_DIV = 16'd434; // 115200 baud at 50MHz

// Baud rate generator
always @(posedge clk or posedge rst) begin
    if (rst) begin
        baud_count <= 16'd0;
        baud_tick <= 1'b0;
    end
    else begin
        if (baud_count == BAUD_DIV - 1) begin
            baud_count <= 16'd0;
            baud_tick <= 1'b1;
        end
        else begin
            baud_count <= baud_count + 1'b1;
            baud_tick <= 1'b0;
        end
    end
end

// State machine and shift register
always @(posedge clk or posedge rst) begin
    if (rst) begin
        state <= IDLE;
        bit_count <= 3'd0;
        shift_reg <= 8'd0;
        tx_out <= 1'b1;
    end
    else begin
        case (state)
            IDLE: begin
                tx_out <= 1'b1;
                if (tx_start) begin
                    state <= START;
                    shift_reg <= tx_data;
                end
            end
            
            START: begin
                if (baud_tick) begin
                    tx_out <= 1'b0;
                    state <= DATA;
                    bit_count <= 3'd0;
                end
            end
            
            DATA: begin
                if (baud_tick) begin
                    if (bit_count == 3'd7) begin
                        state <= STOP;
                    end
                    else begin
                        bit_count <= bit_count + 1'b1;
                    end
                    tx_out <= shift_reg[0];
                    shift_reg <= {1'b0, shift_reg[7:1]};
                end
            end
            
            STOP: begin
                if (baud_tick) begin
                    tx_out <= 1'b1;
                    state <= IDLE;
                end
            end
        endcase
    end
end

endmodule

module uart_tx_tb;
    reg clk, rst, tx_start;
    reg [7:0] tx_data;
    wire tx_out;
    
    uart_tx dut (
        .clk(clk),
        .rst(rst),
        .tx_start(tx_start),
        .tx_data(tx_data),
        .tx_out(tx_out)
    );
    
    initial begin
        $dumpfile(""uart_tx.vcd"");
        $dumpvars(0, uart_tx_tb);
        
        clk = 0;
        rst = 1;
        tx_start = 0;
        tx_data = 8'h00;
        
        #20 rst = 0;
        #20 tx_data = 8'h55;
        #20 tx_start = 1;
        #20 tx_start = 0;
        
        #50000 tx_data = 8'hAA;
        #20 tx_start = 1;
        #20 tx_start = 0;
        
        #50000 $finish;
    end
    
    always #10 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t rst=%b tx_start=%b tx_data=%h tx_out=%b"",
                 $time, rst, tx_start, tx_data, tx_out);
    end
endmodule",True,133,False,True,True,,0.0,,12.172687530517578,0.0272982120513916,prompt_only,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,State Machine,complex,"Design UART transmitter with states: IDLE, START, DATA, STOP. Protocol: START(0), 8 data bits LSB-first, STOP(1). Baud rate divider. Include testbench.",gpt-4o,"`timescale 1ns/1ps

module uart_tx(
    input wire clk,
    input wire rst_n,
    input wire tx_start,
    input wire [7:0] tx_data,
    output reg tx_serial,
    output reg tx_busy
);

    reg [3:0] state;
    reg [2:0] bit_index;
    reg [7:0] shift_reg;
    reg [15:0] baud_counter;
    
    parameter IDLE = 4'b0000;
    parameter START = 4'b0001;
    parameter DATA = 4'b0010;
    parameter STOP = 4'b0011;
    
    parameter BAUD_DIV = 16'd5208; // Example for 50MHz clock for 9600 baud

    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            state <= IDLE;
            tx_serial <= 1'b1;
            tx_busy <= 1'b0;
            bit_index <= 3'b000;
            shift_reg <= 8'b00000000;
            baud_counter <= 16'b0000000000000000;
        end else begin
            case (state)
                IDLE: begin
                    tx_serial <= 1'b1;
                    tx_busy <= 1'b0;
                    if (tx_start) begin
                        state <= START;
                        shift_reg <= tx_data;
                        tx_busy <= 1'b1;
                        baud_counter <= 16'b0000000000000000;
                    end
                end
                START: begin
                    if (baud_counter == BAUD_DIV) begin
                        tx_serial <= 1'b0; // Start bit
                        state <= DATA;
                        baud_counter <= 16'b0000000000000000;
                    end else begin
                        baud_counter <= baud_counter + 1'b1;
                    end
                end
                DATA: begin
                    if (baud_counter == BAUD_DIV) begin
                        tx_serial <= shift_reg[0];
                        shift_reg <= shift_reg >> 1;
                        bit_index <= bit_index + 1'b1;
                        baud_counter <= 16'b0000000000000000;
                        if (bit_index == 3'b111) state <= STOP;
                    end else begin
                        baud_counter <= baud_counter + 1'b1;
                    end
                end
                STOP: begin
                    if (baud_counter == BAUD_DIV) begin
                        tx_serial <= 1'b1; // Stop bit
                        state <= IDLE;
                        tx_busy <= 1'b0;
                    end else begin
                        baud_counter <= baud_counter + 1'b1;
                    end
                end
            endcase
        end
    end

endmodule

module testbench;
    reg clk, rst_n, tx_start;
    reg [7:0] tx_data;
    wire tx_serial, tx_busy;

    uart_tx dut (
        .clk(clk),
        .rst_n(rst_n),
        .tx_start(tx_start),
        .tx_data(tx_data),
        .tx_serial(tx_serial),
        .tx_busy(tx_busy)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 1'b0;
        rst_n = 1'b0;
        tx_start = 1'b0;
        tx_data = 8'b10101010;

        #20 rst_n = 1'b1;
        #10 tx_start = 1'b1;
        #10 tx_start = 1'b0;
        #100000 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b tx_start=%b tx_data=%b tx_serial=%b tx_busy=%b"",
                 $time, clk, rst_n, tx_start, tx_data, tx_serial, tx_busy);
    end
endmodule",True,114,True,True,True,True,0.7,True,9.91146993637085,12.122622013092041,"graph TD
    CLK[Clock] --> CTRL(Controller)
    RST[Reset] --> CTRL
    CTRL --> IDLE((IDLE State))
    CTRL --> START((START State))
    CTRL --> DATA((DATA State))
    CTRL --> STOP((STOP State))
    IDLE -->|Start Signal| START
    START --> DATA
    DATA --> STOP
    STOP --> IDLE
    START --> OUT[Start Bit (0)]
    DATA --> D[Data Bits (8 bits LSB-first)]
    STOP --> S[Stop Bit (1)]
    BAUD[Baud Rate Divider] --> CTRL
    TEST[[Testbench]] --> CLK
    TEST --> RST
    TEST --> BAUD
    OUT --> UART_TX[UART TX Line]
    D --> UART_TX
    S --> UART_TX","`timescale 1ns/1ps

module uart_controller(
    input wire clk,
    input wire rst,
    input wire start_signal,
    input wire baud_tick,
    output reg uart_tx
);

    reg [1:0] state;
    reg [2:0] bit_counter;
    reg [7:0] data;

    localparam IDLE = 2'b00;
    localparam START = 2'b01;
    localparam DATA = 2'b10;
    localparam STOP = 2'b11;

    always @(posedge clk or posedge rst) begin
        if (rst) begin
            state <= IDLE;
            bit_counter <= 3'b000;
            uart_tx <= 1'b1;
        end else if (baud_tick) begin
            case (state)
                IDLE: begin
                    uart_tx <= 1'b1;
                    if (start_signal) begin
                        state <= START;
                        data <= 8'b10101010; // Example data: replace with actual data source
                    end
                end
                START: begin
                    uart_tx <= 1'b0;
                    state <= DATA;
                    bit_counter <= 3'b000;
                end
                DATA: begin
                    uart_tx <= data[bit_counter];
                    bit_counter <= bit_counter + 1'b1;
                    if (bit_counter == 3'b111) begin
                        state <= STOP;
                    end
                end
                STOP: begin
                    uart_tx <= 1'b1;
                    state <= IDLE;
                end
            endcase
        end
    end
endmodule

module testbench;
    reg clk, rst, start_signal, baud_tick;
    wire uart_tx;

    uart_controller dut (
        .clk(clk),
        .rst(rst),
        .start_signal(start_signal),
        .baud_tick(baud_tick),
        .uart_tx(uart_tx)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 1'b0;
        rst = 1'b1;
        start_signal = 1'b0;
        baud_tick = 1'b0;

        #20 rst = 1'b0;
        #10 start_signal = 1'b1;
        #10 baud_tick = 1'b1; // Simulating baud rate tick
        #10 baud_tick = 1'b0;
        #10 baud_tick = 1'b1;
        #10 baud_tick = 1'b0;
        #80 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t clk=%b rst=%b start_signal=%b baud_tick=%b uart_tx=%b"",
                 $time, clk, rst, start_signal, baud_tick, uart_tx);
    end
endmodule",True,91,True,True,True,True,0.7,True,12.7084641456604,13.099648714065552,"Design UART transmitter with states: IDLE, START, DATA, STOP. Protocol: START(0), 8 data bits LSB-first, STOP(1). Baud rate divider. Include testbench.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph TD
    CLK[Clock] --> CTRL(Controller)
    RST[Reset] --> CTRL
    CTRL --> IDLE((IDLE State))
    CTRL --> START((START State))
    CTRL --> DATA((DATA State))
    CTRL --> STOP((STOP State))
    IDLE -->|Start Signal| START
    START --> DATA
    DATA --> STOP
    STOP --> IDLE
    START --> OUT[Start Bit (0)]
    DATA --> D[Data Bits (8 bits LSB-first)]
    STOP --> S[Stop Bit (1)]
    BAUD[Baud Rate Divider] --> CTRL
    TEST[[Testbench]] --> CLK
    TEST --> RST
    TEST --> BAUD
    OUT --> UART_TX[UART TX Line]
    D --> UART_TX
    S --> UART_TX
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module uart_tx(
    input wire clk,
    input wire rst_n,
    input wire start_signal,
    input wire [7:0] data_in,
    input wire baud_tick,
    output reg uart_tx
);

    reg [1:0] state, next_state;
    reg [2:0] bit_count;
    reg [7:0] shift_reg;

    localparam IDLE  = 2'b00;
    localparam START = 2'b01;
    localparam DATA  = 2'b10;
    localparam STOP  = 2'b11;

    always @(posedge clk or negedge rst_n) begin
        if (!rst_n)
            state <= IDLE;
        else
            state <= next_state;
    end

    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            uart_tx <= 1'b1;
            bit_count <= 3'b000;
            shift_reg <= 8'b00000000;
        end else if (baud_tick) begin
            case (state)
                IDLE: begin
                    uart_tx <= 1'b1;
                    if (start_signal) begin
                        next_state <= START;
                        shift_reg <= data_in;
                        bit_count <= 3'b000;
                    end else
                        next_state <= IDLE;
                end
                START: begin
                    uart_tx <= 1'b0;
                    next_state <= DATA;
                end
                DATA: begin
                    uart_tx <= shift_reg[0];
                    shift_reg <= shift_reg >> 1;
                    bit_count <= bit_count + 1'b1;
                    if (bit_count == 3'b111)
                        next_state <= STOP;
                    else
                        next_state <= DATA;
                end
                STOP: begin
                    uart_tx <= 1'b1;
                    next_state <= IDLE;
                end
            endcase
        end
    end

endmodule

module baud_rate_divider(
    input wire clk,
    input wire rst_n,
    output reg baud_tick
);

    reg [9:0] counter;

    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            counter <= 10'b0;
            baud_tick <= 1'b0;
        end else begin
            if (counter == 10'd1023) begin
                counter <= 10'b0;
                baud_tick <= 1'b1;
            end else begin
                counter <= counter + 1'b1;
                baud_tick <= 1'b0;
            end
        end
    end

endmodule

module testbench;
    reg clk, rst_n, start_signal;
    reg [7:0] data_in;
    wire uart_tx;
    wire baud_tick;

    uart_tx dut (
        .clk(clk),
        .rst_n(rst_n),
        .start_signal(start_signal),
        .data_in(data_in),
        .baud_tick(baud_tick),
        .uart_tx(uart_tx)
    );

    baud_rate_divider baud_gen (
        .clk(clk),
        .rst_n(rst_n),
        .baud_tick(baud_tick)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 1'b0;
        rst_n = 1'b0;
        start_signal = 1'b0;
        data_in = 8'b10101010;

        #20 rst_n = 1'b1;
        #10 start_signal = 1'b1;
        #10 start_signal = 1'b0;
        #1000 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b start_signal=%b data_in=%b uart_tx=%b"", 
                 $time, clk, rst_n, start_signal, data_in, uart_tx);
    end
endmodule",True,134,True,True,True,True,0.9,True,11.353761434555054,12.016644716262817,prompt_only,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,CPU Component,complex,Create 8-register  8-bit register file with dual read ports and single write port. Include testbench with simultaneous operations.,claude,"`timescale 1ns/1ps

module reg_file (
    input wire clk,
    input wire rst_n,
    input wire write_en,
    input wire [2:0] write_addr,
    input wire [7:0] write_data,
    input wire [2:0] read_addr1,
    input wire [2:0] read_addr2,
    output wire [7:0] read_data1,
    output wire [7:0] read_data2
);

reg [7:0] registers [0:7];
integer i;

assign read_data1 = registers[read_addr1];
assign read_data2 = registers[read_addr2];

always @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
        for (i = 1'b0; i < 8; i = i + 1) begin
            registers[i] <= 8'h00;
        end
    end else if (write_en) begin
        registers[write_addr] <= write_data;
    end
end

endmodule

module testbench;
    reg clk;
    reg rst_n;
    reg write_en;
    reg [2:0] write_addr;
    reg [7:0] write_data;
    reg [2:0] read_addr1;
    reg [2:0] read_addr2;
    wire [7:0] read_data1;
    wire [7:0] read_data2;

    reg_file dut (
        .clk(clk),
        .rst_n(rst_n),
        .write_en(write_en),
        .write_addr(write_addr),
        .write_data(write_data),
        .read_addr1(read_addr1),
        .read_addr2(read_addr2),
        .read_data1(read_data1),
        .read_data2(read_data2)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 1'b0;
        rst_n = 1'b0;
        write_en = 1'b0;
        write_addr = 1'b0;
        write_data = 1'b0;
        read_addr1 = 1'b0;
        read_addr2 = 1'b0;

        #10 rst_n = 1'b1;

        // Write some data
        #10 write_en = 1'b1;
        write_addr = 3'h0; write_data = 8'hA1;
        #10 write_addr = 3'h1; write_data = 8'hB2;
        #10 write_addr = 3'h2; write_data = 8'hC3;
        #10 write_addr = 3'h3; write_data = 8'hD4;
        write_en = 1'b0;

        // Read from different addresses simultaneously
        #10 read_addr1 = 3'h0; read_addr2 = 3'h1;
        #10 read_addr1 = 3'h2; read_addr2 = 3'h3;

        // Write and read simultaneously
        #10 write_en = 1'b1;
        write_addr = 3'h4; write_data = 8'hE5;
        read_addr1 = 3'h0; read_addr2 = 3'h4;

        #20 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t rd1=%h rd2=%h"", $time, read_data1, read_data2);
    end

endmodule",True,96,True,True,True,True,0.75,True,10.300297975540161,6.768056154251099,"graph LR
    CLK[Clock] --> RF[[8x8 Register File]]
    RST[Reset] --> RF
    WD[Write Data 8-bit] --> RF
    WA[Write Address 3-bit] --> RF
    WE[Write Enable] --> RF
    RA1[Read Address 1] --> RF
    RA2[Read Address 2] --> RF
    RF --> RD1[Read Data 1]
    RF --> RD2[Read Data 2]
    TB[[TestBench]]
    TB --> WD
    TB --> WA
    TB --> WE
    TB --> RA1
    TB --> RA2
    RD1 --> TB
    RD2 --> TB
    CLK --> TB
    RST --> TB","`timescale 1ns/1ps

module register_file (
    input wire clk,
    input wire rst,
    input wire [7:0] write_data,
    input wire [2:0] write_addr,
    input wire write_en,
    input wire [2:0] read_addr1,
    input wire [2:0] read_addr2,
    output reg [7:0] read_data1,
    output reg [7:0] read_data2
);

reg [7:0] registers [0:7];
integer i;

always @(posedge clk or posedge rst) begin
    if (rst) begin
        for (i = 0; i < 8; i = i + 1)
            registers[i] <= 8'b0;
    end
    else begin
        if (write_en)
            registers[write_addr] <= write_data;
    end
end

always @(*) begin
    read_data1 = registers[read_addr1];
    read_data2 = registers[read_addr2];
end

endmodule

module testbench;
    reg clk;
    reg rst;
    reg [7:0] write_data;
    reg [2:0] write_addr;
    reg write_en;
    reg [2:0] read_addr1;
    reg [2:0] read_addr2;
    wire [7:0] read_data1;
    wire [7:0] read_data2;

    register_file dut (
        .clk(clk),
        .rst(rst),
        .write_data(write_data),
        .write_addr(write_addr),
        .write_en(write_en),
        .read_addr1(read_addr1),
        .read_addr2(read_addr2),
        .read_data1(read_data1),
        .read_data2(read_data2)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 0;
        rst = 1;
        write_data = 0;
        write_addr = 0;
        write_en = 0;
        read_addr1 = 0;
        read_addr2 = 0;

        #10 rst = 0;

        #10 write_en = 1;
        write_addr = 3'd0;
        write_data = 8'hAA;

        #10 write_addr = 3'd1;
        write_data = 8'hBB;

        #10 write_en = 0;
        read_addr1 = 3'd0;
        read_addr2 = 3'd1;

        #20 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t rst=%b we=%b wa=%h wd=%h ra1=%h rd1=%h ra2=%h rd2=%h"",
                 $time, rst, write_en, write_addr, write_data,
                 read_addr1, read_data1, read_addr2, read_data2);
    end
endmodule",True,94,True,True,True,False,0.4,False,12.413630247116089,7.798585414886475,"Create 8-register  8-bit register file with dual read ports and single write port. Include testbench with simultaneous operations.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph LR
    CLK[Clock] --> RF[[8x8 Register File]]
    RST[Reset] --> RF
    WD[Write Data 8-bit] --> RF
    WA[Write Address 3-bit] --> RF
    WE[Write Enable] --> RF
    RA1[Read Address 1] --> RF
    RA2[Read Address 2] --> RF
    RF --> RD1[Read Data 1]
    RF --> RD2[Read Data 2]
    TB[[TestBench]]
    TB --> WD
    TB --> WA
    TB --> WE
    TB --> RA1
    TB --> RA2
    RD1 --> TB
    RD2 --> TB
    CLK --> TB
    RST --> TB
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module register_file(
    input wire clk,
    input wire rst,
    input wire [7:0] write_data,
    input wire [2:0] write_addr,
    input wire write_en,
    input wire [2:0] read_addr1,
    input wire [2:0] read_addr2,
    output reg [7:0] read_data1,
    output reg [7:0] read_data2
);

reg [7:0] registers [0:7];
integer i;

always @(posedge clk or posedge rst) begin
    if (rst) begin
        for (i = 0; i < 8; i = i + 1)
            registers[i] <= 8'b0;
    end
    else if (write_en) begin
        registers[write_addr] <= write_data;
    end
end

always @(*) begin
    read_data1 = registers[read_addr1];
    read_data2 = registers[read_addr2];
end

endmodule

module testbench;
    reg clk, rst;
    reg [7:0] write_data;
    reg [2:0] write_addr;
    reg write_en;
    reg [2:0] read_addr1, read_addr2;
    wire [7:0] read_data1, read_data2;

    register_file dut (
        .clk(clk),
        .rst(rst),
        .write_data(write_data),
        .write_addr(write_addr),
        .write_en(write_en),
        .read_addr1(read_addr1),
        .read_addr2(read_addr2),
        .read_data1(read_data1),
        .read_data2(read_data2)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 0;
        rst = 1;
        write_en = 0;
        write_data = 8'h00;
        write_addr = 3'b000;
        read_addr1 = 3'b000;
        read_addr2 = 3'b000;

        #10 rst = 0;

        // Write test pattern
        #10;
        write_en = 1;
        write_addr = 3'b001;
        write_data = 8'hAA;
        #10;
        write_addr = 3'b010;
        write_data = 8'hBB;
        #10;

        // Read test
        write_en = 0;
        read_addr1 = 3'b001;
        read_addr2 = 3'b010;
        #10;

        // Simultaneous read/write
        write_en = 1;
        write_addr = 3'b011;
        write_data = 8'hCC;
        read_addr1 = 3'b010;
        read_addr2 = 3'b001;
        #10;

        #20 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t rst=%b we=%b wa=%h wd=%h ra1=%h rd1=%h ra2=%h rd2=%h"",
                 $time, rst, write_en, write_addr, write_data,
                 read_addr1, read_data1, read_addr2, read_data2);
    end
endmodule",True,103,True,True,True,False,0.3,False,10.415112495422363,7.902269601821899,tie,mermaid_only > combined > prompt_only,prompt_only > mermaid_only > combined
combined,CPU Component,complex,Create 8-register  8-bit register file with dual read ports and single write port. Include testbench with simultaneous operations.,gpt-4o,"`timescale 1ns/1ps

module register_file(
    input wire clk,
    input wire rst_n,
    input wire [2:0] read_addr1,
    input wire [2:0] read_addr2,
    input wire [2:0] write_addr,
    input wire [7:0] write_data,
    input wire write_enable,
    output reg [7:0] read_data1,
    output reg [7:0] read_data2
);

    reg [7:0] registers [0:7];
    integer i;

    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            for (i = 1'b0; i < 8; i = i + 1) begin
                registers[i] <= 8'b0000_0000;
            end
        end else if (write_enable) begin
            registers[write_addr] <= write_data;
        end
    end

    always @(*) begin
        read_data1 = registers[read_addr1];
        read_data2 = registers[read_addr2];
    end

endmodule

module testbench;
    reg clk, rst_n, write_enable;
    reg [2:0] read_addr1, read_addr2, write_addr;
    reg [7:0] write_data;
    wire [7:0] read_data1, read_data2;
    
    register_file dut (
        .clk(clk),
        .rst_n(rst_n),
        .read_addr1(read_addr1),
        .read_addr2(read_addr2),
        .write_addr(write_addr),
        .write_data(write_data),
        .write_enable(write_enable),
        .read_data1(read_data1),
        .read_data2(read_data2)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst_n = 1'b0;
        write_enable = 1'b0;
        read_addr1 = 3'b000;
        read_addr2 = 3'b001;
        write_addr = 3'b000;
        write_data = 8'b0000_0000;
        
        #20 rst_n = 1'b1;
        #10 write_enable = 1'b1; write_addr = 3'b000; write_data = 8'hAA;
        #10 write_enable = 1'b1; write_addr = 3'b001; write_data = 8'h55;
        #10 write_enable = 1'b0; read_addr1 = 3'b000; read_addr2 = 3'b001;
        #30 write_enable = 1'b1; write_addr = 3'b010; write_data = 8'hFF;
        #10 write_enable = 1'b0; read_addr1 = 3'b010; read_addr2 = 3'b001;
        #50 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b write_enable=%b write_addr=%b write_data=%h read_addr1=%b read_data1=%h read_addr2=%b read_data2=%h"", 
                 $time, clk, rst_n, write_enable, write_addr, write_data, read_addr1, read_data1, read_addr2, read_data2);
    end
endmodule",True,80,True,True,True,True,0.75,True,6.406672477722168,9.771774768829346,"graph TD
    CLK[Clock] --> WRITE_PORT((Write Port Control))
    RST[Reset] --> WRITE_PORT
    DATA_IN[8-bit Data Input] --> WRITE_PORT
    
    ADDR_W[3-bit Write Address] --> WRITE_PORT
    ENABLE_W[Write Enable] --> WRITE_PORT
    
    WRITE_PORT --> REG_FILE[[8x8 Register File]]
    CLK --> REG_FILE
    RST --> REG_FILE
    
    ADDR_R1[3-bit Read Address 1] --> READ_PORT1((Read Port Control 1))
    ADDR_R2[3-bit Read Address 2] --> READ_PORT2((Read Port Control 2))
    
    READ_PORT1 --> REG_FILE
    READ_PORT2 --> REG_FILE
    
    REG_FILE --> DATA_OUT1[8-bit Data Output 1]
    REG_FILE --> DATA_OUT2[8-bit Data Output 2]
    
    TESTBENCH((Testbench))
    TESTBENCH --> CLK
    TESTBENCH --> RST
    TESTBENCH --> DATA_IN
    TESTBENCH --> ADDR_W
    TESTBENCH --> ENABLE_W
    TESTBENCH --> ADDR_R1
    TESTBENCH --> ADDR_R2
    DATA_OUT1 --> TESTBENCH
    DATA_OUT2 --> TESTBENCH","`timescale 1ns/1ps

module register_file (
    input wire clk,
    input wire rst,
    input wire [7:0] data_in,
    input wire [2:0] addr_w,
    input wire enable_w,
    input wire [2:0] addr_r1,
    input wire [2:0] addr_r2,
    output reg [7:0] data_out1,
    output reg [7:0] data_out2
);

    reg [7:0] reg_file [7:0];
    
    always @(posedge clk or posedge rst) begin
        if (rst) begin
            reg_file[0] <= 8'b0;
            reg_file[1] <= 8'b0;
            reg_file[2] <= 8'b0;
            reg_file[3] <= 8'b0;
            reg_file[4] <= 8'b0;
            reg_file[5] <= 8'b0;
            reg_file[6] <= 8'b0;
            reg_file[7] <= 8'b0;
        end else if (enable_w) begin
            reg_file[addr_w] <= data_in;
        end
    end

    always @(posedge clk) begin
        data_out1 <= reg_file[addr_r1];
        data_out2 <= reg_file[addr_r2];
    end

endmodule

module testbench;
    reg clk, rst;
    reg [7:0] data_in;
    reg [2:0] addr_w;
    reg enable_w;
    reg [2:0] addr_r1;
    reg [2:0] addr_r2;
    wire [7:0] data_out1;
    wire [7:0] data_out2;
    
    register_file dut (
        .clk(clk),
        .rst(rst),
        .data_in(data_in),
        .addr_w(addr_w),
        .enable_w(enable_w),
        .addr_r1(addr_r1),
        .addr_r2(addr_r2),
        .data_out1(data_out1),
        .data_out2(data_out2)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst = 1'b1;
        data_in = 8'b0;
        addr_w = 3'b0;
        enable_w = 1'b0;
        addr_r1 = 3'b0;
        addr_r2 = 3'b0;
        
        #10 rst = 1'b0;
        #10 data_in = 8'hAA; addr_w = 3'd0; enable_w = 1'b1;
        #10 enable_w = 1'b0;
        #10 addr_r1 = 3'd0;
        #10 addr_r2 = 3'd0;
        #50 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t clk=%b rst=%b data_in=%h addr_w=%d enable_w=%b addr_r1=%d addr_r2=%d data_out1=%h data_out2=%h"", 
                 $time, clk, rst, data_in, addr_w, enable_w, addr_r1, addr_r2, data_out1, data_out2);
    end
endmodule",True,87,True,True,True,False,0.3,False,16.822807550430298,11.735913276672363,"Create 8-register  8-bit register file with dual read ports and single write port. Include testbench with simultaneous operations.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph TD
    CLK[Clock] --> WRITE_PORT((Write Port Control))
    RST[Reset] --> WRITE_PORT
    DATA_IN[8-bit Data Input] --> WRITE_PORT
    
    ADDR_W[3-bit Write Address] --> WRITE_PORT
    ENABLE_W[Write Enable] --> WRITE_PORT
    
    WRITE_PORT --> REG_FILE[[8x8 Register File]]
    CLK --> REG_FILE
    RST --> REG_FILE
    
    ADDR_R1[3-bit Read Address 1] --> READ_PORT1((Read Port Control 1))
    ADDR_R2[3-bit Read Address 2] --> READ_PORT2((Read Port Control 2))
    
    READ_PORT1 --> REG_FILE
    READ_PORT2 --> REG_FILE
    
    REG_FILE --> DATA_OUT1[8-bit Data Output 1]
    REG_FILE --> DATA_OUT2[8-bit Data Output 2]
    
    TESTBENCH((Testbench))
    TESTBENCH --> CLK
    TESTBENCH --> RST
    TESTBENCH --> DATA_IN
    TESTBENCH --> ADDR_W
    TESTBENCH --> ENABLE_W
    TESTBENCH --> ADDR_R1
    TESTBENCH --> ADDR_R2
    DATA_OUT1 --> TESTBENCH
    DATA_OUT2 --> TESTBENCH
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module register_file(
    input wire clk,
    input wire rst,
    input wire [7:0] data_in,
    input wire [2:0] addr_w,
    input wire enable_w,
    input wire [2:0] addr_r1,
    input wire [2:0] addr_r2,
    output wire [7:0] data_out1,
    output wire [7:0] data_out2
);
    
    reg [7:0] reg_file [7:0];
    integer i;
    
    always @(posedge clk or posedge rst) begin
        if (rst) begin
            for (i = 1'b0; i < 8; i = i + 1) begin
                reg_file[i] <= 8'b0;
            end
        end else if (enable_w) begin
            reg_file[addr_w] <= data_in;
        end
    end
    
    assign data_out1 = reg_file[addr_r1];
    assign data_out2 = reg_file[addr_r2];
    
endmodule

module testbench;
    reg clk, rst, enable_w;
    reg [7:0] data_in;
    reg [2:0] addr_w, addr_r1, addr_r2;
    wire [7:0] data_out1, data_out2;
    
    register_file dut (
        .clk(clk),
        .rst(rst),
        .data_in(data_in),
        .addr_w(addr_w),
        .enable_w(enable_w),
        .addr_r1(addr_r1),
        .addr_r2(addr_r2),
        .data_out1(data_out1),
        .data_out2(data_out2)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst = 1'b1;
        enable_w = 1'b0;
        data_in = 8'b0;
        addr_w = 3'b0;
        addr_r1 = 3'b0;
        addr_r2 = 3'b0;
        
        #20 rst = 1'b0;
        #10 enable_w = 1'b1; data_in = 8'hAA; addr_w = 3'b001;
        #10 enable_w = 1'b0;
        #10 addr_r1 = 3'b001;
        #10 addr_r2 = 3'b001;
        #50 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t clk=%b rst=%b enable_w=%b data_in=%h addr_w=%d addr_r1=%d addr_r2=%d data_out1=%h data_out2=%h"", 
                 $time, clk, rst, enable_w, data_in, addr_w, addr_r1, addr_r2, data_out1, data_out2);
    end
endmodule",True,77,True,True,True,True,0.75,True,19.044400930404663,14.304810047149658,mermaid_only,mermaid_only > prompt_only > combined,prompt_only > mermaid_only > combined
combined,Advanced Sequential,complex,"Design 8-bit resolution PWM generator with configurable duty cycle. Include testbench with duty cycles: 0%, 25%, 50%, 75%, 100%.",claude,"`timescale 1ns/1ps

module pwm_gen(
    input wire clk,
    input wire rst_n,
    input wire [7:0] duty_cycle,
    output reg pwm_out
);

reg [7:0] counter;

always @(posedge clk or negedge rst_n) begin
    if (!rst_n)
        counter <= 8'h00;
    else
        counter <= counter + 1'b1;
end

always @(posedge clk or negedge rst_n) begin
    if (!rst_n)
        pwm_out <= 1'b0;
    else
        pwm_out <= (counter < duty_cycle);
end

endmodule

module testbench;
    reg clk;
    reg rst_n;
    reg [7:0] duty_cycle;
    wire pwm_out;

    pwm_gen dut (
        .clk(clk),
        .rst_n(rst_n),
        .duty_cycle(duty_cycle),
        .pwm_out(pwm_out)
    );

    initial begin
        $dumpfile(""pwm.vcd"");
        $dumpvars(0, testbench);

        clk = 0;
        rst_n = 0;
        duty_cycle = 8'h00;

        #20 rst_n = 1;

        // Test 0% duty cycle
        #100 duty_cycle = 8'h00;

        // Test 25% duty cycle
        #512 duty_cycle = 8'h40;

        // Test 50% duty cycle
        #512 duty_cycle = 8'h80;

        // Test 75% duty cycle
        #512 duty_cycle = 8'hC0;

        // Test 100% duty cycle
        #512 duty_cycle = 8'hFF;

        #512 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t rst_n=%b duty_cycle=%h pwm_out=%b"",
                 $time, rst_n, duty_cycle, pwm_out);
    end
endmodule",True,75,True,True,True,,0.0,,6.776809453964233,0.015467166900634766,"graph TD
    CLK[Clock Input] --> CNT((8-bit Counter))
    RST[Reset] --> CNT
    CLK --> COMP((Comparator))
    CNT --> COMP
    
    DUTY[[Duty Cycle Register<br>8-bit]] --> COMP
    CFG[Config Input<br>8-bit] --> DUTY
    
    COMP --> OUT[PWM Output]
    
    TB_DC0[Test: 0% DC<br>Value: 0x00] --> |Test 1| DUTY
    TB_DC25[Test: 25% DC<br>Value: 0x40] --> |Test 2| DUTY
    TB_DC50[Test: 50% DC<br>Value: 0x80] --> |Test 3| DUTY
    TB_DC75[Test: 75% DC<br>Value: 0xC0] --> |Test 4| DUTY
    TB_DC100[Test: 100% DC<br>Value: 0xFF] --> |Test 5| DUTY","`timescale 1ns/1ps

module pwm_gen(
    input wire clk,
    input wire rst,
    input wire [7:0] cfg,
    output wire pwm_out
);

reg [7:0] counter;
reg [7:0] duty_reg;
reg pwm_out_reg;

// Counter
always @(posedge clk or posedge rst) begin
    if (rst)
        counter <= 8'h00;
    else
        counter <= counter + 1'b1;
end

// Duty cycle register
always @(posedge clk or posedge rst) begin
    if (rst)
        duty_reg <= 8'h00;
    else
        duty_reg <= cfg;
end

// PWM comparator
always @(posedge clk or posedge rst) begin
    if (rst)
        pwm_out_reg <= 1'b0;
    else
        pwm_out_reg <= (counter < duty_reg);
end

assign pwm_out = pwm_out_reg;

endmodule

module testbench;
    reg clk;
    reg rst;
    reg [7:0] cfg;
    wire pwm_out;

    pwm_gen dut (
        .clk(clk),
        .rst(rst),
        .cfg(cfg),
        .pwm_out(pwm_out)
    );

    initial begin
        $dumpfile(""pwm.vcd"");
        $dumpvars(0, testbench);

        clk = 0;
        rst = 1;
        cfg = 8'h00;

        #20 rst = 0;

        // Test 1: 0% duty cycle
        cfg = 8'h00;
        #512;

        // Test 2: 25% duty cycle
        cfg = 8'h40;
        #512;

        // Test 3: 50% duty cycle
        cfg = 8'h80;
        #512;

        // Test 4: 75% duty cycle
        cfg = 8'hC0;
        #512;

        // Test 5: 100% duty cycle
        cfg = 8'hFF;
        #512;

        $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t rst=%b cfg=%h pwm=%b"", 
                 $time, rst, cfg, pwm_out);
    end
endmodule",True,94,True,True,True,,0.0,,11.764169454574585,0.016705751419067383,"Design 8-bit resolution PWM generator with configurable duty cycle. Include testbench with duty cycles: 0%, 25%, 50%, 75%, 100%.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph TD
    CLK[Clock Input] --> CNT((8-bit Counter))
    RST[Reset] --> CNT
    CLK --> COMP((Comparator))
    CNT --> COMP
    
    DUTY[[Duty Cycle Register<br>8-bit]] --> COMP
    CFG[Config Input<br>8-bit] --> DUTY
    
    COMP --> OUT[PWM Output]
    
    TB_DC0[Test: 0% DC<br>Value: 0x00] --> |Test 1| DUTY
    TB_DC25[Test: 25% DC<br>Value: 0x40] --> |Test 2| DUTY
    TB_DC50[Test: 50% DC<br>Value: 0x80] --> |Test 3| DUTY
    TB_DC75[Test: 75% DC<br>Value: 0xC0] --> |Test 4| DUTY
    TB_DC100[Test: 100% DC<br>Value: 0xFF] --> |Test 5| DUTY
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module pwm_gen (
    input wire clk,
    input wire rst,
    input wire [7:0] cfg,
    output wire pwm_out
);

reg [7:0] counter;
reg [7:0] duty_reg;

// Counter logic
always @(posedge clk or posedge rst) begin
    if (rst)
        counter <= 8'h00;
    else
        counter <= counter + 1'b1;
end

// Duty cycle register
always @(posedge clk or posedge rst) begin
    if (rst)
        duty_reg <= 8'h00;
    else
        duty_reg <= cfg;
end

// Comparator
assign pwm_out = (counter < duty_reg);

endmodule

module testbench;
    reg clk;
    reg rst;
    reg [7:0] cfg;
    wire pwm_out;

    pwm_gen dut (
        .clk(clk),
        .rst(rst),
        .cfg(cfg),
        .pwm_out(pwm_out)
    );

    initial begin
        $dumpfile(""pwm.vcd"");
        $dumpvars(0, testbench);

        clk = 0;
        rst = 1;
        cfg = 8'h00;

        #20 rst = 0;

        // Test 1: 0% duty cycle
        cfg = 8'h00;
        #512;

        // Test 2: 25% duty cycle
        cfg = 8'h40;
        #512;

        // Test 3: 50% duty cycle
        cfg = 8'h80;
        #512;

        // Test 4: 75% duty cycle
        cfg = 8'hC0;
        #512;

        // Test 5: 100% duty cycle
        cfg = 8'hFF;
        #512;

        $finish;
    end

    always #1 clk = ~clk;

    initial begin
        $monitor(""Time=%0t rst=%b cfg=%h pwm=%b"", 
                 $time, rst, cfg, pwm_out);
    end
endmodule",True,86,True,True,True,,0.0,,6.793389320373535,0.01556849479675293,prompt_only,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,Advanced Sequential,complex,"Design 8-bit resolution PWM generator with configurable duty cycle. Include testbench with duty cycles: 0%, 25%, 50%, 75%, 100%.",gpt-4o,"`timescale 1ns/1ps

module pwm_generator(
    input wire clk,
    input wire rst_n,
    input wire [7:0] duty_cycle,
    output reg pwm_out
);
    reg [7:0] counter;

    always @(posedge clk or negedge rst_n) begin
        if (!rst_n)
            counter <= 8'b00000000;
        else
            counter <= counter + 1'b1;
    end

    always @(posedge clk or negedge rst_n) begin
        if (!rst_n)
            pwm_out <= 1'b0;
        else if (counter < duty_cycle)
            pwm_out <= 1'b1;
        else
            pwm_out <= 1'b0;
    end

endmodule

module testbench;
    reg clk, rst_n;
    reg [7:0] duty_cycle;
    wire pwm_out;

    pwm_generator dut (
        .clk(clk),
        .rst_n(rst_n),
        .duty_cycle(duty_cycle),
        .pwm_out(pwm_out)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 1'b0;
        rst_n = 1'b0;
        duty_cycle = 8'b00000000;

        #20 rst_n = 1'b1;
        #10 duty_cycle = 8'd0; // 0% duty cycle
        #200 duty_cycle = 8'd64; // 25% duty cycle
        #200 duty_cycle = 8'd128; // 50% duty cycle
        #200 duty_cycle = 8'd192; // 75% duty cycle
        #200 duty_cycle = 8'd255; // 100% duty cycle
        #200 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b duty_cycle=%d pwm_out=%b"", 
                 $time, clk, rst_n, duty_cycle, pwm_out);
    end
endmodule",True,64,True,True,True,False,0.3,False,4.0214197635650635,6.8769354820251465,"graph TD
    CLK[Clock] --> PWM_GEN(8-bit PWM Generator)
    RST[Reset] --> PWM_GEN
    DUTY_CYCLE[Configurable Duty Cycle] --> PWM_GEN
    PWM_GEN --> PWM_OUT[Pulse Width Modulated Output]
    
    subgraph TB[Testbench]
        DUTY_0[0% Duty Cycle] --> PWM_GEN
        DUTY_25[25% Duty Cycle] --> PWM_GEN
        DUTY_50[50% Duty Cycle] --> PWM_GEN
        DUTY_75[75% Duty Cycle] --> PWM_GEN
        DUTY_100[100% Duty Cycle] --> PWM_GEN
    end","`timescale 1ns/1ps

module pwm_generator(
    input wire clk,
    input wire rst,
    input wire [7:0] duty_cycle,
    output reg pwm_out
);

    reg [7:0] counter;

    always @(posedge clk or posedge rst) begin
        if (rst) begin
            counter <= 8'b00000000;
            pwm_out <= 1'b0;
        end else begin
            if (counter < duty_cycle)
                pwm_out <= 1'b1;
            else
                pwm_out <= 1'b0;

            counter <= counter + 1'b1;
        end
    end

endmodule

module testbench;
    reg clk, rst;
    reg [7:0] duty_cycle;
    wire pwm_out;

    pwm_generator dut (
        .clk(clk),
        .rst(rst),
        .duty_cycle(duty_cycle),
        .pwm_out(pwm_out)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 1'b0;
        rst = 1'b0;
        
        // Test different duty cycles
        #20 rst = 1'b1;
        #10 rst = 1'b0; duty_cycle = 8'd0; // 0% Duty Cycle
        #100 duty_cycle = 8'd64; // 25% Duty Cycle
        #100 duty_cycle = 8'd128; // 50% Duty Cycle
        #100 duty_cycle = 8'd192; // 75% Duty Cycle
        #100 duty_cycle = 8'd255; // 100% Duty Cycle
        #100 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t clk=%b rst=%b duty_cycle=%d pwm_out=%b"", 
                 $time, clk, rst, duty_cycle, pwm_out);
    end
endmodule",True,63,True,True,True,False,0.3,False,7.950953722000122,8.379363775253296,"Design 8-bit resolution PWM generator with configurable duty cycle. Include testbench with duty cycles: 0%, 25%, 50%, 75%, 100%.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph TD
    CLK[Clock] --> PWM_GEN(8-bit PWM Generator)
    RST[Reset] --> PWM_GEN
    DUTY_CYCLE[Configurable Duty Cycle] --> PWM_GEN
    PWM_GEN --> PWM_OUT[Pulse Width Modulated Output]
    
    subgraph TB[Testbench]
        DUTY_0[0% Duty Cycle] --> PWM_GEN
        DUTY_25[25% Duty Cycle] --> PWM_GEN
        DUTY_50[50% Duty Cycle] --> PWM_GEN
        DUTY_75[75% Duty Cycle] --> PWM_GEN
        DUTY_100[100% Duty Cycle] --> PWM_GEN
    end
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module pwm_generator(
    input wire clk,
    input wire rst_n,
    input wire [7:0] duty_cycle,
    output reg pwm_out
);

reg [7:0] counter;

always @(posedge clk or negedge rst_n) begin
    if (!rst_n)
        counter <= 8'b0;
    else
        counter <= counter + 1'b1;
end

always @(posedge clk or negedge rst_n) begin
    if (!rst_n)
        pwm_out <= 1'b0;
    else
        pwm_out <= (counter < duty_cycle) ? 1'b1 : 1'b0;
end

endmodule

module testbench;
    reg clk, rst_n;
    reg [7:0] duty_cycle;
    wire pwm_out;

    pwm_generator dut (
        .clk(clk),
        .rst_n(rst_n),
        .duty_cycle(duty_cycle),
        .pwm_out(pwm_out)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 1'b0;
        rst_n = 1'b0;
        duty_cycle = 8'b0;

        // Test 0% Duty Cycle
        #20 rst_n = 1'b1; duty_cycle = 8'd0;
        #100;

        // Test 25% Duty Cycle
        duty_cycle = 8'd64;
        #100;

        // Test 50% Duty Cycle
        duty_cycle = 8'd128;
        #100;

        // Test 75% Duty Cycle
        duty_cycle = 8'd192;
        #100;

        // Test 100% Duty Cycle
        duty_cycle = 8'd255;
        #100;

        $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b duty_cycle=%d pwm_out=%b"", 
                 $time, clk, rst_n, duty_cycle, pwm_out);
    end
endmodule",True,77,True,True,True,False,0.3,False,6.2196128368377686,9.921727418899536,tie,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,Protocol,complex,"Design SPI master supporting mode 0 (CPOL=0, CPHA=0). Include SCLK generation, MOSI/MISO handling. Include testbench.",claude,"`timescale 1ns/1ps

module spi_master (
    input wire clk,
    input wire rst_n,
    input wire start,
    input wire [7:0] data_in,
    input wire miso,
    output reg sclk,
    output reg mosi,
    output reg busy,
    output reg [7:0] data_out
);

reg [3:0] bit_count;
reg [7:0] shift_reg;
reg spi_active;

always @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
        sclk <= 1'b0;
        mosi <= 1'b0;
        busy <= 1'b0;
        bit_count <= 4'b0;
        shift_reg <= 8'b0;
        data_out <= 8'b0;
        spi_active <= 1'b0;
    end
    else begin
        if (start && !spi_active) begin
            spi_active <= 1'b1;
            busy <= 1'b1;
            shift_reg <= data_in;
            bit_count <= 4'd0;
        end
        else if (spi_active) begin
            sclk <= ~sclk;
            if (!sclk) begin  // Rising edge
                mosi <= shift_reg[7];
            end
            else begin  // Falling edge
                shift_reg <= {shift_reg[6:0], miso};
                bit_count <= bit_count + 1'b1;
                if (bit_count == 4'd7) begin
                    spi_active <= 1'b0;
                    busy <= 1'b0;
                    data_out <= {shift_reg[6:0], miso};
                end
            end
        end
    end
end

endmodule

module testbench;
    reg clk;
    reg rst_n;
    reg start;
    reg [7:0] data_in;
    reg miso;
    wire sclk;
    wire mosi;
    wire busy;
    wire [7:0] data_out;

    spi_master dut (
        .clk(clk),
        .rst_n(rst_n),
        .start(start),
        .data_in(data_in),
        .miso(miso),
        .sclk(sclk),
        .mosi(mosi),
        .busy(busy),
        .data_out(data_out)
    );

    initial begin
        $dumpfile(""spi_master.vcd"");
        $dumpvars(0, testbench);

        clk = 0;
        rst_n = 0;
        start = 0;
        data_in = 0;
        miso = 0;

        #10 rst_n = 1;
        #10 data_in = 8'hA5;
        #10 start = 1;
        #10 start = 0;
        
        // Simulate MISO input
        repeat(16) begin
            #10 miso = $random;
        end

        #200 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t rst_n=%b start=%b data_in=%h miso=%b sclk=%b mosi=%b busy=%b data_out=%h"",
                 $time, rst_n, start, data_in, miso, sclk, mosi, busy, data_out);
    end
endmodule",True,108,True,True,True,,0.0,,11.229109525680542,0.014253616333007812,"graph LR
    CLK[System Clock] --> CLKGEN(Clock Divider)
    RST[Reset] --> CTRL(Control Unit)
    START[Start] --> CTRL
    
    CLKGEN --> SCLK[SCLK Output]
    CLKGEN --> CTRL
    
    DATA_IN[TX Data] --> TXREG[[TX Register]]
    TXREG --> SHIFTER(Shift Register)
    SHIFTER --> MOSI[MOSI Output]
    
    MISO[MISO Input] --> RXSHFT(RX Shift Register)
    RXSHFT --> RXREG[[RX Register]]
    RXREG --> DATA_OUT[RX Data]
    
    CTRL --> SHIFTER
    CTRL --> RXSHFT
    CTRL --> BUSY[Busy Flag]
    
    TB_CLK[TB Clock] -.-> |Testbench| TB(SPI Test Logic)
    TB_RST[TB Reset] -.-> |Testbench| TB
    TB -.-> |Stimulus| DATA_IN
    TB -.-> |Monitor| DATA_OUT","`timescale 1ns/1ps

module spi_controller (
    input wire clk,
    input wire rst_n,
    input wire start,
    input wire miso,
    input wire [7:0] data_in,
    output reg sclk,
    output reg mosi,
    output reg busy,
    output reg [7:0] data_out
);

reg [3:0] clk_div;
reg [2:0] bit_count;
reg [7:0] tx_reg, rx_reg, shift_reg;

always @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
        clk_div <= 4'b0;
        sclk <= 1'b0;
    end else begin
        clk_div <= clk_div + 1'b1;
        sclk <= clk_div[3];
    end
end

always @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
        busy <= 1'b0;
        bit_count <= 3'b0;
        tx_reg <= 8'b0;
        rx_reg <= 8'b0;
        shift_reg <= 8'b0;
        mosi <= 1'b0;
        data_out <= 8'b0;
    end else begin
        if (start && !busy) begin
            busy <= 1'b1;
            bit_count <= 3'b111;
            tx_reg <= data_in;
            shift_reg <= data_in;
        end else if (busy && clk_div == 4'b1111) begin
            if (bit_count == 3'b0) begin
                busy <= 1'b0;
                data_out <= rx_reg;
            end else begin
                bit_count <= bit_count - 1'b1;
                shift_reg <= {shift_reg[6:0], 1'b0};
                rx_reg <= {rx_reg[6:0], miso};
                mosi <= shift_reg[7];
            end
        end
    end
end

endmodule

module testbench;
    reg clk, rst_n, start, miso;
    reg [7:0] data_in;
    wire sclk, mosi, busy;
    wire [7:0] data_out;

    spi_controller dut (
        .clk(clk),
        .rst_n(rst_n),
        .start(start),
        .miso(miso),
        .data_in(data_in),
        .sclk(sclk),
        .mosi(mosi),
        .busy(busy),
        .data_out(data_out)
    );

    initial begin
        $dumpfile(""spi.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst_n = 1'b0;
        start = 1'b0;
        miso = 1'b0;
        data_in = 8'h00;
        
        #20 rst_n = 1'b1;
        #10 data_in = 8'hA5;
        #10 start = 1'b1;
        #10 start = 1'b0;
        miso = 1'b1;
        
        #200;
        
        data_in = 8'h5A;
        start = 1'b1;
        #10 start = 1'b0;
        miso = 1'b0;
        
        #200 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t rst_n=%b start=%b busy=%b data_in=%h data_out=%h"",
                 $time, rst_n, start, busy, data_in, data_out);
    end
endmodule",True,110,True,True,True,,0.0,,16.33592462539673,0.014200687408447266,"Design SPI master supporting mode 0 (CPOL=0, CPHA=0). Include SCLK generation, MOSI/MISO handling. Include testbench.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph LR
    CLK[System Clock] --> CLKGEN(Clock Divider)
    RST[Reset] --> CTRL(Control Unit)
    START[Start] --> CTRL
    
    CLKGEN --> SCLK[SCLK Output]
    CLKGEN --> CTRL
    
    DATA_IN[TX Data] --> TXREG[[TX Register]]
    TXREG --> SHIFTER(Shift Register)
    SHIFTER --> MOSI[MOSI Output]
    
    MISO[MISO Input] --> RXSHFT(RX Shift Register)
    RXSHFT --> RXREG[[RX Register]]
    RXREG --> DATA_OUT[RX Data]
    
    CTRL --> SHIFTER
    CTRL --> RXSHFT
    CTRL --> BUSY[Busy Flag]
    
    TB_CLK[TB Clock] -.-> |Testbench| TB(SPI Test Logic)
    TB_RST[TB Reset] -.-> |Testbench| TB
    TB -.-> |Stimulus| DATA_IN
    TB -.-> |Monitor| DATA_OUT
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module spi_master(
    input wire clk,
    input wire rst,
    input wire start,
    input wire miso,
    input wire [7:0] data_in,
    output reg sclk,
    output reg mosi,
    output reg busy,
    output reg [7:0] data_out
);

reg [3:0] clk_div;
reg [2:0] bit_count;
reg [7:0] tx_reg;
reg [7:0] rx_shift;
reg active;

always @(posedge clk or posedge rst) begin
    if (rst) begin
        clk_div <= 4'd0;
        sclk <= 1'b0;
    end else if (active) begin
        clk_div <= clk_div + 1'b1;
        if (clk_div == 4'd8) begin
            clk_div <= 4'd0;
            sclk <= ~sclk;
        end
    end else begin
        clk_div <= 4'd0;
        sclk <= 1'b0;
    end
end

always @(posedge clk or posedge rst) begin
    if (rst) begin
        active <= 1'b0;
        busy <= 1'b0;
        bit_count <= 3'd0;
        tx_reg <= 8'd0;
        mosi <= 1'b0;
        data_out <= 8'd0;
        rx_shift <= 8'd0;
    end else begin
        if (start && !active) begin
            active <= 1'b1;
            busy <= 1'b1;
            bit_count <= 3'd7;
            tx_reg <= data_in;
            mosi <= data_in[7];
        end else if (active && clk_div == 4'd8) begin
            if (bit_count == 3'd0) begin
                active <= 1'b0;
                busy <= 1'b0;
                data_out <= rx_shift;
            end else begin
                bit_count <= bit_count - 1'b1;
                tx_reg <= {tx_reg[6:0], 1'b0};
                mosi <= tx_reg[6];
            end
        end
        
        if (active && !sclk) begin
            rx_shift <= {rx_shift[6:0], miso};
        end
    end
end

endmodule

module spi_master_tb;
    reg clk, rst, start;
    reg [7:0] data_in;
    reg miso;
    wire sclk, mosi, busy;
    wire [7:0] data_out;
    
    spi_master dut (
        .clk(clk),
        .rst(rst),
        .start(start),
        .miso(miso),
        .data_in(data_in),
        .sclk(sclk),
        .mosi(mosi),
        .busy(busy),
        .data_out(data_out)
    );
    
    initial begin
        $dumpfile(""spi_master.vcd"");
        $dumpvars(0, spi_master_tb);
        
        clk = 1'b0;
        rst = 1'b1;
        start = 1'b0;
        data_in = 1'b0;
        miso = 1'b0;
        
        #20 rst = 1'b0;
        
        #20 data_in = 8'hA5;
        start = 1'b1;
        #10 start = 1'b0;
        
        @(negedge busy);
        #100;
        
        data_in = 8'h5A;
        miso = 1'b1;
        start = 1'b1;
        #10 start = 1'b0;
        
        @(negedge busy);
        #100 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t rst=%b start=%b busy=%b data_in=%h data_out=%h"",
                 $time, rst, start, busy, data_in, data_out);
    end
endmodule",True,126,False,True,True,,0.0,,12.536600351333618,0.013972043991088867,prompt_only,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,Protocol,complex,"Design SPI master supporting mode 0 (CPOL=0, CPHA=0). Include SCLK generation, MOSI/MISO handling. Include testbench.",gpt-4o,"`timescale 1ns/1ps

module spi_master(
    input wire clk,
    input wire rst_n,
    input wire [7:0] data_in,
    input wire start,
    output reg sclk,
    output reg mosi,
    input wire miso,
    output reg [7:0] data_out,
    output reg done
);

    reg [2:0] bit_cnt;
    reg [7:0] shift_reg;
    reg active;

    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            sclk <= 1'b0;
            mosi <= 1'b0;
            data_out <= 8'b0;
            bit_cnt <= 3'b0;
            shift_reg <= 8'b0;
            active <= 1'b0;
            done <= 1'b0;
        end else begin
            if (start && !active) begin
                active <= 1'b1;
                shift_reg <= data_in;
                bit_cnt <= 3'b0;
                done <= 1'b0;
            end

            if (active) begin
                sclk <= ~sclk;

                if (sclk) begin  // Rising edge of SCLK
                    mosi <= shift_reg[7];
                    shift_reg <= {shift_reg[6:0], miso};
                    bit_cnt <= bit_cnt + 1'b1;

                    if (bit_cnt == 3'b111) begin
                        active <= 1'b0;
                        done <= 1'b1;
                        data_out <= shift_reg;
                    end
                end
            end
        end
    end

endmodule

module testbench;
    reg clk, rst_n, start;
    reg [7:0] data_in;
    wire sclk, mosi;
    reg miso;
    wire [7:0] data_out;
    wire done;

    spi_master dut (
        .clk(clk),
        .rst_n(rst_n),
        .data_in(data_in),
        .start(start),
        .sclk(sclk),
        .mosi(mosi),
        .miso(miso),
        .data_out(data_out),
        .done(done)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 1'b0;
        rst_n = 1'b0;
        start = 1'b0;
        data_in = 8'hA5;
        miso = 1'b0;

        #20 rst_n = 1'b1;
        #10 start = 1'b1;
        #10 start = 1'b0;

        #200 miso = 1'b1; // Simulate a MISO input
        #20 miso = 1'b0;
        #20 miso = 1'b1;
        #20 miso = 1'b0;
        #20 miso = 1'b1;
        #20 miso = 1'b0;
        #20 miso = 1'b1;
        #20 miso = 1'b0;

        #100 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b start=%b data_in=%h sclk=%b mosi=%b miso=%b data_out=%h done=%b"", 
                 $time, clk, rst_n, start, data_in, sclk, mosi, miso, data_out, done);
    end
endmodule",True,108,True,True,True,False,0.3,False,12.528947591781616,12.109710931777954,"graph TD
    CLK[Clock] --> SCLK_GEN(SCLK Generation)
    RST[Reset] --> SPI_MASTER(SPI Master)
    
    SPI_MASTER --> SCLK_GEN
    SCLK_GEN --> SCLK_OUT[SCLK Output]
    
    MOSI_IN[MOSI Input] --> SPI_MASTER
    SPI_MASTER --> MOSI_OUT[MOSI Output]
    
    MISO_IN[MISO Input] --> SPI_MASTER
    SPI_MASTER --> MISO_OUT[MISO Output]
    
    TB[Testbench] --> CLK
    TB --> RST
    TB --> MOSI_IN
    TB --> MISO_IN
    SCLK_OUT --> TB
    MOSI_OUT --> TB
    MISO_OUT --> TB","`timescale 1ns/1ps

module spi_master(
    input wire clk,
    input wire rst_n,
    input wire mosi_in,
    input wire miso_in,
    output reg mosi_out,
    output reg miso_out
);

    reg mosi_reg, miso_reg;
    
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            mosi_reg <= 1'b0;
            miso_reg <= 1'b0;
        end else begin
            mosi_reg <= mosi_in;
            miso_reg <= miso_in;
        end
    end
    
    always @(posedge clk) begin
        mosi_out <= mosi_reg;
        miso_out <= miso_reg;
    end
    
endmodule

module sclk_generation(
    input wire clk,
    input wire rst_n,
    output reg sclk_out
);
    
    reg sclk_reg;
    
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            sclk_reg <= 1'b0;
        end else begin
            sclk_reg <= ~sclk_reg;
        end
    end
    
    always @(posedge clk) begin
        sclk_out <= sclk_reg;
    end
    
endmodule

module testbench;
    reg clk, rst_n, mosi_in, miso_in;
    wire sclk_out, mosi_out, miso_out;
    
    spi_master spi_master_inst (
        .clk(clk),
        .rst_n(rst_n),
        .mosi_in(mosi_in),
        .miso_in(miso_in),
        .mosi_out(mosi_out),
        .miso_out(miso_out)
    );
    
    sclk_generation sclk_gen_inst (
        .clk(clk),
        .rst_n(rst_n),
        .sclk_out(sclk_out)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst_n = 1'b0;
        mosi_in = 1'b0;
        miso_in = 1'b0;
        
        #20 rst_n = 1'b1;
        #10 mosi_in = 1'b1;
        #10 miso_in = 1'b1;
        #100 mosi_in = 1'b0;
        #100 miso_in = 1'b0;
        #20 rst_n = 1'b0;
        #20 rst_n = 1'b1;
        #50 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b mosi_in=%b miso_in=%b mosi_out=%b miso_out=%b sclk_out=%b"", 
                 $time, clk, rst_n, mosi_in, miso_in, mosi_out, miso_out, sclk_out);
    end
endmodule",True,97,True,True,True,True,0.75,True,12.025943040847778,14.093369245529175,"Design SPI master supporting mode 0 (CPOL=0, CPHA=0). Include SCLK generation, MOSI/MISO handling. Include testbench.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph TD
    CLK[Clock] --> SCLK_GEN(SCLK Generation)
    RST[Reset] --> SPI_MASTER(SPI Master)
    
    SPI_MASTER --> SCLK_GEN
    SCLK_GEN --> SCLK_OUT[SCLK Output]
    
    MOSI_IN[MOSI Input] --> SPI_MASTER
    SPI_MASTER --> MOSI_OUT[MOSI Output]
    
    MISO_IN[MISO Input] --> SPI_MASTER
    SPI_MASTER --> MISO_OUT[MISO Output]
    
    TB[Testbench] --> CLK
    TB --> RST
    TB --> MOSI_IN
    TB --> MISO_IN
    SCLK_OUT --> TB
    MOSI_OUT --> TB
    MISO_OUT --> TB
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module spi_master(
    input wire clk,
    input wire rst_n,
    input wire mosi_in,
    input wire miso_in,
    output reg mosi_out,
    output reg miso_out,
    output reg sclk_out
);

reg [7:0] shift_register;
reg [2:0] bit_counter;
reg sclk_reg;

always @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
        sclk_reg <= 1'b0;
        bit_counter <= 3'b000;
        shift_register <= 8'b00000000;
        mosi_out <= 1'b0;
        miso_out <= 1'b0;
    end else begin
        sclk_reg <= ~sclk_reg;
        if (sclk_reg == 1'b0) begin
            mosi_out <= shift_register[7];
            shift_register <= {shift_register[6:0], mosi_in};
            bit_counter <= bit_counter + 1'b1;
        end
        if (bit_counter == 3'b111) begin
            miso_out <= miso_in;
            bit_counter <= 3'b000;
        end
    end
end

assign sclk_out = sclk_reg;

endmodule

module testbench;
    reg clk, rst_n, mosi_in, miso_in;
    wire mosi_out, miso_out, sclk_out;
    
    spi_master uut (
        .clk(clk),
        .rst_n(rst_n),
        .mosi_in(mosi_in),
        .miso_in(miso_in),
        .mosi_out(mosi_out),
        .miso_out(miso_out),
        .sclk_out(sclk_out)
    );
    
    initial begin
        $dumpfile(""spi_dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst_n = 1'b0;
        mosi_in = 1'b0;
        miso_in = 1'b0;
        
        #20 rst_n = 1'b1;
        #10 mosi_in = 1'b1;
        #50 mosi_in = 1'b0;
        #100 miso_in = 1'b1;
        #50 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b mosi_in=%b miso_in=%b mosi_out=%b miso_out=%b sclk_out=%b"", 
                 $time, clk, rst_n, mosi_in, miso_in, mosi_out, miso_out, sclk_out);
    end
endmodule",True,78,True,False,False,,0.0,,9.60621690750122,0.010985374450683594,prompt_only,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
