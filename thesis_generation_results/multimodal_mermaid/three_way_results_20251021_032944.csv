circuit_name,category,complexity,original_prompt,model,prompt_only_verilog,prompt_only_generation_success,prompt_only_lines_of_code,prompt_only_has_testbench,prompt_only_compilation_success,prompt_only_simulation_success,prompt_only_vae_verdict,prompt_only_vae_confidence,prompt_only_consensus_anomalous,prompt_only_generation_time,prompt_only_simulation_time,mermaid_only_mermaid,mermaid_only_verilog,mermaid_only_generation_success,mermaid_only_lines_of_code,mermaid_only_has_testbench,mermaid_only_compilation_success,mermaid_only_simulation_success,mermaid_only_vae_verdict,mermaid_only_vae_confidence,mermaid_only_consensus_anomalous,mermaid_only_generation_time,mermaid_only_simulation_time,combined_prompt,combined_verilog,combined_generation_success,combined_lines_of_code,combined_has_testbench,combined_compilation_success,combined_simulation_success,combined_vae_verdict,combined_vae_confidence,combined_consensus_anomalous,combined_generation_time,combined_simulation_time,best_approach,correctness_ranking,simulation_ranking
combined,Combinational,simple,"Design a 2-to-1 multiplexer with inputs a, b, select sel, and output out. Include testbench testing all combinations.",claude,"`timescale 1ns/1ps

module mux2to1(
    input wire a,
    input wire b,
    input wire sel,
    output reg out
);

always @(*) begin
    if (sel)
        out = b;
    else
        out = a;
end

endmodule

module testbench;
    reg a, b, sel;
    wire out;
    
    mux2to1 dut (
        .a(a),
        .b(b),
        .sel(sel),
        .out(out)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        // Test all combinations
        a = 0; b = 0; sel = 0; #10;
        a = 0; b = 0; sel = 1; #10;
        a = 0; b = 1; sel = 0; #10;
        a = 0; b = 1; sel = 1; #10;
        a = 1; b = 0; sel = 0; #10;
        a = 1; b = 0; sel = 1; #10;
        a = 1; b = 1; sel = 0; #10;
        a = 1; b = 1; sel = 1; #10;
        
        $finish;
    end
    
    initial begin
        $monitor(""Time=%0t a=%b b=%b sel=%b out=%b"",
                 $time, a, b, sel, out);
    end
endmodule",True,51,True,True,True,False,0.4,False,4.941770553588867,6.690412759780884,"graph LR
    A[Input A] --> MUX{2:1 MUX}
    B[Input B] --> MUX
    SEL[Select] --> MUX
    MUX --> OUT[Output]
    TB[[Testbench]]
    TB --> |Test 1: sel=0, a=0, b=0|MUX
    TB --> |Test 2: sel=0, a=0, b=1|MUX
    TB --> |Test 3: sel=0, a=1, b=0|MUX
    TB --> |Test 4: sel=0, a=1, b=1|MUX
    TB --> |Test 5: sel=1, a=0, b=0|MUX
    TB --> |Test 6: sel=1, a=0, b=1|MUX
    TB --> |Test 7: sel=1, a=1, b=0|MUX
    TB --> |Test 8: sel=1, a=1, b=1|MUX","`timescale 1ns/1ps

module mux2to1(
    input wire clk,
    input wire rst_n,
    input wire a,
    input wire b,
    input wire sel,
    output reg out
);

always @(posedge clk or negedge rst_n) begin
    if (!rst_n)
        out <= 1'b0;
    else
        out <= sel ? b : a;
end

endmodule

module testbench;
    reg clk, rst_n;
    reg a, b, sel;
    wire out;
    
    mux2to1 dut (
        .clk(clk),
        .rst_n(rst_n),
        .a(a),
        .b(b),
        .sel(sel),
        .out(out)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 0;
        rst_n = 0;
        a = 0;
        b = 0;
        sel = 0;
        
        #10 rst_n = 1;
        
        // Test 1: sel=0, a=0, b=0
        #10 sel = 0; a = 0; b = 0;
        
        // Test 2: sel=0, a=0, b=1
        #10 sel = 0; a = 0; b = 1;
        
        // Test 3: sel=0, a=1, b=0
        #10 sel = 0; a = 1; b = 0;
        
        // Test 4: sel=0, a=1, b=1
        #10 sel = 0; a = 1; b = 1;
        
        // Test 5: sel=1, a=0, b=0
        #10 sel = 1; a = 0; b = 0;
        
        // Test 6: sel=1, a=0, b=1
        #10 sel = 1; a = 0; b = 1;
        
        // Test 7: sel=1, a=1, b=0
        #10 sel = 1; a = 1; b = 0;
        
        // Test 8: sel=1, a=1, b=1
        #10 sel = 1; a = 1; b = 1;
        
        #10 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t sel=%b a=%b b=%b out=%b"",
                 $time, sel, a, b, out);
    end
endmodule",True,80,True,True,True,False,0.3,False,11.444435834884644,7.571162223815918,"Design a 2-to-1 multiplexer with inputs a, b, select sel, and output out. Include testbench testing all combinations.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph LR
    A[Input A] --> MUX{2:1 MUX}
    B[Input B] --> MUX
    SEL[Select] --> MUX
    MUX --> OUT[Output]
    TB[[Testbench]]
    TB --> |Test 1: sel=0, a=0, b=0|MUX
    TB --> |Test 2: sel=0, a=0, b=1|MUX
    TB --> |Test 3: sel=0, a=1, b=0|MUX
    TB --> |Test 4: sel=0, a=1, b=1|MUX
    TB --> |Test 5: sel=1, a=0, b=0|MUX
    TB --> |Test 6: sel=1, a=0, b=1|MUX
    TB --> |Test 7: sel=1, a=1, b=0|MUX
    TB --> |Test 8: sel=1, a=1, b=1|MUX
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module mux2to1 (
    input wire a,
    input wire b,
    input wire sel,
    output reg out
);

always @(*) begin
    case(sel)
        1'b0: out = a;
        1'b1: out = b;
        default: out = 1'b0;
    endcase
end

endmodule

module testbench;
    reg a, b, sel;
    wire out;

    mux2to1 dut (
        .a(a),
        .b(b),
        .sel(sel),
        .out(out)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        // Test 1: sel=0, a=0, b=0
        sel = 0; a = 0; b = 0; #10;
        
        // Test 2: sel=0, a=0, b=1
        sel = 0; a = 0; b = 1; #10;
        
        // Test 3: sel=0, a=1, b=0
        sel = 0; a = 1; b = 0; #10;
        
        // Test 4: sel=0, a=1, b=1
        sel = 0; a = 1; b = 1; #10;
        
        // Test 5: sel=1, a=0, b=0
        sel = 1; a = 0; b = 0; #10;
        
        // Test 6: sel=1, a=0, b=1
        sel = 1; a = 0; b = 1; #10;
        
        // Test 7: sel=1, a=1, b=0
        sel = 1; a = 1; b = 0; #10;
        
        // Test 8: sel=1, a=1, b=1
        sel = 1; a = 1; b = 1; #10;

        $finish;
    end

    initial begin
        $monitor(""Time=%0t sel=%b a=%b b=%b out=%b"", 
                 $time, sel, a, b, out);
    end

endmodule",True,67,True,True,True,False,0.4,False,6.590411424636841,7.817950487136841,tie,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,Combinational,simple,"Design a 2-to-1 multiplexer with inputs a, b, select sel, and output out. Include testbench testing all combinations.",gpt-4o,"`timescale 1ns/1ps

module mux2to1(
    input wire a,
    input wire b,
    input wire sel,
    output wire out
);

assign out = sel ? b : a;

endmodule

module testbench;
    reg a, b, sel;
    wire out;

    mux2to1 dut (
        .a(a),
        .b(b),
        .sel(sel),
        .out(out)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        a = 1'b0; b = 1'b0; sel = 1'b0;
        #10 a = 1'b0; b = 1'b1; sel = 1'b0;
        #10 a = 1'b1; b = 1'b0; sel = 1'b0;
        #10 a = 1'b1; b = 1'b1; sel = 1'b0;
        #10 a = 1'b0; b = 1'b0; sel = 1'b1;
        #10 a = 1'b0; b = 1'b1; sel = 1'b1;
        #10 a = 1'b1; b = 1'b0; sel = 1'b1;
        #10 a = 1'b1; b = 1'b1; sel = 1'b1;
        #10 $finish;
    end

    initial begin
        $monitor(""Time=%0t a=%b b=%b sel=%b out=%b"", 
                 $time, a, b, sel, out);
    end
endmodule",True,44,True,True,True,False,0.4,False,4.546466827392578,13.63415241241455,"graph TD
    A[Input a] --> MUX{2-to-1 MUX}
    B[Input b] --> MUX
    SEL[Select sel] --> MUX
    MUX --> OUT[Output out]
    
    subgraph Testbench
        A_TEST[Input a Test] --> MUX
        B_TEST[Input b Test] --> MUX
        SEL_TEST[Select sel Test] --> MUX
        OUT_TEST[Output out Test] --> OUT
    end","`timescale 1ns/1ps

module mux_2_to_1(
    input wire a,
    input wire b,
    input wire sel,
    output reg out
);
    
    always @(*) begin
        if (sel)
            out = b;
        else
            out = a;
    end

endmodule

module testbench;
    reg a_test, b_test, sel_test;
    wire out_test;
    
    mux_2_to_1 dut(
        .a(a_test),
        .b(b_test),
        .sel(sel_test),
        .out(out_test)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        a_test = 0;
        b_test = 0;
        sel_test = 0;
        
        #10 a_test = 1;
        #10 b_test = 1;
        #10 sel_test = 1;
        #10 sel_test = 0;
        #10 $finish;
    end
    
    initial begin
        $monitor(""Time=%0t a_test=%b b_test=%b sel_test=%b out_test=%b"", 
                 $time, a_test, b_test, sel_test, out_test);
    end
endmodule",True,49,True,True,True,False,0.4,False,5.117297649383545,8.422565460205078,"Design a 2-to-1 multiplexer with inputs a, b, select sel, and output out. Include testbench testing all combinations.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph TD
    A[Input a] --> MUX{2-to-1 MUX}
    B[Input b] --> MUX
    SEL[Select sel] --> MUX
    MUX --> OUT[Output out]
    
    subgraph Testbench
        A_TEST[Input a Test] --> MUX
        B_TEST[Input b Test] --> MUX
        SEL_TEST[Select sel Test] --> MUX
        OUT_TEST[Output out Test] --> OUT
    end
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module mux_2to1(
    input wire a,
    input wire b,
    input wire sel,
    output wire out
);

assign out = sel ? b : a;

endmodule

module testbench;
    reg a_test, b_test, sel_test;
    wire out_test;
    
    mux_2to1 dut (
        .a(a_test),
        .b(b_test),
        .sel(sel_test),
        .out(out_test)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        // Test all combinations of inputs
        a_test = 0; b_test = 0; sel_test = 0;
        #10 a_test = 0; b_test = 1; sel_test = 0;
        #10 a_test = 1; b_test = 0; sel_test = 0;
        #10 a_test = 1; b_test = 1; sel_test = 0;
        
        #10 a_test = 0; b_test = 0; sel_test = 1;
        #10 a_test = 0; b_test = 1; sel_test = 1;
        #10 a_test = 1; b_test = 0; sel_test = 1;
        #10 a_test = 1; b_test = 1; sel_test = 1;
        
        #10 $finish;
    end
    
    initial begin
        $monitor(""Time=%0t a_test=%b b_test=%b sel_test=%b out_test=%b"", 
                 $time, a_test, b_test, sel_test, out_test);
    end
endmodule",True,47,True,True,True,False,0.4,False,4.6455113887786865,9.433518409729004,tie,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,Sequential,simple,"Create a D flip-flop with clock, reset, input d, and output q. Include testbench with timing verification.",claude,"`timescale 1ns/1ps

module dff(
    input wire clk,
    input wire rst,
    input wire d,
    output reg q
);

always @(posedge clk or posedge rst) begin
    if (rst)
        q <= 1'b0;
    else
        q <= d;
end

endmodule

module testbench;
    reg clk, rst, d;
    wire q;
    
    dff dut (
        .clk(clk),
        .rst(rst),
        .d(d),
        .q(q)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 0;
        rst = 1;
        d = 0;
        
        #20 rst = 0;
        #10 d = 1;
        #10 d = 0;
        #10 d = 1;
        #10 rst = 1;
        #10 rst = 0;
        #30 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t clk=%b rst=%b d=%b q=%b"",
                 $time, clk, rst, d, q);
    end
endmodule",True,53,True,True,True,True,0.7,True,4.289631605148315,7.013451814651489,"graph LR
    CLK[Clock] --> DFF[[D Flip-Flop]]
    RST[Reset] --> DFF
    D[Data Input] --> DFF
    DFF --> Q[Output Q]
    BENCH[Testbench] --> |1. Check Setup Time|TSU{Setup Verify}
    BENCH --> |2. Check Hold Time|THD{Hold Verify}
    BENCH --> |3. Check CLK->Q|TCQ{CLK-Q Delay}
    CLK --> TSU
    CLK --> THD
    CLK --> TCQ
    D --> TSU
    D --> THD
    Q --> TCQ
    TSU --> RESULT[Timing Results]
    THD --> RESULT
    TCQ --> RESULT","`timescale 1ns/1ps

module dff(
    input wire clk,
    input wire rst,
    input wire d,
    output reg q
);

always @(posedge clk or posedge rst) begin
    if (rst)
        q <= 1'b0;
    else
        q <= d;
end

endmodule

module testbench;
    reg clk, rst, d;
    wire q;
    time tsu, thd, tcq;
    
    dff dut (
        .clk(clk),
        .rst(rst),
        .d(d),
        .q(q)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 0;
        rst = 1;
        d = 0;
        
        #10 rst = 0;
        
        // Setup time test
        #10 d = 1;
        tsu = $time;
        #1 clk = 1;
        
        // Hold time test
        #10 clk = 0;
        thd = $time;
        #5 d = 0;
        
        // CLK to Q delay test
        #10 d = 1;
        #5 clk = 1;
        tcq = $time;
        
        #20 $display(""Setup Time: %0t"", tsu);
        $display(""Hold Time: %0t"", thd);
        $display(""CLK->Q Delay: %0t"", tcq);
        $finish;
    end
    
    initial begin
        $monitor(""Time=%0t clk=%b rst=%b d=%b q=%b"",
                 $time, clk, rst, d, q);
    end
endmodule",True,66,True,True,True,False,0.3,False,9.316741466522217,6.7134926319122314,"Create a D flip-flop with clock, reset, input d, and output q. Include testbench with timing verification.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph LR
    CLK[Clock] --> DFF[[D Flip-Flop]]
    RST[Reset] --> DFF
    D[Data Input] --> DFF
    DFF --> Q[Output Q]
    BENCH[Testbench] --> |1. Check Setup Time|TSU{Setup Verify}
    BENCH --> |2. Check Hold Time|THD{Hold Verify}
    BENCH --> |3. Check CLK->Q|TCQ{CLK-Q Delay}
    CLK --> TSU
    CLK --> THD
    CLK --> TCQ
    D --> TSU
    D --> THD
    Q --> TCQ
    TSU --> RESULT[Timing Results]
    THD --> RESULT
    TCQ --> RESULT
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module dff(
    input wire clk,
    input wire rst,
    input wire d,
    output reg q
);

always @(posedge clk or posedge rst) begin
    if (rst)
        q <= 1'b0;
    else
        q <= d;
end

endmodule

module testbench;
    reg clk, rst, d;
    wire q;
    time setup_time, hold_time, clk_to_q;
    
    dff dut(
        .clk(clk),
        .rst(rst),
        .d(d),
        .q(q)
    );
    
    initial begin
        $dumpfile(""dff.vcd"");
        $dumpvars(0, testbench);
        
        clk = 0;
        rst = 1;
        d = 0;
        
        // Reset release
        #20 rst = 0;
        
        // Setup time test
        #10 d = 1;
        @(posedge clk);
        setup_time = $time;
        
        // Hold time test
        #10 d = 0;
        @(negedge clk);
        hold_time = $time;
        
        // Clock to Q delay test
        #10 d = 1;
        @(posedge clk);
        #1;
        clk_to_q = $time;
        
        // Display timing results
        $display(""Setup Time: %0t"", setup_time);
        $display(""Hold Time: %0t"", hold_time);
        $display(""Clock-to-Q Delay: %0t"", clk_to_q);
        
        #100 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t clk=%b rst=%b d=%b q=%b"",
                 $time, clk, rst, d, q);
    end
endmodule",True,72,True,True,True,,0.0,,6.451858758926392,0.013642072677612305,mermaid_only,mermaid_only > prompt_only > combined,prompt_only > mermaid_only > combined
combined,Sequential,simple,"Create a D flip-flop with clock, reset, input d, and output q. Include testbench with timing verification.",gpt-4o,"`timescale 1ns/1ps

module d_flip_flop(
    input wire clk,
    input wire rst_n,
    input wire d,
    output reg q
);

always @(posedge clk or negedge rst_n) begin
    if (!rst_n)
        q <= 1'b0;
    else
        q <= d;
end

endmodule

module testbench;
    reg clk, rst_n, d;
    wire q;
    
    d_flip_flop dut (
        .clk(clk),
        .rst_n(rst_n),
        .d(d),
        .q(q)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst_n = 1'b0;
        d = 1'b0;
        
        #20 rst_n = 1'b1;
        #10 d = 1'b1;
        #10 d = 1'b0;
        #20 d = 1'b1;
        #20 rst_n = 1'b0;
        #20 rst_n = 1'b1;
        #50 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b d=%b q=%b"", 
                 $time, clk, rst_n, d, q);
    end
endmodule",True,53,True,True,True,True,0.7,True,3.7263009548187256,13.229847431182861,"graph LR
    CLK[Clock] --> DFF[[D Flip-Flop]]
    RST[Reset] --> DFF
    D[Input D] --> DFF
    DFF --> Q[Output Q]
    subgraph Testbench
        TB_CLK[Clock] --> DFF
        TB_RST[Reset] --> DFF
        TB_D[Test Input D] --> DFF
        DFF --> TB_Q[Test Output Q]
        TB_Verify[Timing Verification] --> TB_Q
    end","`timescale 1ns/1ps

module dff(
    input wire clk,
    input wire rst,
    input wire d,
    output reg q
);

always @(posedge clk or posedge rst) begin
    if (rst)
        q <= 1'b0;
    else
        q <= d;
end

endmodule

module testbench;
    reg clk, rst, d;
    wire q;
    
    dff dut (
        .clk(clk),
        .rst(rst),
        .d(d),
        .q(q)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst = 1'b1;
        d = 1'b0;
        
        #15 rst = 1'b0;
        #10 d = 1'b1;
        #20 d = 1'b0;
        #30 d = 1'b1;
        #40 d = 1'b0;
        #50 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t clk=%b rst=%b d=%b q=%b"", 
                 $time, clk, rst, d, q);
    end
endmodule",True,52,True,True,True,True,0.7,True,7.652200698852539,11.092586278915405,"Create a D flip-flop with clock, reset, input d, and output q. Include testbench with timing verification.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph LR
    CLK[Clock] --> DFF[[D Flip-Flop]]
    RST[Reset] --> DFF
    D[Input D] --> DFF
    DFF --> Q[Output Q]
    subgraph Testbench
        TB_CLK[Clock] --> DFF
        TB_RST[Reset] --> DFF
        TB_D[Test Input D] --> DFF
        DFF --> TB_Q[Test Output Q]
        TB_Verify[Timing Verification] --> TB_Q
    end
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module d_flip_flop(
    input wire clk,
    input wire rst,
    input wire d,
    output reg q
);

always @(posedge clk or posedge rst) begin
    if (rst)
        q <= 1'b0;
    else
        q <= d;
end

endmodule

module testbench;
    reg tb_clk, tb_rst, tb_d;
    wire tb_q;
    
    d_flip_flop dut (
        .clk(tb_clk),
        .rst(tb_rst),
        .d(tb_d),
        .q(tb_q)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        tb_clk = 1'b0;
        tb_rst = 1'b0;
        tb_d = 1'b0;
        
        #20 tb_rst = 1'b1;
        #10 tb_rst = 1'b0;
        #10 tb_d = 1'b1;
        #20 tb_d = 1'b0;
        #30 tb_d = 1'b1;
        #40 tb_d = 1'b0;
        #50 $finish;
    end
    
    always #5 tb_clk = ~tb_clk;
    
    initial begin
        $monitor(""Time=%0t tb_clk=%b tb_rst=%b tb_d=%b tb_q=%b"", 
                 $time, tb_clk, tb_rst, tb_d, tb_q);
    end
endmodule",True,53,True,True,True,True,0.7,True,4.906842947006226,13.34366226196289,prompt_only,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,Sequential,simple,"Design a 4-bit synchronous counter with clock, reset, enable, and count[3:0]. Include testbench.",claude,"`timescale 1ns/1ps

module counter(
    input wire clk,
    input wire rst_n,
    input wire enable,
    output reg [3:0] count
);

always @(posedge clk or negedge rst_n) begin
    if (!rst_n)
        count <= 4'b0000;
    else if (enable)
        count <= count + 1'b1;
end

endmodule

module testbench;
    reg clk, rst_n, enable;
    wire [3:0] count;
    
    counter dut (
        .clk(clk),
        .rst_n(rst_n),
        .enable(enable),
        .count(count)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst_n = 1'b0;
        enable = 1'b0;
        
        #20 rst_n = 1'b1;
        #10 enable = 1'b1;
        #100 enable = 1'b0;
        #20 rst_n = 1'b0;
        #20 rst_n = 1'b1;
        #50 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b enable=%b count=%d"", 
                 $time, clk, rst_n, enable, count);
    end
endmodule",True,52,True,True,True,False,0.3,False,4.683013677597046,9.523651838302612,"graph TD
    CLK[Clock] --> COUNTER[[4-bit Counter]]
    RST[Reset] --> COUNTER
    EN[Enable] --> COUNTER
    COUNTER --> COUNT[Count[3:0]]
    
    COUNTER --> TB_DUT[[Testbench DUT]]
    CLK --> TB_DUT
    RST --> TB_DUT
    EN --> TB_DUT
    
    TB_STIM(Test Stimulus) --> TB_DUT
    TB_DUT --> TB_MON(Monitor)
    TB_MON --> TB_CHK{Check Results}
    TB_CHK --> TB_PASS[Test Pass]
    TB_CHK --> TB_FAIL[Test Fail]
    
    COUNTER --> CNT_PROC((Counter Logic))
    CNT_PROC --> FF[[Flip-Flops]]
    FF --> COUNT
    CLK --> FF
    RST --> FF
    EN --> CNT_PROC","`timescale 1ns/1ps

module counter(
    input wire clk,
    input wire rst_n,
    input wire enable,
    output reg [3:0] count
);

always @(posedge clk or negedge rst_n) begin
    if (!rst_n)
        count <= 4'b0000;
    else if (enable)
        count <= count + 1'b1;
end

endmodule

module testbench;
    reg clk, rst_n, enable;
    wire [3:0] count;
    
    counter dut (
        .clk(clk),
        .rst_n(rst_n),
        .enable(enable),
        .count(count)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 0;
        rst_n = 0;
        enable = 0;
        
        #20 rst_n = 1;
        #10 enable = 1;
        
        #160 begin
            enable = 0;
            #10 rst_n = 0;
            #10 rst_n = 1;
        end
        
        #50 $finish;
    end
    
    always #5 clk = ~clk;
    
    reg [3:0] expected_count;
    
    always @(posedge clk) begin
        if (!rst_n)
            expected_count <= 0;
        else if (enable)
            expected_count <= expected_count + 1;
            
        if (count !== expected_count) begin
            $display(""ERROR: Count mismatch at time %t"", $time);
            $display(""Expected: %d, Got: %d"", expected_count, count);
            $finish;
        end
    end
    
    initial begin
        $monitor(""Time=%0t rst_n=%b en=%b count=%d"", 
                 $time, rst_n, enable, count);
    end
endmodule",True,71,True,True,True,,0.0,False,12.02747392654419,5.921489715576172,"Design a 4-bit synchronous counter with clock, reset, enable, and count[3:0]. Include testbench.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph TD
    CLK[Clock] --> COUNTER[[4-bit Counter]]
    RST[Reset] --> COUNTER
    EN[Enable] --> COUNTER
    COUNTER --> COUNT[Count[3:0]]
    
    COUNTER --> TB_DUT[[Testbench DUT]]
    CLK --> TB_DUT
    RST --> TB_DUT
    EN --> TB_DUT
    
    TB_STIM(Test Stimulus) --> TB_DUT
    TB_DUT --> TB_MON(Monitor)
    TB_MON --> TB_CHK{Check Results}
    TB_CHK --> TB_PASS[Test Pass]
    TB_CHK --> TB_FAIL[Test Fail]
    
    COUNTER --> CNT_PROC((Counter Logic))
    CNT_PROC --> FF[[Flip-Flops]]
    FF --> COUNT
    CLK --> FF
    RST --> FF
    EN --> CNT_PROC
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module counter(
    input wire clk,
    input wire rst_n,
    input wire enable,
    output reg [3:0] count
);

always @(posedge clk or negedge rst_n) begin
    if (!rst_n)
        count <= 4'b0000;
    else if (enable)
        count <= count + 1'b1;
end

endmodule

module testbench;
    reg clk, rst_n, enable;
    wire [3:0] count;
    reg [31:0] test_vector;
    reg test_pass;
    
    counter dut (
        .clk(clk),
        .rst_n(rst_n),
        .enable(enable),
        .count(count)
    );
    
    initial begin
        $dumpfile(""counter_tb.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst_n = 1'b0;
        enable = 1'b0;
        test_pass = 1'b1;
        test_vector = 0;
        
        // Test Reset
        #20 rst_n = 1'b1;
        if (count !== 4'b0000) test_pass = 1'b0;
        
        // Test Counting
        #10 enable = 1'b1;
        repeat(16) begin
            @(posedge clk);
            test_vector = count;
            if (test_vector !== count) test_pass = 1'b0;
        end
        
        // Test Disable
        enable = 1'b0;
        #20;
        test_vector = count;
        @(posedge clk);
        if (count !== test_vector) test_pass = 1'b0;
        
        // Test Reset Again
        rst_n = 1'b0;
        #20;
        if (count !== 4'b0000) test_pass = 1'b0;
        
        if (test_pass)
            $display(""TEST PASSED"");
        else
            $display(""TEST FAILED"");
            
        #20 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t rst_n=%b enable=%b count=%b test_pass=%b"", 
                 $time, rst_n, enable, count, test_pass);
    end
endmodule",True,80,True,True,True,,0.0,,8.124539613723755,0.014117717742919922,tie,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,Sequential,simple,"Design a 4-bit synchronous counter with clock, reset, enable, and count[3:0]. Include testbench.",gpt-4o,"`timescale 1ns/1ps

module counter(
    input wire clk,
    input wire rst_n,
    input wire enable,
    output reg [3:0] count
);

always @(posedge clk or negedge rst_n) begin
    if (!rst_n)
        count <= 4'b0000;
    else if (enable)
        count <= count + 1'b1;
end

endmodule

module testbench;
    reg clk, rst_n, enable;
    wire [3:0] count;
    
    counter dut (
        .clk(clk),
        .rst_n(rst_n),
        .enable(enable),
        .count(count)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst_n = 1'b0;
        enable = 1'b0;
        
        #20 rst_n = 1'b1;
        #10 enable = 1'b1;
        #100 enable = 1'b0;
        #20 rst_n = 1'b0;
        #20 rst_n = 1'b1;
        #50 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b enable=%b count=%d"", 
                 $time, clk, rst_n, enable, count);
    end
endmodule",True,52,True,True,True,False,0.3,False,4.6445581912994385,11.040897607803345,"graph LR
    CLK[Clock] --> COUNTER(4-bit Counter)
    RST[Reset] --> COUNTER
    EN[Enable] --> COUNTER
    COUNTER --> COUNT[[Count[3:0]]]
    subgraph Testbench
        TB_CLK[Clock] --> TB_COUNTER(4-bit Counter)
        TB_RST[Reset] --> TB_COUNTER
        TB_EN[Enable] --> TB_COUNTER
        TB_COUNTER --> TB_COUNT[[Count[3:0]]]
    end","`timescale 1ns/1ps

module counter(
    input wire clk,
    input wire rst_n,
    input wire enable,
    output reg [3:0] count
);

always @(posedge clk or negedge rst_n) begin
    if (!rst_n)
        count <= 4'b0000;
    else if (enable)
        count <= count + 1'b1;
end

endmodule

module testbench;
    reg clk, rst_n, enable;
    wire [3:0] count;
    
    counter dut (
        .clk(clk),
        .rst_n(rst_n),
        .enable(enable),
        .count(count)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst_n = 1'b0;
        enable = 1'b0;
        
        #20 rst_n = 1'b1;
        #10 enable = 1'b1;
        #100 enable = 1'b0;
        #20 rst_n = 1'b0;
        #20 rst_n = 1'b1;
        #50 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b enable=%b count=%d"", 
                 $time, clk, rst_n, enable, count);
    end
endmodule",True,52,True,True,True,False,0.3,False,6.596099853515625,11.770029306411743,"Design a 4-bit synchronous counter with clock, reset, enable, and count[3:0]. Include testbench.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph LR
    CLK[Clock] --> COUNTER(4-bit Counter)
    RST[Reset] --> COUNTER
    EN[Enable] --> COUNTER
    COUNTER --> COUNT[[Count[3:0]]]
    subgraph Testbench
        TB_CLK[Clock] --> TB_COUNTER(4-bit Counter)
        TB_RST[Reset] --> TB_COUNTER
        TB_EN[Enable] --> TB_COUNTER
        TB_COUNTER --> TB_COUNT[[Count[3:0]]]
    end
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module counter(
    input wire clk,
    input wire rst_n,
    input wire enable,
    output reg [3:0] count
);

always @(posedge clk or negedge rst_n) begin
    if (!rst_n)
        count <= 4'b0000;
    else if (enable)
        count <= count + 1'b1;
end

endmodule

module testbench;
    reg clk, rst_n, enable;
    wire [3:0] count;
    
    counter dut (
        .clk(clk),
        .rst_n(rst_n),
        .enable(enable),
        .count(count)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst_n = 1'b0;
        enable = 1'b0;
        
        #20 rst_n = 1'b1;
        #10 enable = 1'b1;
        #100 enable = 1'b0;
        #20 rst_n = 1'b0;
        #20 rst_n = 1'b1;
        #50 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b enable=%b count=%d"", 
                 $time, clk, rst_n, enable, count);
    end
endmodule",True,52,True,True,True,False,0.3,False,3.8711392879486084,9.809016704559326,tie,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,Combinational,simple,"Create a full adder with inputs a, b, cin and outputs sum, cout. Include testbench with all 8 cases.",claude,"`timescale 1ns/1ps

module full_adder (
    input wire a,
    input wire b,
    input wire cin,
    output wire sum,
    output wire cout
);

assign sum = a ^ b ^ cin;
assign cout = (a & b) | (b & cin) | (a & cin);

endmodule

module testbench;
    reg a, b, cin;
    wire sum, cout;

    full_adder dut (
        .a(a),
        .b(b),
        .cin(cin),
        .sum(sum),
        .cout(cout)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        // Test all 8 cases
        {a, b, cin} = 3'b000; #10;
        {a, b, cin} = 3'b001; #10;
        {a, b, cin} = 3'b010; #10;
        {a, b, cin} = 3'b011; #10;
        {a, b, cin} = 3'b100; #10;
        {a, b, cin} = 3'b101; #10;
        {a, b, cin} = 3'b110; #10;
        {a, b, cin} = 3'b111; #10;

        $finish;
    end

    initial begin
        $monitor(""Time=%0t a=%b b=%b cin=%b sum=%b cout=%b"",
                 $time, a, b, cin, sum, cout);
    end
endmodule",True,49,True,True,True,False,0.4,False,4.771504640579224,7.160598039627075,"graph LR
    A[Input A] --> HA1((Half Adder 1))
    B[Input B] --> HA1
    HA1 --> S1((XOR))
    HA1 --> C1((AND))
    Cin[Input Cin] --> S2((XOR))
    S1 --> S2
    S2 --> Sum[Output Sum]
    Cin --> C2((AND))
    S1 --> C2
    C1 --> OR1((OR))
    C2 --> OR1
    OR1 --> Cout[Output Cout]
    TB[Testbench Cases] --> |000|V1[[Case 1: 0+0+0=0,0]]
    TB --> |001|V2[[Case 2: 0+0+1=1,0]]
    TB --> |010|V3[[Case 3: 0+1+0=1,0]]
    TB --> |011|V4[[Case 4: 0+1+1=0,1]]
    TB --> |100|V5[[Case 5: 1+0+0=1,0]]
    TB --> |101|V6[[Case 6: 1+0+1=0,1]]
    TB --> |110|V7[[Case 7: 1+1+0=0,1]]
    TB --> |111|V8[[Case 8: 1+1+1=1,1]]","`timescale 1ns/1ps

module full_adder (
    input wire a,
    input wire b,
    input wire cin,
    output wire sum,
    output wire cout
);

wire ha1_sum, ha1_cout;
wire ha2_cout;

// Half adder 1
assign ha1_sum = a ^ b;
assign ha1_cout = a & b;

// Final sum using second XOR
assign sum = ha1_sum ^ cin;

// Carry out logic
assign ha2_cout = ha1_sum & cin;
assign cout = ha1_cout | ha2_cout;

endmodule

module testbench;
    reg a, b, cin;
    wire sum, cout;

    full_adder dut (
        .a(a),
        .b(b),
        .cin(cin),
        .sum(sum),
        .cout(cout)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        // Test all cases
        {a, b, cin} = 3'b000; #10;
        {a, b, cin} = 3'b001; #10;
        {a, b, cin} = 3'b010; #10;
        {a, b, cin} = 3'b011; #10;
        {a, b, cin} = 3'b100; #10;
        {a, b, cin} = 3'b101; #10;
        {a, b, cin} = 3'b110; #10;
        {a, b, cin} = 3'b111; #10;

        $finish;
    end

    initial begin
        $monitor(""Time=%0t a=%b b=%b cin=%b sum=%b cout=%b"",
                 $time, a, b, cin, sum, cout);
    end
endmodule",True,60,True,True,True,False,0.4,False,11.116594076156616,7.220179319381714,"Create a full adder with inputs a, b, cin and outputs sum, cout. Include testbench with all 8 cases.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph LR
    A[Input A] --> HA1((Half Adder 1))
    B[Input B] --> HA1
    HA1 --> S1((XOR))
    HA1 --> C1((AND))
    Cin[Input Cin] --> S2((XOR))
    S1 --> S2
    S2 --> Sum[Output Sum]
    Cin --> C2((AND))
    S1 --> C2
    C1 --> OR1((OR))
    C2 --> OR1
    OR1 --> Cout[Output Cout]
    TB[Testbench Cases] --> |000|V1[[Case 1: 0+0+0=0,0]]
    TB --> |001|V2[[Case 2: 0+0+1=1,0]]
    TB --> |010|V3[[Case 3: 0+1+0=1,0]]
    TB --> |011|V4[[Case 4: 0+1+1=0,1]]
    TB --> |100|V5[[Case 5: 1+0+0=1,0]]
    TB --> |101|V6[[Case 6: 1+0+1=0,1]]
    TB --> |110|V7[[Case 7: 1+1+0=0,1]]
    TB --> |111|V8[[Case 8: 1+1+1=1,1]]
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module full_adder (
    input wire a,
    input wire b,
    input wire cin,
    output wire sum,
    output wire cout
);

wire s1, c1, c2;

// Half adder 1
assign s1 = a ^ b;
assign c1 = a & b;

// Final sum and carry logic
assign sum = s1 ^ cin;
assign c2 = s1 & cin;
assign cout = c1 | c2;

endmodule

module testbench;
    reg a, b, cin;
    wire sum, cout;
    
    full_adder dut (
        .a(a),
        .b(b),
        .cin(cin),
        .sum(sum),
        .cout(cout)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        // Test case 1: 0+0+0=0,0
        a = 0; b = 0; cin = 0; #10;
        
        // Test case 2: 0+0+1=1,0
        a = 0; b = 0; cin = 1; #10;
        
        // Test case 3: 0+1+0=1,0
        a = 0; b = 1; cin = 0; #10;
        
        // Test case 4: 0+1+1=0,1
        a = 0; b = 1; cin = 1; #10;
        
        // Test case 5: 1+0+0=1,0
        a = 1; b = 0; cin = 0; #10;
        
        // Test case 6: 1+0+1=0,1
        a = 1; b = 0; cin = 1; #10;
        
        // Test case 7: 1+1+0=0,1
        a = 1; b = 1; cin = 0; #10;
        
        // Test case 8: 1+1+1=1,1
        a = 1; b = 1; cin = 1; #10;
        
        $finish;
    end
    
    initial begin
        $monitor(""Time=%0t a=%b b=%b cin=%b sum=%b cout=%b"", 
                 $time, a, b, cin, sum, cout);
    end
endmodule",True,71,True,True,True,False,0.4,False,7.540870428085327,7.690738201141357,tie,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,Combinational,simple,"Create a full adder with inputs a, b, cin and outputs sum, cout. Include testbench with all 8 cases.",gpt-4o,"`timescale 1ns/1ps

module full_adder(
    input wire a,
    input wire b,
    input wire cin,
    output wire sum,
    output wire cout
);
    assign sum = a ^ b ^ cin;
    assign cout = (a & b) | (b & cin) | (a & cin);
endmodule

module testbench;
    reg a, b, cin;
    wire sum, cout;

    full_adder dut (
        .a(a),
        .b(b),
        .cin(cin),
        .sum(sum),
        .cout(cout)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        a = 0; b = 0; cin = 0; #10;
        a = 0; b = 0; cin = 1; #10;
        a = 0; b = 1; cin = 0; #10;
        a = 0; b = 1; cin = 1; #10;
        a = 1; b = 0; cin = 0; #10;
        a = 1; b = 0; cin = 1; #10;
        a = 1; b = 1; cin = 0; #10;
        a = 1; b = 1; cin = 1; #10;
        $finish;
    end

    initial begin
        $monitor(""Time=%0t a=%b b=%b cin=%b sum=%b cout=%b"", 
                 $time, a, b, cin, sum, cout);
    end
endmodule",True,45,True,True,True,False,0.4,False,5.479702711105347,8.943791151046753,"graph LR
    A[a] --> FA(Full Adder)
    B[b] --> FA
    CIN[cin] --> FA
    FA --> SUM[sum]
    FA --> COUT[cout]
    
    subgraph Testbench
        direction TB
        A1[Test Case 1: a=0, b=0, cin=0]
        A2[Test Case 2: a=0, b=0, cin=1]
        A3[Test Case 3: a=0, b=1, cin=0]
        A4[Test Case 4: a=0, b=1, cin=1]
        A5[Test Case 5: a=1, b=0, cin=0]
        A6[Test Case 6: a=1, b=0, cin=1]
        A7[Test Case 7: a=1, b=1, cin=0]
        A8[Test Case 8: a=1, b=1, cin=1]
        
        A1 --> A
        A1 --> B
        A1 --> CIN
        
        A2 --> A
        A2 --> B
        A2 --> CIN
        
        A3 --> A
        A3 --> B
        A3 --> CIN
        
        A4 --> A
        A4 --> B
        A4 --> CIN
        
        A5 --> A
        A5 --> B
        A5 --> CIN
        
        A6 --> A
        A6 --> B
        A6 --> CIN
        
        A7 --> A
        A7 --> B
        A7 --> CIN
        
        A8 --> A
        A8 --> B
        A8 --> CIN
    end","`timescale 1ns/1ps

module full_adder(
    input wire a,
    input wire b,
    input wire cin,
    output reg sum,
    output reg cout
);

always @(*) begin
    {cout, sum} = a + b + cin;
end

endmodule

module testbench;
    reg a, b, cin;
    wire sum, cout;
    
    full_adder uut (
        .a(a),
        .b(b),
        .cin(cin),
        .sum(sum),
        .cout(cout)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        // Test Case 1: a=0, b=0, cin=0
        a = 0; b = 0; cin = 0;
        #10;
        
        // Test Case 2: a=0, b=0, cin=1
        a = 0; b = 0; cin = 1;
        #10;
        
        // Test Case 3: a=0, b=1, cin=0
        a = 0; b = 1; cin = 0;
        #10;
        
        // Test Case 4: a=0, b=1, cin=1
        a = 0; b = 1; cin = 1;
        #10;
        
        // Test Case 5: a=1, b=0, cin=0
        a = 1; b = 0; cin = 0;
        #10;
        
        // Test Case 6: a=1, b=0, cin=1
        a = 1; b = 0; cin = 1;
        #10;
        
        // Test Case 7: a=1, b=1, cin=0
        a = 1; b = 1; cin = 0;
        #10;
        
        // Test Case 8: a=1, b=1, cin=1
        a = 1; b = 1; cin = 1;
        #10;
        
        $finish;
    end
    
    initial begin
        $monitor(""Time=%0t a=%b b=%b cin=%b sum=%b cout=%b"", 
                 $time, a, b, cin, sum, cout);
    end
endmodule",True,72,True,True,True,False,0.4,False,24.413820266723633,9.241936206817627,"Create a full adder with inputs a, b, cin and outputs sum, cout. Include testbench with all 8 cases.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph LR
    A[a] --> FA(Full Adder)
    B[b] --> FA
    CIN[cin] --> FA
    FA --> SUM[sum]
    FA --> COUT[cout]
    
    subgraph Testbench
        direction TB
        A1[Test Case 1: a=0, b=0, cin=0]
        A2[Test Case 2: a=0, b=0, cin=1]
        A3[Test Case 3: a=0, b=1, cin=0]
        A4[Test Case 4: a=0, b=1, cin=1]
        A5[Test Case 5: a=1, b=0, cin=0]
        A6[Test Case 6: a=1, b=0, cin=1]
        A7[Test Case 7: a=1, b=1, cin=0]
        A8[Test Case 8: a=1, b=1, cin=1]
        
        A1 --> A
        A1 --> B
        A1 --> CIN
        
        A2 --> A
        A2 --> B
        A2 --> CIN
        
        A3 --> A
        A3 --> B
        A3 --> CIN
        
        A4 --> A
        A4 --> B
        A4 --> CIN
        
        A5 --> A
        A5 --> B
        A5 --> CIN
        
        A6 --> A
        A6 --> B
        A6 --> CIN
        
        A7 --> A
        A7 --> B
        A7 --> CIN
        
        A8 --> A
        A8 --> B
        A8 --> CIN
    end
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module full_adder(
    input wire a,
    input wire b,
    input wire cin,
    output wire sum,
    output wire cout
);

assign sum = a ^ b ^ cin;
assign cout = (a & b) | (b & cin) | (cin & a);

endmodule

module testbench;
    reg a, b, cin;
    wire sum, cout;
    
    full_adder dut (
        .a(a),
        .b(b),
        .cin(cin),
        .sum(sum),
        .cout(cout)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        // Test Case 1: a=0, b=0, cin=0
        a = 0; b = 0; cin = 0;
        #10;
        
        // Test Case 2: a=0, b=0, cin=1
        a = 0; b = 0; cin = 1;
        #10;
        
        // Test Case 3: a=0, b=1, cin=0
        a = 0; b = 1; cin = 0;
        #10;
        
        // Test Case 4: a=0, b=1, cin=1
        a = 0; b = 1; cin = 1;
        #10;
        
        // Test Case 5: a=1, b=0, cin=0
        a = 1; b = 0; cin = 0;
        #10;
        
        // Test Case 6: a=1, b=0, cin=1
        a = 1; b = 0; cin = 1;
        #10;
        
        // Test Case 7: a=1, b=1, cin=0
        a = 1; b = 1; cin = 0;
        #10;
        
        // Test Case 8: a=1, b=1, cin=1
        a = 1; b = 1; cin = 1;
        #10;
        
        $finish;
    end
    
    initial begin
        $monitor(""Time=%0t a=%b b=%b cin=%b sum=%b cout=%b"", 
                 $time, a, b, cin, sum, cout);
    end
endmodule",True,71,True,True,True,False,0.4,False,4.847132444381714,9.564024925231934,tie,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,Combinational,simple,"Design a 2-bit comparator with inputs a[1:0], b[1:0] and outputs eq, gt, lt. Include testbench.",claude,"`timescale 1ns/1ps

module comparator(
    input wire [1:0] a,
    input wire [1:0] b,
    output reg eq,
    output reg gt,
    output reg lt
);

always @(*) begin
    eq = (a == b);
    gt = (a > b);
    lt = (a < b);
end

endmodule

module testbench;
    reg [1:0] a, b;
    wire eq, gt, lt;
    
    comparator dut (
        .a(a),
        .b(b),
        .eq(eq),
        .gt(gt),
        .lt(lt)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        a = 2'b00; b = 2'b00; #10;
        a = 2'b01; b = 2'b00; #10;
        a = 2'b10; b = 2'b11; #10;
        a = 2'b11; b = 2'b01; #10;
        a = 2'b01; b = 2'b01; #10;
        a = 2'b10; b = 2'b00; #10;
        a = 2'b00; b = 2'b11; #10;
        
        $finish;
    end
    
    initial begin
        $monitor(""Time=%0t a=%b b=%b eq=%b gt=%b lt=%b"", 
                 $time, a, b, eq, gt, lt);
    end
endmodule",True,50,True,True,True,False,0.4,False,5.228578567504883,7.349059820175171,"graph LR
    A0[a0] --> COMP((2-bit</br>Comparator</br>Logic))
    A1[a1] --> COMP
    B0[b0] --> COMP
    B1[b1] --> COMP
    COMP --> EQ[eq]
    COMP --> GT[gt]
    COMP --> LT[lt]
    TB[Testbench] --> |Test Vectors| COMP
    TB --> |Expected Values| VAL{Validation}
    COMP --> |Actual Values| VAL
    VAL --> RES[Test Results]
    CLK[Clock] --> TB
    RST[Reset] --> TB","`timescale 1ns/1ps

module comparator_2bit (
    input wire a0,
    input wire a1, 
    input wire b0,
    input wire b1,
    input wire clk,
    input wire rst_n,
    output reg eq,
    output reg gt,
    output reg lt
);

always @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
        eq <= 1'b0;
        gt <= 1'b0;
        lt <= 1'b0;
    end
    else begin
        eq <= (a1 == b1) && (a0 == b0);
        gt <= (a1 > b1) || ((a1 == b1) && (a0 > b0));
        lt <= (a1 < b1) || ((a1 == b1) && (a0 < b0));
    end
end

endmodule

module testbench;
    reg clk, rst_n;
    reg a0, a1, b0, b1;
    wire eq, gt, lt;
    
    comparator_2bit dut (
        .a0(a0),
        .a1(a1),
        .b0(b0),
        .b1(b1),
        .clk(clk),
        .rst_n(rst_n),
        .eq(eq),
        .gt(gt),
        .lt(lt)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 0;
        rst_n = 0;
        a0 = 0; a1 = 0;
        b0 = 0; b1 = 0;
        
        #10 rst_n = 1;
        
        // Test vector 1: A = B
        #10 a1 = 0; a0 = 0; b1 = 0; b0 = 0;
        
        // Test vector 2: A > B
        #10 a1 = 1; a0 = 1; b1 = 0; b0 = 1;
        
        // Test vector 3: A < B
        #10 a1 = 0; a0 = 1; b1 = 1; b0 = 0;
        
        #20 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t rst_n=%b a=%b%b b=%b%b eq=%b gt=%b lt=%b"",
                 $time, rst_n, a1, a0, b1, b0, eq, gt, lt);
    end
endmodule",True,76,True,True,True,False,0.4,False,11.52103042602539,5.702106475830078,"Design a 2-bit comparator with inputs a[1:0], b[1:0] and outputs eq, gt, lt. Include testbench.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph LR
    A0[a0] --> COMP((2-bit</br>Comparator</br>Logic))
    A1[a1] --> COMP
    B0[b0] --> COMP
    B1[b1] --> COMP
    COMP --> EQ[eq]
    COMP --> GT[gt]
    COMP --> LT[lt]
    TB[Testbench] --> |Test Vectors| COMP
    TB --> |Expected Values| VAL{Validation}
    COMP --> |Actual Values| VAL
    VAL --> RES[Test Results]
    CLK[Clock] --> TB
    RST[Reset] --> TB
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module comparator(
    input wire [1:0] a,
    input wire [1:0] b,
    output wire eq,
    output wire gt,
    output wire lt
);

assign eq = (a == b);
assign gt = (a > b);
assign lt = (a < b);

endmodule

module testbench;
    reg clk;
    reg rst_n;
    reg [1:0] a;
    reg [1:0] b;
    wire eq, gt, lt;
    
    comparator dut (
        .a(a),
        .b(b),
        .eq(eq),
        .gt(gt),
        .lt(lt)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 0;
        rst_n = 0;
        a = 2'b00;
        b = 2'b00;
        
        #10 rst_n = 1;
        
        // Test vector 1: a = b
        #10 a = 2'b01; b = 2'b01;
        
        // Test vector 2: a > b
        #10 a = 2'b10; b = 2'b01;
        
        // Test vector 3: a < b
        #10 a = 2'b01; b = 2'b11;
        
        // Test all combinations
        #10 a = 2'b00; b = 2'b00;
        #10 a = 2'b00; b = 2'b01;
        #10 a = 2'b00; b = 2'b10;
        #10 a = 2'b00; b = 2'b11;
        #10 a = 2'b01; b = 2'b00;
        #10 a = 2'b10; b = 2'b00;
        #10 a = 2'b11; b = 2'b00;
        
        #10 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t rst_n=%b a=%b b=%b eq=%b gt=%b lt=%b"",
                 $time, rst_n, a, b, eq, gt, lt);
    end
endmodule",True,70,True,True,True,False,0.4,False,7.294130563735962,7.150152206420898,tie,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,Combinational,simple,"Design a 2-bit comparator with inputs a[1:0], b[1:0] and outputs eq, gt, lt. Include testbench.",gpt-4o,"`timescale 1ns/1ps

module comparator(
    input wire [1:0] a,
    input wire [1:0] b,
    output reg eq,
    output reg gt,
    output reg lt
);

always @(*) begin
    if (a == b) begin
        eq = 1'b1;
        gt = 1'b0;
        lt = 1'b0;
    end else if (a > b) begin
        eq = 1'b0;
        gt = 1'b1;
        lt = 1'b0;
    end else begin
        eq = 1'b0;
        gt = 1'b0;
        lt = 1'b1;
    end
end

endmodule

module testbench;
    reg [1:0] a, b;
    wire eq, gt, lt;
    
    comparator dut (
        .a(a),
        .b(b),
        .eq(eq),
        .gt(gt),
        .lt(lt)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        a = 2'b00; b = 2'b00;
        #10 a = 2'b01; b = 2'b00;
        #10 a = 2'b10; b = 2'b11;
        #10 a = 2'b11; b = 2'b10;
        #10 a = 2'b01; b = 2'b01;
        #10 $finish;
    end
    
    initial begin
        $monitor(""Time=%0t a=%b b=%b eq=%b gt=%b lt=%b"", 
                 $time, a, b, eq, gt, lt);
    end
endmodule",True,57,True,True,True,False,0.4,False,4.449105262756348,10.639408826828003,"graph TD
    A[a[1:0]] --> COMP(2-bit Comparator)
    B[b[1:0]] --> COMP
    COMP --> EQ[eq: Equal]
    COMP --> GT[gt: Greater Than]
    COMP --> LT[lt: Less Than]

    subgraph Testbench
        CLK[Clock] --> TB
        RST[Reset] --> TB
        TB[Testing Block] --> A
        TB --> B
        EQ --> TB
        GT --> TB
        LT --> TB
    end","`timescale 1ns/1ps

module comparator_2bit(
    input wire [1:0] a,
    input wire [1:0] b,
    output reg eq,
    output reg gt,
    output reg lt
);

always @(*) begin
    eq = (a == b);
    gt = (a > b);
    lt = (a < b);
end

endmodule

module testbench;
    reg clk, rst;
    reg [1:0] a, b;
    wire eq, gt, lt;
    
    comparator_2bit comp (
        .a(a),
        .b(b),
        .eq(eq),
        .gt(gt),
        .lt(lt)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst = 1'b0;
        a = 2'b00;
        b = 2'b00;
        
        #20 rst = 1'b1;
        #10 a = 2'b01; b = 2'b10;
        #10 a = 2'b11; b = 2'b10;
        #10 a = 2'b10; b = 2'b10;
        #10 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t clk=%b rst=%b a=%b b=%b eq=%b gt=%b lt=%b"", 
                 $time, clk, rst, a, b, eq, gt, lt);
    end
endmodule",True,54,True,True,True,False,0.4,False,8.180170059204102,7.238549709320068,"Design a 2-bit comparator with inputs a[1:0], b[1:0] and outputs eq, gt, lt. Include testbench.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph TD
    A[a[1:0]] --> COMP(2-bit Comparator)
    B[b[1:0]] --> COMP
    COMP --> EQ[eq: Equal]
    COMP --> GT[gt: Greater Than]
    COMP --> LT[lt: Less Than]

    subgraph Testbench
        CLK[Clock] --> TB
        RST[Reset] --> TB
        TB[Testing Block] --> A
        TB --> B
        EQ --> TB
        GT --> TB
        LT --> TB
    end
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module comparator_2bit(
    input wire [1:0] a,
    input wire [1:0] b,
    output reg eq,
    output reg gt,
    output reg lt
);

always @(*) begin
    if (a == b) begin
        eq = 1'b1;
        gt = 1'b0;
        lt = 1'b0;
    end else if (a > b) begin
        eq = 1'b0;
        gt = 1'b1;
        lt = 1'b0;
    end else begin
        eq = 1'b0;
        gt = 1'b0;
        lt = 1'b1;
    end
end

endmodule

module testbench;
    reg [1:0] a, b;
    wire eq, gt, lt;
    reg clk, rst;

    comparator_2bit uut (
        .a(a),
        .b(b),
        .eq(eq),
        .gt(gt),
        .lt(lt)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 1'b0;
        rst = 1'b0;
        a = 2'b00;
        b = 2'b00;
        
        #10 rst = 1'b1;
        #10 a = 2'b01; b = 2'b00;
        #10 a = 2'b10; b = 2'b10;
        #10 a = 2'b11; b = 2'b01;
        #10 a = 2'b00; b = 2'b11;
        #10 a = 2'b10; b = 2'b01;
        #10 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t a=%b b=%b eq=%b gt=%b lt=%b"", 
                 $time, a, b, eq, gt, lt);
    end
endmodule",True,66,True,True,True,False,0.4,False,5.849772691726685,8.147460222244263,tie,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,Arithmetic,medium,"Design a 4-bit ALU supporting ADD, SUB, AND, OR operations. Inputs: a[3:0], b[3:0], op[1:0]. Outputs: result[3:0], zero. Include testbench.",claude,"`timescale 1ns/1ps

module alu(
    input wire [3:0] a,
    input wire [3:0] b,
    input wire [1:0] op,
    output reg [3:0] result,
    output wire zero
);

assign zero = (result == 4'b0000);

always @(*) begin
    case(op)
        2'b00: result = a + b;    // ADD
        2'b01: result = a - b;    // SUB
        2'b10: result = a & b;    // AND
        2'b11: result = a | b;    // OR
        default: result = 4'b0000;
    endcase
end

endmodule

module testbench;
    reg [3:0] a, b;
    reg [1:0] op;
    wire [3:0] result;
    wire zero;

    alu dut(
        .a(a),
        .b(b),
        .op(op),
        .result(result),
        .zero(zero)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        // Test ADD
        a = 4'b0011; b = 4'b0010; op = 2'b00;
        #10;

        // Test SUB
        a = 4'b0111; b = 4'b0011; op = 2'b01;
        #10;

        // Test AND
        a = 4'b1100; b = 4'b1010; op = 2'b10;
        #10;

        // Test OR
        a = 4'b1100; b = 4'b0011; op = 2'b11;
        #10;

        // Test zero flag
        a = 4'b0000; b = 4'b0000; op = 2'b00;
        #10;

        $finish;
    end

    initial begin
        $monitor(""Time=%0t a=%b b=%b op=%b result=%b zero=%b"", 
                 $time, a, b, op, result, zero);
    end
endmodule",True,70,True,True,True,False,0.4,False,6.6575891971588135,6.8582000732421875,"graph LR
    A[a 3:0] --> ALU((ALU Core))
    B[b 3:0] --> ALU
    OP[op 1:0] --> CTRL((Control Unit))
    CTRL --> ALU
    ALU --> RES[result 3:0]
    ALU --> ZERO{Zero Detect}
    ZERO --> Z[zero]
    TB[[TestBench]] --> A
    TB --> B
    TB --> OP
    RES --> TB
    Z --> TB
    CLK[Clock] --> TB
    RST[Reset] --> TB
    CLK --> ALU
    RST --> ALU
    subgraph Operations
    ADD[ADD]
    SUB[SUB]
    AND[AND]
    OR[OR]
    end
    Operations -.-> ALU","`timescale 1ns/1ps

module alu(
    input wire clk,
    input wire rst,
    input wire [3:0] a,
    input wire [3:0] b,
    input wire [1:0] op,
    output reg [3:0] result,
    output wire zero
);

reg [3:0] alu_out;

always @(posedge clk or posedge rst) begin
    if (rst)
        result <= 4'b0000;
    else
        result <= alu_out;
end

always @(*) begin
    case (op)
        2'b00: alu_out = a + b;    // ADD
        2'b01: alu_out = a - b;    // SUB
        2'b10: alu_out = a & b;    // AND
        2'b11: alu_out = a | b;    // OR
        default: alu_out = 4'b0000;
    endcase
end

assign zero = (result == 4'b0000);

endmodule

module testbench;
    reg clk;
    reg rst;
    reg [3:0] a;
    reg [3:0] b;
    reg [1:0] op;
    wire [3:0] result;
    wire zero;

    alu dut (
        .clk(clk),
        .rst(rst),
        .a(a),
        .b(b),
        .op(op),
        .result(result),
        .zero(zero)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 0;
        rst = 1;
        a = 0;
        b = 0;
        op = 0;

        #10 rst = 0;

        // Test ADD
        #10 a = 4'h3; b = 4'h2; op = 2'b00;
        
        // Test SUB
        #10 a = 4'h5; b = 4'h3; op = 2'b01;
        
        // Test AND
        #10 a = 4'h7; b = 4'h3; op = 2'b10;
        
        // Test OR
        #10 a = 4'h5; b = 4'h2; op = 2'b11;
        
        // Test zero detection
        #10 a = 4'h0; b = 4'h0; op = 2'b00;

        #10 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t rst=%b a=%h b=%h op=%b result=%h zero=%b"",
                 $time, rst, a, b, op, result, zero);
    end
endmodule",True,91,True,True,True,False,0.4,False,12.065590858459473,7.8519978523254395,"Design a 4-bit ALU supporting ADD, SUB, AND, OR operations. Inputs: a[3:0], b[3:0], op[1:0]. Outputs: result[3:0], zero. Include testbench.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph LR
    A[a 3:0] --> ALU((ALU Core))
    B[b 3:0] --> ALU
    OP[op 1:0] --> CTRL((Control Unit))
    CTRL --> ALU
    ALU --> RES[result 3:0]
    ALU --> ZERO{Zero Detect}
    ZERO --> Z[zero]
    TB[[TestBench]] --> A
    TB --> B
    TB --> OP
    RES --> TB
    Z --> TB
    CLK[Clock] --> TB
    RST[Reset] --> TB
    CLK --> ALU
    RST --> ALU
    subgraph Operations
    ADD[ADD]
    SUB[SUB]
    AND[AND]
    OR[OR]
    end
    Operations -.-> ALU
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module alu_core(
    input wire clk,
    input wire rst,
    input wire [3:0] a,
    input wire [3:0] b,
    input wire [1:0] op_ctrl,
    output reg [3:0] result,
    output wire zero
);

    always @(posedge clk or posedge rst) begin
        if (rst) 
            result <= 4'b0000;
        else begin
            case (op_ctrl)
                2'b00: result <= a + b;    // ADD
                2'b01: result <= a - b;    // SUB
                2'b10: result <= a & b;    // AND
                2'b11: result <= a | b;    // OR
            endcase
        end
    end

    assign zero = (result == 4'b0000);

endmodule

module testbench;
    reg clk;
    reg rst;
    reg [3:0] a;
    reg [3:0] b;
    reg [1:0] op;
    wire [3:0] result;
    wire zero;

    alu_core dut (
        .clk(clk),
        .rst(rst),
        .a(a),
        .b(b),
        .op_ctrl(op),
        .result(result),
        .zero(zero)
    );

    initial begin
        $dumpfile(""alu.vcd"");
        $dumpvars(0, testbench);

        clk = 0;
        rst = 1;
        a = 0;
        b = 0;
        op = 0;

        #10 rst = 0;

        // Test ADD
        #10 a = 4'b0011; b = 4'b0010; op = 2'b00;
        
        // Test SUB
        #10 a = 4'b0111; b = 4'b0011; op = 2'b01;
        
        // Test AND
        #10 a = 4'b1100; b = 4'b1010; op = 2'b10;
        
        // Test OR
        #10 a = 4'b1100; b = 4'b0011; op = 2'b11;
        
        // Test zero detection
        #10 a = 4'b0000; b = 4'b0000; op = 2'b00;

        #10 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t rst=%b a=%b b=%b op=%b result=%b zero=%b"",
                 $time, rst, a, b, op, result, zero);
    end
endmodule",True,85,True,True,True,,0.0,,8.625008583068848,0.01375126838684082,tie,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,Arithmetic,medium,"Design a 4-bit ALU supporting ADD, SUB, AND, OR operations. Inputs: a[3:0], b[3:0], op[1:0]. Outputs: result[3:0], zero. Include testbench.",gpt-4o,"`timescale 1ns/1ps

module alu(
    input wire [3:0] a,
    input wire [3:0] b,
    input wire [1:0] op,
    output reg [3:0] result,
    output wire zero
);

always @(*) begin
    case (op)
        2'b00: result = a + b;
        2'b01: result = a - b;
        2'b10: result = a & b;
        2'b11: result = a | b;
        default: result = 4'b0000;
    endcase
end

assign zero = (result == 4'b0000);

endmodule

module testbench;
    reg [3:0] a, b;
    reg [1:0] op;
    wire [3:0] result;
    wire zero;
    
    alu dut (
        .a(a),
        .b(b),
        .op(op),
        .result(result),
        .zero(zero)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        a = 4'b0000; b = 4'b0000; op = 2'b00;
        #10 a = 4'b0101; b = 4'b0011; op = 2'b00; // ADD
        #10 a = 4'b0101; b = 4'b0011; op = 2'b01; // SUB
        #10 a = 4'b0101; b = 4'b0011; op = 2'b10; // AND
        #10 a = 4'b0101; b = 4'b0011; op = 2'b11; // OR
        #10 a = 4'b1111; b = 4'b1111; op = 2'b00; // ADD to zero
        #10 $finish;
    end
    
    initial begin
        $monitor(""Time=%0t a=%b b=%b op=%b result=%b zero=%b"", 
                 $time, a, b, op, result, zero);
    end
endmodule",True,56,True,True,True,False,0.4,False,7.382983684539795,14.389588594436646,"graph LR
    subgraph ALU
        A[a[3:0]] --> ADD
        B[b[3:0]] --> ADD
        A --> SUB
        B --> SUB
        A --> AND
        B --> AND
        A --> OR
        B --> OR
        OP[op[1:0]] --> MUX{Operation Select}
        ADD(ADD) --> MUX
        SUB(SUB) --> MUX
        AND(AND) --> MUX
        OR(OR) --> MUX
        MUX --> RESULT[result[3:0]]
    end
    
    RESULT --> ZERO{Zero Check}
    ZERO --> Z[zero]

    subgraph Testbench
        CLK[Clock]
        RST[Reset]
        CLK --> ALU
        RST --> ALU
    end","`timescale 1ns/1ps

module alu(
    input wire clk,
    input wire rst_n,
    input wire [3:0] a,
    input wire [3:0] b,
    input wire [1:0] op,
    output reg [3:0] result,
    output reg zero
);

    reg [3:0] add, sub, and_op, or_op;

    always @(*) begin
        add = a + b;
        sub = a - b;
        and_op = a & b;
        or_op = a | b;
    end

    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            result <= 4'b0000;
            zero <= 1'b0;
        end else begin
            case(op)
                2'b00: result <= add;
                2'b01: result <= sub;
                2'b10: result <= and_op;
                2'b11: result <= or_op;
                default: result <= 4'b0000;
            endcase
            zero <= (result == 4'b0000);
        end
    end

endmodule

module testbench;
    reg clk, rst_n;
    reg [3:0] a, b;
    reg [1:0] op;
    wire [3:0] result;
    wire zero;
    
    alu dut (
        .clk(clk),
        .rst_n(rst_n),
        .a(a),
        .b(b),
        .op(op),
        .result(result),
        .zero(zero)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst_n = 1'b0;
        a = 4'b0000;
        b = 4'b0000;
        op = 2'b00;
        
        #20 rst_n = 1'b1;
        #10 a = 4'b0011;
        b = 4'b0001;
        op = 2'b00; // ADD
        #10 op = 2'b01; // SUB
        #10 op = 2'b10; // AND
        #10 op = 2'b11; // OR
        #50 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b a=%b b=%b op=%b result=%b zero=%b"", 
                 $time, clk, rst_n, a, b, op, result, zero);
    end
endmodule",True,83,True,True,True,True,0.7,True,13.517232656478882,16.77454400062561,"Design a 4-bit ALU supporting ADD, SUB, AND, OR operations. Inputs: a[3:0], b[3:0], op[1:0]. Outputs: result[3:0], zero. Include testbench.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph LR
    subgraph ALU
        A[a[3:0]] --> ADD
        B[b[3:0]] --> ADD
        A --> SUB
        B --> SUB
        A --> AND
        B --> AND
        A --> OR
        B --> OR
        OP[op[1:0]] --> MUX{Operation Select}
        ADD(ADD) --> MUX
        SUB(SUB) --> MUX
        AND(AND) --> MUX
        OR(OR) --> MUX
        MUX --> RESULT[result[3:0]]
    end
    
    RESULT --> ZERO{Zero Check}
    ZERO --> Z[zero]

    subgraph Testbench
        CLK[Clock]
        RST[Reset]
        CLK --> ALU
        RST --> ALU
    end
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module alu(
    input wire clk,
    input wire rst,
    input wire [3:0] a,
    input wire [3:0] b,
    input wire [1:0] op,
    output reg [3:0] result,
    output reg zero
);

wire [3:0] add_res, sub_res, and_res, or_res;

// Operations
assign add_res = a + b;
assign sub_res = a - b;
assign and_res = a & b;
assign or_res  = a | b;

always @(posedge clk or posedge rst) begin
    if (rst) begin
        result <= 4'b0000;
        zero <= 1'b0;
    end else begin
        case (op)
            2'b00: result <= add_res;
            2'b01: result <= sub_res;
            2'b10: result <= and_res;
            2'b11: result <= or_res;
            default: result <= 4'b0000;
        endcase
        zero <= (result == 4'b0000);
    end
end

endmodule

module testbench;
    reg clk, rst;
    reg [3:0] a, b;
    reg [1:0] op;
    wire [3:0] result;
    wire zero;

    alu dut (
        .clk(clk),
        .rst(rst),
        .a(a),
        .b(b),
        .op(op),
        .result(result),
        .zero(zero)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 1'b0;
        rst = 1'b1;
        a = 4'b0000;
        b = 4'b0000;
        op = 2'b00;

        #20 rst = 1'b0;
        #10 a = 4'b0011; b = 4'b0001; op = 2'b00; // ADD
        #10 a = 4'b0100; b = 4'b0010; op = 2'b01; // SUB
        #10 a = 4'b1100; b = 4'b1010; op = 2'b10; // AND
        #10 a = 4'b1100; b = 4'b0011; op = 2'b11; // OR
        #10 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t clk=%b rst=%b a=%b b=%b op=%b result=%b zero=%b"", 
                 $time, clk, rst, a, b, op, result, zero);
    end
endmodule",True,80,True,True,True,False,0.3,False,9.503697872161865,13.783411026000977,tie,prompt_only > combined > mermaid_only,prompt_only > mermaid_only > combined
combined,Combinational,medium,"Create an 8:1 multiplexer with input data[7:0], select sel[2:0], and output out. Include testbench.",claude,"`timescale 1ns/1ps

module mux8to1(
    input wire [7:0] data,
    input wire [2:0] sel,
    output reg out
);

always @(*) begin
    case (sel)
        3'b000: out = data[0];
        3'b001: out = data[1];
        3'b010: out = data[2];
        3'b011: out = data[3];
        3'b100: out = data[4];
        3'b101: out = data[5];
        3'b110: out = data[6];
        3'b111: out = data[7];
        default: out = 1'b0;
    endcase
end

endmodule

module testbench;
    reg [7:0] data;
    reg [2:0] sel;
    wire out;

    mux8to1 dut (
        .data(data),
        .sel(sel),
        .out(out)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        data = 8'b10101010;
        
        sel = 3'b000; #10;
        sel = 3'b001; #10;
        sel = 3'b010; #10;
        sel = 3'b011; #10;
        sel = 3'b100; #10;
        sel = 3'b101; #10;
        sel = 3'b110; #10;
        sel = 3'b111; #10;

        data = 8'b11110000;
        
        sel = 3'b000; #10;
        sel = 3'b111; #10;

        $finish;
    end

    initial begin
        $monitor(""Time=%0t data=%b sel=%b out=%b"", 
                 $time, data, sel, out);
    end
endmodule",True,63,True,True,True,False,0.4,False,5.953415155410767,7.1357951164245605,"graph LR
    D0[data0] --> MUX{8:1 MUX}
    D1[data1] --> MUX
    D2[data2] --> MUX
    D3[data3] --> MUX
    D4[data4] --> MUX
    D5[data5] --> MUX
    D6[data6] --> MUX
    D7[data7] --> MUX
    S0[sel0] --> MUX
    S1[sel1] --> MUX
    S2[sel2] --> MUX
    MUX --> OUT[out]
    TB[[Testbench]]
    TB --> D0
    TB --> D1
    TB --> D2
    TB --> D3
    TB --> D4
    TB --> D5
    TB --> D6
    TB --> D7
    TB --> S0
    TB --> S1
    TB --> S2
    OUT --> TB","`timescale 1ns/1ps

module mux8(
    input wire clk,
    input wire rst_n,
    input wire [7:0] data0,
    input wire [7:0] data1,
    input wire [7:0] data2,
    input wire [7:0] data3,
    input wire [7:0] data4,
    input wire [7:0] data5,
    input wire [7:0] data6,
    input wire [7:0] data7,
    input wire [2:0] sel,
    output reg [7:0] out
);

always @(posedge clk or negedge rst_n) begin
    if (!rst_n)
        out <= 8'h00;
    else
        case (sel)
            3'b000: out <= data0;
            3'b001: out <= data1;
            3'b010: out <= data2;
            3'b011: out <= data3;
            3'b100: out <= data4;
            3'b101: out <= data5;
            3'b110: out <= data6;
            3'b111: out <= data7;
            default: out <= 8'h00;
        endcase
end

endmodule

module testbench;
    reg clk, rst_n;
    reg [7:0] data0, data1, data2, data3, data4, data5, data6, data7;
    reg [2:0] sel;
    wire [7:0] out;
    
    mux8 dut (
        .clk(clk),
        .rst_n(rst_n),
        .data0(data0),
        .data1(data1),
        .data2(data2),
        .data3(data3),
        .data4(data4),
        .data5(data5),
        .data6(data6),
        .data7(data7),
        .sel(sel),
        .out(out)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 0;
        rst_n = 0;
        data0 = 8'h11;
        data1 = 8'h22;
        data2 = 8'h33;
        data3 = 8'h44;
        data4 = 8'h55;
        data5 = 8'h66;
        data6 = 8'h77;
        data7 = 8'h88;
        sel = 3'b000;
        
        #10 rst_n = 1;
        
        #10 sel = 3'b001;
        #10 sel = 3'b010;
        #10 sel = 3'b011;
        #10 sel = 3'b100;
        #10 sel = 3'b101;
        #10 sel = 3'b110;
        #10 sel = 3'b111;
        
        #10 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t rst_n=%b sel=%b out=%h"", 
                 $time, rst_n, sel, out);
    end
endmodule",True,93,True,True,True,False,0.4,False,12.267879009246826,9.122286081314087,"Create an 8:1 multiplexer with input data[7:0], select sel[2:0], and output out. Include testbench.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph LR
    D0[data0] --> MUX{8:1 MUX}
    D1[data1] --> MUX
    D2[data2] --> MUX
    D3[data3] --> MUX
    D4[data4] --> MUX
    D5[data5] --> MUX
    D6[data6] --> MUX
    D7[data7] --> MUX
    S0[sel0] --> MUX
    S1[sel1] --> MUX
    S2[sel2] --> MUX
    MUX --> OUT[out]
    TB[[Testbench]]
    TB --> D0
    TB --> D1
    TB --> D2
    TB --> D3
    TB --> D4
    TB --> D5
    TB --> D6
    TB --> D7
    TB --> S0
    TB --> S1
    TB --> S2
    OUT --> TB
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module mux8to1 (
    input wire [7:0] data,
    input wire [2:0] sel,
    output reg out
);

always @(*) begin
    case (sel)
        3'b000: out = data[0];
        3'b001: out = data[1];
        3'b010: out = data[2];
        3'b011: out = data[3];
        3'b100: out = data[4];
        3'b101: out = data[5];
        3'b110: out = data[6];
        3'b111: out = data[7];
        default: out = 1'b0;
    endcase
end

endmodule

module testbench;
    reg [7:0] data;
    reg [2:0] sel;
    wire out;
    
    mux8to1 dut (
        .data(data),
        .sel(sel),
        .out(out)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        // Test all combinations
        data = 8'b10101010;
        sel = 3'b000;
        #10;
        
        sel = 3'b001;
        #10;
        
        sel = 3'b010;
        #10;
        
        sel = 3'b011;
        #10;
        
        data = 8'b01010101;
        sel = 3'b100;
        #10;
        
        sel = 3'b101;
        #10;
        
        sel = 3'b110;
        #10;
        
        sel = 3'b111;
        #10;
        
        $finish;
    end
    
    initial begin
        $monitor(""Time=%0t data=%b sel=%b out=%b"", 
                 $time, data, sel, out);
    end
endmodule",True,74,True,True,True,False,0.4,False,6.100790500640869,6.357023239135742,tie,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,Combinational,medium,"Create an 8:1 multiplexer with input data[7:0], select sel[2:0], and output out. Include testbench.",gpt-4o,"`timescale 1ns/1ps

module mux8to1(
    input wire [7:0] data,
    input wire [2:0] sel,
    output reg out
);

always @(*) begin
    case (sel)
        3'b000: out = data[0];
        3'b001: out = data[1];
        3'b010: out = data[2];
        3'b011: out = data[3];
        3'b100: out = data[4];
        3'b101: out = data[5];
        3'b110: out = data[6];
        3'b111: out = data[7];
        default: out = 1'b0;
    endcase
end

endmodule

module testbench;
    reg [7:0] data;
    reg [2:0] sel;
    wire out;

    mux8to1 dut (
        .data(data),
        .sel(sel),
        .out(out)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        data = 8'b10101010;
        sel = 3'b000;
        
        #10 sel = 3'b001;
        #10 sel = 3'b010;
        #10 sel = 3'b011;
        #10 sel = 3'b100;
        #10 sel = 3'b101;
        #10 sel = 3'b110;
        #10 sel = 3'b111;
        #10 $finish;
    end

    initial begin
        $monitor(""Time=%0t sel=%b out=%b"", 
                 $time, sel, out);
    end
endmodule",True,57,True,True,True,False,0.4,False,4.56570291519165,12.650835752487183,"graph LR
    IN0[data[0]] --> MUX{8:1 MUX}
    IN1[data[1]] --> MUX
    IN2[data[2]] --> MUX
    IN3[data[3]] --> MUX
    IN4[data[4]] --> MUX
    IN5[data[5]] --> MUX
    IN6[data[6]] --> MUX
    IN7[data[7]] --> MUX
    SEL[sel[2:0]] --> MUX
    MUX --> OUT[out]
    TB[Testbench]
    TB --> IN0
    TB --> IN1
    TB --> IN2
    TB --> IN3
    TB --> IN4
    TB --> IN5
    TB --> IN6
    TB --> IN7
    TB --> SEL
    OUT --> TB","`timescale 1ns/1ps

module mux_8to1(
    input wire [7:0] data,
    input wire [2:0] sel,
    output reg out
);

always @(*) begin
    case (sel)
        3'b000: out = data[0];
        3'b001: out = data[1];
        3'b010: out = data[2];
        3'b011: out = data[3];
        3'b100: out = data[4];
        3'b101: out = data[5];
        3'b110: out = data[6];
        3'b111: out = data[7];
        default: out = 1'b0;
    endcase
end

endmodule

module testbench;
    reg [7:0] data;
    reg [2:0] sel;
    wire out;
    
    mux_8to1 dut (
        .data(data),
        .sel(sel),
        .out(out)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        data = 8'b10101010;
        
        sel = 3'b000;
        #10 sel = 3'b001;
        #10 sel = 3'b010;
        #10 sel = 3'b011;
        #10 sel = 3'b100;
        #10 sel = 3'b101;
        #10 sel = 3'b110;
        #10 sel = 3'b111;
        #10 $finish;
    end
    
    initial begin
        $monitor(""Time=%0t sel=%b out=%b"", $time, sel, out);
    end
endmodule",True,56,True,True,True,False,0.4,False,7.471491813659668,8.269002199172974,"Create an 8:1 multiplexer with input data[7:0], select sel[2:0], and output out. Include testbench.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph LR
    IN0[data[0]] --> MUX{8:1 MUX}
    IN1[data[1]] --> MUX
    IN2[data[2]] --> MUX
    IN3[data[3]] --> MUX
    IN4[data[4]] --> MUX
    IN5[data[5]] --> MUX
    IN6[data[6]] --> MUX
    IN7[data[7]] --> MUX
    SEL[sel[2:0]] --> MUX
    MUX --> OUT[out]
    TB[Testbench]
    TB --> IN0
    TB --> IN1
    TB --> IN2
    TB --> IN3
    TB --> IN4
    TB --> IN5
    TB --> IN6
    TB --> IN7
    TB --> SEL
    OUT --> TB
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module mux_8_to_1 (
    input wire [7:0] data,
    input wire [2:0] sel,
    output reg out
);

always @(*) begin
    case (sel)
        3'b000: out = data[0];
        3'b001: out = data[1];
        3'b010: out = data[2];
        3'b011: out = data[3];
        3'b100: out = data[4];
        3'b101: out = data[5];
        3'b110: out = data[6];
        3'b111: out = data[7];
        default: out = 1'b0;
    endcase
end

endmodule

module testbench;
    reg [7:0] data;
    reg [2:0] sel;
    wire out;
    
    mux_8_to_1 dut (
        .data(data),
        .sel(sel),
        .out(out)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        data = 8'b10101010;
        sel = 3'b000;
        
        #10 sel = 3'b001;
        #10 sel = 3'b010;
        #10 sel = 3'b011;
        #10 sel = 3'b100;
        #10 sel = 3'b101;
        #10 sel = 3'b110;
        #10 sel = 3'b111;
        #10 $finish;
    end
    
    initial begin
        $monitor(""Time=%0t data=%b sel=%b out=%b"", $time, data, sel, out);
    end
endmodule",True,56,True,True,True,False,0.4,False,5.329829931259155,15.237529993057251,tie,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,State Machine,medium,Design an FSM detecting pattern 1011 in serial input with overlapping detection. Include testbench with sequence: 10110111011.,claude,"`timescale 1ns/1ps

module pattern_detect(
    input wire clk,
    input wire rst_n,
    input wire data_in,
    output reg pattern_found
);

reg [2:0] state, next_state;
parameter S0 = 3'b000,
          S1 = 3'b001,
          S2 = 3'b010,
          S3 = 3'b011,
          S4 = 3'b100;

always @(posedge clk or negedge rst_n) begin
    if (!rst_n)
        state <= S0;
    else
        state <= next_state;
end

always @(*) begin
    case (state)
        S0: next_state = (data_in) ? S1 : S0;
        S1: next_state = (data_in) ? S1 : S2;
        S2: next_state = (data_in) ? S3 : S0;
        S3: next_state = (data_in) ? S4 : S2;
        S4: next_state = (data_in) ? S1 : S2;
        default: next_state = S0;
    endcase
end

always @(posedge clk or negedge rst_n) begin
    if (!rst_n)
        pattern_found <= 1'b0;
    else
        pattern_found <= (state == S3 && data_in == 1'b1);
end

endmodule

module testbench;
    reg clk;
    reg rst_n;
    reg data_in;
    wire pattern_found;

    pattern_detect dut (
        .clk(clk),
        .rst_n(rst_n),
        .data_in(data_in),
        .pattern_found(pattern_found)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 0;
        rst_n = 0;
        data_in = 0;
        
        #10 rst_n = 1;
        
        // Test sequence: 10110111011
        #10 data_in = 1;
        #10 data_in = 0;
        #10 data_in = 1;
        #10 data_in = 1;
        #10 data_in = 0;
        #10 data_in = 1;
        #10 data_in = 1;
        #10 data_in = 1;
        #10 data_in = 0;
        #10 data_in = 1;
        #10 data_in = 1;
        
        #20 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t rst_n=%b data_in=%b pattern_found=%b"",
                 $time, rst_n, data_in, pattern_found);
    end
endmodule",True,89,True,True,True,False,0.3,False,8.642897129058838,8.150359630584717,"graph LR
    CLK[Clock Input] --> FSM
    RST[Reset] --> FSM
    DIN[Serial Input] --> FSM
    FSM[[Pattern FSM<br/>States: S0,S1,S2,S3,S4]] --> DOUT[Pattern Detected]
    
    TB1[Testbench<br/>Input: 10110111011] --> DIN
    CLK --> TB1
    RST --> TB1
    
    STATES{State Transitions<br/>S0->S1: 1<br/>S1->S2: 0<br/>S2->S3: 1<br/>S3->S4: 1<br/>S4->S1: 1<br/>S4->S2: 0} --> FSM
    
    FSM --> CTRL[Control Logic]
    CTRL --> |Next State|FSM
    CTRL --> |Pattern Found|DOUT","`timescale 1ns/1ps

module pattern_fsm (
    input wire clk,
    input wire rst,
    input wire din,
    output reg pattern_detected
);

reg [2:0] state, next_state;
parameter S0 = 3'b000, S1 = 3'b001, S2 = 3'b010, S3 = 3'b011, S4 = 3'b100;

always @(posedge clk or posedge rst) begin
    if (rst)
        state <= S0;
    else
        state <= next_state;
end

always @(*) begin
    case (state)
        S0: next_state = (din) ? S1 : S0;
        S1: next_state = (din) ? S1 : S2;
        S2: next_state = (din) ? S3 : S0;
        S3: next_state = (din) ? S4 : S0;
        S4: next_state = (din) ? S1 : S2;
        default: next_state = S0;
    endcase
end

always @(posedge clk or posedge rst) begin
    if (rst)
        pattern_detected <= 1'b0;
    else
        pattern_detected <= (state == S4);
end

endmodule

module testbench;
    reg clk, rst, din;
    wire pattern_detected;
    
    pattern_fsm dut (
        .clk(clk),
        .rst(rst),
        .din(din),
        .pattern_detected(pattern_detected)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 0;
        rst = 1;
        din = 0;
        
        #10 rst = 0;
        
        // Test pattern: 10110111011
        #10 din = 1;
        #10 din = 0;
        #10 din = 1;
        #10 din = 1;
        #10 din = 0;
        #10 din = 1;
        #10 din = 1;
        #10 din = 1;
        #10 din = 0;
        #10 din = 1;
        #10 din = 1;
        
        #50 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t rst=%b din=%b pattern_detected=%b"", 
                 $time, rst, din, pattern_detected);
    end
endmodule",True,83,True,True,True,False,0.3,False,12.274103879928589,7.801790237426758,"Design an FSM detecting pattern 1011 in serial input with overlapping detection. Include testbench with sequence: 10110111011.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph LR
    CLK[Clock Input] --> FSM
    RST[Reset] --> FSM
    DIN[Serial Input] --> FSM
    FSM[[Pattern FSM<br/>States: S0,S1,S2,S3,S4]] --> DOUT[Pattern Detected]
    
    TB1[Testbench<br/>Input: 10110111011] --> DIN
    CLK --> TB1
    RST --> TB1
    
    STATES{State Transitions<br/>S0->S1: 1<br/>S1->S2: 0<br/>S2->S3: 1<br/>S3->S4: 1<br/>S4->S1: 1<br/>S4->S2: 0} --> FSM
    
    FSM --> CTRL[Control Logic]
    CTRL --> |Next State|FSM
    CTRL --> |Pattern Found|DOUT
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module pattern_fsm (
    input wire clk,
    input wire rst,
    input wire din,
    output reg dout
);

reg [2:0] state, next_state;
parameter S0 = 3'b000;
parameter S1 = 3'b001;
parameter S2 = 3'b010;
parameter S3 = 3'b011;
parameter S4 = 3'b100;

always @(posedge clk or posedge rst) begin
    if (rst)
        state <= S0;
    else
        state <= next_state;
end

always @(*) begin
    case (state)
        S0: next_state = (din) ? S1 : S0;
        S1: next_state = (din) ? S1 : S2;
        S2: next_state = (din) ? S3 : S0;
        S3: next_state = (din) ? S4 : S0;
        S4: next_state = (din) ? S1 : S2;
        default: next_state = S0;
    endcase
end

always @(*) begin
    dout = (state == S3 && din == 1'b1);
end

endmodule

module testbench;
    reg clk;
    reg rst;
    reg din;
    wire dout;
    
    pattern_fsm dut (
        .clk(clk),
        .rst(rst),
        .din(din),
        .dout(dout)
    );
    
    initial begin
        $dumpfile(""pattern_fsm.vcd"");
        $dumpvars(0, testbench);
        
        clk = 0;
        rst = 1;
        din = 0;
        
        #10 rst = 0;
        
        // Test sequence: 10110111011
        #10 din = 1;
        #10 din = 0;
        #10 din = 1;
        #10 din = 1;
        #10 din = 0;
        #10 din = 1;
        #10 din = 1;
        #10 din = 1;
        #10 din = 0;
        #10 din = 1;
        #10 din = 1;
        
        #20 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t rst=%b din=%b dout=%b state=%d"", 
                 $time, rst, din, dout, dut.state);
    end
endmodule",True,86,True,True,True,,0.0,,8.259543657302856,0.01557612419128418,tie,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,State Machine,medium,Design an FSM detecting pattern 1011 in serial input with overlapping detection. Include testbench with sequence: 10110111011.,gpt-4o,"`timescale 1ns/1ps

module fsm_1011_detector(
    input wire clk,
    input wire rst_n,
    input wire serial_in,
    output reg detected
);

    reg [2:0] state, next_state;

    localparam S0 = 3'b000,
               S1 = 3'b001,
               S10 = 3'b010,
               S101 = 3'b011,
               S1011 = 3'b100;

    always @(posedge clk or negedge rst_n) begin
        if (!rst_n)
            state <= S0;
        else
            state <= next_state;
    end

    always @(*) begin
        case (state)
            S0: begin
                if (serial_in)
                    next_state = S1;
                else
                    next_state = S0;
            end
            S1: begin
                if (serial_in)
                    next_state = S1;
                else
                    next_state = S10;
            end
            S10: begin
                if (serial_in)
                    next_state = S101;
                else
                    next_state = S0;
            end
            S101: begin
                if (serial_in)
                    next_state = S1011;
                else
                    next_state = S10;
            end
            S1011: begin
                if (serial_in)
                    next_state = S1;
                else
                    next_state = S10;
            end
            default: next_state = S0;
        endcase
    end

    always @(posedge clk or negedge rst_n) begin
        if (!rst_n)
            detected <= 1'b0;
        else if (state == S1011)
            detected <= 1'b1;
        else 
            detected <= 1'b0;
    end

endmodule

module testbench;
    reg clk, rst_n, serial_in;
    wire detected;

    fsm_1011_detector dut (
        .clk(clk),
        .rst_n(rst_n),
        .serial_in(serial_in),
        .detected(detected)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 1'b0;
        rst_n = 1'b0;
        serial_in = 1'b0;

        #15 rst_n = 1'b1;
        
        #10 serial_in = 1'b1; // 1
        #10 serial_in = 1'b0; // 0
        #10 serial_in = 1'b1; // 1
        #10 serial_in = 1'b1; // 1 - Detected
        #10 serial_in = 1'b0; // 0
        #10 serial_in = 1'b1; // 1
        #10 serial_in = 1'b1; // 1
        #10 serial_in = 1'b0; // 0
        #10 serial_in = 1'b1; // 1
        #10 serial_in = 1'b1; // 1 - Detected

        #20 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b serial_in=%b detected=%b"", 
                 $time, clk, rst_n, serial_in, detected);
    end
endmodule",True,113,True,True,True,True,0.7,True,12.948695421218872,11.214409828186035,"graph LR
    CLK[Clock] --> FSM
    RST[Reset] --> FSM
    IN[Serial Input] --> FSM

    subgraph FSM_Detector
        direction LR
        S0((S0)) -->|1| S1((S1))
        S0 -->|0| S0
        S1 -->|0| S2((S2))
        S1 -->|1| S1
        S2 -->|1| S3((S3))
        S2 -->|0| S0
        S3 -->|1| S4((S4))
        S3 -->|0| S2
        S4 -->|1| S1
        S4 -->|0| S2
        S4 -->|1011 Detected| OUT[Output]
    end

    FSM --> FSM_Detector
    OUT --> TB[Testbench Sequence]
    TB -->|10110111011| FSM","`timescale 1ns/1ps

module fsm_detector(
    input wire clk,
    input wire rst,
    input wire serial_in,
    output reg detected
);

    typedef enum reg [2:0] {
        S0 = 3'b000,
        S1 = 3'b001,
        S2 = 3'b010,
        S3 = 3'b011,
        S4 = 3'b100
    } state_t;

    reg [2:0] state, next_state;

    always @(posedge clk or posedge rst) begin
        if (rst)
            state <= S0;
        else
            state <= next_state;
    end

    always @* begin
        next_state = state;
        detected = 1'b0;
        case (state)
            S0: begin
                if (serial_in)
                    next_state = S1;
            end
            S1: begin
                if (!serial_in)
                    next_state = S2;
            end
            S2: begin
                if (serial_in)
                    next_state = S3;
                else
                    next_state = S0;
            end
            S3: begin
                if (serial_in)
                    next_state = S4;
                else
                    next_state = S2;
            end
            S4: begin
                if (serial_in)
                    next_state = S1;
                else
                    next_state = S2;
                detected = (serial_in == 1'b0);
            end
            default: next_state = S0;
        endcase
    end

endmodule

module testbench;
    reg clk, rst, serial_in;
    wire detected;
    
    fsm_detector dut (
        .clk(clk),
        .rst(rst),
        .serial_in(serial_in),
        .detected(detected)
    );
    
    initial begin
        $dumpfile(""fsm_dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst = 1'b1;
        serial_in = 1'b0;
        
        #10 rst = 1'b0;
        #10 serial_in = 1'b1; // Sequence: 1
        #10 serial_in = 1'b0; // Sequence: 10
        #10 serial_in = 1'b1; // Sequence: 101
        #10 serial_in = 1'b1; // Sequence: 1011 (Detected)
        #10 serial_in = 1'b0; // Reset sequence
        #10 serial_in = 1'b1; // Sequence: 1
        #10 serial_in = 1'b0; // Sequence: 10
        #10 serial_in = 1'b1; // Sequence: 101
        #10 serial_in = 1'b1; // Sequence: 1011 (Detected)
        #20 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t clk=%b rst=%b serial_in=%b detected=%b"", 
                 $time, clk, rst, serial_in, detected);
    end
endmodule",True,102,True,True,True,,0.0,,17.83914303779602,0.02296757698059082,"Design an FSM detecting pattern 1011 in serial input with overlapping detection. Include testbench with sequence: 10110111011.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph LR
    CLK[Clock] --> FSM
    RST[Reset] --> FSM
    IN[Serial Input] --> FSM

    subgraph FSM_Detector
        direction LR
        S0((S0)) -->|1| S1((S1))
        S0 -->|0| S0
        S1 -->|0| S2((S2))
        S1 -->|1| S1
        S2 -->|1| S3((S3))
        S2 -->|0| S0
        S3 -->|1| S4((S4))
        S3 -->|0| S2
        S4 -->|1| S1
        S4 -->|0| S2
        S4 -->|1011 Detected| OUT[Output]
    end

    FSM --> FSM_Detector
    OUT --> TB[Testbench Sequence]
    TB -->|10110111011| FSM
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module fsm_detector(
    input wire clk,
    input wire rst_n,
    input wire serial_in,
    output reg detected
);

reg [2:0] state, next_state;

localparam S0 = 3'b000,
           S1 = 3'b001,
           S2 = 3'b010,
           S3 = 3'b011,
           S4 = 3'b100;

always @(posedge clk or negedge rst_n) begin
    if (!rst_n)
        state <= S0;
    else
        state <= next_state;
end

always @(*) begin
    detected = 1'b0;
    case (state)
        S0: begin
            if (serial_in)
                next_state = S1;
            else
                next_state = S0;
        end
        S1: begin
            if (serial_in)
                next_state = S1;
            else
                next_state = S2;
        end
        S2: begin
            if (serial_in)
                next_state = S3;
            else
                next_state = S0;
        end
        S3: begin
            if (serial_in)
                next_state = S4;
            else
                next_state = S2;
        end
        S4: begin
            if (serial_in)
                next_state = S1;
            else
                next_state = S2;
            detected = 1'b1;
        end
        default: next_state = S0;
    endcase
end

endmodule

module testbench;
    reg clk, rst_n, serial_in;
    wire detected;
    
    fsm_detector dut (
        .clk(clk),
        .rst_n(rst_n),
        .serial_in(serial_in),
        .detected(detected)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst_n = 1'b0;
        serial_in = 1'b0;
        
        #20 rst_n = 1'b1;
        #10 serial_in = 1'b1; // 1
        #10 serial_in = 1'b0; // 0
        #10 serial_in = 1'b1; // 1
        #10 serial_in = 1'b1; // 1
        #10 serial_in = 1'b0; // 0
        #10 serial_in = 1'b1; // 1
        #10 serial_in = 1'b1; // 1
        #10 serial_in = 1'b1; // 1
        #10 serial_in = 1'b0; // 0
        #10 serial_in = 1'b1; // 1
        #10 serial_in = 1'b1; // 1
        #50 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b serial_in=%b detected=%b"", 
                 $time, clk, rst_n, serial_in, detected);
    end
endmodule",True,105,True,True,True,True,0.7,True,11.173105716705322,19.733044862747192,prompt_only,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,Sequential,medium,"Create a 4-bit PISO shift register with clock, reset, load, parallel input[3:0], and serial output. Include testbench.",claude,"`timescale 1ns/1ps

module piso_shift_register(
    input wire clk,
    input wire rst_n,
    input wire load,
    input wire [3:0] parallel_in,
    output reg serial_out
);

reg [3:0] shift_reg;

always @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
        shift_reg <= 4'b0000;
        serial_out <= 1'b0;
    end
    else begin
        if (load)
            shift_reg <= parallel_in;
        else begin
            serial_out <= shift_reg[3];
            shift_reg <= {shift_reg[2:0], 1'b0};
        end
    end
end

endmodule

module testbench;
    reg clk, rst_n, load;
    reg [3:0] parallel_in;
    wire serial_out;

    piso_shift_register dut (
        .clk(clk),
        .rst_n(rst_n),
        .load(load),
        .parallel_in(parallel_in),
        .serial_out(serial_out)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 0;
        rst_n = 0;
        load = 0;
        parallel_in = 4'b0000;

        #10 rst_n = 1;
        #10 parallel_in = 4'b1101;
        #10 load = 1;
        #10 load = 0;
        #50 parallel_in = 4'b1010;
        #10 load = 1;
        #10 load = 0;
        #50 rst_n = 0;
        #20 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t rst_n=%b load=%b parallel_in=%b serial_out=%b"", 
                 $time, rst_n, load, parallel_in, serial_out);
    end
endmodule",True,69,True,True,True,True,0.7,True,6.692584037780762,7.383948802947998,"graph TD
    CLK[Clock] --> SREG[[PISO Register]]
    RST[Reset] --> SREG
    LOAD[Load] --> SREG
    PI0[Parallel In 0] --> SREG
    PI1[Parallel In 1] --> SREG
    PI2[Parallel In 2] --> SREG
    PI3[Parallel In 3] --> SREG
    SREG --> SO[Serial Out]
    
    subgraph TB[Testbench]
        TBCLK[TB Clock Gen] --> CLK
        TBRST[TB Reset Gen] --> RST
        TBLD[TB Load Gen] --> LOAD
        TBPI[TB Parallel Data Gen] --> PI0
        TBPI --> PI1
        TBPI --> PI2
        TBPI --> PI3
        SO --> TBMON[TB Monitor]
    end","`timescale 1ns/1ps

module piso_reg (
    input wire clk,
    input wire rst,
    input wire load,
    input wire [3:0] parallel_in,
    output reg serial_out
);

reg [3:0] shift_reg;

always @(posedge clk or posedge rst) begin
    if (rst) begin
        shift_reg <= 4'b0000;
        serial_out <= 1'b0;
    end else if (load) begin
        shift_reg <= parallel_in;
        serial_out <= parallel_in[3];
    end else begin
        shift_reg <= {shift_reg[2:0], 1'b0};
        serial_out <= shift_reg[3];
    end
end

endmodule

module testbench;
    reg clk, rst, load;
    reg [3:0] parallel_in;
    wire serial_out;

    piso_reg dut (
        .clk(clk),
        .rst(rst),
        .load(load),
        .parallel_in(parallel_in),
        .serial_out(serial_out)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst = 1'b1;
        load = 1'b0;
        parallel_in = 4'b0000;

        #10 rst = 1'b0;
        
        #10 parallel_in = 4'b1010;
        load = 1'b1;
        #10 load = 1'b0;
        
        #40 parallel_in = 4'b1111;
        load = 1'b1;
        #10 load = 1'b0;
        
        #40 rst = 1'b1;
        #10 rst = 1'b0;
        
        #20 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t rst=%b load=%b parallel_in=%b serial_out=%b"",
                 $time, rst, load, parallel_in, serial_out);
    end
endmodule",True,72,True,True,True,False,0.3,False,9.963682174682617,7.806823968887329,"Create a 4-bit PISO shift register with clock, reset, load, parallel input[3:0], and serial output. Include testbench.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph TD
    CLK[Clock] --> SREG[[PISO Register]]
    RST[Reset] --> SREG
    LOAD[Load] --> SREG
    PI0[Parallel In 0] --> SREG
    PI1[Parallel In 1] --> SREG
    PI2[Parallel In 2] --> SREG
    PI3[Parallel In 3] --> SREG
    SREG --> SO[Serial Out]
    
    subgraph TB[Testbench]
        TBCLK[TB Clock Gen] --> CLK
        TBRST[TB Reset Gen] --> RST
        TBLD[TB Load Gen] --> LOAD
        TBPI[TB Parallel Data Gen] --> PI0
        TBPI --> PI1
        TBPI --> PI2
        TBPI --> PI3
        SO --> TBMON[TB Monitor]
    end
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module piso_register(
    input wire clk,
    input wire rst,
    input wire load,
    input wire [3:0] parallel_in,
    output reg serial_out
);

reg [3:0] shift_reg;

always @(posedge clk or posedge rst) begin
    if (rst) begin
        shift_reg <= 4'b0000;
        serial_out <= 1'b0;
    end else if (load) begin
        shift_reg <= parallel_in;
        serial_out <= parallel_in[3];
    end else begin
        shift_reg <= {shift_reg[2:0], 1'b0};
        serial_out <= shift_reg[3];
    end
end

endmodule

module testbench;
    reg clk, rst, load;
    reg [3:0] parallel_in;
    wire serial_out;

    piso_register dut (
        .clk(clk),
        .rst(rst),
        .load(load),
        .parallel_in(parallel_in),
        .serial_out(serial_out)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 1'b0;
        rst = 1'b1;
        load = 1'b0;
        parallel_in = 4'b0000;

        #20 rst = 1'b0;
        
        #10 parallel_in = 4'b1010;
        load = 1'b1;
        #10 load = 1'b0;
        
        #40 parallel_in = 4'b1111;
        load = 1'b1;
        #10 load = 1'b0;
        
        #40 rst = 1'b1;
        #10 rst = 1'b0;
        
        #50 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t rst=%b load=%b parallel_in=%b serial_out=%b"", 
                 $time, rst, load, parallel_in, serial_out);
    end
endmodule",True,72,True,True,True,False,0.3,False,6.162978887557983,7.828643560409546,tie,mermaid_only > combined > prompt_only,prompt_only > mermaid_only > combined
combined,Sequential,medium,"Create a 4-bit PISO shift register with clock, reset, load, parallel input[3:0], and serial output. Include testbench.",gpt-4o,"`timescale 1ns/1ps

module piso_shift_register(
    input wire clk,
    input wire rst_n,
    input wire load,
    input wire [3:0] parallel_in,
    output reg serial_out
);
    reg [3:0] shift_reg;

    always @(posedge clk or negedge rst_n) begin
        if (!rst_n)
            shift_reg <= 4'b0000;
        else if (load)
            shift_reg <= parallel_in;
        else
            shift_reg <= {shift_reg[2:0], 1'b0};
    end

    always @(posedge clk or negedge rst_n) begin
        if (!rst_n)
            serial_out <= 1'b0;
        else
            serial_out <= shift_reg[3];
    end
endmodule

module testbench;
    reg clk, rst_n, load;
    reg [3:0] parallel_in;
    wire serial_out;

    piso_shift_register dut (
        .clk(clk),
        .rst_n(rst_n),
        .load(load),
        .parallel_in(parallel_in),
        .serial_out(serial_out)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 1'b0;
        rst_n = 1'b0;
        load = 1'b0;
        parallel_in = 4'b0000;

        #20 rst_n = 1'b1;
        #10 load = 1'b1; parallel_in = 4'b1010;
        #10 load = 1'b0;
        #100 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b load=%b parallel_in=%b serial_out=%b"", 
                 $time, clk, rst_n, load, parallel_in, serial_out);
    end
endmodule",True,63,True,True,True,True,0.7,True,5.003948926925659,8.892903089523315,"graph LR
    CLK[Clock] --> SHIFT(PISO Shift Register)
    RST[Reset] --> SHIFT
    LOAD[Load] --> SHIFT
    PIN[Parallel Input[3:0]] --> SHIFT
    SOUT[Serial Output] --> SHIFT
    TESTBENCH[Testbench] --> CLK
    TESTBENCH --> RST
    TESTBENCH --> LOAD
    TESTBENCH --> PIN
    SHIFT --> SOUT","`timescale 1ns/1ps

module piso_shift_register(
    input wire clk,
    input wire rst,
    input wire load,
    input wire [3:0] parallel_in,
    output reg serial_out
);

    reg [3:0] shift_reg;

    always @(posedge clk or posedge rst) begin
        if (rst) begin
            shift_reg <= 4'b0000;
            serial_out <= 1'b0;
        end else if (load) begin
            shift_reg <= parallel_in;
        end else begin
            serial_out <= shift_reg[0];
            shift_reg <= {1'b0, shift_reg[3:1]};
        end
    end

endmodule

module testbench;
    reg clk, rst, load;
    reg [3:0] parallel_in;
    wire serial_out;
    
    piso_shift_register dut (
        .clk(clk),
        .rst(rst),
        .load(load),
        .parallel_in(parallel_in),
        .serial_out(serial_out)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst = 1'b1;
        load = 1'b0;
        parallel_in = 4'b0000;
        
        #10 rst = 1'b0;
        #10 load = 1'b1; parallel_in = 4'b1010;
        #10 load = 1'b0;
        #40 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t clk=%b rst=%b load=%b parallel_in=%b serial_out=%b"", 
                 $time, clk, rst, load, parallel_in, serial_out);
    end
endmodule",True,61,True,True,True,False,0.3,False,7.520352840423584,15.330713987350464,"Create a 4-bit PISO shift register with clock, reset, load, parallel input[3:0], and serial output. Include testbench.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph LR
    CLK[Clock] --> SHIFT(PISO Shift Register)
    RST[Reset] --> SHIFT
    LOAD[Load] --> SHIFT
    PIN[Parallel Input[3:0]] --> SHIFT
    SOUT[Serial Output] --> SHIFT
    TESTBENCH[Testbench] --> CLK
    TESTBENCH --> RST
    TESTBENCH --> LOAD
    TESTBENCH --> PIN
    SHIFT --> SOUT
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module piso_shift_register(
    input wire clk,
    input wire rst_n,
    input wire load,
    input wire [3:0] parallel_in,
    output reg serial_out
);

    reg [3:0] shift_reg;

    always @(posedge clk or negedge rst_n) begin
        if (!rst_n)
            shift_reg <= 4'b0000;
        else if (load)
            shift_reg <= parallel_in;
        else
            shift_reg <= {shift_reg[2:0], 1'b0};
    end

    always @(posedge clk or negedge rst_n) begin
        if (!rst_n)
            serial_out <= 1'b0;
        else
            serial_out <= shift_reg[3];
    end

endmodule

module testbench;
    reg clk, rst_n, load;
    reg [3:0] parallel_in;
    wire serial_out;

    piso_shift_register dut (
        .clk(clk),
        .rst_n(rst_n),
        .load(load),
        .parallel_in(parallel_in),
        .serial_out(serial_out)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 1'b0;
        rst_n = 1'b0;
        load = 1'b0;
        parallel_in = 4'b0000;

        #20 rst_n = 1'b1;
        #10 load = 1'b1;
            parallel_in = 4'b1010;
        #10 load = 1'b0;
        #100 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b load=%b parallel_in=%b serial_out=%b"", 
                 $time, clk, rst_n, load, parallel_in, serial_out);
    end
endmodule",True,66,True,True,True,True,0.7,True,13.412040710449219,11.710996389389038,mermaid_only,mermaid_only > prompt_only > combined,prompt_only > mermaid_only > combined
combined,Combinational,medium,"Design a 4-to-2 priority encoder with input in[3:0], output out[1:0], and valid bit. Highest bit has priority. Include testbench.",claude,"`timescale 1ns/1ps

module priority_encoder(
    input wire [3:0] in,
    output reg [1:0] out,
    output reg valid
);

always @(*) begin
    if (in[3]) begin
        out = 2'b11;
        valid = 1'b1;
    end
    else if (in[2]) begin
        out = 2'b10;
        valid = 1'b1;
    end
    else if (in[1]) begin
        out = 2'b01;
        valid = 1'b1;
    end
    else if (in[0]) begin
        out = 2'b00;
        valid = 1'b1;
    end
    else begin
        out = 2'b00;
        valid = 1'b0;
    end
end

endmodule

module testbench;
    reg [3:0] in;
    wire [1:0] out;
    wire valid;

    priority_encoder dut (
        .in(in),
        .out(out),
        .valid(valid)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        in = 4'b0000;
        #10;
        in = 4'b0001;
        #10;
        in = 4'b0010;
        #10;
        in = 4'b0100;
        #10;
        in = 4'b1000;
        #10;
        in = 4'b1111;
        #10;
        in = 4'b0011;
        #10;
        in = 4'b0000;
        #10;
        $finish;
    end

    initial begin
        $monitor(""Time=%0t in=%b out=%b valid=%b"", 
                 $time, in, out, valid);
    end
endmodule",True,72,True,True,True,False,0.4,False,5.5805439949035645,7.470107078552246,"graph LR
    IN0[in[0]] --> ENC((Priority Encoder))
    IN1[in[1]] --> ENC
    IN2[in[2]] --> ENC
    IN3[in[3]] --> ENC
    ENC --> OUT[out[1:0]]
    ENC --> VALID[valid]
    TB[Testbench] -.-> IN0
    TB -.-> IN1
    TB -.-> IN2
    TB -.-> IN3
    OUT -.-> TB
    VALID -.-> TB
    subgraph Priority_Rules
    P1[3 has highest]
    P2[2 has second]
    P3[1 has third]
    P4[0 has lowest]
    end
    Priority_Rules -.-> ENC","`timescale 1ns/1ps

module priority_encoder(
    input wire clk,
    input wire rst_n,
    input wire [3:0] in,
    output reg [1:0] out,
    output reg valid
);

always @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
        out <= 2'b00;
        valid <= 1'b0;
    end
    else begin
        valid <= |in;
        if (in[3])
            out <= 2'b11;
        else if (in[2])
            out <= 2'b10;
        else if (in[1])
            out <= 2'b01;
        else if (in[0])
            out <= 2'b00;
        else
            out <= 2'b00;
    end
end

endmodule

module testbench;
    reg clk, rst_n;
    reg [3:0] in;
    wire [1:0] out;
    wire valid;

    priority_encoder dut (
        .clk(clk),
        .rst_n(rst_n),
        .in(in),
        .out(out),
        .valid(valid)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 0;
        rst_n = 0;
        in = 4'b0000;

        #10 rst_n = 1;

        #10 in = 4'b0001;
        #10 in = 4'b0010;
        #10 in = 4'b0100;
        #10 in = 4'b1000;
        #10 in = 4'b1111;
        #10 in = 4'b0011;
        #10 in = 4'b0000;

        #10 rst_n = 0;
        #10 rst_n = 1;
        
        #10 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t rst_n=%b in=%b out=%b valid=%b"",
                 $time, rst_n, in, out, valid);
    end
endmodule",True,77,True,True,True,True,0.8,True,10.315269231796265,9.089081048965454,"Design a 4-to-2 priority encoder with input in[3:0], output out[1:0], and valid bit. Highest bit has priority. Include testbench.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph LR
    IN0[in[0]] --> ENC((Priority Encoder))
    IN1[in[1]] --> ENC
    IN2[in[2]] --> ENC
    IN3[in[3]] --> ENC
    ENC --> OUT[out[1:0]]
    ENC --> VALID[valid]
    TB[Testbench] -.-> IN0
    TB -.-> IN1
    TB -.-> IN2
    TB -.-> IN3
    OUT -.-> TB
    VALID -.-> TB
    subgraph Priority_Rules
    P1[3 has highest]
    P2[2 has second]
    P3[1 has third]
    P4[0 has lowest]
    end
    Priority_Rules -.-> ENC
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module priority_encoder(
    input wire [3:0] in,
    output reg [1:0] out,
    output reg valid
);

always @(*) begin
    if (in[3]) begin
        out = 2'b11;
        valid = 1'b1;
    end
    else if (in[2]) begin
        out = 2'b10;
        valid = 1'b1;
    end
    else if (in[1]) begin
        out = 2'b01;
        valid = 1'b1;
    end
    else if (in[0]) begin
        out = 2'b00;
        valid = 1'b1;
    end
    else begin
        out = 2'b00;
        valid = 1'b0;
    end
end

endmodule

module testbench;
    reg [3:0] in;
    wire [1:0] out;
    wire valid;

    priority_encoder dut(
        .in(in),
        .out(out),
        .valid(valid)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        // Test all priority cases
        in = 4'b0000; #10;
        in = 4'b0001; #10;
        in = 4'b0010; #10;
        in = 4'b0011; #10;
        in = 4'b0100; #10;
        in = 4'b0101; #10;
        in = 4'b0110; #10;
        in = 4'b0111; #10;
        in = 4'b1000; #10;
        in = 4'b1001; #10;
        in = 4'b1010; #10;
        in = 4'b1011; #10;
        in = 4'b1100; #10;
        in = 4'b1101; #10;
        in = 4'b1110; #10;
        in = 4'b1111; #10;

        $finish;
    end

    initial begin
        $monitor(""Time=%0t in=%b out=%b valid=%b"", 
                 $time, in, out, valid);
    end

endmodule",True,75,True,True,True,False,0.4,False,6.600981950759888,8.114063501358032,tie,prompt_only > combined > mermaid_only,prompt_only > mermaid_only > combined
combined,Combinational,medium,"Design a 4-to-2 priority encoder with input in[3:0], output out[1:0], and valid bit. Highest bit has priority. Include testbench.",gpt-4o,"`timescale 1ns/1ps

module priority_encoder(
    input wire [3:0] in,
    output reg [1:0] out,
    output reg valid
);

always @(in) begin
    valid = 1'b0;
    out = 2'b00;
    if (in[3]) begin
        out = 2'b11;
        valid = 1'b1;
    end else if (in[2]) begin
        out = 2'b10;
        valid = 1'b1;
    end else if (in[1]) begin
        out = 2'b01;
        valid = 1'b1;
    end else if (in[0]) begin
        out = 2'b00;
        valid = 1'b1;
    end
end

endmodule

module testbench;
    reg [3:0] in;
    wire [1:0] out;
    wire valid;

    priority_encoder dut (
        .in(in),
        .out(out),
        .valid(valid)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        in = 4'b0000;
        #10 in = 4'b0001;
        #10 in = 4'b0010;
        #10 in = 4'b0100;
        #10 in = 4'b1000;
        #10 in = 4'b1100;
        #10 in = 4'b1010;
        #10 in = 4'b0110;
        #10 in = 4'b1111;
        #10 $finish;
    end

    initial begin
        $monitor(""Time=%0t in=%b out=%b valid=%b"", $time, in, out, valid);
    end
endmodule",True,59,True,True,True,False,0.4,False,4.999975204467773,10.675679206848145,"graph TD
    IN[in[3:0]] --> ENCODER
    ENCODER((Priority Encoder))
    ENCODER --> OUT[out[1:0]]
    ENCODER --> VALID[Valid Bit]

    subgraph TESTBENCH
        CLK[Clock] --> ENCODER
        RST[Reset] --> ENCODER
        TEST_INPUT[Test Input] --> ENCODER
        EXPECTED_OUTPUT[Expected Output] --> COMPARE
        OUT --> COMPARE{Compare}
        VALID --> COMPARE
        COMPARE --> TEST_RESULT[Test Result]
    end","`timescale 1ns/1ps

module priority_encoder(
    input wire clk,
    input wire rst_n,
    input wire [3:0] in,
    output reg [1:0] out,
    output reg valid
);

always @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
        out <= 2'b00;
        valid <= 1'b0;
    end else begin
        casez (in)
            4'b1???: begin
                out <= 2'b11;
                valid <= 1'b1;
            end
            4'b01??: begin
                out <= 2'b10;
                valid <= 1'b1;
            end
            4'b001?: begin
                out <= 2'b01;
                valid <= 1'b1;
            end
            4'b0001: begin
                out <= 2'b00;
                valid <= 1'b1;
            end
            default: begin
                out <= 2'b00;
                valid <= 1'b0;
            end
        endcase
    end
end

endmodule

module testbench;
    reg clk, rst_n;
    reg [3:0] test_input;
    wire [1:0] out;
    wire valid;
    reg [1:0] expected_output;
    wire test_result;

    priority_encoder dut (
        .clk(clk),
        .rst_n(rst_n),
        .in(test_input),
        .out(out),
        .valid(valid)
    );

    assign test_result = (out == expected_output) && valid;

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 1'b0;
        rst_n = 1'b0;
        test_input = 4'b0000;
        expected_output = 2'b00;

        #20 rst_n = 1'b1;
        #10 test_input = 4'b0001; expected_output = 2'b00;
        #10 test_input = 4'b0010; expected_output = 2'b01;
        #10 test_input = 4'b0100; expected_output = 2'b10;
        #10 test_input = 4'b1000; expected_output = 2'b11;
        #10 test_input = 4'b1100; expected_output = 2'b11;
        #10 test_input = 4'b1010; expected_output = 2'b11;
        #10 test_input = 4'b0110; expected_output = 2'b10;
        #50 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b test_input=%b out=%b valid=%b expected_output=%b test_result=%b"", 
                 $time, clk, rst_n, test_input, out, valid, expected_output, test_result);
    end
endmodule",True,87,True,True,True,True,0.7,True,13.975836992263794,9.128615617752075,"Design a 4-to-2 priority encoder with input in[3:0], output out[1:0], and valid bit. Highest bit has priority. Include testbench.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph TD
    IN[in[3:0]] --> ENCODER
    ENCODER((Priority Encoder))
    ENCODER --> OUT[out[1:0]]
    ENCODER --> VALID[Valid Bit]

    subgraph TESTBENCH
        CLK[Clock] --> ENCODER
        RST[Reset] --> ENCODER
        TEST_INPUT[Test Input] --> ENCODER
        EXPECTED_OUTPUT[Expected Output] --> COMPARE
        OUT --> COMPARE{Compare}
        VALID --> COMPARE
        COMPARE --> TEST_RESULT[Test Result]
    end
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module priority_encoder(
    input wire [3:0] in,
    output reg [1:0] out,
    output reg valid
);

always @(*) begin
    valid = 1'b0;
    out = 2'b00;
    if (in[3]) begin
        out = 2'b11;
        valid = 1'b1;
    end else if (in[2]) begin
        out = 2'b10;
        valid = 1'b1;
    end else if (in[1]) begin
        out = 2'b01;
        valid = 1'b1;
    end else if (in[0]) begin
        out = 2'b00;
        valid = 1'b1;
    end
end

endmodule

module testbench;
    reg [3:0] test_input;
    wire [1:0] out;
    wire valid;
    reg clk, rst;
    reg [1:0] expected_output;
    reg expected_valid;
    wire test_result;

    priority_encoder dut (
        .in(test_input),
        .out(out),
        .valid(valid)
    );

    assign test_result = (out == expected_output) && (valid == expected_valid);

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst = 1'b0;
        test_input = 4'b0000;
        expected_output = 2'b00;
        expected_valid = 1'b0;
        
        #10 rst = 1'b1;
        #10 test_input = 4'b1000; expected_output = 2'b11; expected_valid = 1'b1;
        #10 test_input = 4'b0100; expected_output = 2'b10; expected_valid = 1'b1;
        #10 test_input = 4'b0010; expected_output = 2'b01; expected_valid = 1'b1;
        #10 test_input = 4'b0001; expected_output = 2'b00; expected_valid = 1'b1;
        #10 test_input = 4'b0000; expected_output = 2'b00; expected_valid = 1'b0;
        #50 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t test_input=%b out=%b valid=%b test_result=%b"", 
                 $time, test_input, out, valid, test_result);
    end
endmodule",True,71,True,True,True,True,0.9,True,8.739896059036255,13.615693807601929,prompt_only,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,State Machine,complex,"Design a traffic light FSM with 4 states: NS_GREEN, NS_YELLOW, EW_GREEN, EW_YELLOW. Inputs: clk, rst, emergency. Outputs: ns_light[1:0], ew_light[1:0]. Timing: GREEN=8 cycles, YELLOW=2 cycles. Emergency makes both RED. Include testbench.",claude,"`timescale 1ns/1ps

module traffic_light(
    input wire clk,
    input wire rst,
    input wire emergency,
    output reg [1:0] ns_light,
    output reg [1:0] ew_light
);

parameter RED = 2'b00;
parameter YELLOW = 2'b01;
parameter GREEN = 2'b10;

parameter NS_GREEN = 2'b00;
parameter NS_YELLOW = 2'b01;
parameter EW_GREEN = 2'b10;
parameter EW_YELLOW = 2'b11;

reg [1:0] state;
reg [3:0] timer;

always @(posedge clk or posedge rst) begin
    if (rst) begin
        state <= NS_GREEN;
        timer <= 4'd0;
        ns_light <= GREEN;
        ew_light <= RED;
    end
    else if (emergency) begin
        ns_light <= RED;
        ew_light <= RED;
        state <= NS_GREEN;
        timer <= 4'd0;
    end
    else begin
        case (state)
            NS_GREEN: begin
                if (timer == 4'd7) begin
                    state <= NS_YELLOW;
                    ns_light <= YELLOW;
                    timer <= 4'd0;
                end
                else begin
                    timer <= timer + 1'b1;
                end
            end
            
            NS_YELLOW: begin
                if (timer == 4'd1) begin
                    state <= EW_GREEN;
                    ns_light <= RED;
                    ew_light <= GREEN;
                    timer <= 4'd0;
                end
                else begin
                    timer <= timer + 1'b1;
                end
            end
            
            EW_GREEN: begin
                if (timer == 4'd7) begin
                    state <= EW_YELLOW;
                    ew_light <= YELLOW;
                    timer <= 4'd0;
                end
                else begin
                    timer <= timer + 1'b1;
                end
            end
            
            EW_YELLOW: begin
                if (timer == 4'd1) begin
                    state <= NS_GREEN;
                    ew_light <= RED;
                    ns_light <= GREEN;
                    timer <= 4'd0;
                end
                else begin
                    timer <= timer + 1'b1;
                end
            end
        endcase
    end
end

endmodule

module testbench;
    reg clk;
    reg rst;
    reg emergency;
    wire [1:0] ns_light;
    wire [1:0] ew_light;
    
    traffic_light dut (
        .clk(clk),
        .rst(rst),
        .emergency(emergency),
        .ns_light(ns_light),
        .ew_light(ew_light)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 0;
        rst = 1;
        emergency = 0;
        
        #10 rst = 0;
        
        #100 emergency = 1;
        #20 emergency = 0;
        
        #200 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t rst=%b emergency=%b ns_light=%b ew_light=%b"", 
                 $time, rst, emergency, ns_light, ew_light);
    end
endmodule",True,126,True,True,True,False,0.4,False,10.263571500778198,9.341738224029541,"graph TD
    CLK[Clock] --> FSM[[FSM State Register]]
    RST[Reset] --> FSM
    EMG[Emergency] --> FSM

    FSM --> COUNTER[[Counter<4>]]
    CLK --> COUNTER
    RST --> COUNTER

    FSM --> DECODER(State Decoder)
    COUNTER --> TIMER{Timer Logic}
    TIMER --> FSM

    DECODER --> NS[ns_light<2>]
    DECODER --> EW[ew_light<2>]

    FSM -->|State| ST[Current State]
    ST -->|NS_GREEN| G1[00: GREEN]
    ST -->|NS_YELLOW| Y1[01: YELLOW]
    ST -->|EW_GREEN| G2[10: GREEN]
    ST -->|EW_YELLOW| Y2[11: YELLOW]

    TB[Testbench] -->|clk| CLK
    TB -->|rst| RST
    TB -->|emergency| EMG
    NS -->|verify| TB
    EW -->|verify| TB","`timescale 1ns/1ps

// State definitions
parameter NS_GREEN  = 2'b00;
parameter NS_YELLOW = 2'b01;
parameter EW_GREEN  = 2'b10;
parameter EW_YELLOW = 2'b11;

module traffic_controller(
    input wire clk,
    input wire rst,
    input wire emergency,
    output reg [1:0] ns_light,
    output reg [1:0] ew_light
);

reg [1:0] state, next_state;
reg [3:0] counter;
wire timer_done;

// Counter logic
always @(posedge clk or posedge rst) begin
    if (rst)
        counter <= 4'b0000;
    else
        counter <= counter + 1'b1;
end

assign timer_done = (counter == 4'b1111);

// State register
always @(posedge clk or posedge rst) begin
    if (rst)
        state <= NS_GREEN;
    else
        state <= next_state;
end

// Next state logic
always @(*) begin
    case (state)
        NS_GREEN: 
            if (emergency || timer_done)
                next_state = NS_YELLOW;
            else
                next_state = NS_GREEN;
        NS_YELLOW:
            if (timer_done)
                next_state = EW_GREEN;
            else
                next_state = NS_YELLOW;
        EW_GREEN:
            if (emergency || timer_done)
                next_state = EW_YELLOW;
            else
                next_state = EW_GREEN;
        EW_YELLOW:
            if (timer_done)
                next_state = NS_GREEN;
            else
                next_state = EW_YELLOW;
        default:
            next_state = NS_GREEN;
    endcase
end

// Output decoder
always @(*) begin
    case (state)
        NS_GREEN: begin
            ns_light = 2'b00;
            ew_light = 2'b11;
        end
        NS_YELLOW: begin
            ns_light = 2'b01;
            ew_light = 2'b11;
        end
        EW_GREEN: begin
            ns_light = 2'b11;
            ew_light = 2'b00;
        end
        EW_YELLOW: begin
            ns_light = 2'b11;
            ew_light = 2'b01;
        end
        default: begin
            ns_light = 2'b11;
            ew_light = 2'b11;
        end
    endcase
end

endmodule

module testbench;
    reg clk, rst, emergency;
    wire [1:0] ns_light, ew_light;
    
    traffic_controller dut (
        .clk(clk),
        .rst(rst),
        .emergency(emergency),
        .ns_light(ns_light),
        .ew_light(ew_light)
    );
    
    initial begin
        $dumpfile(""traffic.vcd"");
        $dumpvars(0, testbench);
        
        clk = 0;
        rst = 1;
        emergency = 0;
        
        #20 rst = 0;
        #100 emergency = 1;
        #20 emergency = 0;
        #200 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t rst=%b emergency=%b ns_light=%b ew_light=%b"", 
                 $time, rst, emergency, ns_light, ew_light);
    end
endmodule",True,127,True,True,True,,0.0,,15.669463872909546,0.014610052108764648,"Design a traffic light FSM with 4 states: NS_GREEN, NS_YELLOW, EW_GREEN, EW_YELLOW. Inputs: clk, rst, emergency. Outputs: ns_light[1:0], ew_light[1:0]. Timing: GREEN=8 cycles, YELLOW=2 cycles. Emergency makes both RED. Include testbench.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph TD
    CLK[Clock] --> FSM[[FSM State Register]]
    RST[Reset] --> FSM
    EMG[Emergency] --> FSM

    FSM --> COUNTER[[Counter<4>]]
    CLK --> COUNTER
    RST --> COUNTER

    FSM --> DECODER(State Decoder)
    COUNTER --> TIMER{Timer Logic}
    TIMER --> FSM

    DECODER --> NS[ns_light<2>]
    DECODER --> EW[ew_light<2>]

    FSM -->|State| ST[Current State]
    ST -->|NS_GREEN| G1[00: GREEN]
    ST -->|NS_YELLOW| Y1[01: YELLOW]
    ST -->|EW_GREEN| G2[10: GREEN]
    ST -->|EW_YELLOW| Y2[11: YELLOW]

    TB[Testbench] -->|clk| CLK
    TB -->|rst| RST
    TB -->|emergency| EMG
    NS -->|verify| TB
    EW -->|verify| TB
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module traffic_light(
    input wire clk,
    input wire rst,
    input wire emergency,
    output reg [1:0] ns_light,
    output reg [1:0] ew_light
);

parameter NS_GREEN = 2'b00;
parameter NS_YELLOW = 2'b01;
parameter EW_GREEN = 2'b10;
parameter EW_YELLOW = 2'b11;

reg [1:0] state, next_state;
reg [3:0] counter;
wire timer_done;

// Counter logic
always @(posedge clk or posedge rst) begin
    if (rst)
        counter <= 4'b0000;
    else if (timer_done)
        counter <= 4'b0000;
    else
        counter <= counter + 1'b1;
end

// Timer logic
assign timer_done = ((state == NS_GREEN || state == EW_GREEN) && counter == 4'b0111) ||
                   ((state == NS_YELLOW || state == EW_YELLOW) && counter == 4'b0001);

// State register
always @(posedge clk or posedge rst) begin
    if (rst)
        state <= NS_GREEN;
    else if (emergency)
        state <= NS_GREEN;
    else
        state <= next_state;
end

// Next state logic
always @(*) begin
    case (state)
        NS_GREEN: next_state = timer_done ? NS_YELLOW : NS_GREEN;
        NS_YELLOW: next_state = timer_done ? EW_GREEN : NS_YELLOW;
        EW_GREEN: next_state = timer_done ? EW_YELLOW : EW_GREEN;
        EW_YELLOW: next_state = timer_done ? NS_GREEN : EW_YELLOW;
        default: next_state = NS_GREEN;
    endcase
end

// Output decoder
always @(*) begin
    if (emergency) begin
        ns_light = 2'b01; // RED
        ew_light = 2'b01; // RED
    end
    else begin
        case (state)
            NS_GREEN: begin
                ns_light = 2'b10; // GREEN
                ew_light = 2'b01; // RED
            end
            NS_YELLOW: begin
                ns_light = 2'b00; // YELLOW
                ew_light = 2'b01; // RED
            end
            EW_GREEN: begin
                ns_light = 2'b01; // RED
                ew_light = 2'b10; // GREEN
            end
            EW_YELLOW: begin
                ns_light = 2'b01; // RED
                ew_light = 2'b00; // YELLOW
            end
            default: begin
                ns_light = 2'b01; // RED
                ew_light = 2'b01; // RED
            end
        endcase
    end
end

endmodule

module testbench;
    reg clk, rst, emergency;
    wire [1:0] ns_light, ew_light;
    
    traffic_light dut (
        .clk(clk),
        .rst(rst),
        .emergency(emergency),
        .ns_light(ns_light),
        .ew_light(ew_light)
    );
    
    initial begin
        $dumpfile(""traffic.vcd"");
        $dumpvars(0, testbench);
        
        clk = 0;
        rst = 1;
        emergency = 0;
        
        #10 rst = 0;
        
        // Normal operation
        #200;
        
        // Test emergency
        emergency = 1;
        #50;
        emergency = 0;
        
        // More normal operation
        #200;
        
        $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t rst=%b emergency=%b ns_light=%b ew_light=%b"",
                 $time, rst, emergency, ns_light, ew_light);
    end
endmodule",True,131,True,True,True,,0.0,,12.289897918701172,0.015249252319335938,prompt_only,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,State Machine,complex,"Design a traffic light FSM with 4 states: NS_GREEN, NS_YELLOW, EW_GREEN, EW_YELLOW. Inputs: clk, rst, emergency. Outputs: ns_light[1:0], ew_light[1:0]. Timing: GREEN=8 cycles, YELLOW=2 cycles. Emergency makes both RED. Include testbench.",gpt-4o,"`timescale 1ns/1ps

module traffic_light_fsm(
    input wire clk,
    input wire rst,
    input wire emergency,
    output reg [1:0] ns_light,
    output reg [1:0] ew_light
);

    // State Encoding
    localparam NS_GREEN  = 2'b00;
    localparam NS_YELLOW = 2'b01;
    localparam EW_GREEN  = 2'b10;
    localparam EW_YELLOW = 2'b11;

    // Light Encoding
    localparam RED    = 2'b00;
    localparam GREEN  = 2'b01;
    localparam YELLOW = 2'b10;

    reg [1:0] state, next_state;
    reg [3:0] timer;

    always @(posedge clk or posedge rst) begin
        if (rst) begin
            state <= NS_GREEN;
            timer <= 4'b0000;
        end else if (emergency) begin
            state <= NS_GREEN;
            timer <= 4'b0000;
        end else begin
            state <= next_state;
            timer <= (timer == 4'b1001) ? 4'b0000 : timer + 1'b1;
        end
    end

    always @(*) begin
        case (state)
            NS_GREEN: begin
                ns_light = GREEN;
                ew_light = RED;
                if (timer == 4'b0111) // 8 cycles
                    next_state = NS_YELLOW;
                else
                    next_state = NS_GREEN;
            end

            NS_YELLOW: begin
                ns_light = YELLOW;
                ew_light = RED;
                if (timer == 4'b0001) // 2 cycles
                    next_state = EW_GREEN;
                else
                    next_state = NS_YELLOW;
            end

            EW_GREEN: begin
                ns_light = RED;
                ew_light = GREEN;
                if (timer == 4'b0111) // 8 cycles
                    next_state = EW_YELLOW;
                else
                    next_state = EW_GREEN;
            end

            EW_YELLOW: begin
                ns_light = RED;
                ew_light = YELLOW;
                if (timer == 4'b0001) // 2 cycles
                    next_state = NS_GREEN;
                else
                    next_state = EW_YELLOW;
            end

            default: begin
                next_state = NS_GREEN;
            end
        endcase
    end

endmodule

module testbench;
    reg clk, rst, emergency;
    wire [1:0] ns_light, ew_light;

    traffic_light_fsm dut (
        .clk(clk),
        .rst(rst),
        .emergency(emergency),
        .ns_light(ns_light),
        .ew_light(ew_light)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 1'b0;
        rst = 1'b0;
        emergency = 1'b0;

        #20 rst = 1'b1;
        #160 emergency = 1'b1;
        #20 emergency = 1'b0;
        #200 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t clk=%b rst=%b emergency=%b ns_light=%b ew_light=%b"", 
                 $time, clk, rst, emergency, ns_light, ew_light);
    end
endmodule",True,116,True,True,True,True,0.7,True,10.284529209136963,12.569756984710693,"graph LR
    CLK[clk] --> FSM
    RST[rst] --> FSM
    EMERGENCY[emergency] --> DECISION{{Emergency?}}
    
    FSM(NS_GREEN) -->|8 cycles| FSM_EW_GREEN
    FSM_EW_GREEN(EW_GREEN) -->|8 cycles| FSM_EW_YELLOW
    FSM_EW_YELLOW(EW_YELLOW) -->|2 cycles| FSM_NS_GREEN
    FSM_NS_GREEN(NS_GREEN) -->|8 cycles| FSM_NS_YELLOW
    FSM_NS_YELLOW(NS_YELLOW) -->|2 cycles| FSM
    
    FSM --> NS_LIGHT[ns_light[1:0]]
    FSM --> EW_LIGHT[ew_light[1:0]]

    DECISION -->|Yes| EMERGENCY_STATE((Both RED))
    DECISION -->|No| FSM

    EMERGENCY_STATE --> NS_LIGHT
    EMERGENCY_STATE --> EW_LIGHT","`timescale 1ns/1ps

module traffic_light_fsm(
    input wire clk,
    input wire rst,
    input wire emergency,
    output reg [1:0] ns_light,
    output reg [1:0] ew_light
);

    typedef enum reg [2:0] {
        FSM_NS_GREEN = 3'b000,
        FSM_NS_YELLOW = 3'b001,
        FSM_EW_GREEN = 3'b010,
        FSM_EW_YELLOW = 3'b011,
        EMERGENCY_STATE = 3'b100
    } state_t;

    state_t state, next_state;
    reg [3:0] cycle_count;

    always @(posedge clk or posedge rst) begin
        if (rst) begin
            state <= FSM_NS_GREEN;
            cycle_count <= 4'b0;
        end else begin
            state <= next_state;
            if (state == next_state) begin
                cycle_count <= cycle_count + 1'b1;
            end else begin
                cycle_count <= 4'b0;
            end
        end
    end

    always @(*) begin
        next_state = state;
        case (state)
            FSM_NS_GREEN: begin
                ns_light = 2'b01; // Green
                ew_light = 2'b00; // Red
                if (cycle_count == 4'd8) next_state = FSM_NS_YELLOW;
            end
            FSM_NS_YELLOW: begin
                ns_light = 2'b10; // Yellow
                ew_light = 2'b00; // Red
                if (cycle_count == 4'd2) next_state = FSM_EW_GREEN;
            end
            FSM_EW_GREEN: begin
                ns_light = 2'b00; // Red
                ew_light = 2'b01; // Green
                if (cycle_count == 4'd8) next_state = FSM_EW_YELLOW;
            end
            FSM_EW_YELLOW: begin
                ns_light = 2'b00; // Red
                ew_light = 2'b10; // Yellow
                if (cycle_count == 4'd2) next_state = FSM_NS_GREEN;
            end
            EMERGENCY_STATE: begin
                ns_light = 2'b00; // Red
                ew_light = 2'b00; // Red
                if (!emergency) next_state = FSM_NS_GREEN;
            end
        endcase

        if (emergency) begin
            next_state = EMERGENCY_STATE;
        end
    end

endmodule

module testbench;
    reg clk, rst, emergency;
    wire [1:0] ns_light, ew_light;

    traffic_light_fsm dut (
        .clk(clk),
        .rst(rst),
        .emergency(emergency),
        .ns_light(ns_light),
        .ew_light(ew_light)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 1'b0;
        rst = 1'b0;
        emergency = 1'b0;

        #20 rst = 1'b1;
        #10 rst = 1'b0;
        #100 emergency = 1'b1;
        #20 emergency = 1'b0;
        #100 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t clk=%b rst=%b emergency=%b ns_light=%b ew_light=%b"",
                 $time, clk, rst, emergency, ns_light, ew_light);
    end
endmodule",True,106,True,True,True,False,0.3,False,18.597111701965332,13.713087558746338,"Design a traffic light FSM with 4 states: NS_GREEN, NS_YELLOW, EW_GREEN, EW_YELLOW. Inputs: clk, rst, emergency. Outputs: ns_light[1:0], ew_light[1:0]. Timing: GREEN=8 cycles, YELLOW=2 cycles. Emergency makes both RED. Include testbench.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph LR
    CLK[clk] --> FSM
    RST[rst] --> FSM
    EMERGENCY[emergency] --> DECISION{{Emergency?}}
    
    FSM(NS_GREEN) -->|8 cycles| FSM_EW_GREEN
    FSM_EW_GREEN(EW_GREEN) -->|8 cycles| FSM_EW_YELLOW
    FSM_EW_YELLOW(EW_YELLOW) -->|2 cycles| FSM_NS_GREEN
    FSM_NS_GREEN(NS_GREEN) -->|8 cycles| FSM_NS_YELLOW
    FSM_NS_YELLOW(NS_YELLOW) -->|2 cycles| FSM
    
    FSM --> NS_LIGHT[ns_light[1:0]]
    FSM --> EW_LIGHT[ew_light[1:0]]

    DECISION -->|Yes| EMERGENCY_STATE((Both RED))
    DECISION -->|No| FSM

    EMERGENCY_STATE --> NS_LIGHT
    EMERGENCY_STATE --> EW_LIGHT
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module traffic_light_fsm(
    input wire clk,
    input wire rst,
    input wire emergency,
    output reg [1:0] ns_light,
    output reg [1:0] ew_light
);

    typedef enum reg [2:0] {
        NS_GREEN = 3'b000,
        NS_YELLOW = 3'b001,
        EW_GREEN = 3'b010,
        EW_YELLOW = 3'b011,
        EMERGENCY_STATE = 3'b100
    } state_t;

    reg [2:0] current_state, next_state;
    reg [3:0] cycle_count;

    always @(posedge clk or posedge rst) begin
        if (rst) begin
            current_state <= NS_GREEN;
            cycle_count <= 4'b0000;
        end else if (emergency) begin
            current_state <= EMERGENCY_STATE;
        end else begin
            if (cycle_count == 0) begin
                current_state <= next_state;
                case (current_state)
                    NS_GREEN: cycle_count <= 8;
                    NS_YELLOW: cycle_count <= 2;
                    EW_GREEN: cycle_count <= 8;
                    EW_YELLOW: cycle_count <= 2;
                    default: cycle_count <= 4'b0000;
                endcase
            end else begin
                cycle_count <= cycle_count - 1;
            end
        end
    end

    always @(*) begin
        case (current_state)
            NS_GREEN: begin
                ns_light = 2'b01; // GREEN
                ew_light = 2'b00; // RED
                next_state = NS_YELLOW;
            end
            NS_YELLOW: begin
                ns_light = 2'b10; // YELLOW
                ew_light = 2'b00; // RED
                next_state = EW_GREEN;
            end
            EW_GREEN: begin
                ns_light = 2'b00; // RED
                ew_light = 2'b01; // GREEN
                next_state = EW_YELLOW;
            end
            EW_YELLOW: begin
                ns_light = 2'b00; // RED
                ew_light = 2'b10; // YELLOW
                next_state = NS_GREEN;
            end
            EMERGENCY_STATE: begin
                ns_light = 2'b00; // RED
                ew_light = 2'b00; // RED
                next_state = EMERGENCY_STATE;
            end
            default: begin
                ns_light = 2'b00; // RED
                ew_light = 2'b00; // RED
                next_state = NS_GREEN;
            end
        endcase
    end

endmodule

module testbench;
    reg clk, rst, emergency;
    wire [1:0] ns_light, ew_light;

    traffic_light_fsm dut (
        .clk(clk),
        .rst(rst),
        .emergency(emergency),
        .ns_light(ns_light),
        .ew_light(ew_light)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 1'b0;
        rst = 1'b1;
        emergency = 1'b0;

        #20 rst = 1'b0;
        #160 emergency = 1'b1;
        #40 emergency = 1'b0;
        #200 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t clk=%b rst=%b emergency=%b ns_light=%b ew_light=%b"",
                 $time, clk, rst, emergency, ns_light, ew_light);
    end
endmodule",True,113,True,True,True,True,0.7,True,12.813831567764282,13.958209753036499,mermaid_only,mermaid_only > prompt_only > combined,prompt_only > mermaid_only > combined
combined,State Machine,complex,"Design UART transmitter with states: IDLE, START, DATA, STOP. Protocol: START(0), 8 data bits LSB-first, STOP(1). Baud rate divider. Include testbench.",claude,"`timescale 1ns/1ps

module uart_tx (
    input wire clk,
    input wire rst_n,
    input wire tx_start,
    input wire [7:0] tx_data,
    output reg tx_busy,
    output reg tx_out
);

parameter IDLE = 2'b00;
parameter START = 2'b01;
parameter DATA = 2'b10;
parameter STOP = 2'b11;

reg [1:0] state;
reg [2:0] bit_count;
reg [7:0] shift_reg;
reg [15:0] baud_count;

parameter BAUD_DIV = 16'd434; // For 115200 baud at 50MHz

always @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
        state <= IDLE;
        tx_out <= 1'b1;
        tx_busy <= 1'b0;
        bit_count <= 3'd0;
        baud_count <= 16'd0;
        shift_reg <= 8'd0;
    end
    else begin
        case (state)
            IDLE: begin
                tx_out <= 1'b1;
                if (tx_start) begin
                    state <= START;
                    tx_busy <= 1'b1;
                    shift_reg <= tx_data;
                    baud_count <= 16'd0;
                end
            end

            START: begin
                tx_out <= 1'b0;
                if (baud_count == BAUD_DIV - 1) begin
                    state <= DATA;
                    bit_count <= 3'd0;
                    baud_count <= 16'd0;
                end
                else
                    baud_count <= baud_count + 1'b1;
            end

            DATA: begin
                tx_out <= shift_reg[0];
                if (baud_count == BAUD_DIV - 1) begin
                    baud_count <= 16'd0;
                    if (bit_count == 3'd7) begin
                        state <= STOP;
                    end
                    else begin
                        bit_count <= bit_count + 1'b1;
                        shift_reg <= {1'b0, shift_reg[7:1]};
                    end
                end
                else
                    baud_count <= baud_count + 1'b1;
            end

            STOP: begin
                tx_out <= 1'b1;
                if (baud_count == BAUD_DIV - 1) begin
                    state <= IDLE;
                    tx_busy <= 1'b0;
                    baud_count <= 16'd0;
                end
                else
                    baud_count <= baud_count + 1'b1;
            end
        endcase
    end
end

endmodule

module testbench;
    reg clk;
    reg rst_n;
    reg tx_start;
    reg [7:0] tx_data;
    wire tx_busy;
    wire tx_out;

    uart_tx dut (
        .clk(clk),
        .rst_n(rst_n),
        .tx_start(tx_start),
        .tx_data(tx_data),
        .tx_busy(tx_busy),
        .tx_out(tx_out)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 0;
        rst_n = 0;
        tx_start = 0;
        tx_data = 8'h00;

        #100 rst_n = 1;
        #100 tx_data = 8'hA5;
        #10 tx_start = 1;
        #10 tx_start = 0;

        #100000 tx_data = 8'h3C;
        #10 tx_start = 1;
        #10 tx_start = 0;

        #100000 $finish;
    end

    always #10 clk = ~clk;

    initial begin
        $monitor(""Time=%0t rst_n=%b tx_start=%b tx_data=%h tx_busy=%b tx_out=%b"",
                 $time, rst_n, tx_start, tx_data, tx_busy, tx_out);
    end
endmodule",True,132,True,True,True,True,0.7,True,12.802293539047241,8.697601079940796,"graph LR
    CLK[Clock Input] --> BAUD(Baud Rate Divider)
    RST[Reset] --> FSM
    BAUD --> FSM(State Machine FSM)
    BAUD --> TX_CTRL(TX Controller)
    
    TX_DATA[TX Data Input] --> [[TX Buffer]]
    [[TX Buffer]] --> TX_CTRL
    
    FSM --> |State|TX_CTRL
    TX_CTRL --> TX[UART TX Output]
    
    START_TX[TX Start] --> FSM
    
    FSM --> |States|STATES{IDLE START DATA STOP}
    
    TX_CTRL --> |Bit Counter|BIT_CNT[[Bit Counter]]
    BIT_CNT --> TX_CTRL
    
    TESTBENCH[TB Stimulus] --> TX_DATA
    TESTBENCH --> START_TX
    TESTBENCH --> |Monitor|TX
    
    CLK --> TX_CTRL
    RST --> TX_CTRL
    BUSY[Busy Signal] --> |Status|TESTBENCH","`timescale 1ns/1ps

module uart_tx (
    input wire clk,
    input wire rst,
    input wire start_tx,
    input wire [7:0] tx_data,
    output reg tx,
    output wire busy
);

// State encoding
parameter IDLE  = 2'b00;
parameter START = 2'b01;
parameter DATA  = 2'b10; 
parameter STOP  = 2'b11;

reg [1:0] state, next_state;
reg [3:0] bit_count;
reg [7:0] tx_buffer;
reg baud_tick;
reg [15:0] baud_count;

// Baud rate generator (9600 baud @ 50MHz clock)
parameter BAUD_DIVIDER = 16'd5208;

always @(posedge clk or posedge rst) begin
    if (rst)
        baud_count <= 16'd0;
    else if (baud_count == BAUD_DIVIDER-1)
        baud_count <= 16'd0;
    else
        baud_count <= baud_count + 1'b1;
end

always @(posedge clk or posedge rst) begin
    if (rst)
        baud_tick <= 1'b0;
    else
        baud_tick <= (baud_count == 16'd0);
end

// State machine
always @(posedge clk or posedge rst) begin
    if (rst)
        state <= IDLE;
    else
        state <= next_state;
end

always @(*) begin
    case (state)
        IDLE: next_state = start_tx ? START : IDLE;
        START: next_state = baud_tick ? DATA : START;
        DATA: next_state = (baud_tick && bit_count == 4'd7) ? STOP : DATA;
        STOP: next_state = baud_tick ? IDLE : STOP;
        default: next_state = IDLE;
    endcase
end

// Bit counter
always @(posedge clk or posedge rst) begin
    if (rst)
        bit_count <= 4'd0;
    else if (state == IDLE)
        bit_count <= 4'd0;
    else if (state == DATA && baud_tick)
        bit_count <= bit_count + 1'b1;
end

// TX buffer
always @(posedge clk or posedge rst) begin
    if (rst)
        tx_buffer <= 8'd0;
    else if (state == IDLE && start_tx)
        tx_buffer <= tx_data;
end

// TX output control
always @(posedge clk or posedge rst) begin
    if (rst)
        tx <= 1'b1;
    else begin
        case (state)
            IDLE: tx <= 1'b1;
            START: tx <= 1'b0;
            DATA: tx <= tx_buffer[bit_count];
            STOP: tx <= 1'b1;
        endcase
    end
end

assign busy = (state != IDLE);

endmodule

module testbench;
    reg clk;
    reg rst;
    reg start_tx;
    reg [7:0] tx_data;
    wire tx;
    wire busy;

    uart_tx dut (
        .clk(clk),
        .rst(rst),
        .start_tx(start_tx),
        .tx_data(tx_data),
        .tx(tx),
        .busy(busy)
    );

    initial begin
        $dumpfile(""uart_tx.vcd"");
        $dumpvars(0, testbench);
        
        clk = 0;
        rst = 1;
        start_tx = 0;
        tx_data = 8'h00;
        
        #20 rst = 0;
        #20 tx_data = 8'h55;
        #10 start_tx = 1;
        #10 start_tx = 0;
        
        #200000 tx_data = 8'hAA;
        #10 start_tx = 1;
        #10 start_tx = 0;
        
        #200000 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t rst=%b start_tx=%b tx_data=%h tx=%b busy=%b"",
                 $time, rst, start_tx, tx_data, tx, busy);
    end
endmodule",True,141,True,True,True,,0.0,,18.678083658218384,0.13956451416015625,"Design UART transmitter with states: IDLE, START, DATA, STOP. Protocol: START(0), 8 data bits LSB-first, STOP(1). Baud rate divider. Include testbench.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph LR
    CLK[Clock Input] --> BAUD(Baud Rate Divider)
    RST[Reset] --> FSM
    BAUD --> FSM(State Machine FSM)
    BAUD --> TX_CTRL(TX Controller)
    
    TX_DATA[TX Data Input] --> [[TX Buffer]]
    [[TX Buffer]] --> TX_CTRL
    
    FSM --> |State|TX_CTRL
    TX_CTRL --> TX[UART TX Output]
    
    START_TX[TX Start] --> FSM
    
    FSM --> |States|STATES{IDLE START DATA STOP}
    
    TX_CTRL --> |Bit Counter|BIT_CNT[[Bit Counter]]
    BIT_CNT --> TX_CTRL
    
    TESTBENCH[TB Stimulus] --> TX_DATA
    TESTBENCH --> START_TX
    TESTBENCH --> |Monitor|TX
    
    CLK --> TX_CTRL
    RST --> TX_CTRL
    BUSY[Busy Signal] --> |Status|TESTBENCH
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

// Baud Rate Generator
module baud_gen (
    input wire clk,
    input wire rst_n,
    output reg baud_tick
);

parameter BAUD_DIV = 16'd10416; // For 9600 baud with 100MHz clock

reg [15:0] counter;

always @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
        counter <= 16'd0;
        baud_tick <= 1'b0;
    end else begin
        if (counter == BAUD_DIV - 1) begin
            counter <= 16'd0;
            baud_tick <= 1'b1;
        end else begin
            counter <= counter + 1'b1;
            baud_tick <= 1'b0;
        end
    end
end
endmodule

// UART TX Module
module uart_tx (
    input wire clk,
    input wire rst_n,
    input wire [7:0] tx_data,
    input wire start_tx,
    output reg tx,
    output reg busy
);

// State encoding
parameter IDLE  = 2'b00;
parameter START = 2'b01;
parameter DATA  = 2'b10;
parameter STOP  = 2'b11;

reg [1:0] state, next_state;
reg [7:0] tx_buffer;
reg [2:0] bit_cnt;
wire baud_tick;

baud_gen baud_gen_inst (
    .clk(clk),
    .rst_n(rst_n),
    .baud_tick(baud_tick)
);

// State register
always @(posedge clk or negedge rst_n) begin
    if (!rst_n)
        state <= IDLE;
    else
        state <= next_state;
end

// Next state logic
always @(*) begin
    case (state)
        IDLE: next_state = (start_tx) ? START : IDLE;
        START: next_state = (baud_tick) ? DATA : START;
        DATA: next_state = (baud_tick && bit_cnt == 3'b111) ? STOP : DATA;
        STOP: next_state = (baud_tick) ? IDLE : STOP;
        default: next_state = IDLE;
    endcase
end

// Output logic
always @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
        tx <= 1'b1;
        tx_buffer <= 8'h00;
        bit_cnt <= 3'b000;
        busy <= 1'b0;
    end else begin
        case (state)
            IDLE: begin
                tx <= 1'b1;
                busy <= 1'b0;
                if (start_tx) begin
                    tx_buffer <= tx_data;
                    busy <= 1'b1;
                end
            end
            START: begin
                if (baud_tick)
                    tx <= 1'b0;
            end
            DATA: begin
                if (baud_tick) begin
                    tx <= tx_buffer[bit_cnt];
                    bit_cnt <= bit_cnt + 1'b1;
                end
            end
            STOP: begin
                if (baud_tick) begin
                    tx <= 1'b1;
                    bit_cnt <= 3'b000;
                end
            end
        endcase
    end
end
endmodule

// Testbench
module testbench;
    reg clk, rst_n;
    reg [7:0] tx_data;
    reg start_tx;
    wire tx;
    wire busy;

    uart_tx dut (
        .clk(clk),
        .rst_n(rst_n),
        .tx_data(tx_data),
        .start_tx(start_tx),
        .tx(tx),
        .busy(busy)
    );

    initial begin
        $dumpfile(""uart_tx.vcd"");
        $dumpvars(0, testbench);

        clk = 1'b0;
        rst_n = 1'b0;
        tx_data = 8'h00;
        start_tx = 1'b0;

        #20 rst_n = 1'b1;
        #20;

        // Test transmission
        tx_data = 8'h55;
        start_tx = 1'b1;
        #10 start_tx = 1'b0;

        // Wait for transmission to complete
        wait(!busy);
        #1000;

        // Send another byte
        tx_data = 8'hAA;
        start_tx = 1'b1;
        #10 start_tx = 1'b0;

        wait(!busy);
        #1000;

        $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t rst_n=%b tx_data=%h start_tx=%b tx=%b busy=%b"",
                 $time, rst_n, tx_data, start_tx, tx, busy);
    end
endmodule",True,169,True,True,True,,0.0,,15.501871824264526,0.5031006336212158,prompt_only,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,State Machine,complex,"Design UART transmitter with states: IDLE, START, DATA, STOP. Protocol: START(0), 8 data bits LSB-first, STOP(1). Baud rate divider. Include testbench.",gpt-4o,"`timescale 1ns/1ps

module uart_tx(
    input wire clk,
    input wire rst_n,
    input wire start,
    input wire [7:0] data_in,
    output reg tx
);

    reg [3:0] state;
    reg [3:0] bit_index;
    reg [7:0] baud_divider;
    reg [7:0] data;
    
    parameter IDLE = 4'b0000;
    parameter START = 4'b0001;
    parameter DATA = 4'b0010;
    parameter STOP = 4'b0011;
    parameter BAUD_DIV = 8'd104; // Assuming a specific clock and baud rate

    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            state <= IDLE;
            tx <= 1'b1;
            baud_divider <= 8'd0;
            bit_index <= 4'd0;
        end else begin
            case (state)
                IDLE: begin
                    tx <= 1'b1;
                    if (start) begin
                        state <= START;
                        data <= data_in;
                        baud_divider <= 8'd0;
                    end
                end
                START: begin
                    if (baud_divider == BAUD_DIV) begin
                        tx <= 1'b0;
                        state <= DATA;
                        baud_divider <= 8'd0;
                        bit_index <= 4'd0;
                    end else begin
                        baud_divider <= baud_divider + 1'b1;
                    end
                end
                DATA: begin
                    if (baud_divider == BAUD_DIV) begin
                        tx <= data[bit_index];
                        baud_divider <= 8'd0;
                        if (bit_index == 4'd7) begin
                            state <= STOP;
                        end else begin
                            bit_index <= bit_index + 1'b1;
                        end
                    end else begin
                        baud_divider <= baud_divider + 1'b1;
                    end
                end
                STOP: begin
                    if (baud_divider == BAUD_DIV) begin
                        tx <= 1'b1;
                        state <= IDLE;
                    end else begin
                        baud_divider <= baud_divider + 1'b1;
                    end
                end
                default: state <= IDLE;
            endcase
        end
    end

endmodule

module testbench;
    reg clk, rst_n, start;
    reg [7:0] data_in;
    wire tx;
    
    uart_tx dut (
        .clk(clk),
        .rst_n(rst_n),
        .start(start),
        .data_in(data_in),
        .tx(tx)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst_n = 1'b0;
        start = 1'b0;
        data_in = 8'b10101010;
        
        #20 rst_n = 1'b1;
        #10 start = 1'b1;
        #10 start = 1'b0;
        #1000 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b start=%b data_in=%b tx=%b"", 
                 $time, clk, rst_n, start, data_in, tx);
    end
endmodule",True,110,True,True,True,True,0.9,True,11.49606442451477,11.359181880950928,"graph TD
    CLK[Clock] --> UART(Processing: UART Transmitter)
    RST[Reset] --> UART
    BAUD[Baud Rate Divider] --> UART
    DATA[Input Data] --> UART
    UART --> SERIAL_OUT[Serial Output]
    
    UART --> IDLE_STATE{State: IDLE}
    UART --> START_STATE{State: START}
    UART --> DATA_STATE{State: DATA}
    UART --> STOP_STATE{State: STOP}
    
    START_STATE --> |0| DATA_STATE
    DATA_STATE --> |8 Data Bits LSB-first| STOP_STATE
    STOP_STATE --> |1| IDLE_STATE
    
    CLK --> TESTBENCH(Processing: Testbench)
    TESTBENCH --> UART
    TESTBENCH --> BAUD","`timescale 1ns/1ps

module uart_transmitter (
    input wire clk,
    input wire rst,
    input wire baud,
    input wire [7:0] data_in,
    output reg serial_out
);
    reg [3:0] state;
    reg [2:0] bit_index;
    reg [7:0] data_reg;
    
    localparam IDLE  = 4'd0;
    localparam START = 4'd1;
    localparam DATA  = 4'd2;
    localparam STOP  = 4'd3;
    
    always @(posedge clk or posedge rst) begin
        if (rst) begin
            state <= IDLE;
            serial_out <= 1'b1;
            bit_index <= 3'd0;
            data_reg <= 8'b0;
        end else begin
            case (state)
                IDLE: begin
                    if (baud) begin
                        data_reg <= data_in;
                        state <= START;
                        serial_out <= 1'b0;
                    end
                end
                START: begin
                    if (baud) begin
                        state <= DATA;
                        bit_index <= 3'd0;
                    end
                end
                DATA: begin
                    if (baud) begin
                        serial_out <= data_reg[bit_index];
                        bit_index <= bit_index + 1'b1;
                        if (bit_index == 3'd7)
                            state <= STOP;
                    end
                end
                STOP: begin
                    if (baud) begin
                        serial_out <= 1'b1;
                        state <= IDLE;
                    end
                end
            endcase
        end
    end
endmodule

module testbench;
    reg clk, rst, baud;
    reg [7:0] data_in;
    wire serial_out;
    
    uart_transmitter dut (
        .clk(clk),
        .rst(rst),
        .baud(baud),
        .data_in(data_in),
        .serial_out(serial_out)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst = 1'b1;
        baud = 1'b0;
        data_in = 8'b10101010;
        
        #20 rst = 1'b0;
        #10 baud = 1'b1;
        #10 baud = 1'b0;
        #80 baud = 1'b1;
        #10 baud = 1'b0;
        #80 baud = 1'b1;
        #10 baud = 1'b0;
        #80 baud = 1'b1;
        #10 baud = 1'b0;
        #80 baud = 1'b1;
        #10 baud = 1'b0;
        #80 baud = 1'b1;
        #10 baud = 1'b0;
        #80 baud = 1'b1;
        #10 baud = 1'b0;
        #80 baud = 1'b1;
        #10 baud = 1'b0;
        #80 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t clk=%b rst=%b baud=%b data_in=%b serial_out=%b"", 
                 $time, clk, rst, baud, data_in, serial_out);
    end
endmodule",True,107,True,True,True,True,0.7,True,11.558171033859253,12.778804779052734,"Design UART transmitter with states: IDLE, START, DATA, STOP. Protocol: START(0), 8 data bits LSB-first, STOP(1). Baud rate divider. Include testbench.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph TD
    CLK[Clock] --> UART(Processing: UART Transmitter)
    RST[Reset] --> UART
    BAUD[Baud Rate Divider] --> UART
    DATA[Input Data] --> UART
    UART --> SERIAL_OUT[Serial Output]
    
    UART --> IDLE_STATE{State: IDLE}
    UART --> START_STATE{State: START}
    UART --> DATA_STATE{State: DATA}
    UART --> STOP_STATE{State: STOP}
    
    START_STATE --> |0| DATA_STATE
    DATA_STATE --> |8 Data Bits LSB-first| STOP_STATE
    STOP_STATE --> |1| IDLE_STATE
    
    CLK --> TESTBENCH(Processing: Testbench)
    TESTBENCH --> UART
    TESTBENCH --> BAUD
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module uart_transmitter(
    input wire clk,
    input wire rst_n,
    input wire [7:0] data_in,
    input wire baud_tick,
    output reg serial_out
);

    reg [3:0] state, next_state;
    reg [2:0] bit_index;
    reg [7:0] shift_reg;

    parameter IDLE = 4'b0000;
    parameter START = 4'b0001;
    parameter DATA = 4'b0010;
    parameter STOP = 4'b0011;

    always @(posedge clk or negedge rst_n) begin
        if (!rst_n)
            state <= IDLE;
        else
            state <= next_state;
    end

    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            bit_index <= 3'b0;
            shift_reg <= 8'b0;
            serial_out <= 1'b1;
        end else if (baud_tick) begin
            case (state)
                IDLE: begin
                    serial_out <= 1'b1;
                    if (data_in != 8'b0) begin
                        shift_reg <= data_in;
                        bit_index <= 3'b0;
                        next_state <= START;
                    end
                end
                START: begin
                    serial_out <= 1'b0;
                    next_state <= DATA;
                end
                DATA: begin
                    serial_out <= shift_reg[bit_index];
                    bit_index <= bit_index + 1'b1;
                    if (bit_index == 3'b111)
                        next_state <= STOP;
                end
                STOP: begin
                    serial_out <= 1'b1;
                    next_state <= IDLE;
                end
            endcase
        end
    end

    always @(*) begin
        next_state = state;
    end

endmodule

module testbench;
    reg clk, rst_n, baud_tick;
    reg [7:0] data_in;
    wire serial_out;

    uart_transmitter uut (
        .clk(clk),
        .rst_n(rst_n),
        .data_in(data_in),
        .baud_tick(baud_tick),
        .serial_out(serial_out)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 1'b0;
        rst_n = 1'b0;
        baud_tick = 1'b0;
        data_in = 8'b10101010;

        #20 rst_n = 1'b1;
        #10 baud_tick = 1'b1;
        #160 baud_tick = 1'b0;
        #20 baud_tick = 1'b1;
        #160 baud_tick = 1'b0;
        #20 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b baud_tick=%b data_in=%b serial_out=%b"", 
                 $time, clk, rst_n, baud_tick, data_in, serial_out);
    end
endmodule",True,102,True,True,True,True,0.7,True,7.840285778045654,12.616023302078247,prompt_only,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,CPU Component,complex,Create 8-register  8-bit register file with dual read ports and single write port. Include testbench with simultaneous operations.,claude,"`timescale 1ns/1ps

module reg_file(
    input wire clk,
    input wire rst_n,
    input wire write_en,
    input wire [2:0] write_addr,
    input wire [7:0] write_data,
    input wire [2:0] read_addr1,
    input wire [2:0] read_addr2,
    output reg [7:0] read_data1,
    output reg [7:0] read_data2
);

reg [7:0] registers [0:7];
integer i;

always @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
        for (i = 0; i < 8; i = i + 1)
            registers[i] <= 8'h00;
    end
    else if (write_en)
        registers[write_addr] <= write_data;
end

always @(*) begin
    read_data1 = registers[read_addr1];
    read_data2 = registers[read_addr2];
end

endmodule

module testbench;
    reg clk;
    reg rst_n;
    reg write_en;
    reg [2:0] write_addr;
    reg [7:0] write_data;
    reg [2:0] read_addr1;
    reg [2:0] read_addr2;
    wire [7:0] read_data1;
    wire [7:0] read_data2;

    reg_file dut (
        .clk(clk),
        .rst_n(rst_n),
        .write_en(write_en),
        .write_addr(write_addr),
        .write_data(write_data),
        .read_addr1(read_addr1),
        .read_addr2(read_addr2),
        .read_data1(read_data1),
        .read_data2(read_data2)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 0;
        rst_n = 0;
        write_en = 0;
        write_addr = 0;
        write_data = 0;
        read_addr1 = 0;
        read_addr2 = 0;

        #10 rst_n = 1;

        // Write some data
        #10 write_en = 1;
        write_addr = 3'd0;
        write_data = 8'hA5;
        
        #10 write_addr = 3'd1;
        write_data = 8'hB4;

        #10 write_addr = 3'd2;
        write_data = 8'hC3;

        // Read while writing
        #10 write_addr = 3'd3;
        write_data = 8'hD2;
        read_addr1 = 3'd0;
        read_addr2 = 3'd1;

        // Multiple reads
        #10 write_en = 0;
        read_addr1 = 3'd2;
        read_addr2 = 3'd3;

        #20 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t rd1=%h rd2=%h"", $time, read_data1, read_data2);
    end
endmodule",True,101,True,True,True,False,0.4,False,10.07142949104309,7.359175682067871,"graph LR
    CLK[Clock] --> RF[[8x8 Register File]]
    RST[Reset] --> RF
    WD[Write Data 8-bit] --> RF
    WA[Write Address 3-bit] --> RF
    WE[Write Enable] --> RF
    RA1[Read Address 1] --> RF
    RA2[Read Address 2] --> RF
    RF --> RD1[Read Data 1]
    RF --> RD2[Read Data 2]
    TB[Testbench Control]
    TB --> |Write Stimulus| WD
    TB --> |Write Addr| WA
    TB --> |Write Enable| WE
    TB --> |Read Addr 1| RA1
    TB --> |Read Addr 2| RA2
    RD1 --> |Verify| TB
    RD2 --> |Verify| TB
    CLK --> TB
    RST --> TB","`timescale 1ns/1ps

module register_file(
    input wire clk,
    input wire rst,
    input wire [7:0] write_data,
    input wire [2:0] write_addr,
    input wire write_enable,
    input wire [2:0] read_addr1,
    input wire [2:0] read_addr2,
    output reg [7:0] read_data1,
    output reg [7:0] read_data2
);

reg [7:0] registers [0:7];
integer i;

always @(posedge clk or posedge rst) begin
    if (rst) begin
        for (i = 0; i < 8; i = i + 1)
            registers[i] <= 8'b0;
    end
    else if (write_enable) begin
        registers[write_addr] <= write_data;
    end
end

always @(*) begin
    read_data1 = registers[read_addr1];
    read_data2 = registers[read_addr2];
end

endmodule

module testbench;
    reg clk, rst;
    reg [7:0] write_data;
    reg [2:0] write_addr;
    reg write_enable;
    reg [2:0] read_addr1, read_addr2;
    wire [7:0] read_data1, read_data2;

    register_file dut (
        .clk(clk),
        .rst(rst),
        .write_data(write_data),
        .write_addr(write_addr),
        .write_enable(write_enable),
        .read_addr1(read_addr1),
        .read_addr2(read_addr2),
        .read_data1(read_data1),
        .read_data2(read_data2)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 0;
        rst = 1;
        write_enable = 0;
        write_data = 0;
        write_addr = 0;
        read_addr1 = 0;
        read_addr2 = 0;

        #10 rst = 0;

        // Write test pattern
        #10 write_enable = 1;
        write_addr = 3'b001;
        write_data = 8'h55;
        
        #10 write_addr = 3'b010;
        write_data = 8'hAA;

        #10 write_enable = 0;
        read_addr1 = 3'b001;
        read_addr2 = 3'b010;

        #20 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t rst=%b we=%b wa=%h wd=%h ra1=%h rd1=%h ra2=%h rd2=%h"",
                 $time, rst, write_enable, write_addr, write_data,
                 read_addr1, read_data1, read_addr2, read_data2);
    end
endmodule",True,91,True,True,True,False,0.3,False,13.617191553115845,8.247608184814453,"Create 8-register  8-bit register file with dual read ports and single write port. Include testbench with simultaneous operations.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph LR
    CLK[Clock] --> RF[[8x8 Register File]]
    RST[Reset] --> RF
    WD[Write Data 8-bit] --> RF
    WA[Write Address 3-bit] --> RF
    WE[Write Enable] --> RF
    RA1[Read Address 1] --> RF
    RA2[Read Address 2] --> RF
    RF --> RD1[Read Data 1]
    RF --> RD2[Read Data 2]
    TB[Testbench Control]
    TB --> |Write Stimulus| WD
    TB --> |Write Addr| WA
    TB --> |Write Enable| WE
    TB --> |Read Addr 1| RA1
    TB --> |Read Addr 2| RA2
    RD1 --> |Verify| TB
    RD2 --> |Verify| TB
    CLK --> TB
    RST --> TB
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module register_file (
    input wire clk,
    input wire rst,
    input wire [7:0] write_data,
    input wire [2:0] write_addr,
    input wire write_en,
    input wire [2:0] read_addr1,
    input wire [2:0] read_addr2,
    output reg [7:0] read_data1,
    output reg [7:0] read_data2
);

reg [7:0] registers [0:7];
integer i;

always @(posedge clk or posedge rst) begin
    if (rst) begin
        for (i = 0; i < 8; i = i + 1)
            registers[i] <= 8'b0;
    end
    else if (write_en) begin
        registers[write_addr] <= write_data;
    end
end

always @(*) begin
    read_data1 = registers[read_addr1];
    read_data2 = registers[read_addr2];
end

endmodule

module testbench;
    reg clk;
    reg rst;
    reg [7:0] write_data;
    reg [2:0] write_addr;
    reg write_en;
    reg [2:0] read_addr1;
    reg [2:0] read_addr2;
    wire [7:0] read_data1;
    wire [7:0] read_data2;

    register_file dut (
        .clk(clk),
        .rst(rst),
        .write_data(write_data),
        .write_addr(write_addr),
        .write_en(write_en),
        .read_addr1(read_addr1),
        .read_addr2(read_addr2),
        .read_data1(read_data1),
        .read_data2(read_data2)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 0;
        rst = 1;
        write_data = 0;
        write_addr = 0;
        write_en = 0;
        read_addr1 = 0;
        read_addr2 = 0;

        #10 rst = 0;

        // Write test pattern
        #10 write_en = 1;
        write_addr = 3'd0; write_data = 8'hAA;
        #10 write_addr = 3'd1; write_data = 8'hBB;
        #10 write_addr = 3'd2; write_data = 8'hCC;
        
        // Read test
        #10 write_en = 0;
        read_addr1 = 3'd0;
        read_addr2 = 3'd1;
        #10 read_addr1 = 3'd1;
        read_addr2 = 3'd2;
        
        #20 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t rd1=%h rd2=%h"", $time, read_data1, read_data2);
    end

endmodule",True,94,True,True,True,False,0.4,False,9.56223464012146,6.97783899307251,tie,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,CPU Component,complex,Create 8-register  8-bit register file with dual read ports and single write port. Include testbench with simultaneous operations.,gpt-4o,"`timescale 1ns/1ps

module regfile(
    input wire clk,
    input wire rst_n,
    input wire [2:0] read_addr1,
    input wire [2:0] read_addr2,
    input wire [2:0] write_addr,
    input wire [7:0] write_data,
    input wire write_enable,
    output reg [7:0] read_data1,
    output reg [7:0] read_data2
);

    reg [7:0] registers [7:0];

    // Read operation
    always @(*) begin
        read_data1 = registers[read_addr1];
        read_data2 = registers[read_addr2];
    end

    // Write operation
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            registers[0] <= 8'b0;
            registers[1] <= 8'b0;
            registers[2] <= 8'b0;
            registers[3] <= 8'b0;
            registers[4] <= 8'b0;
            registers[5] <= 8'b0;
            registers[6] <= 8'b0;
            registers[7] <= 8'b0;
        end else if (write_enable) begin
            registers[write_addr] <= write_data;
        end
    end

endmodule

module testbench;
    reg clk, rst_n;
    reg [2:0] read_addr1, read_addr2, write_addr;
    reg [7:0] write_data;
    reg write_enable;
    wire [7:0] read_data1, read_data2;
    
    regfile dut (
        .clk(clk),
        .rst_n(rst_n),
        .read_addr1(read_addr1),
        .read_addr2(read_addr2),
        .write_addr(write_addr),
        .write_data(write_data),
        .write_enable(write_enable),
        .read_data1(read_data1),
        .read_data2(read_data2)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst_n = 1'b0;
        write_enable = 1'b0;
        read_addr1 = 3'b0;
        read_addr2 = 3'b0;
        write_addr = 3'b0;
        write_data = 8'b0;
        
        #20 rst_n = 1'b1;
        #10 write_enable = 1'b1; write_addr = 3'b001; write_data = 8'hAA;
        #10 write_enable = 1'b0; read_addr1 = 3'b001; read_addr2 = 3'b010;
        #10 write_enable = 1'b1; write_addr = 3'b010; write_data = 8'hBB;
        #10 write_enable = 1'b0; read_addr1 = 3'b001; read_addr2 = 3'b010;
        #50 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b write_enable=%b write_addr=%d write_data=%h read_data1=%h read_data2=%h"", 
                 $time, clk, rst_n, write_enable, write_addr, write_data, read_data1, read_data2);
    end
endmodule",True,86,True,True,True,True,0.7,True,14.396090507507324,16.131187677383423,"graph TD
    CLK[Clock] --> RF[[Register File: 8x8]]
    RST[Reset] --> RF
    DIN[8-bit Data In] --> RF
    WADDR[3-bit Write Address] --> RF
    WE[Write Enable] --> RF
    RADDR1[3-bit Read Address 1] --> RF
    RADDR2[3-bit Read Address 2] --> RF
    RF --> DOUT1[8-bit Data Out 1]
    RF --> DOUT2[8-bit Data Out 2]
    
    subgraph Testbench
        CLK --> TBPROC(Testbench Processor)
        RST --> TBPROC
        TBPROC --> DIN
        TBPROC --> WADDR
        TBPROC --> WE
        TBPROC --> RADDR1
        TBPROC --> RADDR2
        DOUT1 --> TBPROC
        DOUT2 --> TBPROC
    end","`timescale 1ns/1ps

module register_file(
    input wire clk,
    input wire rst_n,
    input wire [7:0] data_in,
    input wire [2:0] write_addr,
    input wire write_enable,
    input wire [2:0] read_addr1,
    input wire [2:0] read_addr2,
    output reg [7:0] data_out1,
    output reg [7:0] data_out2
);

    reg [7:0] regfile [7:0];

    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            regfile[0] <= 8'b00000000;
            regfile[1] <= 8'b00000000;
            regfile[2] <= 8'b00000000;
            regfile[3] <= 8'b00000000;
            regfile[4] <= 8'b00000000;
            regfile[5] <= 8'b00000000;
            regfile[6] <= 8'b00000000;
            regfile[7] <= 8'b00000000;
        end else if (write_enable) begin
            regfile[write_addr] <= data_in;
        end
    end

    always @(posedge clk) begin
        data_out1 <= regfile[read_addr1];
        data_out2 <= regfile[read_addr2];
    end

endmodule

module testbench;
    reg clk, rst_n, write_enable;
    reg [7:0] data_in;
    reg [2:0] write_addr, read_addr1, read_addr2;
    wire [7:0] data_out1, data_out2;
    
    register_file dut (
        .clk(clk),
        .rst_n(rst_n),
        .data_in(data_in),
        .write_addr(write_addr),
        .write_enable(write_enable),
        .read_addr1(read_addr1),
        .read_addr2(read_addr2),
        .data_out1(data_out1),
        .data_out2(data_out2)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst_n = 1'b0;
        write_enable = 1'b0;
        data_in = 8'b00000000;
        write_addr = 3'b000;
        read_addr1 = 3'b000;
        read_addr2 = 3'b001;
        
        #20 rst_n = 1'b1;
        #10 write_enable = 1'b1;
        data_in = 8'b10101010;
        write_addr = 3'b000;
        
        #10 write_enable = 1'b0;
        read_addr1 = 3'b000;
        read_addr2 = 3'b001;
        
        #50 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b write_enable=%b data_in=%b write_addr=%d read_addr1=%d read_addr2=%d data_out1=%b data_out2=%b"", 
                 $time, clk, rst_n, write_enable, data_in, write_addr, read_addr1, read_addr2, data_out1, data_out2);
    end
endmodule",True,87,True,True,True,True,0.7,True,10.857978105545044,11.491792440414429,"Create 8-register  8-bit register file with dual read ports and single write port. Include testbench with simultaneous operations.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph TD
    CLK[Clock] --> RF[[Register File: 8x8]]
    RST[Reset] --> RF
    DIN[8-bit Data In] --> RF
    WADDR[3-bit Write Address] --> RF
    WE[Write Enable] --> RF
    RADDR1[3-bit Read Address 1] --> RF
    RADDR2[3-bit Read Address 2] --> RF
    RF --> DOUT1[8-bit Data Out 1]
    RF --> DOUT2[8-bit Data Out 2]
    
    subgraph Testbench
        CLK --> TBPROC(Testbench Processor)
        RST --> TBPROC
        TBPROC --> DIN
        TBPROC --> WADDR
        TBPROC --> WE
        TBPROC --> RADDR1
        TBPROC --> RADDR2
        DOUT1 --> TBPROC
        DOUT2 --> TBPROC
    end
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module register_file(
    input wire clk,
    input wire rst,
    input wire [7:0] din,
    input wire [2:0] waddr,
    input wire we,
    input wire [2:0] raddr1,
    input wire [2:0] raddr2,
    output reg [7:0] dout1,
    output reg [7:0] dout2
);

    reg [7:0] registers [7:0];

    always @(posedge clk or posedge rst) begin
        if (rst) begin
            registers[0] <= 8'b0;
            registers[1] <= 8'b0;
            registers[2] <= 8'b0;
            registers[3] <= 8'b0;
            registers[4] <= 8'b0;
            registers[5] <= 8'b0;
            registers[6] <= 8'b0;
            registers[7] <= 8'b0;
        end else if (we) begin
            registers[waddr] <= din;
        end
    end

    always @(*) begin
        dout1 = registers[raddr1];
        dout2 = registers[raddr2];
    end

endmodule

module testbench;
    reg clk;
    reg rst;
    reg [7:0] din;
    reg [2:0] waddr;
    reg we;
    reg [2:0] raddr1;
    reg [2:0] raddr2;
    wire [7:0] dout1;
    wire [7:0] dout2;

    register_file dut (
        .clk(clk),
        .rst(rst),
        .din(din),
        .waddr(waddr),
        .we(we),
        .raddr1(raddr1),
        .raddr2(raddr2),
        .dout1(dout1),
        .dout2(dout2)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 1'b0;
        rst = 1'b1;
        din = 8'b0;
        waddr = 3'b0;
        we = 1'b0;
        raddr1 = 3'b0;
        raddr2 = 3'b0;

        #10 rst = 1'b0;
        #10 din = 8'b10101010; waddr = 3'b001; we = 1'b1;
        #10 we = 1'b0;
        #10 raddr1 = 3'b001;
        #10 raddr2 = 3'b001;
        #50 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t clk=%b rst=%b din=%b waddr=%b we=%b raddr1=%b raddr2=%b dout1=%b dout2=%b"", 
                 $time, clk, rst, din, waddr, we, raddr1, raddr2, dout1, dout2);
    end
endmodule",True,88,True,True,True,True,0.7,True,6.426114797592163,10.544278144836426,prompt_only,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,Advanced Sequential,complex,"Design 8-bit resolution PWM generator with configurable duty cycle. Include testbench with duty cycles: 0%, 25%, 50%, 75%, 100%.",claude,"`timescale 1ns/1ps

module pwm_gen (
    input wire clk,
    input wire rst_n,
    input wire [7:0] duty_cycle,
    output reg pwm_out
);

reg [7:0] counter;

always @(posedge clk or negedge rst_n) begin
    if (!rst_n)
        counter <= 8'h00;
    else
        counter <= counter + 1'b1;
end

always @(posedge clk or negedge rst_n) begin
    if (!rst_n)
        pwm_out <= 1'b0;
    else
        pwm_out <= (counter < duty_cycle);
end

endmodule

module testbench;
    reg clk;
    reg rst_n;
    reg [7:0] duty_cycle;
    wire pwm_out;
    
    pwm_gen dut (
        .clk(clk),
        .rst_n(rst_n),
        .duty_cycle(duty_cycle),
        .pwm_out(pwm_out)
    );
    
    initial begin
        $dumpfile(""pwm.vcd"");
        $dumpvars(0, testbench);
        
        clk = 0;
        rst_n = 0;
        duty_cycle = 8'h00;
        
        #20 rst_n = 1;
        
        // Test 0% duty cycle
        duty_cycle = 8'h00;
        #512;
        
        // Test 25% duty cycle
        duty_cycle = 8'h40;
        #512;
        
        // Test 50% duty cycle
        duty_cycle = 8'h80;
        #512;
        
        // Test 75% duty cycle
        duty_cycle = 8'hC0;
        #512;
        
        // Test 100% duty cycle
        duty_cycle = 8'hFF;
        #512;
        
        $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t rst_n=%b duty_cycle=%h pwm_out=%b"", 
                 $time, rst_n, duty_cycle, pwm_out);
    end
endmodule",True,80,True,True,True,,0.0,,6.798458814620972,0.014546394348144531,"graph LR
    CLK[Clock Input] --> CNT((8-bit Counter))
    RST[Reset] --> CNT
    
    DC[[Duty Cycle Register]] --> CMP((Comparator))
    CNT --> CMP
    
    DCV[Duty Value Input] --> DC
    
    CMP --> PWM[PWM Output]
    
    TB0[Test 0% DC] -.-> DC
    TB1[Test 25% DC] -.-> DC
    TB2[Test 50% DC] -.-> DC
    TB3[Test 75% DC] -.-> DC
    TB4[Test 100% DC] -.-> DC
    
    CLK --> CMP
    RST --> CMP
    
    style TB0 fill:#f9f,stroke:#333
    style TB1 fill:#f9f,stroke:#333
    style TB2 fill:#f9f,stroke:#333
    style TB3 fill:#f9f,stroke:#333
    style TB4 fill:#f9f,stroke:#333","`timescale 1ns/1ps

module pwm_gen (
    input wire clk,
    input wire rst,
    input wire [7:0] duty_value,
    output reg pwm_out
);

reg [7:0] counter;
reg [7:0] duty_reg;

always @(posedge clk or posedge rst) begin
    if (rst) begin
        counter <= 8'b0;
        duty_reg <= 8'b0;
        pwm_out <= 1'b0;
    end else begin
        counter <= counter + 1'b1;
        duty_reg <= duty_value;
        pwm_out <= (counter < duty_reg) ? 1'b1 : 1'b0;
    end
end

endmodule

module testbench;
    reg clk;
    reg rst;
    reg [7:0] duty_value;
    wire pwm_out;

    pwm_gen dut (
        .clk(clk),
        .rst(rst),
        .duty_value(duty_value),
        .pwm_out(pwm_out)
    );

    initial begin
        $dumpfile(""pwm.vcd"");
        $dumpvars(0, testbench);

        clk = 1'b0;
        rst = 1'b1;
        duty_value = 1'b0;
        #20 rst = 1'b0;

        // Test 0% duty cycle
        #20 duty_value = 8'd0;
        #256;

        // Test 25% duty cycle
        duty_value = 8'd64;
        #256;

        // Test 50% duty cycle
        duty_value = 8'd128;
        #256;

        // Test 75% duty cycle
        duty_value = 8'd192;
        #256;

        // Test 100% duty cycle
        duty_value = 8'd255;
        #256;

        $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t rst=%b duty_value=%d pwm_out=%b"",
                 $time, rst, duty_value, pwm_out);
    end
endmodule",True,78,True,True,True,,0.0,,12.218264818191528,0.015112638473510742,"Design 8-bit resolution PWM generator with configurable duty cycle. Include testbench with duty cycles: 0%, 25%, 50%, 75%, 100%.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph LR
    CLK[Clock Input] --> CNT((8-bit Counter))
    RST[Reset] --> CNT
    
    DC[[Duty Cycle Register]] --> CMP((Comparator))
    CNT --> CMP
    
    DCV[Duty Value Input] --> DC
    
    CMP --> PWM[PWM Output]
    
    TB0[Test 0% DC] -.-> DC
    TB1[Test 25% DC] -.-> DC
    TB2[Test 50% DC] -.-> DC
    TB3[Test 75% DC] -.-> DC
    TB4[Test 100% DC] -.-> DC
    
    CLK --> CMP
    RST --> CMP
    
    style TB0 fill:#f9f,stroke:#333
    style TB1 fill:#f9f,stroke:#333
    style TB2 fill:#f9f,stroke:#333
    style TB3 fill:#f9f,stroke:#333
    style TB4 fill:#f9f,stroke:#333
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module pwm_gen (
    input wire clk,
    input wire rst,
    input wire [7:0] duty_value,
    output reg pwm_out
);

reg [7:0] counter;
reg [7:0] duty_reg;

always @(posedge clk or posedge rst) begin
    if (rst) begin
        counter <= 8'b0;
    end else begin
        counter <= counter + 1'b1;
    end
end

always @(posedge clk or posedge rst) begin
    if (rst) begin
        duty_reg <= 8'b0;
    end else begin
        duty_reg <= duty_value;
    end
end

always @(posedge clk or posedge rst) begin
    if (rst) begin
        pwm_out <= 1'b0;
    end else begin
        pwm_out <= (counter < duty_reg);
    end
end

endmodule

module testbench;
    reg clk;
    reg rst;
    reg [7:0] duty_value;
    wire pwm_out;

    pwm_gen dut (
        .clk(clk),
        .rst(rst),
        .duty_value(duty_value),
        .pwm_out(pwm_out)
    );

    initial begin
        $dumpfile(""pwm.vcd"");
        $dumpvars(0, testbench);

        clk = 1'b0;
        rst = 1'b1;
        duty_value = 8'd0;
        
        #20 rst = 1'b0;

        // Test 0% duty cycle
        #20 duty_value = 8'd0;
        
        // Test 25% duty cycle
        #256 duty_value = 8'd64;
        
        // Test 50% duty cycle
        #256 duty_value = 8'd128;
        
        // Test 75% duty cycle
        #256 duty_value = 8'd192;
        
        // Test 100% duty cycle
        #256 duty_value = 8'd255;
        
        #256 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t rst=%b duty_value=%d pwm_out=%b"", 
                 $time, rst, duty_value, pwm_out);
    end

endmodule",True,87,True,True,True,,0.0,,7.848942279815674,0.016324996948242188,prompt_only,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,Advanced Sequential,complex,"Design 8-bit resolution PWM generator with configurable duty cycle. Include testbench with duty cycles: 0%, 25%, 50%, 75%, 100%.",gpt-4o,"`timescale 1ns/1ps

module pwm_generator(
    input wire clk,
    input wire rst_n,
    input wire [7:0] duty_cycle,
    output reg pwm_out
);

    reg [7:0] counter;

    always @(posedge clk or negedge rst_n) begin
        if (!rst_n)
            counter <= 8'b00000000;
        else
            counter <= counter + 1'b1;
    end

    always @(posedge clk or negedge rst_n) begin
        if (!rst_n)
            pwm_out <= 1'b0;
        else
            pwm_out <= (counter < duty_cycle);
    end

endmodule

module testbench;
    reg clk, rst_n;
    reg [7:0] duty_cycle;
    wire pwm_out;

    pwm_generator dut (
        .clk(clk),
        .rst_n(rst_n),
        .duty_cycle(duty_cycle),
        .pwm_out(pwm_out)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 1'b0;
        rst_n = 1'b0;
        duty_cycle = 8'b00000000; // 0%

        #20 rst_n = 1'b1;
        #10 duty_cycle = 8'b01000000; // 25%
        #100 duty_cycle = 8'b10000000; // 50%
        #100 duty_cycle = 8'b11000000; // 75%
        #100 duty_cycle = 8'b11111111; // 100%
        #100 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b duty_cycle=%d pwm_out=%b"", 
                 $time, clk, rst_n, duty_cycle, pwm_out);
    end
endmodule",True,62,True,True,True,False,0.3,False,5.944896697998047,15.88518214225769,"graph TD
    CLK[Clock] --> COUNTER(Counter)
    RST[Reset] --> COUNTER
    COUNTER --> COMPARE(Comparator)
    DUTY[Duty Cycle Input] --> COMPARE
    COMPARE --> OUT_PWM[Output PWM]
    
    CLK --> TB[Testbench]
    TB --> DUTY
    TB --> CLK
    TB --> RST
    TB --> OUT_PWM

    subgraph Testbench
        TB0[Testbench for 0% Duty Cycle]
        TB0 --> DUTY0[0% Duty Cycle]
        TB0 --> CLK
        TB0 --> RST
        TB0 --> OUT_PWM
        
        TB1[Testbench for 25% Duty Cycle]
        TB1 --> DUTY25[25% Duty Cycle]
        TB1 --> CLK
        TB1 --> RST
        TB1 --> OUT_PWM
        
        TB2[Testbench for 50% Duty Cycle]
        TB2 --> DUTY50[50% Duty Cycle]
        TB2 --> CLK
        TB2 --> RST
        TB2 --> OUT_PWM
        
        TB3[Testbench for 75% Duty Cycle]
        TB3 --> DUTY75[75% Duty Cycle]
        TB3 --> CLK
        TB3 --> RST
        TB3 --> OUT_PWM
        
        TB4[Testbench for 100% Duty Cycle]
        TB4 --> DUTY100[100% Duty Cycle]
        TB4 --> CLK
        TB4 --> RST
        TB4 --> OUT_PWM
    end","`timescale 1ns/1ps

module pwm_controller(
    input wire clk,
    input wire rst,
    input wire [7:0] duty_cycle,
    output reg pwm_out
);

    reg [7:0] counter;
    
    always @(posedge clk or posedge rst) begin
        if (rst)
            counter <= 8'b0;
        else
            counter <= counter + 1'b1;
    end

    always @(posedge clk or posedge rst) begin
        if (rst)
            pwm_out <= 1'b0;
        else
            pwm_out <= (counter < duty_cycle) ? 1'b1 : 1'b0;
    end

endmodule

module testbench;
    reg clk, rst;
    reg [7:0] duty_cycle;
    wire pwm_out;

    pwm_controller dut (
        .clk(clk),
        .rst(rst),
        .duty_cycle(duty_cycle),
        .pwm_out(pwm_out)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 1'b0;
        rst = 1'b1;
        duty_cycle = 8'd0;

        #20 rst = 1'b0;
        #20 duty_cycle = 8'd0;  // Test 0% Duty Cycle
        #100 duty_cycle = 8'd64; // Test 25% Duty Cycle
        #100 duty_cycle = 8'd128; // Test 50% Duty Cycle
        #100 duty_cycle = 8'd192; // Test 75% Duty Cycle
        #100 duty_cycle = 8'd255; // Test 100% Duty Cycle
        #100 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t clk=%b rst=%b duty_cycle=%d pwm_out=%b"", 
                 $time, clk, rst, duty_cycle, pwm_out);
    end
endmodule",True,63,True,True,True,False,0.3,False,8.374948740005493,8.41538119316101,"Design 8-bit resolution PWM generator with configurable duty cycle. Include testbench with duty cycles: 0%, 25%, 50%, 75%, 100%.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph TD
    CLK[Clock] --> COUNTER(Counter)
    RST[Reset] --> COUNTER
    COUNTER --> COMPARE(Comparator)
    DUTY[Duty Cycle Input] --> COMPARE
    COMPARE --> OUT_PWM[Output PWM]
    
    CLK --> TB[Testbench]
    TB --> DUTY
    TB --> CLK
    TB --> RST
    TB --> OUT_PWM

    subgraph Testbench
        TB0[Testbench for 0% Duty Cycle]
        TB0 --> DUTY0[0% Duty Cycle]
        TB0 --> CLK
        TB0 --> RST
        TB0 --> OUT_PWM
        
        TB1[Testbench for 25% Duty Cycle]
        TB1 --> DUTY25[25% Duty Cycle]
        TB1 --> CLK
        TB1 --> RST
        TB1 --> OUT_PWM
        
        TB2[Testbench for 50% Duty Cycle]
        TB2 --> DUTY50[50% Duty Cycle]
        TB2 --> CLK
        TB2 --> RST
        TB2 --> OUT_PWM
        
        TB3[Testbench for 75% Duty Cycle]
        TB3 --> DUTY75[75% Duty Cycle]
        TB3 --> CLK
        TB3 --> RST
        TB3 --> OUT_PWM
        
        TB4[Testbench for 100% Duty Cycle]
        TB4 --> DUTY100[100% Duty Cycle]
        TB4 --> CLK
        TB4 --> RST
        TB4 --> OUT_PWM
    end
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module pwm_generator(
    input wire clk,
    input wire rst_n,
    input wire [7:0] duty_cycle,
    output reg pwm_out
);

    reg [7:0] counter;

    always @(posedge clk or negedge rst_n) begin
        if (!rst_n)
            counter <= 8'b00000000;
        else
            counter <= counter + 1'b1;
    end

    always @(posedge clk or negedge rst_n) begin
        if (!rst_n)
            pwm_out <= 1'b0;
        else
            pwm_out <= (counter < duty_cycle) ? 1'b1 : 1'b0;
    end

endmodule

module testbench;
    reg clk, rst_n;
    reg [7:0] duty_cycle;
    wire pwm_out;

    pwm_generator dut (
        .clk(clk),
        .rst_n(rst_n),
        .duty_cycle(duty_cycle),
        .pwm_out(pwm_out)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 1'b0;
        rst_n = 1'b0;
        duty_cycle = 8'd0;

        #20 rst_n = 1'b1;
        #100 duty_cycle = 8'd64;  // 25% Duty Cycle
        #100 duty_cycle = 8'd128; // 50% Duty Cycle
        #100 duty_cycle = 8'd192; // 75% Duty Cycle
        #100 duty_cycle = 8'd255; // 100% Duty Cycle
        #50 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b duty_cycle=%d pwm_out=%b"", 
                 $time, clk, rst_n, duty_cycle, pwm_out);
    end
endmodule",True,62,True,True,True,False,0.3,False,3.635380506515503,8.705134153366089,tie,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,Protocol,complex,"Design SPI master supporting mode 0 (CPOL=0, CPHA=0). Include SCLK generation, MOSI/MISO handling. Include testbench.",claude,"`timescale 1ns/1ps

module spi_master(
    input wire clk,
    input wire rst_n,
    input wire start,
    input wire [7:0] mosi_data,
    input wire miso,
    output reg sclk,
    output reg mosi,
    output reg cs_n,
    output reg busy,
    output reg [7:0] miso_data
);

reg [3:0] bit_count;
reg [7:0] mosi_shift;
reg [7:0] miso_shift;
reg [3:0] clk_div;

always @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
        sclk <= 1'b0;
        mosi <= 1'b0;
        cs_n <= 1'b1;
        busy <= 1'b0;
        bit_count <= 4'd0;
        mosi_shift <= 8'd0;
        miso_shift <= 8'd0;
        miso_data <= 8'd0;
        clk_div <= 4'd0;
    end
    else begin
        if (!busy && start) begin
            busy <= 1'b1;
            cs_n <= 1'b0;
            mosi_shift <= mosi_data;
            bit_count <= 4'd0;
        end
        else if (busy) begin
            clk_div <= clk_div + 1'b1;
            if (clk_div == 4'd0) begin
                sclk <= 1'b0;
                mosi <= mosi_shift[7];
            end
            else if (clk_div == 4'd7) begin
                sclk <= 1'b1;
                miso_shift <= {miso_shift[6:0], miso};
                if (bit_count == 4'd7) begin
                    busy <= 1'b0;
                    cs_n <= 1'b1;
                    miso_data <= {miso_shift[6:0], miso};
                end
                else begin
                    mosi_shift <= {mosi_shift[6:0], 1'b0};
                    bit_count <= bit_count + 1'b1;
                end
            end
        end
    end
end

endmodule

module testbench;
    reg clk;
    reg rst_n;
    reg start;
    reg [7:0] mosi_data;
    reg miso;
    wire sclk;
    wire mosi;
    wire cs_n;
    wire busy;
    wire [7:0] miso_data;

    spi_master dut (
        .clk(clk),
        .rst_n(rst_n),
        .start(start),
        .mosi_data(mosi_data),
        .miso(miso),
        .sclk(sclk),
        .mosi(mosi),
        .cs_n(cs_n),
        .busy(busy),
        .miso_data(miso_data)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 0;
        rst_n = 0;
        start = 0;
        mosi_data = 0;
        miso = 0;

        #20 rst_n = 1;
        #10 mosi_data = 8'hA5;
        #10 start = 1;
        #10 start = 0;
        
        // Generate MISO response
        #20;
        repeat(8) begin
            #64 miso = ~miso;
        end

        #200;
        
        // Second transfer
        mosi_data = 8'h5A;
        start = 1;
        #10 start = 0;
        
        #500 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t rst_n=%b start=%b mosi_data=%h miso=%b sclk=%b mosi=%b cs_n=%b busy=%b miso_data=%h"",
                 $time, rst_n, start, mosi_data, miso, sclk, mosi, cs_n, busy, miso_data);
    end
endmodule",True,127,True,True,True,True,0.7,True,13.207010984420776,8.089256048202515,"graph TD
    CLK[System Clock] --> DIVIDER(Clock Divider)
    RST[Reset] --> CTRL(SPI Control Logic)
    START[Start Transaction] --> CTRL
    
    DIVIDER --> SCLK_GEN(SCLK Generator)
    SCLK_GEN --> SCLK[SCLK Output]
    
    CTRL --> BIT_CNT[[Bit Counter]]
    CTRL --> TX_REG[[TX Shift Register]]
    CTRL --> RX_REG[[RX Shift Register]]
    
    TX_DATA[TX Data Input] --> TX_REG
    TX_REG --> MOSI[MOSI Output]
    
    MISO[MISO Input] --> RX_REG
    RX_REG --> RX_DATA[RX Data Output]
    
    CTRL --> BUSY[Busy Flag]
    
    TB_CLK[TB Clock] --> TB(Testbench Logic)
    TB_RST[TB Reset] --> TB
    TB --> TB_MISO[TB MISO Generator]
    TB --> TB_VERIFY{Verification Logic}
    
    SCLK --> TB
    MOSI --> TB
    TB_MISO --> MISO
    RX_DATA --> TB_VERIFY","`timescale 1ns/1ps

module spi_master (
    input wire clk,
    input wire rst_n,
    input wire start,
    input wire [7:0] tx_data,
    input wire miso,
    output reg sclk,
    output reg mosi,
    output reg busy,
    output reg [7:0] rx_data
);

reg [3:0] bit_count;
reg [7:0] tx_shift_reg;
reg [7:0] rx_shift_reg;
reg [3:0] clk_div;

always @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
        sclk <= 1'b0;
        clk_div <= 4'd0;
    end
    else begin
        clk_div <= clk_div + 1'b1;
        if (clk_div == 4'd8) begin
            clk_div <= 4'd0;
            sclk <= ~sclk;
        end
    end
end

always @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
        busy <= 1'b0;
        bit_count <= 4'd0;
        tx_shift_reg <= 8'd0;
        rx_shift_reg <= 8'd0;
        mosi <= 1'b0;
        rx_data <= 8'd0;
    end
    else begin
        if (start && !busy) begin
            busy <= 1'b1;
            bit_count <= 4'd7;
            tx_shift_reg <= tx_data;
            mosi <= tx_data[7];
        end
        else if (busy && clk_div == 4'd8) begin
            if (bit_count == 4'd0) begin
                busy <= 1'b0;
                rx_data <= rx_shift_reg;
            end
            else begin
                bit_count <= bit_count - 1'b1;
                tx_shift_reg <= {tx_shift_reg[6:0], 1'b0};
                rx_shift_reg <= {rx_shift_reg[6:0], miso};
                mosi <= tx_shift_reg[6];
            end
        end
    end
end

endmodule

module testbench;
    reg clk;
    reg rst_n;
    reg start;
    reg [7:0] tx_data;
    reg miso;
    wire sclk;
    wire mosi;
    wire busy;
    wire [7:0] rx_data;

    spi_master dut (
        .clk(clk),
        .rst_n(rst_n),
        .start(start),
        .tx_data(tx_data),
        .miso(miso),
        .sclk(sclk),
        .mosi(mosi),
        .busy(busy),
        .rx_data(rx_data)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 0;
        rst_n = 0;
        start = 0;
        tx_data = 8'h55;
        miso = 0;
        
        #20 rst_n = 1;
        #10 start = 1;
        #10 start = 0;
        
        #500 $finish;
    end

    always #5 clk = ~clk;

    always @(posedge sclk) begin
        miso <= ~miso;
    end

    initial begin
        $monitor(""Time=%0t busy=%b tx_data=%h rx_data=%h"", 
                 $time, busy, tx_data, rx_data);
    end
endmodule",True,117,True,True,True,False,0.4,False,16.51826047897339,8.674561738967896,"Design SPI master supporting mode 0 (CPOL=0, CPHA=0). Include SCLK generation, MOSI/MISO handling. Include testbench.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph TD
    CLK[System Clock] --> DIVIDER(Clock Divider)
    RST[Reset] --> CTRL(SPI Control Logic)
    START[Start Transaction] --> CTRL
    
    DIVIDER --> SCLK_GEN(SCLK Generator)
    SCLK_GEN --> SCLK[SCLK Output]
    
    CTRL --> BIT_CNT[[Bit Counter]]
    CTRL --> TX_REG[[TX Shift Register]]
    CTRL --> RX_REG[[RX Shift Register]]
    
    TX_DATA[TX Data Input] --> TX_REG
    TX_REG --> MOSI[MOSI Output]
    
    MISO[MISO Input] --> RX_REG
    RX_REG --> RX_DATA[RX Data Output]
    
    CTRL --> BUSY[Busy Flag]
    
    TB_CLK[TB Clock] --> TB(Testbench Logic)
    TB_RST[TB Reset] --> TB
    TB --> TB_MISO[TB MISO Generator]
    TB --> TB_VERIFY{Verification Logic}
    
    SCLK --> TB
    MOSI --> TB
    TB_MISO --> MISO
    RX_DATA --> TB_VERIFY
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

// SPI Master Module
module spi_master (
    input wire clk,
    input wire rst_n,
    input wire start,
    input wire [7:0] tx_data,
    input wire miso,
    output wire sclk,
    output wire mosi,
    output wire busy,
    output wire [7:0] rx_data
);

reg [3:0] bit_counter;
reg [7:0] tx_shift_reg;
reg [7:0] rx_shift_reg;
reg busy_reg;
reg sclk_reg;
reg [3:0] clk_divider;

assign sclk = sclk_reg;
assign mosi = tx_shift_reg[7];
assign rx_data = rx_shift_reg;
assign busy = busy_reg;

always @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
        bit_counter <= 4'd0;
        tx_shift_reg <= 8'd0;
        rx_shift_reg <= 8'd0;
        busy_reg <= 1'b0;
        sclk_reg <= 1'b0;
        clk_divider <= 4'd0;
    end
    else begin
        if (!busy_reg && start) begin
            busy_reg <= 1'b1;
            tx_shift_reg <= tx_data;
            bit_counter <= 4'd0;
        end
        else if (busy_reg) begin
            clk_divider <= clk_divider + 1'b1;
            if (clk_divider == 4'd7) begin
                sclk_reg <= ~sclk_reg;
                if (sclk_reg) begin
                    rx_shift_reg <= {rx_shift_reg[6:0], miso};
                end
                else begin
                    if (bit_counter == 4'd7)
                        busy_reg <= 1'b0;
                    else begin
                        tx_shift_reg <= {tx_shift_reg[6:0], 1'b0};
                        bit_counter <= bit_counter + 1'b1;
                    end
                end
            end
        end
    end
end

endmodule

// Testbench
module testbench;
    reg clk;
    reg rst_n;
    reg start;
    reg [7:0] tx_data;
    reg miso;
    wire sclk;
    wire mosi;
    wire busy;
    wire [7:0] rx_data;

    spi_master dut (
        .clk(clk),
        .rst_n(rst_n),
        .start(start),
        .tx_data(tx_data),
        .miso(miso),
        .sclk(sclk),
        .mosi(mosi),
        .busy(busy),
        .rx_data(rx_data)
    );

    initial begin
        $dumpfile(""spi_master.vcd"");
        $dumpvars(0, testbench);

        clk = 0;
        rst_n = 0;
        start = 0;
        tx_data = 0;
        miso = 0;

        #20 rst_n = 1;
        #20 tx_data = 8'hA5;
        #20 start = 1;
        #20 start = 0;

        // Generate MISO data
        repeat(64) begin
            #10 miso = $random;
        end

        #1000 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t rst_n=%b start=%b tx_data=%h rx_data=%h busy=%b"",
                 $time, rst_n, start, tx_data, rx_data, busy);
    end
endmodule",True,118,True,True,True,,0.0,,11.273548364639282,0.016048192977905273,mermaid_only,mermaid_only > prompt_only > combined,prompt_only > mermaid_only > combined
combined,Protocol,complex,"Design SPI master supporting mode 0 (CPOL=0, CPHA=0). Include SCLK generation, MOSI/MISO handling. Include testbench.",gpt-4o,"`timescale 1ns/1ps

module spi_master(
    input wire clk,
    input wire rst_n,
    input wire start,
    input wire [7:0] data_in,
    output reg sclk,
    output reg mosi,
    input wire miso,
    output reg [7:0] data_out,
    output reg done
);
    reg [2:0] bit_count;
    reg [7:0] shift_reg;
    reg sclk_enable;

    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            sclk <= 1'b0;
            sclk_enable <= 1'b0;
            bit_count <= 3'b000;
            done <= 1'b0;
        end else if (start) begin
            sclk_enable <= 1'b1;
            shift_reg <= data_in;
            bit_count <= 3'b000;
            done <= 1'b0;
        end else if (sclk_enable) begin
            sclk <= ~sclk;
            if (sclk) begin
                mosi <= shift_reg[7];
                shift_reg <= {shift_reg[6:0], miso};
                bit_count <= bit_count + 1'b1;
                if (bit_count == 3'b111) begin
                    sclk_enable <= 1'b0;
                    data_out <= shift_reg;
                    done <= 1'b1;
                end
            end
        end
    end
endmodule

module testbench;
    reg clk, rst_n, start;
    reg [7:0] data_in;
    wire sclk, mosi, done;
    reg miso;
    wire [7:0] data_out;
    
    spi_master dut (
        .clk(clk),
        .rst_n(rst_n),
        .start(start),
        .data_in(data_in),
        .sclk(sclk),
        .mosi(mosi),
        .miso(miso),
        .data_out(data_out),
        .done(done)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst_n = 1'b0;
        start = 1'b0;
        miso = 1'b0;
        data_in = 8'b10101010;
        
        #20 rst_n = 1'b1;
        #10 start = 1'b1;
        #10 start = 1'b0;
        #160 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b start=%b miso=%b mosi=%b data_out=%b done=%b"", 
                 $time, clk, rst_n, start, miso, mosi, data_out, done);
    end
endmodule",True,86,True,True,True,False,0.3,False,9.430885314941406,14.554464101791382,"graph LR
    CLK[Clock] --> SCLK_GEN(SCLK Generator)
    RST[Reset] --> SCLK_GEN
    SCLK_GEN --> SCLK[SCLK Signal]
    
    MOSI_IN[MOSI Input] --> SHIFT_REG(Shift Register)
    SHIFT_REG --> MOSI_OUT[MOSI Output]
    SCLK --> SHIFT_REG
    MISO_IN[MISO Input] --> SHIFT_REG
    SHIFT_REG --> MISO_OUT[MISO Output]
    
    SPI_CTRL(SPI Control) --> SHIFT_REG
    CLK --> SPI_CTRL
    RST --> SPI_CTRL
    
    TESTBENCH[Testbench] --> CLK
    TESTBENCH --> RST
    TESTBENCH --> MOSI_IN
    MISO_OUT --> TESTBENCH
    MOSI_OUT --> TESTBENCH","`timescale 1ns/1ps

module sclk_generator(
    input wire clk,
    input wire rst,
    output reg sclk
);
    always @(posedge clk or posedge rst) begin
        if (rst)
            sclk <= 1'b0;
        else
            sclk <= ~sclk;
    end
endmodule

module shift_register(
    input wire sclk,
    input wire mosi_in,
    input wire miso_in,
    input wire spi_ctrl,
    output reg mosi_out,
    output reg miso_out
);
    reg [7:0] shift_reg;

    always @(posedge sclk) begin
        if (spi_ctrl) begin
            shift_reg <= {shift_reg[6:0], mosi_in};
            mosi_out <= shift_reg[7];
            miso_out <= shift_reg[0];
        end
    end
endmodule

module spi_control(
    input wire clk,
    input wire rst,
    output reg spi_ctrl
);
    always @(posedge clk or posedge rst) begin
        if (rst)
            spi_ctrl <= 1'b0;
        else
            spi_ctrl <= 1'b1;
    end
endmodule

module testbench;
    reg clk, rst, mosi_in;
    wire mosi_out, miso_out;
    wire sclk, spi_ctrl;

    sclk_generator sclk_gen (
        .clk(clk),
        .rst(rst),
        .sclk(sclk)
    );

    spi_control spi_ctrl_inst (
        .clk(clk),
        .rst(rst),
        .spi_ctrl(spi_ctrl)
    );

    shift_register shift_reg (
        .sclk(sclk),
        .mosi_in(mosi_in),
        .miso_in(1'b0), // Assuming MISO input is tied to 0 for this test
        .spi_ctrl(spi_ctrl),
        .mosi_out(mosi_out),
        .miso_out(miso_out)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst = 1'b1;
        mosi_in = 1'b0;
        
        #20 rst = 1'b0;
        #10 mosi_in = 1'b1;
        #100 mosi_in = 1'b0;
        #50 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t clk=%b rst=%b mosi_in=%b mosi_out=%b miso_out=%b"", 
                 $time, clk, rst, mosi_in, mosi_out, miso_out);
    end
endmodule",True,94,True,True,True,True,0.9,True,8.688701152801514,11.508179664611816,"Design SPI master supporting mode 0 (CPOL=0, CPHA=0). Include SCLK generation, MOSI/MISO handling. Include testbench.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph LR
    CLK[Clock] --> SCLK_GEN(SCLK Generator)
    RST[Reset] --> SCLK_GEN
    SCLK_GEN --> SCLK[SCLK Signal]
    
    MOSI_IN[MOSI Input] --> SHIFT_REG(Shift Register)
    SHIFT_REG --> MOSI_OUT[MOSI Output]
    SCLK --> SHIFT_REG
    MISO_IN[MISO Input] --> SHIFT_REG
    SHIFT_REG --> MISO_OUT[MISO Output]
    
    SPI_CTRL(SPI Control) --> SHIFT_REG
    CLK --> SPI_CTRL
    RST --> SPI_CTRL
    
    TESTBENCH[Testbench] --> CLK
    TESTBENCH --> RST
    TESTBENCH --> MOSI_IN
    MISO_OUT --> TESTBENCH
    MOSI_OUT --> TESTBENCH
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module sclk_generator(
    input wire clk,
    input wire rst,
    output reg sclk
);
    always @(posedge clk or posedge rst) begin
        if (rst)
            sclk <= 1'b0;
        else
            sclk <= ~sclk;
    end
endmodule

module shift_register(
    input wire sclk,
    input wire mosi_in,
    input wire miso_in,
    output reg mosi_out,
    output reg miso_out,
    input wire [7:0] data_in,
    output reg [7:0] data_out
);
    reg [7:0] shift_reg;

    always @(posedge sclk) begin
        shift_reg <= {shift_reg[6:0], mosi_in};
        mosi_out <= shift_reg[7];
        miso_out <= miso_in;
        data_out <= shift_reg;
    end
endmodule

module spi_control(
    input wire clk,
    input wire rst,
    output reg [7:0] data_in,
    input wire [7:0] data_out
);
    always @(posedge clk or posedge rst) begin
        if (rst)
            data_in <= 8'b00000000;
        else
            data_in <= data_out; // Example logic
    end
endmodule

module spi_master(
    input wire clk,
    input wire rst,
    input wire mosi_in,
    input wire miso_in,
    output wire mosi_out,
    output wire miso_out
);
    wire sclk;
    wire [7:0] data_in;
    wire [7:0] data_out;

    sclk_generator sclk_gen(
        .clk(clk),
        .rst(rst),
        .sclk(sclk)
    );

    shift_register shift_reg(
        .sclk(sclk),
        .mosi_in(mosi_in),
        .miso_in(miso_in),
        .mosi_out(mosi_out),
        .miso_out(miso_out),
        .data_in(data_in),
        .data_out(data_out)
    );

    spi_control spi_ctrl(
        .clk(clk),
        .rst(rst),
        .data_in(data_in),
        .data_out(data_out)
    );
endmodule

module testbench;
    reg clk;
    reg rst;
    reg mosi_in;
    wire mosi_out;
    reg miso_in;
    wire miso_out;

    spi_master dut (
        .clk(clk),
        .rst(rst),
        .mosi_in(mosi_in),
        .mosi_out(mosi_out),
        .miso_in(miso_in),
        .miso_out(miso_out)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 1'b0;
        rst = 1'b1;
        mosi_in = 1'b0;
        miso_in = 1'b0;

        #20 rst = 1'b0;
        #10 mosi_in = 1'b1;
        #100 mosi_in = 1'b0;
        #50 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t clk=%b rst=%b mosi_in=%b mosi_out=%b miso_in=%b miso_out=%b"",
                 $time, clk, rst, mosi_in, mosi_out, miso_in, miso_out);
    end
endmodule",True,123,True,True,True,True,0.9,True,26.489444255828857,16.772748470306396,prompt_only,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
