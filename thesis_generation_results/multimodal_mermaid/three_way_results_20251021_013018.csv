circuit_name,category,complexity,original_prompt,model,prompt_only_verilog,prompt_only_generation_success,prompt_only_lines_of_code,prompt_only_has_testbench,prompt_only_compilation_success,prompt_only_simulation_success,prompt_only_vae_verdict,prompt_only_vae_confidence,prompt_only_consensus_anomalous,prompt_only_generation_time,prompt_only_simulation_time,mermaid_only_mermaid,mermaid_only_verilog,mermaid_only_generation_success,mermaid_only_lines_of_code,mermaid_only_has_testbench,mermaid_only_compilation_success,mermaid_only_simulation_success,mermaid_only_vae_verdict,mermaid_only_vae_confidence,mermaid_only_consensus_anomalous,mermaid_only_generation_time,mermaid_only_simulation_time,combined_prompt,combined_verilog,combined_generation_success,combined_lines_of_code,combined_has_testbench,combined_compilation_success,combined_simulation_success,combined_vae_verdict,combined_vae_confidence,combined_consensus_anomalous,combined_generation_time,combined_simulation_time,best_approach,correctness_ranking,simulation_ranking
combined,Combinational,simple,"Design a 2-to-1 multiplexer with inputs a, b, select sel, and output out. Include testbench testing all combinations.",claude,"`timescale 1ns/1ps

module mux2to1 (
    input wire a,
    input wire b,
    input wire sel,
    output reg out
);

always @(*) begin
    if (sel)
        out = b;
    else
        out = a;
end

endmodule

module testbench;
    reg a, b, sel;
    wire out;
    
    mux2to1 dut (
        .a(a),
        .b(b),
        .sel(sel),
        .out(out)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        // Test all combinations
        a = 0; b = 0; sel = 0; #10;
        a = 0; b = 0; sel = 1; #10;
        a = 0; b = 1; sel = 0; #10;
        a = 0; b = 1; sel = 1; #10;
        a = 1; b = 0; sel = 0; #10;
        a = 1; b = 0; sel = 1; #10;
        a = 1; b = 1; sel = 0; #10;
        a = 1; b = 1; sel = 1; #10;
        
        $finish;
    end
    
    initial begin
        $monitor(""Time=%0t a=%b b=%b sel=%b out=%b"", 
                 $time, a, b, sel, out);
    end
endmodule",True,51,True,True,True,False,0.4,False,4.99103569984436,6.383342027664185,,,False,0,False,False,False,,0.0,,90.09136772155762,0.0,,,False,0,False,False,False,,0.0,,0.0,0.0,prompt_only,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,Combinational,simple,"Design a 2-to-1 multiplexer with inputs a, b, select sel, and output out. Include testbench testing all combinations.",gpt-4o,"`timescale 1ns/1ps

module mux_2to1(
    input wire a,
    input wire b,
    input wire sel,
    output reg out
);

always @(*) begin
    if (sel == 1'b0)
        out = a;
    else
        out = b;
end

endmodule

module testbench;
    reg a, b, sel;
    wire out;

    mux_2to1 dut (
        .a(a),
        .b(b),
        .sel(sel),
        .out(out)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        a = 1'b0; b = 1'b0; sel = 1'b0;
        #10 sel = 1'b1;
        #10 b = 1'b1;
        #10 a = 1'b1;
        #10 sel = 1'b0;
        #10 $finish;
    end

    initial begin
        $monitor(""Time=%0t a=%b b=%b sel=%b out=%b"", 
                 $time, a, b, sel, out);
    end
endmodule",True,46,True,True,True,False,0.4,False,4.108471870422363,8.457440614700317,"graph LR
    SEL[Select (sel)] --> MUX{2-to-1 MUX}
    A[Input (a)] --> MUX
    B[Input (b)] --> MUX
    MUX --> OUT[Output (out)]
    
    %% Testbench Section
    subgraph Testbench
        TB_A[Test Input (a)]
        TB_B[Test Input (b)]
        TB_SEL[Test Select (sel)]
        TB_OUT[Test Output (out)]
        
        TB_A --> MUX
        TB_B --> MUX
        TB_SEL --> MUX
        MUX --> TB_OUT
    end","`timescale 1ns/1ps

module mux_2to1 (
    input wire a,
    input wire b,
    input wire sel,
    output reg out
);

always @(*) begin
    if (sel)
        out = b;
    else
        out = a;
end

endmodule

module testbench;
    reg a, b, sel;
    wire out;
    
    mux_2to1 dut (
        .a(a),
        .b(b),
        .sel(sel),
        .out(out)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        a = 1'b0; b = 1'b0; sel = 1'b0;
        
        #10 a = 1'b1;
        #10 b = 1'b1;
        #10 sel = 1'b1;
        #10 a = 1'b0;
        #10 b = 1'b0;
        #10 sel = 1'b0;
        #10 $finish;
    end
    
    initial begin
        $monitor(""Time=%0t a=%b b=%b sel=%b out=%b"", 
                 $time, a, b, sel, out);
    end
endmodule",True,49,True,True,True,False,0.4,False,5.959235191345215,10.25684928894043,"Design a 2-to-1 multiplexer with inputs a, b, select sel, and output out. Include testbench testing all combinations.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph LR
    SEL[Select (sel)] --> MUX{2-to-1 MUX}
    A[Input (a)] --> MUX
    B[Input (b)] --> MUX
    MUX --> OUT[Output (out)]
    
    %% Testbench Section
    subgraph Testbench
        TB_A[Test Input (a)]
        TB_B[Test Input (b)]
        TB_SEL[Test Select (sel)]
        TB_OUT[Test Output (out)]
        
        TB_A --> MUX
        TB_B --> MUX
        TB_SEL --> MUX
        MUX --> TB_OUT
    end
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module mux_2to1(
    input wire a,
    input wire b,
    input wire sel,
    output wire out
);

assign out = sel ? b : a;

endmodule

module testbench;
    reg a, b, sel;
    wire out;

    mux_2to1 dut (
        .a(a),
        .b(b),
        .sel(sel),
        .out(out)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        a = 0; b = 0; sel = 0;
        #10 sel = 1;
        #10 b = 1; sel = 0;
        #10 sel = 1;
        #10 a = 1; b = 0; sel = 0;
        #10 sel = 1;
        #10 b = 1; sel = 0;
        #10 sel = 1;
        #10 $finish;
    end

    initial begin
        $monitor(""Time=%0t a=%b b=%b sel=%b out=%b"", $time, a, b, sel, out);
    end
endmodule",True,43,True,True,True,False,0.4,False,4.273071527481079,14.436059951782227,tie,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,Sequential,simple,"Create a D flip-flop with clock, reset, input d, and output q. Include testbench with timing verification.",claude,"`timescale 1ns/1ps

module dff(
    input wire clk,
    input wire rst_n,
    input wire d,
    output reg q
);

always @(posedge clk or negedge rst_n) begin
    if (!rst_n)
        q <= 1'b0;
    else
        q <= d;
end

endmodule

module testbench;
    reg clk, rst_n, d;
    wire q;
    
    dff dut (
        .clk(clk),
        .rst_n(rst_n),
        .d(d),
        .q(q)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst_n = 1'b0;
        d = 1'b0;
        
        #20 rst_n = 1'b1;
        #10 d = 1'b1;
        #10 d = 1'b0;
        #10 d = 1'b1;
        #20 rst_n = 1'b0;
        #20 rst_n = 1'b1;
        #50 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b d=%b q=%b"", 
                 $time, clk, rst_n, d, q);
    end
endmodule",True,53,True,True,True,True,0.7,True,4.606540203094482,6.826668977737427,"graph LR
    CLK[Clock] --> DFF[[D Flip-Flop]]
    RST[Reset] --> DFF
    D[Input D] --> DFF
    DFF --> Q[Output Q]
    TB[Testbench] --> |Clock Gen|CLK
    TB --> |Reset Ctrl|RST
    TB --> |Test Vectors|D
    Q --> |Verify|CHCK{Timing Check}
    CHCK --> |Pass/Fail|RES[Results]
    CLK --> |Setup/Hold|CHCK
    D --> |Setup/Hold|CHCK","`timescale 1ns/1ps

module dff (
    input wire clk,
    input wire rst,
    input wire d,
    output reg q
);

always @(posedge clk or posedge rst) begin
    if (rst)
        q <= 1'b0;
    else
        q <= d;
end

endmodule

module testbench;
    reg clk, rst, d;
    wire q;
    
    dff dut (
        .clk(clk),
        .rst(rst),
        .d(d),
        .q(q)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 0;
        rst = 1;
        d = 0;
        
        #10 rst = 0;
        
        // Test vector sequence
        #10 d = 1;
        #10 d = 0;
        #10 d = 1;
        #10 d = 1;
        
        // Test reset during operation
        #10 rst = 1;
        #10 rst = 0;
        
        #20 $finish;
    end
    
    always #5 clk = ~clk;
    
    // Setup and hold time checks
    specify
        $setup(d, posedge clk, 2);
        $hold(posedge clk, d, 1);
    endspecify
    
    initial begin
        $monitor(""Time=%0t clk=%b rst=%b d=%b q=%b"",
                 $time, clk, rst, d, q);
    end
endmodule",True,65,True,True,True,True,0.7,True,8.717862129211426,7.0525407791137695,"Create a D flip-flop with clock, reset, input d, and output q. Include testbench with timing verification.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph LR
    CLK[Clock] --> DFF[[D Flip-Flop]]
    RST[Reset] --> DFF
    D[Input D] --> DFF
    DFF --> Q[Output Q]
    TB[Testbench] --> |Clock Gen|CLK
    TB --> |Reset Ctrl|RST
    TB --> |Test Vectors|D
    Q --> |Verify|CHCK{Timing Check}
    CHCK --> |Pass/Fail|RES[Results]
    CLK --> |Setup/Hold|CHCK
    D --> |Setup/Hold|CHCK
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module dff (
    input wire clk,
    input wire rst,
    input wire d,
    output reg q
);

always @(posedge clk or posedge rst) begin
    if (rst)
        q <= 1'b0;
    else
        q <= d;
end

endmodule

module testbench;
    reg clk, rst, d;
    wire q;
    reg timing_error;
    time last_data_change, last_clock_edge;
    parameter SETUP_TIME = 2;
    parameter HOLD_TIME = 1;
    
    dff dut (
        .clk(clk),
        .rst(rst),
        .d(d),
        .q(q)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        timing_error = 0;
        clk = 0;
        rst = 1;
        d = 0;
        
        #10 rst = 0;
        
        // Test vector 1
        #5 d = 1;
        #10 d = 0;
        
        // Test vector 2
        #10 d = 1;
        #15 d = 0;
        
        // Reset test
        #10 rst = 1;
        #5 rst = 0;
        
        #20 $finish;
    end
    
    always #5 clk = ~clk;
    
    // Timing check
    always @(d) begin
        last_data_change = $time;
    end
    
    always @(posedge clk) begin
        last_clock_edge = $time;
        if ((last_clock_edge - last_data_change) < SETUP_TIME) begin
            $display(""Setup violation at time %0t"", $time);
            timing_error = 1;
        end
    end
    
    always @(posedge clk) begin
        #HOLD_TIME;
        if ($time - last_data_change < HOLD_TIME) begin
            $display(""Hold violation at time %0t"", $time);
            timing_error = 1;
        end
    end
    
    initial begin
        $monitor(""Time=%0t clk=%b rst=%b d=%b q=%b"", 
                 $time, clk, rst, d, q);
    end
endmodule",True,87,True,True,True,False,0.3,False,8.296040534973145,6.814727544784546,combined,combined > prompt_only > mermaid_only,prompt_only > mermaid_only > combined
combined,Sequential,simple,"Create a D flip-flop with clock, reset, input d, and output q. Include testbench with timing verification.",gpt-4o,"`timescale 1ns/1ps

module d_flip_flop(
    input wire clk,
    input wire rst_n,
    input wire d,
    output reg q
);

always @(posedge clk or negedge rst_n) begin
    if (!rst_n)
        q <= 1'b0;
    else
        q <= d;
end

endmodule

module testbench;
    reg clk, rst_n, d;
    wire q;
    
    d_flip_flop dut (
        .clk(clk),
        .rst_n(rst_n),
        .d(d),
        .q(q)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst_n = 1'b0;
        d = 1'b0;
        
        #20 rst_n = 1'b1;
        #10 d = 1'b1;
        #10 d = 1'b0;
        #10 d = 1'b1;
        #10 d = 1'b0;
        #20 rst_n = 1'b0;
        #20 rst_n = 1'b1;
        #50 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b d=%b q=%b"", 
                 $time, clk, rst_n, d, q);
    end
endmodule",True,54,True,True,True,True,0.7,True,2.9269216060638428,14.75184416770935,"graph TD
    CLK[Clock] --> DFF[[D Flip-Flop]]
    RST[Reset] --> DFF
    D[Input D] --> DFF
    DFF --> Q[Output Q]
    
    subgraph Testbench
        CLK --> TB[Timing Verification]
        RST --> TB
        D --> TB
        Q --> TB
    end","`timescale 1ns/1ps

module dff(
    input wire clk,
    input wire rst,
    input wire d,
    output reg q
);

always @(posedge clk or posedge rst) begin
    if (rst)
        q <= 1'b0;
    else
        q <= d;
end

endmodule

module testbench;
    reg clk, rst, d;
    wire q;

    dff dut (
        .clk(clk),
        .rst(rst),
        .d(d),
        .q(q)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 1'b0;
        rst = 1'b0;
        d = 1'b0;

        #10 rst = 1'b1;
        #10 rst = 1'b0;
        #10 d = 1'b1;
        #20 d = 1'b0;
        #30 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t clk=%b rst=%b d=%b q=%b"", 
                 $time, clk, rst, d, q);
    end
endmodule",True,51,True,True,True,False,0.3,False,7.059382915496826,13.409943103790283,"Create a D flip-flop with clock, reset, input d, and output q. Include testbench with timing verification.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph TD
    CLK[Clock] --> DFF[[D Flip-Flop]]
    RST[Reset] --> DFF
    D[Input D] --> DFF
    DFF --> Q[Output Q]
    
    subgraph Testbench
        CLK --> TB[Timing Verification]
        RST --> TB
        D --> TB
        Q --> TB
    end
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module d_flip_flop(
    input wire clk,
    input wire rst,
    input wire d,
    output reg q
);

always @(posedge clk or posedge rst) begin
    if (rst)
        q <= 1'b0;
    else
        q <= d;
end

endmodule

module testbench;
    reg clk, rst, d;
    wire q;
    
    d_flip_flop dut (
        .clk(clk),
        .rst(rst),
        .d(d),
        .q(q)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst = 1'b0;
        d = 1'b0;
        
        #20 rst = 1'b1;
        #10 rst = 1'b0;
        #10 d = 1'b1;
        #10 d = 1'b0;
        #20 d = 1'b1;
        #10 rst = 1'b1;
        #10 rst = 1'b0;
        #50 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t clk=%b rst=%b d=%b q=%b"", 
                 $time, clk, rst, d, q);
    end
endmodule",True,54,True,True,True,True,0.7,True,3.6337244510650635,12.985138416290283,mermaid_only,mermaid_only > prompt_only > combined,prompt_only > mermaid_only > combined
combined,Sequential,simple,"Design a 4-bit synchronous counter with clock, reset, enable, and count[3:0]. Include testbench.",claude,"`timescale 1ns/1ps

module counter(
    input wire clk,
    input wire rst_n,
    input wire enable,
    output reg [3:0] count
);

always @(posedge clk or negedge rst_n) begin
    if (!rst_n)
        count <= 4'b0000;
    else if (enable)
        count <= count + 1'b1;
end

endmodule

module testbench;
    reg clk, rst_n, enable;
    wire [3:0] count;
    
    counter dut (
        .clk(clk),
        .rst_n(rst_n),
        .enable(enable),
        .count(count)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst_n = 1'b0;
        enable = 1'b0;
        
        #20 rst_n = 1'b1;
        #10 enable = 1'b1;
        #100 enable = 1'b0;
        #20 rst_n = 1'b0;
        #20 rst_n = 1'b1;
        #50 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b enable=%b count=%d"", 
                 $time, clk, rst_n, enable, count);
    end
endmodule",True,52,True,True,True,False,0.3,False,4.908382892608643,7.926369905471802,"graph TD
    CLK[Clock] --> CNT[[Counter Register]]
    RST[Reset] --> CNT
    EN[Enable] --> CTRL(Control Logic)
    CNT --> INC(Increment Logic)
    INC --> MUX{Reset or Inc}
    RST --> MUX
    MUX --> CNT
    CNT --> OUT[count[3:0]]
    
    TB1[Testbench Stimulus] --> CLK
    TB2[Testbench Stimulus] --> RST
    TB3[Testbench Stimulus] --> EN
    OUT --> TB4[Testbench Monitor]
    CNT --> TB4","`timescale 1ns/1ps

module counter(
    input wire clk,
    input wire rst_n,
    input wire enable,
    output reg [3:0] count
);

wire [3:0] next_count;

assign next_count = (!rst_n) ? 4'b0000 : (count + 1'b1);

always @(posedge clk or negedge rst_n) begin
    if (!rst_n)
        count <= 4'b0000;
    else if (enable)
        count <= next_count;
end

endmodule

module testbench;
    reg clk, rst_n, enable;
    wire [3:0] count;
    
    counter dut (
        .clk(clk),
        .rst_n(rst_n),
        .enable(enable),
        .count(count)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst_n = 1'b0;
        enable = 1'b0;
        
        #20 rst_n = 1'b1;
        #10 enable = 1'b1;
        #100 enable = 1'b0;
        #20 rst_n = 1'b0;
        #20 rst_n = 1'b1;
        #50 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b enable=%b count=%h"", 
                 $time, clk, rst_n, enable, count);
    end
endmodule",True,56,True,True,True,True,0.7,True,9.05437970161438,7.253486633300781,"Design a 4-bit synchronous counter with clock, reset, enable, and count[3:0]. Include testbench.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph TD
    CLK[Clock] --> CNT[[Counter Register]]
    RST[Reset] --> CNT
    EN[Enable] --> CTRL(Control Logic)
    CNT --> INC(Increment Logic)
    INC --> MUX{Reset or Inc}
    RST --> MUX
    MUX --> CNT
    CNT --> OUT[count[3:0]]
    
    TB1[Testbench Stimulus] --> CLK
    TB2[Testbench Stimulus] --> RST
    TB3[Testbench Stimulus] --> EN
    OUT --> TB4[Testbench Monitor]
    CNT --> TB4
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module counter(
    input wire clk,
    input wire rst_n,
    input wire enable,
    output reg [3:0] count
);

wire [3:0] inc_value;
wire [3:0] next_value;

// Increment Logic
assign inc_value = count + 1'b1;

// Control Logic & MUX
assign next_value = (!rst_n) ? 4'b0000 : 
                    (enable) ? inc_value : count;

// Counter Register
always @(posedge clk or negedge rst_n) begin
    if (!rst_n)
        count <= 4'b0000;
    else
        count <= next_value;
end

endmodule

module testbench;
    reg clk, rst_n, enable;
    wire [3:0] count;
    
    counter dut (
        .clk(clk),
        .rst_n(rst_n),
        .enable(enable),
        .count(count)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst_n = 1'b0;
        enable = 1'b0;
        
        #20 rst_n = 1'b1;
        #10 enable = 1'b1;
        #160 enable = 1'b0;
        #20 rst_n = 1'b0;
        #20 rst_n = 1'b1;
        #50 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t rst_n=%b enable=%b count=%h"", 
                 $time, rst_n, enable, count);
    end
endmodule",True,63,True,True,True,True,0.8,True,5.855032920837402,7.694042205810547,prompt_only,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,Sequential,simple,"Design a 4-bit synchronous counter with clock, reset, enable, and count[3:0]. Include testbench.",gpt-4o,"`timescale 1ns/1ps

module counter(
    input wire clk,
    input wire rst_n,
    input wire enable,
    output reg [3:0] count
);

always @(posedge clk or negedge rst_n) begin
    if (!rst_n)
        count <= 4'b0000;
    else if (enable)
        count <= count + 1'b1;
end

endmodule

module testbench;
    reg clk, rst_n, enable;
    wire [3:0] count;
    
    counter dut (
        .clk(clk),
        .rst_n(rst_n),
        .enable(enable),
        .count(count)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst_n = 1'b0;
        enable = 1'b0;
        
        #20 rst_n = 1'b1;
        #10 enable = 1'b1;
        #100 enable = 1'b0;
        #20 rst_n = 1'b0;
        #20 rst_n = 1'b1;
        #50 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b enable=%b count=%d"", 
                 $time, clk, rst_n, enable, count);
    end
endmodule",True,52,True,True,True,False,0.3,False,2.8065378665924072,8.796569585800171,"graph LR
    CLK[Clock] --> COUNTER(Counter Logic)
    RST[Reset] --> COUNTER
    EN[Enable] --> COUNTER
    COUNTER --> COUNT[[Count[3:0]]]
    subgraph Testbench
        TB_CLK[Clock] --> TB_COUNTER
        TB_RST[Reset] --> TB_COUNTER
        TB_EN[Enable] --> TB_COUNTER
        TB_COUNTER --> TB_COUNT[[Count[3:0]]]
    end","`timescale 1ns/1ps

module counter(
    input wire clk,
    input wire rst,
    input wire enable,
    output reg [3:0] count
);

always @(posedge clk or posedge rst) begin
    if (rst)
        count <= 4'b0000;
    else if (enable)
        count <= count + 1'b1;
end

endmodule

module testbench;
    reg clk, rst, enable;
    wire [3:0] count;
    
    counter dut (
        .clk(clk),
        .rst(rst),
        .enable(enable),
        .count(count)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst = 1'b1;
        enable = 1'b0;
        
        #20 rst = 1'b0;
        #10 enable = 1'b1;
        #100 enable = 1'b0;
        #20 rst = 1'b1;
        #20 rst = 1'b0;
        #50 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t clk=%b rst=%b enable=%b count=%d"", 
                 $time, clk, rst, enable, count);
    end
endmodule",True,52,True,True,True,False,0.3,False,5.091269493103027,12.200899362564087,"Design a 4-bit synchronous counter with clock, reset, enable, and count[3:0]. Include testbench.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph LR
    CLK[Clock] --> COUNTER(Counter Logic)
    RST[Reset] --> COUNTER
    EN[Enable] --> COUNTER
    COUNTER --> COUNT[[Count[3:0]]]
    subgraph Testbench
        TB_CLK[Clock] --> TB_COUNTER
        TB_RST[Reset] --> TB_COUNTER
        TB_EN[Enable] --> TB_COUNTER
        TB_COUNTER --> TB_COUNT[[Count[3:0]]]
    end
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module counter(
    input wire clk,
    input wire rst,
    input wire enable,
    output reg [3:0] count
);

always @(posedge clk or posedge rst) begin
    if (rst)
        count <= 4'b0000;
    else if (enable)
        count <= count + 1'b1;
end

endmodule

module testbench;
    reg clk, rst, enable;
    wire [3:0] count;
    
    counter dut (
        .clk(clk),
        .rst(rst),
        .enable(enable),
        .count(count)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst = 1'b0;
        enable = 1'b0;
        
        #20 rst = 1'b1;
        #10 rst = 1'b0;
        #10 enable = 1'b1;
        #100 enable = 1'b0;
        #20 rst = 1'b1;
        #20 rst = 1'b0;
        #50 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t clk=%b rst=%b enable=%b count=%d"", 
                 $time, clk, rst, enable, count);
    end
endmodule",True,53,True,True,True,False,0.3,False,3.0711629390716553,9.386944770812988,tie,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,Combinational,simple,"Create a full adder with inputs a, b, cin and outputs sum, cout. Include testbench with all 8 cases.",claude,"`timescale 1ns/1ps

module full_adder(
    input wire a,
    input wire b, 
    input wire cin,
    output wire sum,
    output wire cout
);

assign sum = a ^ b ^ cin;
assign cout = (a & b) | (b & cin) | (a & cin);

endmodule

module testbench;
    reg a, b, cin;
    wire sum, cout;
    
    full_adder dut(
        .a(a),
        .b(b),
        .cin(cin),
        .sum(sum),
        .cout(cout)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        // Test all 8 cases
        {a, b, cin} = 3'b000; #10;
        {a, b, cin} = 3'b001; #10;
        {a, b, cin} = 3'b010; #10;
        {a, b, cin} = 3'b011; #10;
        {a, b, cin} = 3'b100; #10;
        {a, b, cin} = 3'b101; #10;
        {a, b, cin} = 3'b110; #10;
        {a, b, cin} = 3'b111; #10;
        
        $finish;
    end
    
    initial begin
        $monitor(""Time=%0t a=%b b=%b cin=%b sum=%b cout=%b"",
                 $time, a, b, cin, sum, cout);
    end
endmodule",True,49,True,True,True,False,0.4,False,4.8631932735443115,7.137166738510132,"graph LR
    A[Input A] --> FA((Full Adder))
    B[Input B] --> FA
    CIN[Carry In] --> FA
    FA --> SUM[Sum Output]
    FA --> COUT[Carry Out]
    TB[Test Cases] --> |Case 0: 000| TV{Test Vector}
    TB --> |Case 1: 001| TV
    TB --> |Case 2: 010| TV
    TB --> |Case 3: 011| TV
    TB --> |Case 4: 100| TV
    TB --> |Case 5: 101| TV
    TB --> |Case 6: 110| TV
    TB --> |Case 7: 111| TV
    TV --> |A| FA
    TV --> |B| FA
    TV --> |Cin| FA
    FA --> RES[[Results]]
    SUM --> RES
    COUT --> RES","`timescale 1ns/1ps

module full_adder(
    input wire clk,
    input wire rst_n,
    input wire a,
    input wire b,
    input wire cin,
    output reg sum,
    output reg cout
);

always @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
        sum <= 1'b0;
        cout <= 1'b0;
    end else begin
        sum <= a ^ b ^ cin;
        cout <= (a & b) | (b & cin) | (a & cin);
    end
end

endmodule

module testbench;
    reg clk, rst_n;
    reg a, b, cin;
    wire sum, cout;
    
    full_adder dut (
        .clk(clk),
        .rst_n(rst_n),
        .a(a),
        .b(b),
        .cin(cin),
        .sum(sum),
        .cout(cout)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst_n = 1'b0;
        a = 1'b0;
        b = 1'b0;
        cin = 1'b0;
        
        #10 rst_n = 1'b1;
        
        // Test Case 0: 000
        #10 {a,b,cin} = 3'b000;
        // Test Case 1: 001
        #10 {a,b,cin} = 3'b001;
        // Test Case 2: 010
        #10 {a,b,cin} = 3'b010;
        // Test Case 3: 011
        #10 {a,b,cin} = 3'b011;
        // Test Case 4: 100
        #10 {a,b,cin} = 3'b100;
        // Test Case 5: 101
        #10 {a,b,cin} = 3'b101;
        // Test Case 6: 110
        #10 {a,b,cin} = 3'b110;
        // Test Case 7: 111
        #10 {a,b,cin} = 3'b111;
        
        #10 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t a=%b b=%b cin=%b sum=%b cout=%b"",
                 $time, a, b, cin, sum, cout);
    end
endmodule",True,78,True,True,True,True,0.7,True,12.098890781402588,8.51582670211792,"Create a full adder with inputs a, b, cin and outputs sum, cout. Include testbench with all 8 cases.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph LR
    A[Input A] --> FA((Full Adder))
    B[Input B] --> FA
    CIN[Carry In] --> FA
    FA --> SUM[Sum Output]
    FA --> COUT[Carry Out]
    TB[Test Cases] --> |Case 0: 000| TV{Test Vector}
    TB --> |Case 1: 001| TV
    TB --> |Case 2: 010| TV
    TB --> |Case 3: 011| TV
    TB --> |Case 4: 100| TV
    TB --> |Case 5: 101| TV
    TB --> |Case 6: 110| TV
    TB --> |Case 7: 111| TV
    TV --> |A| FA
    TV --> |B| FA
    TV --> |Cin| FA
    FA --> RES[[Results]]
    SUM --> RES
    COUT --> RES
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module full_adder(
    input wire a,
    input wire b,
    input wire cin,
    output wire sum,
    output wire cout
);

assign sum = a ^ b ^ cin;
assign cout = (a & b) | (b & cin) | (a & cin);

endmodule

module testbench;
    reg a, b, cin;
    wire sum, cout;
    
    full_adder dut (
        .a(a),
        .b(b),
        .cin(cin),
        .sum(sum),
        .cout(cout)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        // Test Case 0: 000
        a = 0; b = 0; cin = 0;
        #10;
        
        // Test Case 1: 001
        a = 0; b = 0; cin = 1;
        #10;
        
        // Test Case 2: 010
        a = 0; b = 1; cin = 0;
        #10;
        
        // Test Case 3: 011
        a = 0; b = 1; cin = 1;
        #10;
        
        // Test Case 4: 100
        a = 1; b = 0; cin = 0;
        #10;
        
        // Test Case 5: 101
        a = 1; b = 0; cin = 1;
        #10;
        
        // Test Case 6: 110
        a = 1; b = 1; cin = 0;
        #10;
        
        // Test Case 7: 111
        a = 1; b = 1; cin = 1;
        #10;
        
        $finish;
    end
    
    initial begin
        $monitor(""Time=%0t a=%b b=%b cin=%b sum=%b cout=%b"", 
                 $time, a, b, cin, sum, cout);
    end
endmodule",True,71,True,True,True,False,0.4,False,6.50528621673584,6.812816619873047,tie,prompt_only > combined > mermaid_only,prompt_only > mermaid_only > combined
combined,Combinational,simple,"Create a full adder with inputs a, b, cin and outputs sum, cout. Include testbench with all 8 cases.",gpt-4o,"`timescale 1ns/1ps

module full_adder(
    input wire a,
    input wire b,
    input wire cin,
    output wire sum,
    output wire cout
);

assign sum = a ^ b ^ cin;
assign cout = (a & b) | (b & cin) | (cin & a);

endmodule

module testbench;
    reg a, b, cin;
    wire sum, cout;

    full_adder dut (
        .a(a),
        .b(b),
        .cin(cin),
        .sum(sum),
        .cout(cout)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        $display(""Time=%0t a=%b b=%b cin=%b | sum=%b cout=%b"", 
                 $time, a, b, cin, sum, cout);

        a = 0; b = 0; cin = 0; #10;
        a = 0; b = 0; cin = 1; #10;
        a = 0; b = 1; cin = 0; #10;
        a = 0; b = 1; cin = 1; #10;
        a = 1; b = 0; cin = 0; #10;
        a = 1; b = 0; cin = 1; #10;
        a = 1; b = 1; cin = 0; #10;
        a = 1; b = 1; cin = 1; #10;

        $finish;
    end

    initial begin
        $monitor(""Time=%0t a=%b b=%b cin=%b | sum=%b cout=%b"", 
                 $time, a, b, cin, sum, cout);
    end
endmodule",True,51,True,True,True,False,0.4,False,5.970170497894287,7.495550632476807,"graph TD
    A[a] --> XOR1
    B[b] --> XOR1
    CIN[cin] --> XOR2
    XOR1((XOR)) --> XOR2((XOR))
    XOR2 --> SUM[sum]
    
    A --> AND1((AND))
    B --> AND1
    CIN --> AND2((AND))
    XOR1 --> AND2
    AND1 --> OR1((OR))
    AND2 --> OR1
    CIN --> AND3((AND))
    B --> AND3
    AND3 --> OR1
    OR1 --> COUT[cout]
    
    %% Testbench
    subgraph Testbench
        direction TB
        TBCLK[Clock] --> TEST[Tester]
        TBRESET[Reset] --> TEST
        TEST --> A
        TEST --> B
        TEST --> CIN
        SUM --> TEST
        COUT --> TEST
    end","`timescale 1ns/1ps

module full_adder(
    input wire a,
    input wire b,
    input wire cin,
    output wire sum,
    output wire cout
);
    wire xor1_out, xor2_out;
    wire and1_out, and2_out, and3_out;
    wire or1_out;

    // XOR gates
    assign xor1_out = a ^ b;
    assign xor2_out = xor1_out ^ cin;
    assign sum = xor2_out;

    // AND gates
    assign and1_out = a & b;
    assign and2_out = xor1_out & cin;
    assign and3_out = cin & b;

    // OR gate
    assign or1_out = and1_out | and2_out | and3_out;
    assign cout = or1_out;

endmodule

module testbench;
    reg clk, reset;
    reg a, b, cin;
    wire sum, cout;

    full_adder dut (
        .a(a),
        .b(b),
        .cin(cin),
        .sum(sum),
        .cout(cout)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 1'b0;
        reset = 1'b0;
        a = 1'b0;
        b = 1'b0;
        cin = 1'b0;

        #20 reset = 1'b1;
        #10 a = 1'b1; b = 1'b0; cin = 1'b0;
        #10 a = 1'b0; b = 1'b1; cin = 1'b0;
        #10 a = 1'b1; b = 1'b1; cin = 1'b0;
        #10 a = 1'b0; b = 1'b0; cin = 1'b1;
        #10 a = 1'b1; b = 1'b0; cin = 1'b1;
        #10 a = 1'b0; b = 1'b1; cin = 1'b1;
        #10 a = 1'b1; b = 1'b1; cin = 1'b1;
        #50 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t a=%b b=%b cin=%b sum=%b cout=%b"",
                 $time, a, b, cin, sum, cout);
    end
endmodule",True,70,True,True,True,False,0.4,False,12.135220289230347,10.945289611816406,"Create a full adder with inputs a, b, cin and outputs sum, cout. Include testbench with all 8 cases.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph TD
    A[a] --> XOR1
    B[b] --> XOR1
    CIN[cin] --> XOR2
    XOR1((XOR)) --> XOR2((XOR))
    XOR2 --> SUM[sum]
    
    A --> AND1((AND))
    B --> AND1
    CIN --> AND2((AND))
    XOR1 --> AND2
    AND1 --> OR1((OR))
    AND2 --> OR1
    CIN --> AND3((AND))
    B --> AND3
    AND3 --> OR1
    OR1 --> COUT[cout]
    
    %% Testbench
    subgraph Testbench
        direction TB
        TBCLK[Clock] --> TEST[Tester]
        TBRESET[Reset] --> TEST
        TEST --> A
        TEST --> B
        TEST --> CIN
        SUM --> TEST
        COUT --> TEST
    end
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module full_adder(
    input wire a,
    input wire b,
    input wire cin,
    output wire sum,
    output wire cout
);
    wire xor1_out, xor2_out;
    wire and1_out, and2_out, and3_out;
    wire or1_out;
    
    assign xor1_out = a ^ b;
    assign xor2_out = xor1_out ^ cin;
    assign sum = xor2_out;
    
    assign and1_out = a & b;
    assign and2_out = xor1_out & cin;
    assign and3_out = cin & b;
    
    assign or1_out = and1_out | and2_out | and3_out;
    assign cout = or1_out;
endmodule

module testbench;
    reg a, b, cin;
    wire sum, cout;
    
    full_adder dut (
        .a(a),
        .b(b),
        .cin(cin),
        .sum(sum),
        .cout(cout)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        a = 0; b = 0; cin = 0;
        #10 a = 0; b = 0; cin = 1;
        #10 a = 0; b = 1; cin = 0;
        #10 a = 0; b = 1; cin = 1;
        #10 a = 1; b = 0; cin = 0;
        #10 a = 1; b = 0; cin = 1;
        #10 a = 1; b = 1; cin = 0;
        #10 a = 1; b = 1; cin = 1;
        #10 $finish;
    end
    
    initial begin
        $monitor(""Time=%0t a=%b b=%b cin=%b | sum=%b cout=%b"", 
                 $time, a, b, cin, sum, cout);
    end
endmodule",True,57,True,True,True,False,0.4,False,4.297856092453003,12.038410425186157,tie,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,Combinational,simple,"Design a 2-bit comparator with inputs a[1:0], b[1:0] and outputs eq, gt, lt. Include testbench.",claude,"`timescale 1ns/1ps

module comparator(
    input wire [1:0] a,
    input wire [1:0] b,
    output reg eq,
    output reg gt,
    output reg lt
);

always @(*) begin
    if (a == b) begin
        eq = 1'b1;
        gt = 1'b0;
        lt = 1'b0;
    end
    else if (a > b) begin
        eq = 1'b0;
        gt = 1'b1;
        lt = 1'b0;
    end
    else begin
        eq = 1'b0;
        gt = 1'b0;
        lt = 1'b1;
    end
end

endmodule

module testbench;
    reg [1:0] a, b;
    wire eq, gt, lt;

    comparator dut (
        .a(a),
        .b(b),
        .eq(eq),
        .gt(gt),
        .lt(lt)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        a = 2'b00; b = 2'b00; #10;
        a = 2'b01; b = 2'b00; #10;
        a = 2'b00; b = 2'b01; #10;
        a = 2'b10; b = 2'b01; #10;
        a = 2'b11; b = 2'b11; #10;
        a = 2'b01; b = 2'b10; #10;
        
        $finish;
    end

    initial begin
        $monitor(""Time=%0t a=%b b=%b eq=%b gt=%b lt=%b"", 
                 $time, a, b, eq, gt, lt);
    end
endmodule",True,61,True,True,True,False,0.4,False,5.7530317306518555,0.37326645851135254,,,False,0,False,False,False,,0.0,,0.3294711112976074,0.0,,,False,0,False,False,False,,0.0,,0.0,0.0,prompt_only,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,Combinational,simple,"Design a 2-bit comparator with inputs a[1:0], b[1:0] and outputs eq, gt, lt. Include testbench.",gpt-4o,"`timescale 1ns/1ps

module comparator(
    input wire [1:0] a,
    input wire [1:0] b,
    output reg eq,
    output reg gt,
    output reg lt
);

always @(*) begin
    if (a > b) begin
        gt = 1'b1;
        eq = 1'b0;
        lt = 1'b0;
    end else if (a < b) begin
        gt = 1'b0;
        eq = 1'b0;
        lt = 1'b1;
    end else begin
        gt = 1'b0;
        eq = 1'b1;
        lt = 1'b0;
    end
end

endmodule

module testbench;
    reg [1:0] a, b;
    wire eq, gt, lt;

    comparator dut (
        .a(a),
        .b(b),
        .eq(eq),
        .gt(gt),
        .lt(lt)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        a = 2'b00; b = 2'b00;
        #10 a = 2'b01; b = 2'b00;
        #10 a = 2'b10; b = 2'b11;
        #10 a = 2'b11; b = 2'b10;
        #10 a = 2'b01; b = 2'b01;
        #10 $finish;
    end

    initial begin
        $monitor(""Time=%0t a=%b b=%b eq=%b gt=%b lt=%b"", 
                 $time, a, b, eq, gt, lt);
    end
endmodule",True,57,True,True,True,False,0.4,False,6.118628978729248,10.040220499038696,"graph LR
    A1[a[1:0]] --> COMP(Comparator)
    B1[b[1:0]] --> COMP
    COMP --> EQ[eq]
    COMP --> GT[gt]
    COMP --> LT[lt]
    TB[Testbench] --> A1
    TB --> B1
    TB --> CLK[Clock]
    TB --> RST[Reset]
    CLK --> COMP
    RST --> COMP","`timescale 1ns/1ps

module comparator(
    input wire clk,
    input wire rst_n,
    input wire [1:0] a,
    input wire [1:0] b,
    output reg eq,
    output reg gt,
    output reg lt
);

reg [1:0] a_reg, b_reg;

always @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
        a_reg <= 2'b00;
        b_reg <= 2'b00;
        eq <= 1'b0;
        gt <= 1'b0;
        lt <= 1'b0;
    end else begin
        a_reg <= a;
        b_reg <= b;
        eq <= (a_reg == b_reg);
        gt <= (a_reg > b_reg);
        lt <= (a_reg < b_reg);
    end
end

endmodule

module testbench;
    reg clk, rst_n;
    reg [1:0] a, b;
    wire eq, gt, lt;

    comparator dut (
        .clk(clk),
        .rst_n(rst_n),
        .a(a),
        .b(b),
        .eq(eq),
        .gt(gt),
        .lt(lt)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 1'b0;
        rst_n = 1'b0;
        a = 2'b00;
        b = 2'b00;

        #20 rst_n = 1'b1;
        #10 a = 2'b01; b = 2'b10;
        #10 a = 2'b10; b = 2'b01;
        #10 a = 2'b11; b = 2'b11;
        #50 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b a=%b b=%b eq=%b gt=%b lt=%b"", 
                 $time, clk, rst_n, a, b, eq, gt, lt);
    end
endmodule",True,70,True,True,True,True,0.7,True,8.465771913528442,12.21863579750061,"Design a 2-bit comparator with inputs a[1:0], b[1:0] and outputs eq, gt, lt. Include testbench.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph LR
    A1[a[1:0]] --> COMP(Comparator)
    B1[b[1:0]] --> COMP
    COMP --> EQ[eq]
    COMP --> GT[gt]
    COMP --> LT[lt]
    TB[Testbench] --> A1
    TB --> B1
    TB --> CLK[Clock]
    TB --> RST[Reset]
    CLK --> COMP
    RST --> COMP
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module comparator(
    input wire [1:0] a,
    input wire [1:0] b,
    input wire clk,
    input wire rst,
    output reg eq,
    output reg gt,
    output reg lt
);

always @(posedge clk or posedge rst) begin
    if (rst) begin
        eq <= 1'b0;
        gt <= 1'b0;
        lt <= 1'b0;
    end else begin
        if (a == b) begin
            eq <= 1'b1;
            gt <= 1'b0;
            lt <= 1'b0;
        end else if (a > b) begin
            eq <= 1'b0;
            gt <= 1'b1;
            lt <= 1'b0;
        end else begin
            eq <= 1'b0;
            gt <= 1'b0;
            lt <= 1'b1;
        end
    end
end

endmodule

module testbench;
    reg [1:0] a;
    reg [1:0] b;
    reg clk;
    reg rst;
    wire eq;
    wire gt;
    wire lt;
    
    comparator dut (
        .a(a),
        .b(b),
        .clk(clk),
        .rst(rst),
        .eq(eq),
        .gt(gt),
        .lt(lt)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst = 1'b1;
        a = 2'b00;
        b = 2'b00;
        
        #10 rst = 1'b0;
        #10 a = 2'b01; b = 2'b00;
        #10 a = 2'b10; b = 2'b10;
        #10 a = 2'b11; b = 2'b10;
        #10 a = 2'b00; b = 2'b01;
        #10 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t a=%b b=%b eq=%b gt=%b lt=%b"", 
                 $time, a, b, eq, gt, lt);
    end
endmodule",True,79,True,True,True,False,0.3,False,5.430274248123169,10.133915662765503,tie,prompt_only > combined > mermaid_only,prompt_only > mermaid_only > combined
combined,Arithmetic,medium,"Design a 4-bit ALU supporting ADD, SUB, AND, OR operations. Inputs: a[3:0], b[3:0], op[1:0]. Outputs: result[3:0], zero. Include testbench.",claude,,False,0,False,False,False,,0.0,,0.3387782573699951,0.0,,,False,0,False,False,False,,0.0,,0.3218996524810791,0.0,,,False,0,False,False,False,,0.0,,0.0,0.0,none,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,Arithmetic,medium,"Design a 4-bit ALU supporting ADD, SUB, AND, OR operations. Inputs: a[3:0], b[3:0], op[1:0]. Outputs: result[3:0], zero. Include testbench.",gpt-4o,"`timescale 1ns/1ps

module alu(
    input wire [3:0] a,
    input wire [3:0] b,
    input wire [1:0] op,
    output reg [3:0] result,
    output wire zero
);

always @(*) begin
    case (op)
        2'b00: result = a + b;  // ADD
        2'b01: result = a - b;  // SUB
        2'b10: result = a & b;  // AND
        2'b11: result = a | b;  // OR
        default: result = 4'b0000;
    endcase
end

assign zero = (result == 4'b0000);

endmodule

module testbench;
    reg [3:0] a, b;
    reg [1:0] op;
    wire [3:0] result;
    wire zero;
    
    alu dut (
        .a(a),
        .b(b),
        .op(op),
        .result(result),
        .zero(zero)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        a = 4'b0000; b = 4'b0000; op = 2'b00;
        #10 a = 4'b0010; b = 4'b0011; op = 2'b00;  // ADD
        #10 a = 4'b0100; b = 4'b0010; op = 2'b01;  // SUB
        #10 a = 4'b1100; b = 4'b1010; op = 2'b10;  // AND
        #10 a = 4'b1100; b = 4'b1010; op = 2'b11;  // OR
        #10 $finish;
    end
    
    initial begin
        $monitor(""Time=%0t a=%b b=%b op=%b result=%b zero=%b"", 
                 $time, a, b, op, result, zero);
    end
endmodule",True,55,True,True,True,False,0.4,False,6.024835586547852,14.930092096328735,"graph LR
    a[a[3:0]] --> ALU
    b[b[3:0]] --> ALU
    op[op[1:0]] --> ALU
    ALU(4-bit ALU) --> result[result[3:0]]
    ALU --> zero[zero]
    
    subgraph ALU
        ADD(ADD)
        SUB(SUB)
        AND(AND)
        OR(OR)
        MUX{MUX}
        
        a --> ADD
        b --> ADD
        a --> SUB
        b --> SUB
        a --> AND
        b --> AND
        a --> OR
        b --> OR
        
        ADD --> MUX
        SUB --> MUX
        AND --> MUX
        OR --> MUX
        
        op --> MUX
        MUX --> result
    end
    
    subgraph Testbench
        TB[TB: Testbench]
        TB --> a
        TB --> b
        TB --> op
    end","`timescale 1ns/1ps

module alu(
    input wire [3:0] a,
    input wire [3:0] b,
    input wire [1:0] op,
    output reg [3:0] result,
    output reg zero
);
    reg [3:0] add_res, sub_res, and_res, or_res;
    
    always @(*) begin
        add_res = a + b;
        sub_res = a - b;
        and_res = a & b;
        or_res = a | b;
        
        case(op)
            2'b00: result = add_res;
            2'b01: result = sub_res;
            2'b10: result = and_res;
            2'b11: result = or_res;
            default: result = 4'b0000;
        endcase
        
        zero = (result == 4'b0000) ? 1'b1 : 1'b0;
    end
endmodule

module testbench;
    reg [3:0] a, b;
    reg [1:0] op;
    wire [3:0] result;
    wire zero;
    
    alu dut (
        .a(a),
        .b(b),
        .op(op),
        .result(result),
        .zero(zero)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        a = 4'b0000;
        b = 4'b0000;
        op = 2'b00;
        
        #10 a = 4'b0011; b = 4'b0001; op = 2'b00; // Test ADD
        #10 a = 4'b0100; b = 4'b0001; op = 2'b01; // Test SUB
        #10 a = 4'b1010; b = 4'b1100; op = 2'b10; // Test AND
        #10 a = 4'b1010; b = 4'b1100; op = 2'b11; // Test OR
        #10 $finish;
    end
    
    initial begin
        $monitor(""Time=%0t a=%b b=%b op=%b result=%b zero=%b"", 
                 $time, a, b, op, result, zero);
    end
endmodule",True,63,True,True,True,False,0.4,False,9.135753393173218,12.713836193084717,"Design a 4-bit ALU supporting ADD, SUB, AND, OR operations. Inputs: a[3:0], b[3:0], op[1:0]. Outputs: result[3:0], zero. Include testbench.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph LR
    a[a[3:0]] --> ALU
    b[b[3:0]] --> ALU
    op[op[1:0]] --> ALU
    ALU(4-bit ALU) --> result[result[3:0]]
    ALU --> zero[zero]
    
    subgraph ALU
        ADD(ADD)
        SUB(SUB)
        AND(AND)
        OR(OR)
        MUX{MUX}
        
        a --> ADD
        b --> ADD
        a --> SUB
        b --> SUB
        a --> AND
        b --> AND
        a --> OR
        b --> OR
        
        ADD --> MUX
        SUB --> MUX
        AND --> MUX
        OR --> MUX
        
        op --> MUX
        MUX --> result
    end
    
    subgraph Testbench
        TB[TB: Testbench]
        TB --> a
        TB --> b
        TB --> op
    end
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module alu (
    input wire [3:0] a,
    input wire [3:0] b,
    input wire [1:0] op,
    output reg [3:0] result,
    output wire zero
);
    wire [3:0] add_result;
    wire [3:0] sub_result;
    wire [3:0] and_result;
    wire [3:0] or_result;

    assign add_result = a + b;
    assign sub_result = a - b;
    assign and_result = a & b;
    assign or_result = a | b;

    always @(*) begin
        case (op)
            2'b00: result = add_result;
            2'b01: result = sub_result;
            2'b10: result = and_result;
            2'b11: result = or_result;
            default: result = 4'b0000;
        endcase
    end

    assign zero = (result == 4'b0000);

endmodule

module testbench;
    reg [3:0] a;
    reg [3:0] b;
    reg [1:0] op;
    wire [3:0] result;
    wire zero;

    alu dut (
        .a(a),
        .b(b),
        .op(op),
        .result(result),
        .zero(zero)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        a = 4'b0000;
        b = 4'b0000;
        op = 2'b00;

        #10 a = 4'b0011; b = 4'b0001; op = 2'b00; // ADD
        #10 a = 4'b0100; b = 4'b0010; op = 2'b01; // SUB
        #10 a = 4'b1100; b = 4'b1010; op = 2'b10; // AND
        #10 a = 4'b0110; b = 4'b1100; op = 2'b11; // OR

        #10 $finish;
    end

    initial begin
        $monitor(""Time=%0t a=%b b=%b op=%b result=%b zero=%b"",
                 $time, a, b, op, result, zero);
    end
endmodule",True,69,True,True,True,False,0.4,False,7.198194265365601,17.15773344039917,tie,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,Combinational,medium,"Create an 8:1 multiplexer with input data[7:0], select sel[2:0], and output out. Include testbench.",claude,,False,0,False,False,False,,0.0,,0.3099863529205322,0.0,,,False,0,False,False,False,,0.0,,0.3066861629486084,0.0,,,False,0,False,False,False,,0.0,,0.0,0.0,none,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,Combinational,medium,"Create an 8:1 multiplexer with input data[7:0], select sel[2:0], and output out. Include testbench.",gpt-4o,"`timescale 1ns/1ps

module mux8to1(
    input wire [7:0] data,
    input wire [2:0] sel,
    output reg out
);

always @(*) begin
    case (sel)
        3'b000: out = data[0];
        3'b001: out = data[1];
        3'b010: out = data[2];
        3'b011: out = data[3];
        3'b100: out = data[4];
        3'b101: out = data[5];
        3'b110: out = data[6];
        3'b111: out = data[7];
        default: out = 1'b0;
    endcase
end

endmodule

module testbench;
    reg [7:0] data;
    reg [2:0] sel;
    wire out;
    
    mux8to1 dut (
        .data(data),
        .sel(sel),
        .out(out)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        data = 8'b10101010;
        sel = 3'b000;
        
        #10 sel = 3'b001;
        #10 sel = 3'b010;
        #10 sel = 3'b011;
        #10 sel = 3'b100;
        #10 sel = 3'b101;
        #10 sel = 3'b110;
        #10 sel = 3'b111;
        #10 $finish;
    end
    
    initial begin
        $monitor(""Time=%0t data=%b sel=%b out=%b"", 
                 $time, data, sel, out);
    end
endmodule",True,57,True,True,True,False,0.4,False,5.241117715835571,10.337738990783691,"graph TD
    CLK[Clock] --> MUX{8:1 Mux}
    RST[Reset] --> TB[Testbench]
    data0[Input Data 0] --> MUX
    data1[Input Data 1] --> MUX
    data2[Input Data 2] --> MUX
    data3[Input Data 3] --> MUX
    data4[Input Data 4] --> MUX
    data5[Input Data 5] --> MUX
    data6[Input Data 6] --> MUX
    data7[Input Data 7] --> MUX
    sel0[Select 0] --> MUX
    sel1[Select 1] --> MUX
    sel2[Select 2] --> MUX
    MUX --> out[Output]
    TB --> data0
    TB --> data1
    TB --> data2
    TB --> data3
    TB --> data4
    TB --> data5
    TB --> data6
    TB --> data7
    TB --> sel0
    TB --> sel1
    TB --> sel2
    TB --> CLK
    TB --> RST
    TB --> out","`timescale 1ns/1ps

module mux_8to1 (
    input wire clk,
    input wire rst,
    input wire [7:0] data_in [7:0],
    input wire [2:0] sel,
    output reg out
);

    always @(posedge clk or posedge rst) begin
        if (rst)
            out <= 1'b0;
        else begin
            case (sel)
                3'b000: out <= data_in[0];
                3'b001: out <= data_in[1];
                3'b010: out <= data_in[2];
                3'b011: out <= data_in[3];
                3'b100: out <= data_in[4];
                3'b101: out <= data_in[5];
                3'b110: out <= data_in[6];
                3'b111: out <= data_in[7];
                default: out <= 1'b0;
            endcase
        end
    end

endmodule

module testbench;
    reg clk, rst;
    reg [7:0] data [7:0];
    reg [2:0] sel;
    wire out;

    mux_8to1 dut (
        .clk(clk),
        .rst(rst),
        .data_in(data),
        .sel(sel),
        .out(out)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 1'b0;
        rst = 1'b1;
        sel = 3'b000;
        data[0] = 8'b00000001;
        data[1] = 8'b00000010;
        data[2] = 8'b00000100;
        data[3] = 8'b00001000;
        data[4] = 8'b00010000;
        data[5] = 8'b00100000;
        data[6] = 8'b01000000;
        data[7] = 8'b10000000;

        #10 rst = 1'b0;
        #10 sel = 3'b001;
        #10 sel = 3'b010;
        #10 sel = 3'b011;
        #10 sel = 3'b100;
        #10 sel = 3'b101;
        #10 sel = 3'b110;
        #10 sel = 3'b111;
        #10 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t clk=%b rst=%b sel=%b out=%b"", 
                 $time, clk, rst, sel, out);
    end
endmodule",True,78,True,False,False,,0.0,,10.130545616149902,0.009203672409057617,"Create an 8:1 multiplexer with input data[7:0], select sel[2:0], and output out. Include testbench.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph TD
    CLK[Clock] --> MUX{8:1 Mux}
    RST[Reset] --> TB[Testbench]
    data0[Input Data 0] --> MUX
    data1[Input Data 1] --> MUX
    data2[Input Data 2] --> MUX
    data3[Input Data 3] --> MUX
    data4[Input Data 4] --> MUX
    data5[Input Data 5] --> MUX
    data6[Input Data 6] --> MUX
    data7[Input Data 7] --> MUX
    sel0[Select 0] --> MUX
    sel1[Select 1] --> MUX
    sel2[Select 2] --> MUX
    MUX --> out[Output]
    TB --> data0
    TB --> data1
    TB --> data2
    TB --> data3
    TB --> data4
    TB --> data5
    TB --> data6
    TB --> data7
    TB --> sel0
    TB --> sel1
    TB --> sel2
    TB --> CLK
    TB --> RST
    TB --> out
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module mux_8to1(
    input wire [7:0] data_in,
    input wire [2:0] sel,
    output reg out
);
    always @(*) begin
        case (sel)
            3'b000: out = data_in[0];
            3'b001: out = data_in[1];
            3'b010: out = data_in[2];
            3'b011: out = data_in[3];
            3'b100: out = data_in[4];
            3'b101: out = data_in[5];
            3'b110: out = data_in[6];
            3'b111: out = data_in[7];
            default: out = 1'b0;
        endcase
    end
endmodule

module testbench;
    reg clk;
    reg rst;
    reg [7:0] data_in;
    reg [2:0] sel;
    wire out;

    mux_8to1 dut (
        .data_in(data_in),
        .sel(sel),
        .out(out)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 1'b0;
        rst = 1'b0;
        data_in = 8'b00000000;
        sel = 3'b000;

        #20 rst = 1'b1;
        #10 data_in = 8'b10101010; sel = 3'b000;
        #10 sel = 3'b001;
        #10 sel = 3'b010;
        #10 sel = 3'b011;
        #10 sel = 3'b100;
        #10 sel = 3'b101;
        #10 sel = 3'b110;
        #10 sel = 3'b111;
        #50 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t clk=%b rst=%b sel=%b data_in=%b out=%b"", 
                 $time, clk, rst, sel, data_in, out);
    end
endmodule",True,63,True,True,True,False,0.4,False,7.266436576843262,17.164508819580078,tie,prompt_only > combined > mermaid_only,prompt_only > combined > mermaid_only
combined,State Machine,medium,Design an FSM detecting pattern 1011 in serial input with overlapping detection. Include testbench with sequence: 10110111011.,claude,,False,0,False,False,False,,0.0,,0.5366363525390625,0.0,,,False,0,False,False,False,,0.0,,0.3199470043182373,0.0,,,False,0,False,False,False,,0.0,,0.0,0.0,none,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,State Machine,medium,Design an FSM detecting pattern 1011 in serial input with overlapping detection. Include testbench with sequence: 10110111011.,gpt-4o,"`timescale 1ns/1ps

module fsm_1011_detector(
    input wire clk,
    input wire rst_n,
    input wire serial_in,
    output reg pattern_detected
);

    typedef enum reg [2:0] {
        S0, S1, S2, S3, S4
    } state_t;

    reg [2:0] current_state, next_state;

    always @(posedge clk or negedge rst_n) begin
        if (!rst_n)
            current_state <= S0;
        else
            current_state <= next_state;
    end

    always @(*) begin
        pattern_detected = 1'b0;
        next_state = current_state;
        case (current_state)
            S0: if (serial_in) next_state = S1;
            S1: if (!serial_in) next_state = S2;
                else next_state = S1;
            S2: if (serial_in) next_state = S3;
                else next_state = S0;
            S3: if (serial_in) begin
                    next_state = S4;
                    pattern_detected = 1'b1;
                end
                else next_state = S2;
            S4: if (!serial_in) next_state = S2;
                else next_state = S1;
            default: next_state = S0;
        endcase
    end
endmodule

module testbench;
    reg clk, rst_n, serial_in;
    wire pattern_detected;

    fsm_1011_detector dut (
        .clk(clk),
        .rst_n(rst_n),
        .serial_in(serial_in),
        .pattern_detected(pattern_detected)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 1'b0;
        rst_n = 1'b0;
        serial_in = 1'b0;

        #20 rst_n = 1'b1;
        #10 serial_in = 1'b1;
        #10 serial_in = 1'b0;
        #10 serial_in = 1'b1;
        #10 serial_in = 1'b1;
        #10 serial_in = 1'b0;
        #10 serial_in = 1'b1;
        #10 serial_in = 1'b1;
        #10 serial_in = 1'b1;
        #10 serial_in = 1'b0;
        #10 serial_in = 1'b1;
        #10 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b serial_in=%b pattern_detected=%b"", 
                 $time, clk, rst_n, serial_in, pattern_detected);
    end
endmodule",True,83,True,True,True,True,0.7,True,10.543382406234741,20.32530188560486,"graph LR
    CLK[Clock] --> FSM
    RST[Reset] --> FSM
    IN[Serial Input] --> FSM
    FSM((FSM))
    FSM --> DETECTED[Pattern Detected]

    subgraph TB[Testbench]
        S1[10110111011] --> IN
    end","`timescale 1ns/1ps

module fsm(
    input wire clk,
    input wire rst,
    input wire serial_in,
    output reg pattern_detected
);

reg delayed_input;

always @(posedge clk or posedge rst) begin
    if (rst) begin
        delayed_input <= 1'b0;
        pattern_detected <= 1'b0;
    end else begin
        delayed_input <= serial_in;
        pattern_detected <= delayed_input;
    end
end

endmodule

module testbench;
    reg clk, rst;
    reg serial_in;
    wire pattern_detected;

    fsm dut (
        .clk(clk),
        .rst(rst),
        .serial_in(serial_in),
        .pattern_detected(pattern_detected)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 1'b0;
        rst = 1'b1;
        serial_in = 1'b0;

        #20 rst = 1'b0;

        #10 serial_in = 1'b1;
        #10 serial_in = 1'b0;
        #10 serial_in = 1'b1;
        #10 serial_in = 1'b1;
        #10 serial_in = 1'b0;
        #10 serial_in = 1'b1;
        #10 serial_in = 1'b1;
        #10 serial_in = 1'b1;
        #10 serial_in = 1'b0;
        #10 serial_in = 1'b1;
        #10 serial_in = 1'b1;

        #50 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t clk=%b rst=%b serial_in=%b pattern_detected=%b"", 
                 $time, clk, rst, serial_in, pattern_detected);
    end
endmodule",True,67,True,True,True,True,0.7,True,5.782177925109863,13.094803094863892,"Design an FSM detecting pattern 1011 in serial input with overlapping detection. Include testbench with sequence: 10110111011.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph LR
    CLK[Clock] --> FSM
    RST[Reset] --> FSM
    IN[Serial Input] --> FSM
    FSM((FSM))
    FSM --> DETECTED[Pattern Detected]

    subgraph TB[Testbench]
        S1[10110111011] --> IN
    end
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module fsm_detector (
    input wire clk,
    input wire rst_n,
    input wire serial_in,
    output reg detected
);

    typedef enum logic [1:0] {
        S0 = 2'b00,
        S1 = 2'b01,
        S2 = 2'b10,
        S3 = 2'b11
    } state_t;

    state_t state, next_state;

    always @(posedge clk or negedge rst_n) begin
        if (!rst_n)
            state <= S0;
        else
            state <= next_state;
    end

    always @(*) begin
        next_state = state;
        detected = 1'b0;
        case (state)
            S0: if (serial_in) next_state = S1;
            S1: if (serial_in) next_state = S2; else next_state = S0;
            S2: if (!serial_in) next_state = S3; else next_state = S2;
            S3: begin
                if (serial_in) begin
                    next_state = S1;
                    detected = 1'b1;
                end else begin
                    next_state = S0;
                end
            end
        endcase
    end

endmodule

module testbench;
    reg clk, rst_n, serial_in;
    wire detected;

    fsm_detector uut (
        .clk(clk),
        .rst_n(rst_n),
        .serial_in(serial_in),
        .detected(detected)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 1'b0;
        rst_n = 1'b0;
        serial_in = 1'b0;

        #10 rst_n = 1'b1;
        #10 serial_in = 1'b1; // Start sequence 10110111011
        #10 serial_in = 1'b0;
        #10 serial_in = 1'b1;
        #10 serial_in = 1'b1;
        #10 serial_in = 1'b0;
        #10 serial_in = 1'b1;
        #10 serial_in = 1'b1;
        #10 serial_in = 1'b1;
        #10 serial_in = 1'b0;
        #10 serial_in = 1'b1;
        #10 serial_in = 1'b1;
        #10 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b serial_in=%b detected=%b"", 
                 $time, clk, rst_n, serial_in, detected);
    end

endmodule",True,87,True,True,True,True,0.7,True,8.779998064041138,7.450333595275879,prompt_only,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,Sequential,medium,"Create a 4-bit PISO shift register with clock, reset, load, parallel input[3:0], and serial output. Include testbench.",claude,,False,0,False,False,False,,0.0,,0.35294103622436523,0.0,,,False,0,False,False,False,,0.0,,0.30603981018066406,0.0,,,False,0,False,False,False,,0.0,,0.0,0.0,none,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,Sequential,medium,"Create a 4-bit PISO shift register with clock, reset, load, parallel input[3:0], and serial output. Include testbench.",gpt-4o,"`timescale 1ns/1ps

module piso_shift_register(
    input wire clk,
    input wire rst_n,
    input wire load,
    input wire [3:0] parallel_in,
    output reg serial_out
);

    reg [3:0] shift_reg;

    always @(posedge clk or negedge rst_n) begin
        if (!rst_n)
            shift_reg <= 4'b0000;
        else if (load)
            shift_reg <= parallel_in;
        else
            shift_reg <= {shift_reg[2:0], 1'b0};
    end

    always @(shift_reg) begin
        serial_out = shift_reg[3];
    end

endmodule

module testbench;
    reg clk, rst_n, load;
    reg [3:0] parallel_in;
    wire serial_out;

    piso_shift_register dut (
        .clk(clk),
        .rst_n(rst_n),
        .load(load),
        .parallel_in(parallel_in),
        .serial_out(serial_out)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 1'b0;
        rst_n = 1'b0;
        load = 1'b0;
        parallel_in = 4'b1010;

        #20 rst_n = 1'b1;
        #10 load = 1'b1;
        #10 load = 1'b0;
        #100 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b load=%b parallel_in=%b serial_out=%b"",
                 $time, clk, rst_n, load, parallel_in, serial_out);
    end
endmodule",True,62,True,True,True,True,0.7,True,4.742477893829346,10.750807285308838,"graph LR
    CLK[Clock] --> LOAD(Load Control)
    RST[Reset] --> PISO[4-bit PISO Shift Register]
    LOAD --> PISO
    PI[Parallel Input[3:0]] --> PISO
    SO[Serial Output] --> TESTBENCH[Testbench]
    PISO --> SO
    CLK --> PISO
    RST --> TESTBENCH
    PI --> TESTBENCH","`timescale 1ns/1ps

module piso_shift_register(
    input wire clk,
    input wire rst,
    input wire load,
    input wire [3:0] pi,
    output reg so
);

    reg [3:0] shift_reg;

    always @(posedge clk or posedge rst) begin
        if (rst)
            shift_reg <= 4'b0000;
        else if (load)
            shift_reg <= pi;
        else
            shift_reg <= {shift_reg[2:0], 1'b0};
    end

    always @(posedge clk or posedge rst) begin
        if (rst)
            so <= 1'b0;
        else
            so <= shift_reg[3];
    end

endmodule

module testbench;
    reg clk, rst, load;
    reg [3:0] pi;
    wire so;
    
    piso_shift_register dut (
        .clk(clk),
        .rst(rst),
        .load(load),
        .pi(pi),
        .so(so)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst = 1'b1;
        load = 1'b0;
        pi = 4'b0000;
        
        #20 rst = 1'b0;
        #10 load = 1'b1; pi = 4'b1010;
        #10 load = 1'b0;
        #100 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t clk=%b rst=%b load=%b pi=%b so=%b"", 
                 $time, clk, rst, load, pi, so);
    end
endmodule",True,65,True,True,True,True,0.7,True,14.46311902999878,10.096581220626831,"Create a 4-bit PISO shift register with clock, reset, load, parallel input[3:0], and serial output. Include testbench.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph LR
    CLK[Clock] --> LOAD(Load Control)
    RST[Reset] --> PISO[4-bit PISO Shift Register]
    LOAD --> PISO
    PI[Parallel Input[3:0]] --> PISO
    SO[Serial Output] --> TESTBENCH[Testbench]
    PISO --> SO
    CLK --> PISO
    RST --> TESTBENCH
    PI --> TESTBENCH
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module piso_shift_register(
    input wire clk,
    input wire rst_n,
    input wire load,
    input wire [3:0] parallel_in,
    output reg serial_out
);
    reg [3:0] shift_reg;

    always @(posedge clk or negedge rst_n) begin
        if (!rst_n)
            shift_reg <= 4'b0000;
        else if (load)
            shift_reg <= parallel_in;
        else
            shift_reg <= {shift_reg[2:0], 1'b0};
    end

    always @(posedge clk or negedge rst_n) begin
        if (!rst_n)
            serial_out <= 1'b0;
        else
            serial_out <= shift_reg[3];
    end

endmodule

module testbench;
    reg clk, rst_n, load;
    reg [3:0] parallel_in;
    wire serial_out;

    piso_shift_register dut (
        .clk(clk),
        .rst_n(rst_n),
        .load(load),
        .parallel_in(parallel_in),
        .serial_out(serial_out)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 1'b0;
        rst_n = 1'b0;
        load = 1'b0;
        parallel_in = 4'b0000;

        #20 rst_n = 1'b1;
        #10 load = 1'b1; parallel_in = 4'b1010;
        #10 load = 1'b0; 
        #40 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b load=%b parallel_in=%b serial_out=%b"", 
                 $time, clk, rst_n, load, parallel_in, serial_out);
    end
endmodule",True,64,True,True,True,True,0.7,True,5.286315679550171,16.038079500198364,prompt_only,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,Combinational,medium,"Design a 4-to-2 priority encoder with input in[3:0], output out[1:0], and valid bit. Highest bit has priority. Include testbench.",claude,,False,0,False,False,False,,0.0,,0.32219362258911133,0.0,,,False,0,False,False,False,,0.0,,0.30611658096313477,0.0,,,False,0,False,False,False,,0.0,,0.0,0.0,none,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,Combinational,medium,"Design a 4-to-2 priority encoder with input in[3:0], output out[1:0], and valid bit. Highest bit has priority. Include testbench.",gpt-4o,"`timescale 1ns/1ps

module priority_encoder(
    input wire [3:0] in,
    output reg [1:0] out,
    output reg valid
);

always @(*) begin
    valid = 1'b0;
    out = 2'b00;
    if (in[3]) begin
        valid = 1'b1;
        out = 2'b11;
    end else if (in[2]) begin
        valid = 1'b1;
        out = 2'b10;
    end else if (in[1]) begin
        valid = 1'b1;
        out = 2'b01;
    end else if (in[0]) begin
        valid = 1'b1;
        out = 2'b00;
    end
end

endmodule

module testbench;
    reg [3:0] in;
    wire [1:0] out;
    wire valid;
    
    priority_encoder dut (
        .in(in),
        .out(out),
        .valid(valid)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        in = 4'b0000;
        #10 in = 4'b0001;
        #10 in = 4'b0010;
        #10 in = 4'b0100;
        #10 in = 4'b1000;
        #10 in = 4'b1100;
        #10 in = 4'b0110;
        #10 in = 4'b1010;
        #10 in = 4'b1110;
        #10 in = 4'b1111;
        #10 $finish;
    end
    
    initial begin
        $monitor(""Time=%0t in=%b out=%b valid=%b"", $time, in, out, valid);
    end
endmodule",True,60,True,True,True,False,0.4,False,5.354857683181763,16.32329273223877,"graph TD
    CLK[Clock] --> ENCODER(Priority Encoder)
    RST[Reset] --> ENCODER
    in0[in[0]] --> ENCODER
    in1[in[1]] --> ENCODER
    in2[in[2]] --> ENCODER
    in3[in[3]] --> ENCODER
    ENCODER --> out0[out[0]]
    ENCODER --> out1[out[1]]
    ENCODER --> valid[Valid Bit]

    subgraph Testbench
        CLK --> TB[Test Bench]
        RST --> TB
        TB --> in0
        TB --> in1
        TB --> in2
        TB --> in3
        out0 --> TB
        out1 --> TB
        valid --> TB
    end","`timescale 1ns/1ps

module priority_encoder(
    input wire clk,
    input wire rst,
    input wire [3:0] in,
    output reg [1:0] out,
    output reg valid
);

always @(posedge clk or posedge rst) begin
    if (rst) begin
        out <= 2'b00;
        valid <= 1'b0;
    end else begin
        if (in[3]) begin
            out <= 2'b11;
            valid <= 1'b1;
        end else if (in[2]) begin
            out <= 2'b10;
            valid <= 1'b1;
        end else if (in[1]) begin
            out <= 2'b01;
            valid <= 1'b1;
        end else if (in[0]) begin
            out <= 2'b00;
            valid <= 1'b1;
        end else begin
            out <= 2'b00;
            valid <= 1'b0;
        end
    end
end

endmodule

module testbench;
    reg clk, rst;
    reg [3:0] in;
    wire [1:0] out;
    wire valid;

    priority_encoder dut (
        .clk(clk),
        .rst(rst),
        .in(in),
        .out(out),
        .valid(valid)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 1'b0;
        rst = 1'b1;
        in = 4'b0000;

        #15 rst = 1'b0;
        #10 in = 4'b0001;
        #10 in = 4'b0010;
        #10 in = 4'b0100;
        #10 in = 4'b1000;
        #10 in = 4'b0000;
        #10 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t clk=%b rst=%b in=%b out=%b valid=%b"", 
                 $time, clk, rst, in, out, valid);
    end
endmodule",True,74,True,True,True,False,0.3,False,10.644691705703735,12.031007051467896,"Design a 4-to-2 priority encoder with input in[3:0], output out[1:0], and valid bit. Highest bit has priority. Include testbench.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph TD
    CLK[Clock] --> ENCODER(Priority Encoder)
    RST[Reset] --> ENCODER
    in0[in[0]] --> ENCODER
    in1[in[1]] --> ENCODER
    in2[in[2]] --> ENCODER
    in3[in[3]] --> ENCODER
    ENCODER --> out0[out[0]]
    ENCODER --> out1[out[1]]
    ENCODER --> valid[Valid Bit]

    subgraph Testbench
        CLK --> TB[Test Bench]
        RST --> TB
        TB --> in0
        TB --> in1
        TB --> in2
        TB --> in3
        out0 --> TB
        out1 --> TB
        valid --> TB
    end
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module priority_encoder (
    input wire clk,
    input wire rst,
    input wire [3:0] in,
    output reg [1:0] out,
    output reg valid
);

always @(posedge clk or posedge rst) begin
    if (rst) begin
        out <= 2'b00;
        valid <= 1'b0;
    end else begin
        casez (in)
            4'b1???: begin
                out <= 2'b11;
                valid <= 1'b1;
            end
            4'b01??: begin
                out <= 2'b10;
                valid <= 1'b1;
            end
            4'b001?: begin
                out <= 2'b01;
                valid <= 1'b1;
            end
            4'b0001: begin
                out <= 2'b00;
                valid <= 1'b1;
            end
            default: begin
                out <= 2'b00;
                valid <= 1'b0;
            end
        endcase
    end
end

endmodule

module testbench;
    reg clk, rst;
    reg [3:0] in;
    wire [1:0] out;
    wire valid;
    
    priority_encoder dut (
        .clk(clk),
        .rst(rst),
        .in(in),
        .out(out),
        .valid(valid)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst = 1'b1;
        in = 4'b0000;
        
        #10 rst = 1'b0;
        #10 in = 4'b0001;
        #10 in = 4'b0010;
        #10 in = 4'b0100;
        #10 in = 4'b1000;
        #10 in = 4'b0110;
        #10 in = 4'b1010;
        #10 in = 4'b1100;
        #10 in = 4'b1110;
        #10 in = 4'b0000;
        #10 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t clk=%b rst=%b in=%b out=%b valid=%b"", 
                 $time, clk, rst, in, out, valid);
    end
endmodule",True,84,True,True,True,True,0.7,True,8.339527606964111,14.286766767501831,tie,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,State Machine,complex,"Design a traffic light FSM with 4 states: NS_GREEN, NS_YELLOW, EW_GREEN, EW_YELLOW. Inputs: clk, rst, emergency. Outputs: ns_light[1:0], ew_light[1:0]. Timing: GREEN=8 cycles, YELLOW=2 cycles. Emergency makes both RED. Include testbench.",claude,,False,0,False,False,False,,0.0,,0.368518590927124,0.0,,,False,0,False,False,False,,0.0,,0.3140392303466797,0.0,,,False,0,False,False,False,,0.0,,0.0,0.0,none,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,State Machine,complex,"Design a traffic light FSM with 4 states: NS_GREEN, NS_YELLOW, EW_GREEN, EW_YELLOW. Inputs: clk, rst, emergency. Outputs: ns_light[1:0], ew_light[1:0]. Timing: GREEN=8 cycles, YELLOW=2 cycles. Emergency makes both RED. Include testbench.",gpt-4o,"`timescale 1ns/1ps

module traffic_light_fsm(
    input wire clk,
    input wire rst,
    input wire emergency,
    output reg [1:0] ns_light,
    output reg [1:0] ew_light
);

    reg [1:0] state;
    reg [3:0] timer;
    
    parameter NS_GREEN = 2'b00, NS_YELLOW = 2'b01, EW_GREEN = 2'b10, EW_YELLOW = 2'b11;
    parameter GREEN_TIME = 4'd8, YELLOW_TIME = 4'd2;

    always @(posedge clk or posedge rst) begin
        if (rst) begin
            state <= NS_GREEN;
            timer <= 4'b0000;
        end else if (emergency) begin
            ns_light <= 2'b00; // RED
            ew_light <= 2'b00; // RED
            timer <= 4'b0000;
        end else begin
            case (state)
                NS_GREEN: begin
                    ns_light <= 2'b10; // GREEN
                    ew_light <= 2'b00; // RED
                    if (timer < GREEN_TIME) begin
                        timer <= timer + 1'b1;
                    end else begin
                        state <= NS_YELLOW;
                        timer <= 4'b0000;
                    end
                end
                NS_YELLOW: begin
                    ns_light <= 2'b01; // YELLOW
                    ew_light <= 2'b00; // RED
                    if (timer < YELLOW_TIME) begin
                        timer <= timer + 1'b1;
                    end else begin
                        state <= EW_GREEN;
                        timer <= 4'b0000;
                    end
                end
                EW_GREEN: begin
                    ns_light <= 2'b00; // RED
                    ew_light <= 2'b10; // GREEN
                    if (timer < GREEN_TIME) begin
                        timer <= timer + 1'b1;
                    end else begin
                        state <= EW_YELLOW;
                        timer <= 4'b0000;
                    end
                end
                EW_YELLOW: begin
                    ns_light <= 2'b00; // RED
                    ew_light <= 2'b01; // YELLOW
                    if (timer < YELLOW_TIME) begin
                        timer <= timer + 1'b1;
                    end else begin
                        state <= NS_GREEN;
                        timer <= 4'b0000;
                    end
                end
            endcase
        end
    end
endmodule

module testbench;
    reg clk, rst, emergency;
    wire [1:0] ns_light, ew_light;

    traffic_light_fsm dut (
        .clk(clk),
        .rst(rst),
        .emergency(emergency),
        .ns_light(ns_light),
        .ew_light(ew_light)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst = 1'b0;
        emergency = 1'b0;
        
        #10 rst = 1'b1;
        #10 rst = 1'b0;
        #200 emergency = 1'b1;
        #20 emergency = 1'b0;
        #200 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t clk=%b rst=%b emergency=%b ns_light=%b ew_light=%b"", 
                 $time, clk, rst, emergency, ns_light, ew_light);
    end
endmodule",True,105,True,True,True,True,0.7,True,8.168192863464355,12.280285358428955,"graph TD
    CLK[Clock] --> FSM
    RST[Reset] --> FSM
    EMG[Emergency] --> FSM
    FSM((Traffic Light FSM))
    FSM --> NSG(NS_GREEN)
    FSM --> NSY(NS_YELLOW)
    FSM --> EWG(EW_GREEN)
    FSM --> EWY(EW_YELLOW)
    NSG --> NSY
    NSY --> EWG
    EWG --> EWY
    EWY --> NSG
    FSM --> NS_LIGHT[ns_light[1:0]]
    FSM --> EW_LIGHT[ew_light[1:0]]
    FSM -- ""8 cycles"" --> NSG
    FSM -- ""2 cycles"" --> NSY
    FSM -- ""8 cycles"" --> EWG
    FSM -- ""2 cycles"" --> EWY
    NSG --> |emergency| EMG
    NSY --> |emergency| EMG
    EWG --> |emergency| EMG
    EWY --> |emergency| EMG
    subgraph Testbench
        TB[TB] --> CLK
        TB --> RST
        TB --> EMG
        TB --> FSM
    end","`timescale 1ns/1ps

module traffic_light_fsm(
    input wire clk,
    input wire rst,
    input wire emergency,
    output reg [1:0] ns_light,
    output reg [1:0] ew_light
);

    typedef enum reg [1:0] {
        NS_GREEN  = 2'b00,
        NS_YELLOW = 2'b01,
        EW_GREEN  = 2'b10,
        EW_YELLOW = 2'b11
    } state_t;

    state_t state, next_state;
    reg [3:0] cycle_counter;

    always @(posedge clk or posedge rst) begin
        if (rst) begin
            state <= NS_GREEN;
            cycle_counter <= 4'd0;
        end else if (emergency) begin
            state <= state; // Hold state during emergency
        end else begin
            if (cycle_counter == 4'd9) begin
                state <= next_state;
                cycle_counter <= 4'd0;
            end else begin
                cycle_counter <= cycle_counter + 4'd1;
            end
        end
    end

    always @(*) begin
        case (state)
            NS_GREEN: begin
                ns_light = 2'b01; // Green
                ew_light = 2'b00; // Red
                next_state = (cycle_counter == 4'd7) ? NS_YELLOW : NS_GREEN;
            end
            NS_YELLOW: begin
                ns_light = 2'b10; // Yellow
                ew_light = 2'b00; // Red
                next_state = (cycle_counter == 4'd1) ? EW_GREEN : NS_YELLOW;
            end
            EW_GREEN: begin
                ns_light = 2'b00; // Red
                ew_light = 2'b01; // Green
                next_state = (cycle_counter == 4'd7) ? EW_YELLOW : EW_GREEN;
            end
            EW_YELLOW: begin
                ns_light = 2'b00; // Red
                ew_light = 2'b10; // Yellow
                next_state = (cycle_counter == 4'd1) ? NS_GREEN : EW_YELLOW;
            end
            default: begin
                ns_light = 2'b00;
                ew_light = 2'b00;
                next_state = NS_GREEN;
            end
        endcase
    end

endmodule

module testbench;
    reg clk, rst, emergency;
    wire [1:0] ns_light, ew_light;

    traffic_light_fsm dut (
        .clk(clk),
        .rst(rst),
        .emergency(emergency),
        .ns_light(ns_light),
        .ew_light(ew_light)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 1'b0;
        rst = 1'b0;
        emergency = 1'b0;

        #15 rst = 1'b1;
        #10 rst = 1'b0;
        #100 emergency = 1'b1;
        #20 emergency = 1'b0;
        #200 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t clk=%b rst=%b emergency=%b ns_light=%b ew_light=%b"", 
                 $time, clk, rst, emergency, ns_light, ew_light);
    end
endmodule",True,102,True,False,False,,0.0,,17.05885672569275,0.008285760879516602,"Design a traffic light FSM with 4 states: NS_GREEN, NS_YELLOW, EW_GREEN, EW_YELLOW. Inputs: clk, rst, emergency. Outputs: ns_light[1:0], ew_light[1:0]. Timing: GREEN=8 cycles, YELLOW=2 cycles. Emergency makes both RED. Include testbench.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph TD
    CLK[Clock] --> FSM
    RST[Reset] --> FSM
    EMG[Emergency] --> FSM
    FSM((Traffic Light FSM))
    FSM --> NSG(NS_GREEN)
    FSM --> NSY(NS_YELLOW)
    FSM --> EWG(EW_GREEN)
    FSM --> EWY(EW_YELLOW)
    NSG --> NSY
    NSY --> EWG
    EWG --> EWY
    EWY --> NSG
    FSM --> NS_LIGHT[ns_light[1:0]]
    FSM --> EW_LIGHT[ew_light[1:0]]
    FSM -- ""8 cycles"" --> NSG
    FSM -- ""2 cycles"" --> NSY
    FSM -- ""8 cycles"" --> EWG
    FSM -- ""2 cycles"" --> EWY
    NSG --> |emergency| EMG
    NSY --> |emergency| EMG
    EWG --> |emergency| EMG
    EWY --> |emergency| EMG
    subgraph Testbench
        TB[TB] --> CLK
        TB --> RST
        TB --> EMG
        TB --> FSM
    end
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module traffic_light_fsm(
    input wire clk,
    input wire rst,
    input wire emergency,
    output reg [1:0] ns_light,
    output reg [1:0] ew_light
);

    typedef enum logic [1:0] {
        NS_GREEN = 2'b00,
        NS_YELLOW = 2'b01,
        EW_GREEN = 2'b10,
        EW_YELLOW = 2'b11
    } state_t;

    state_t current_state, next_state;
    reg [3:0] cycle_count;

    always @(posedge clk or posedge rst) begin
        if (rst) begin
            current_state <= NS_GREEN;
            cycle_count <= 4'd0;
        end else if (emergency) begin
            current_state <= NS_GREEN;
            cycle_count <= 4'd0;
        end else begin
            if (cycle_count == ((current_state == NS_GREEN || current_state == EW_GREEN) ? 4'd7 : 4'd1)) begin
                current_state <= next_state;
                cycle_count <= 4'd0;
            end else begin
                cycle_count <= cycle_count + 4'd1;
            end
        end
    end

    always @(*) begin
        case (current_state)
            NS_GREEN: begin
                ns_light = 2'b01;
                ew_light = 2'b00;
                next_state = NS_YELLOW;
            end
            NS_YELLOW: begin
                ns_light = 2'b10;
                ew_light = 2'b00;
                next_state = EW_GREEN;
            end
            EW_GREEN: begin
                ns_light = 2'b00;
                ew_light = 2'b01;
                next_state = EW_YELLOW;
            end
            EW_YELLOW: begin
                ns_light = 2'b00;
                ew_light = 2'b10;
                next_state = NS_GREEN;
            end
        endcase
    end

endmodule

module testbench;
    reg clk;
    reg rst;
    reg emergency;
    wire [1:0] ns_light;
    wire [1:0] ew_light;

    traffic_light_fsm dut (
        .clk(clk),
        .rst(rst),
        .emergency(emergency),
        .ns_light(ns_light),
        .ew_light(ew_light)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 1'b0;
        rst = 1'b1;
        emergency = 1'b0;
        
        #10 rst = 1'b0;
        #20 emergency = 1'b1;
        #20 emergency = 1'b0;
        #200 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t clk=%b rst=%b emergency=%b ns_light=%b ew_light=%b"", 
                 $time, clk, rst, emergency, ns_light, ew_light);
    end
endmodule",True,100,True,True,True,True,0.7,True,7.920945882797241,13.735706329345703,prompt_only,prompt_only > mermaid_only > combined,prompt_only > combined > mermaid_only
combined,State Machine,complex,"Design UART transmitter with states: IDLE, START, DATA, STOP. Protocol: START(0), 8 data bits LSB-first, STOP(1). Baud rate divider. Include testbench.",claude,,False,0,False,False,False,,0.0,,0.30741262435913086,0.0,,,False,0,False,False,False,,0.0,,0.3587775230407715,0.0,,,False,0,False,False,False,,0.0,,0.0,0.0,none,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,State Machine,complex,"Design UART transmitter with states: IDLE, START, DATA, STOP. Protocol: START(0), 8 data bits LSB-first, STOP(1). Baud rate divider. Include testbench.",gpt-4o,"`timescale 1ns/1ps

module uart_tx(
    input wire clk,
    input wire rst_n,
    input wire tx_start,
    input wire [7:0] tx_data,
    output reg tx,
    output reg tx_busy
);

    reg [3:0] state;
    reg [3:0] bit_counter;
    reg [15:0] baud_counter;
    reg [7:0] data_shift_reg;

    parameter IDLE = 4'b0000;
    parameter START = 4'b0001;
    parameter DATA = 4'b0010;
    parameter STOP = 4'b0011;
    parameter BAUD_DIV = 16'd5208; // Example value for baud rate division

    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            state <= IDLE;
            tx <= 1'b1;
            tx_busy <= 1'b0;
            bit_counter <= 4'b0000;
            baud_counter <= 16'b0;
            data_shift_reg <= 8'b0;
        end
        else begin
            case (state)
                IDLE: begin
                    tx <= 1'b1;
                    tx_busy <= 1'b0;
                    if (tx_start) begin
                        state <= START;
                        data_shift_reg <= tx_data;
                        tx_busy <= 1'b1;
                    end
                end
                START: begin
                    if (baud_counter == BAUD_DIV) begin
                        baud_counter <= 16'b0;
                        tx <= 1'b0;
                        state <= DATA;
                        bit_counter <= 4'b0000;
                    end
                    else
                        baud_counter <= baud_counter + 1'b1;
                end
                DATA: begin
                    if (baud_counter == BAUD_DIV) begin
                        baud_counter <= 16'b0;
                        tx <= data_shift_reg[0];
                        data_shift_reg <= data_shift_reg >> 1;
                        if (bit_counter == 4'd7)
                            state <= STOP;
                        else
                            bit_counter <= bit_counter + 1'b1;
                    end
                    else
                        baud_counter <= baud_counter + 1'b1;
                end
                STOP: begin
                    if (baud_counter == BAUD_DIV) begin
                        baud_counter <= 16'b0;
                        tx <= 1'b1;
                        state <= IDLE;
                        tx_busy <= 1'b0;
                    end
                    else
                        baud_counter <= baud_counter + 1'b1;
                end
            endcase
        end
    end
endmodule

module testbench;
    reg clk, rst_n, tx_start;
    reg [7:0] tx_data;
    wire tx, tx_busy;
    
    uart_tx dut (
        .clk(clk),
        .rst_n(rst_n),
        .tx_start(tx_start),
        .tx_data(tx_data),
        .tx(tx),
        .tx_busy(tx_busy)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst_n = 1'b0;
        tx_start = 1'b0;
        tx_data = 8'b0;
        
        #20 rst_n = 1'b1;
        #10 tx_data = 8'b10101010;
        #10 tx_start = 1'b1;
        #10 tx_start = 1'b0;
        #1000 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b tx_start=%b tx_data=%b tx=%b tx_busy=%b"", 
                 $time, clk, rst_n, tx_start, tx_data, tx, tx_busy);
    end
endmodule",True,117,True,True,True,True,0.9,True,13.179142951965332,23.81879496574402,"graph LR
    CLK[Clock] --> BAUD[Baud Rate Divider]
    RST[Reset] --> IDLE
    RST --> BAUD
    BAUD --> FSM(State Machine)
    
    IDLE((IDLE State)) -->|Start Bit Detected| START((START State))
    START --> DATA((DATA State))
    DATA --> STOP((STOP State))
    STOP -->|Transmission Complete| IDLE
    
    FSM --> IDLE
    FSM --> START
    FSM --> DATA
    FSM --> STOP
    
    TX_DATA[TX Data] -->|8 bits LSB-first| DATA
    DATA --> TX_OUT[TX Output]
    START -->|0| TX_OUT
    STOP -->|1| TX_OUT
    
    TESTBENCH[[Testbench]]
    TESTBENCH --> TX_DATA
    TESTBENCH --> CLK
    TESTBENCH --> RST","`timescale 1ns/1ps

module uart_fsm(
    input wire clk,
    input wire rst_n,
    input wire [7:0] tx_data,
    output reg tx_out
);

    reg [1:0] state, next_state;
    reg [3:0] baud_counter;
    reg baud_tick;

    localparam IDLE = 2'b00;
    localparam START = 2'b01;
    localparam DATA = 2'b10;
    localparam STOP = 2'b11;

    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            state <= IDLE;
            baud_counter <= 4'b0000;
            baud_tick <= 1'b0;
        end else begin
            state <= next_state;
            if (baud_counter == 4'b1001) begin
                baud_counter <= 4'b0000;
                baud_tick <= 1'b1;
            end else begin
                baud_counter <= baud_counter + 1'b1;
                baud_tick <= 1'b0;
            end
        end
    end

    always @* begin
        next_state = state;
        tx_out = 1'b1;
        case (state)
            IDLE: begin
                if (baud_tick) next_state = START;
            end
            START: begin
                tx_out = 1'b0;
                if (baud_tick) next_state = DATA;
            end
            DATA: begin
                tx_out = tx_data[0];
                if (baud_tick) next_state = STOP;
            end
            STOP: begin
                tx_out = 1'b1;
                if (baud_tick) next_state = IDLE;
            end
        endcase
    end

endmodule

module testbench;
    reg clk, rst_n;
    reg [7:0] tx_data;
    wire tx_out;

    uart_fsm dut (
        .clk(clk),
        .rst_n(rst_n),
        .tx_data(tx_data),
        .tx_out(tx_out)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 1'b0;
        rst_n = 1'b0;
        tx_data = 8'b10101010;

        #20 rst_n = 1'b1;
        #200 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b tx_data=%b tx_out=%b"", 
                 $time, clk, rst_n, tx_data, tx_out);
    end
endmodule",True,90,True,True,True,True,0.7,True,10.587087631225586,11.239145994186401,"Design UART transmitter with states: IDLE, START, DATA, STOP. Protocol: START(0), 8 data bits LSB-first, STOP(1). Baud rate divider. Include testbench.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph LR
    CLK[Clock] --> BAUD[Baud Rate Divider]
    RST[Reset] --> IDLE
    RST --> BAUD
    BAUD --> FSM(State Machine)
    
    IDLE((IDLE State)) -->|Start Bit Detected| START((START State))
    START --> DATA((DATA State))
    DATA --> STOP((STOP State))
    STOP -->|Transmission Complete| IDLE
    
    FSM --> IDLE
    FSM --> START
    FSM --> DATA
    FSM --> STOP
    
    TX_DATA[TX Data] -->|8 bits LSB-first| DATA
    DATA --> TX_OUT[TX Output]
    START -->|0| TX_OUT
    STOP -->|1| TX_OUT
    
    TESTBENCH[[Testbench]]
    TESTBENCH --> TX_DATA
    TESTBENCH --> CLK
    TESTBENCH --> RST
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module uart_tx(
    input wire clk,
    input wire rst_n,
    input wire [7:0] tx_data,
    output reg tx_out
);

    reg [3:0] state;
    reg [3:0] bit_count;
    reg baud_tick;
    reg [3:0] baud_count;

    localparam IDLE = 4'b0000;
    localparam START = 4'b0001;
    localparam DATA = 4'b0010;
    localparam STOP = 4'b0011;

    // Baud Rate Divider
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            baud_count <= 4'b0000;
            baud_tick <= 1'b0;
        end else begin
            if (baud_count == 4'b1111) begin
                baud_count <= 4'b0000;
                baud_tick <= 1'b1;
            end else begin
                baud_count <= baud_count + 1'b1;
                baud_tick <= 1'b0;
            end
        end
    end

    // State Machine
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            state <= IDLE;
            tx_out <= 1'b1;
            bit_count <= 4'b0000;
        end else if (baud_tick) begin
            case (state)
                IDLE: begin
                    tx_out <= 1'b1;
                    if (tx_data[0] == 1'b0) begin
                        state <= START;
                    end
                end
                START: begin
                    tx_out <= 1'b0;
                    state <= DATA;
                    bit_count <= 4'b0000;
                end
                DATA: begin
                    tx_out <= tx_data[bit_count];
                    bit_count <= bit_count + 1'b1;
                    if (bit_count == 4'b1000) begin
                        state <= STOP;
                    end
                end
                STOP: begin
                    tx_out <= 1'b1;
                    state <= IDLE;
                end
                default: state <= IDLE;
            endcase
        end
    end

endmodule

module testbench;
    reg clk;
    reg rst_n;
    reg [7:0] tx_data;
    wire tx_out;

    uart_tx dut (
        .clk(clk),
        .rst_n(rst_n),
        .tx_data(tx_data),
        .tx_out(tx_out)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 1'b0;
        rst_n = 1'b0;
        tx_data = 8'b00000000;

        #20 rst_n = 1'b1;
        #20 tx_data = 8'b10101010;
        
        #200 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b tx_data=%b tx_out=%b"", 
                 $time, clk, rst_n, tx_data, tx_out);
    end
endmodule",True,106,True,True,True,True,0.9,True,8.806595802307129,14.025285482406616,prompt_only,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,CPU Component,complex,Create 8-register × 8-bit register file with dual read ports and single write port. Include testbench with simultaneous operations.,claude,,False,0,False,False,False,,0.0,,0.31191134452819824,0.0,,,False,0,False,False,False,,0.0,,0.3235294818878174,0.0,,,False,0,False,False,False,,0.0,,0.0,0.0,none,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,CPU Component,complex,Create 8-register × 8-bit register file with dual read ports and single write port. Include testbench with simultaneous operations.,gpt-4o,"`timescale 1ns/1ps

module register_file (
    input wire clk,
    input wire rst_n,
    input wire [2:0] read_addr1,
    input wire [2:0] read_addr2,
    input wire [2:0] write_addr,
    input wire [7:0] write_data,
    input wire write_enable,
    output reg [7:0] read_data1,
    output reg [7:0] read_data2
);

    reg [7:0] registers [7:0];
    integer i;

    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            for (i = 1'b0; i < 8; i = i + 1) begin
                registers[i] <= 8'b0;
            end
        end else if (write_enable) begin
            registers[write_addr] <= write_data;
        end
    end

    always @(*) begin
        read_data1 = registers[read_addr1];
        read_data2 = registers[read_addr2];
    end

endmodule

module testbench;
    reg clk;
    reg rst_n;
    reg [2:0] read_addr1;
    reg [2:0] read_addr2;
    reg [2:0] write_addr;
    reg [7:0] write_data;
    reg write_enable;
    wire [7:0] read_data1;
    wire [7:0] read_data2;

    register_file dut (
        .clk(clk),
        .rst_n(rst_n),
        .read_addr1(read_addr1),
        .read_addr2(read_addr2),
        .write_addr(write_addr),
        .write_data(write_data),
        .write_enable(write_enable),
        .read_data1(read_data1),
        .read_data2(read_data2)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 1'b0;
        rst_n = 1'b0;
        write_enable = 1'b0;
        write_data = 8'b0;
        write_addr = 3'b0;
        read_addr1 = 3'b0;
        read_addr2 = 3'b0;

        #20 rst_n = 1'b1;
        #10 write_enable = 1'b1; write_addr = 3'b001; write_data = 8'b10101010;
        #10 write_enable = 1'b0; read_addr1 = 3'b001; read_addr2 = 3'b000;
        #30 write_enable = 1'b1; write_addr = 3'b010; write_data = 8'b01010101;
        #10 write_enable = 1'b0; read_addr1 = 3'b010; read_addr2 = 3'b001;
        #30 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b write_enable=%b read_addr1=%d read_addr2=%d write_addr=%d write_data=%b read_data1=%b read_data2=%b"",
                 $time, clk, rst_n, write_enable, read_addr1, read_addr2, write_addr, write_data, read_data1, read_data2);
    end
endmodule",True,84,True,True,True,True,0.75,True,8.74509048461914,9.605376720428467,"graph TD
    CLK[Clock] --> CTRL(Controller)
    RST[Reset] --> CTRL
    DATA_IN[Write Data (8-bit)] --> W_PORT(Write Port)
    ADDR_W[Write Address (3-bit)] --> W_PORT
    ADDR_R1[Read Address 1 (3-bit)] --> MUX1{MUX}
    ADDR_R2[Read Address 2 (3-bit)] --> MUX2{MUX}
    W_PORT --> RF[[Register File<br>8x8-bit]]
    CTRL --> W_PORT
    MUX1 --> RF
    MUX2 --> RF
    RF --> R_PORT1[Read Port 1 (8-bit)]
    RF --> R_PORT2[Read Port 2 (8-bit)]
    TB[Testbench] --> ADDR_W
    TB --> DATA_IN
    TB --> ADDR_R1
    TB --> ADDR_R2
    TB --> CTRL
    TB --> CLK
    TB --> RST
    R_PORT1 --> TB
    R_PORT2 --> TB","`timescale 1ns/1ps

module register_file(
    input wire clk,
    input wire rst,
    input wire [2:0] addr_w,
    input wire [7:0] data_in,
    input wire [2:0] addr_r1,
    input wire [2:0] addr_r2,
    input wire write_enable,
    output reg [7:0] data_out1,
    output reg [7:0] data_out2
);
    reg [7:0] mem [7:0];
    
    always @(posedge clk or posedge rst) begin
        if (rst) begin
            // Optional: Initialize memory on reset
            mem[0] <= 8'b0;
            mem[1] <= 8'b0;
            mem[2] <= 8'b0;
            mem[3] <= 8'b0;
            mem[4] <= 8'b0;
            mem[5] <= 8'b0;
            mem[6] <= 8'b0;
            mem[7] <= 8'b0;
        end else if (write_enable) begin
            mem[addr_w] <= data_in;
        end
    end
    
    always @(*) begin
        data_out1 = mem[addr_r1];
        data_out2 = mem[addr_r2];
    end
endmodule

module controller(
    input wire clk,
    input wire rst,
    output reg write_enable
);
    always @(posedge clk or posedge rst) begin
        if (rst) begin
            write_enable <= 1'b0;
        end else begin
            write_enable <= 1'b1; // Example: always enable write
        end
    end
endmodule

module testbench;
    reg clk, rst;
    reg [2:0] addr_w, addr_r1, addr_r2;
    reg [7:0] data_in;
    wire [7:0] data_out1, data_out2;
    wire write_enable;

    register_file rf (
        .clk(clk),
        .rst(rst),
        .addr_w(addr_w),
        .data_in(data_in),
        .addr_r1(addr_r1),
        .addr_r2(addr_r2),
        .write_enable(write_enable),
        .data_out1(data_out1),
        .data_out2(data_out2)
    );
    
    controller ctrl (
        .clk(clk),
        .rst(rst),
        .write_enable(write_enable)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 1'b0;
        rst = 1'b1;
        addr_w = 3'b0;
        data_in = 8'b0;
        addr_r1 = 3'b0;
        addr_r2 = 3'b0;

        #20 rst = 1'b0;
        #10 addr_w = 3'b001; data_in = 8'hAA;
        #10 addr_w = 3'b010; data_in = 8'hBB;
        #10 addr_r1 = 3'b001;
        #10 addr_r2 = 3'b010;
        #50 $finish;
    end

    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t clk=%b rst=%b addr_w=%b data_in=%h addr_r1=%b addr_r2=%b data_out1=%h data_out2=%h"",
                 $time, clk, rst, addr_w, data_in, addr_r1, addr_r2, data_out1, data_out2);
    end
endmodule",True,102,True,True,True,True,0.75,True,17.398641109466553,20.357819318771362,"Create 8-register × 8-bit register file with dual read ports and single write port. Include testbench with simultaneous operations.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph TD
    CLK[Clock] --> CTRL(Controller)
    RST[Reset] --> CTRL
    DATA_IN[Write Data (8-bit)] --> W_PORT(Write Port)
    ADDR_W[Write Address (3-bit)] --> W_PORT
    ADDR_R1[Read Address 1 (3-bit)] --> MUX1{MUX}
    ADDR_R2[Read Address 2 (3-bit)] --> MUX2{MUX}
    W_PORT --> RF[[Register File<br>8x8-bit]]
    CTRL --> W_PORT
    MUX1 --> RF
    MUX2 --> RF
    RF --> R_PORT1[Read Port 1 (8-bit)]
    RF --> R_PORT2[Read Port 2 (8-bit)]
    TB[Testbench] --> ADDR_W
    TB --> DATA_IN
    TB --> ADDR_R1
    TB --> ADDR_R2
    TB --> CTRL
    TB --> CLK
    TB --> RST
    R_PORT1 --> TB
    R_PORT2 --> TB
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module register_file_8x8 (
    input wire clk,
    input wire rst_n,
    input wire [2:0] addr_w,
    input wire [7:0] data_in,
    input wire [2:0] addr_r1,
    input wire [2:0] addr_r2,
    input wire write_enable,
    output wire [7:0] read_data1,
    output wire [7:0] read_data2
);
    reg [7:0] registers [7:0];
    
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            // Initialize all registers to zero
            registers[0] <= 8'b0;
            registers[1] <= 8'b0;
            registers[2] <= 8'b0;
            registers[3] <= 8'b0;
            registers[4] <= 8'b0;
            registers[5] <= 8'b0;
            registers[6] <= 8'b0;
            registers[7] <= 8'b0;
        end else if (write_enable) begin
            registers[addr_w] <= data_in;
        end
    end
    
    assign read_data1 = registers[addr_r1];
    assign read_data2 = registers[addr_r2];
    
endmodule

module testbench;
    reg clk;
    reg rst_n;
    reg [2:0] addr_w;
    reg [7:0] data_in;
    reg [2:0] addr_r1;
    reg [2:0] addr_r2;
    reg write_enable;
    wire [7:0] read_data1;
    wire [7:0] read_data2;
    
    register_file_8x8 uut (
        .clk(clk),
        .rst_n(rst_n),
        .addr_w(addr_w),
        .data_in(data_in),
        .addr_r1(addr_r1),
        .addr_r2(addr_r2),
        .write_enable(write_enable),
        .read_data1(read_data1),
        .read_data2(read_data2)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst_n = 1'b0;
        addr_w = 3'b000;
        data_in = 8'b0;
        addr_r1 = 3'b000;
        addr_r2 = 3'b001;
        write_enable = 1'b0;
        
        #20 rst_n = 1'b1;
        #10 write_enable = 1'b1; addr_w = 3'b010; data_in = 8'hAA;
        #10 write_enable = 1'b0; addr_r1 = 3'b010;
        #10 addr_r2 = 3'b010;
        #10 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b addr_w=%b data_in=%b addr_r1=%b addr_r2=%b read_data1=%b read_data2=%b"",
                 $time, clk, rst_n, addr_w, data_in, addr_r1, addr_r2, read_data1, read_data2);
    end
endmodule",True,85,True,True,True,False,0.4,False,8.62460994720459,11.157111883163452,combined,combined > prompt_only > mermaid_only,prompt_only > mermaid_only > combined
combined,Advanced Sequential,complex,"Design 8-bit resolution PWM generator with configurable duty cycle. Include testbench with duty cycles: 0%, 25%, 50%, 75%, 100%.",claude,,False,0,False,False,False,,0.0,,0.33045458793640137,0.0,,,False,0,False,False,False,,0.0,,0.2933220863342285,0.0,,,False,0,False,False,False,,0.0,,0.0,0.0,none,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,Advanced Sequential,complex,"Design 8-bit resolution PWM generator with configurable duty cycle. Include testbench with duty cycles: 0%, 25%, 50%, 75%, 100%.",gpt-4o,"`timescale 1ns/1ps

module pwm_generator(
    input wire clk,
    input wire rst_n,
    input wire [7:0] duty_cycle,
    output reg pwm_out
);

reg [7:0] counter;

always @(posedge clk or negedge rst_n) begin
    if (!rst_n)
        counter <= 8'b0;
    else
        counter <= counter + 1'b1;
end

always @(posedge clk or negedge rst_n) begin
    if (!rst_n)
        pwm_out <= 1'b0;
    else
        pwm_out <= (counter < duty_cycle) ? 1'b1 : 1'b0;
end

endmodule

module testbench;
    reg clk, rst_n;
    reg [7:0] duty_cycle;
    wire pwm_out;

    pwm_generator dut (
        .clk(clk),
        .rst_n(rst_n),
        .duty_cycle(duty_cycle),
        .pwm_out(pwm_out)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 1'b0;
        rst_n = 1'b0;
        duty_cycle = 8'd0;

        #20 rst_n = 1'b1;

        // Test with 0% duty cycle
        #10 duty_cycle = 8'd0;
        #100;

        // Test with 25% duty cycle
        #10 duty_cycle = 8'd64;
        #100;

        // Test with 50% duty cycle
        #10 duty_cycle = 8'd128;
        #100;

        // Test with 75% duty cycle
        #10 duty_cycle = 8'd192;
        #100;

        // Test with 100% duty cycle
        #10 duty_cycle = 8'd255;
        #100;

        #50 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b duty_cycle=%d pwm_out=%b"", 
                 $time, clk, rst_n, duty_cycle, pwm_out);
    end
endmodule",True,79,True,True,True,False,0.3,False,4.693676710128784,11.276923656463623,"graph TD
    CLK[Clock] --> CNT(Counter)
    RST[Reset] --> CNT
    CNT --> CMP(Comparator)
    DC[Duty Cycle Input] --> CMP
    CMP --> PWM_OUT[PWM Output]
    subgraph Testbench
        TB_CLK[Testbench Clock] --> TB_CNT
        TB_RST[Testbench Reset] --> TB_CNT
        DC0[0% Duty Cycle] --> TB_DC
        DC25[25% Duty Cycle] --> TB_DC
        DC50[50% Duty Cycle] --> TB_DC
        DC75[75% Duty Cycle] --> TB_DC
        DC100[100% Duty Cycle] --> TB_DC
        TB_CNT --> TB_CMP
        TB_DC --> TB_CMP
        TB_CMP --> TB_PWM_OUT[Testbench PWM Output]
    end","`timescale 1ns/1ps

module counter(
    input wire clk,
    input wire rst_n,
    output reg [3:0] count
);

always @(posedge clk or negedge rst_n) begin
    if (!rst_n)
        count <= 4'b0000;
    else
        count <= count + 1'b1;
end

endmodule

module comparator(
    input wire [3:0] count,
    input wire [3:0] duty_cycle,
    output reg pwm_out
);

always @(*) begin
    if (count < duty_cycle)
        pwm_out = 1'b1;
    else
        pwm_out = 1'b0;
end

endmodule

module pwm(
    input wire clk,
    input wire rst_n,
    input wire [3:0] duty_cycle,
    output wire pwm_out
);

wire [3:0] count;

counter cnt (
    .clk(clk),
    .rst_n(rst_n),
    .count(count)
);

comparator cmp (
    .count(count),
    .duty_cycle(duty_cycle),
    .pwm_out(pwm_out)
);

endmodule

module testbench;
    reg clk, rst_n;
    reg [3:0] duty_cycle;
    wire pwm_out;
    
    pwm dut (
        .clk(clk),
        .rst_n(rst_n),
        .duty_cycle(duty_cycle),
        .pwm_out(pwm_out)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst_n = 1'b0;
        duty_cycle = 4'b0000;
        
        #20 rst_n = 1'b1;
        #10 duty_cycle = 4'b0000; // 0% Duty Cycle
        #100 duty_cycle = 4'b0100; // 25% Duty Cycle
        #100 duty_cycle = 4'b1000; // 50% Duty Cycle
        #100 duty_cycle = 4'b1100; // 75% Duty Cycle
        #100 duty_cycle = 4'b1111; // 100% Duty Cycle
        #50 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b duty_cycle=%d pwm_out=%b"", 
                 $time, clk, rst_n, duty_cycle, pwm_out);
    end
endmodule",True,91,True,True,True,False,0.3,False,11.816615343093872,10.423958778381348,"Design 8-bit resolution PWM generator with configurable duty cycle. Include testbench with duty cycles: 0%, 25%, 50%, 75%, 100%.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph TD
    CLK[Clock] --> CNT(Counter)
    RST[Reset] --> CNT
    CNT --> CMP(Comparator)
    DC[Duty Cycle Input] --> CMP
    CMP --> PWM_OUT[PWM Output]
    subgraph Testbench
        TB_CLK[Testbench Clock] --> TB_CNT
        TB_RST[Testbench Reset] --> TB_CNT
        DC0[0% Duty Cycle] --> TB_DC
        DC25[25% Duty Cycle] --> TB_DC
        DC50[50% Duty Cycle] --> TB_DC
        DC75[75% Duty Cycle] --> TB_DC
        DC100[100% Duty Cycle] --> TB_DC
        TB_CNT --> TB_CMP
        TB_DC --> TB_CMP
        TB_CMP --> TB_PWM_OUT[Testbench PWM Output]
    end
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module pwm_generator(
    input wire clk,
    input wire rst_n,
    input wire [7:0] duty_cycle,
    output reg pwm_out
);

reg [7:0] counter;

always @(posedge clk or negedge rst_n) begin
    if (!rst_n)
        counter <= 8'b00000000;
    else
        counter <= counter + 1'b1;
end

always @(posedge clk or negedge rst_n) begin
    if (!rst_n)
        pwm_out <= 1'b0;
    else
        pwm_out <= (counter < duty_cycle) ? 1'b1 : 1'b0;
end

endmodule

module testbench;
    reg tb_clk, tb_rst_n;
    reg [7:0] tb_duty_cycle;
    wire tb_pwm_out;
    
    pwm_generator dut (
        .clk(tb_clk),
        .rst_n(tb_rst_n),
        .duty_cycle(tb_duty_cycle),
        .pwm_out(tb_pwm_out)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        tb_clk = 1'b0;
        tb_rst_n = 1'b0;
        tb_duty_cycle = 8'd0;
        
        #20 tb_rst_n = 1'b1;
        #10 tb_duty_cycle = 8'd0;    // 0% Duty Cycle
        #100 tb_duty_cycle = 8'd64;  // 25% Duty Cycle
        #100 tb_duty_cycle = 8'd128; // 50% Duty Cycle
        #100 tb_duty_cycle = 8'd192; // 75% Duty Cycle
        #100 tb_duty_cycle = 8'd255; // 100% Duty Cycle
        #50 $finish;
    end
    
    always #5 tb_clk = ~tb_clk;
    
    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b duty_cycle=%d pwm_out=%b"", 
                 $time, tb_clk, tb_rst_n, tb_duty_cycle, tb_pwm_out);
    end
endmodule",True,63,True,True,True,False,0.3,False,7.712251424789429,8.606139898300171,tie,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,Protocol,complex,"Design SPI master supporting mode 0 (CPOL=0, CPHA=0). Include SCLK generation, MOSI/MISO handling. Include testbench.",claude,,False,0,False,False,False,,0.0,,0.30736541748046875,0.0,,,False,0,False,False,False,,0.0,,0.3208153247833252,0.0,,,False,0,False,False,False,,0.0,,0.0,0.0,none,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,Protocol,complex,"Design SPI master supporting mode 0 (CPOL=0, CPHA=0). Include SCLK generation, MOSI/MISO handling. Include testbench.",gpt-4o,"`timescale 1ns/1ps

module spi_master(
    input wire clk,
    input wire rst_n,
    input wire mosi,
    output wire miso,
    output wire sclk,
    input wire start,
    input wire [7:0] data_in,
    output reg [7:0] data_out,
    output reg done
);

    reg [7:0] shift_reg;
    reg [2:0] bit_count;
    reg sclk_reg;
    reg sclk_enable;

    assign sclk = sclk_reg;

    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            sclk_reg <= 1'b0;
            sclk_enable <= 1'b0;
            shift_reg <= 8'b0;
            bit_count <= 3'b0;
            data_out <= 8'b0;
            done <= 1'b0;
        end else begin
            if (start && !sclk_enable) begin
                shift_reg <= data_in;
                bit_count <= 3'b0;
                sclk_enable <= 1'b1;
                done <= 1'b0;
            end

            if (sclk_enable) begin
                sclk_reg <= ~sclk_reg;
                if (sclk_reg == 1'b0) begin
                    shift_reg <= {shift_reg[6:0], mosi};
                    bit_count <= bit_count + 1'b1;
                    if (bit_count == 3'b111) begin
                        sclk_enable <= 1'b0;
                        data_out <= shift_reg;
                        done <= 1'b1;
                    end
                end
            end
        end
    end

    assign miso = shift_reg[7];

endmodule

module testbench;
    reg clk;
    reg rst_n;
    reg mosi;
    wire miso;
    wire sclk;
    reg start;
    reg [7:0] data_in;
    wire [7:0] data_out;
    wire done;

    spi_master dut (
        .clk(clk),
        .rst_n(rst_n),
        .mosi(mosi),
        .miso(miso),
        .sclk(sclk),
        .start(start),
        .data_in(data_in),
        .data_out(data_out),
        .done(done)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 1'b0;
        rst_n = 1'b0;
        mosi = 1'b0;
        start = 1'b0;
        data_in = 8'b10101010;

        #20 rst_n = 1'b1;
        #10 start = 1'b1;
        #10 start = 1'b0;
        #200 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b mosi=%b miso=%b sclk=%b start=%b data_in=%b data_out=%b done=%b"", 
                 $time, clk, rst_n, mosi, miso, sclk, start, data_in, data_out, done);
    end
endmodule",True,102,True,True,True,True,0.9,True,9.428229570388794,12.988105297088623,"graph TD
    CLK[Clock] --> SCLK_GEN(SCLK Generation)
    RST[Reset] --> SCLK_GEN
    SCLK_GEN --> SCLK[SCLK Output]
    SPI_MASTER(SPI Master) --> SCLK_GEN
    MOSI_IN[MOSI Input] --> SPI_MASTER
    SPI_MASTER --> MOSI_OUT[MOSI Output]
    MISO_IN[MISO Input] --> SPI_MASTER
    SPI_MASTER --> MISO_OUT[MISO Output]
    SPI_MASTER --> TESTBENCH
    TESTBENCH --> CLK
    TESTBENCH --> RST
    TESTBENCH --> MOSI_IN
    TESTBENCH --> MISO_OUT
    TESTBENCH --> SCLK","`timescale 1ns/1ps

module sclk_gen(
    input wire clk,
    input wire rst_n,
    output reg sclk
);

always @(posedge clk or negedge rst_n) begin
    if (!rst_n)
        sclk <= 1'b0;
    else
        sclk <= ~sclk;
end

endmodule

module spi_master(
    input wire clk,
    input wire rst_n,
    input wire mosi_in,
    input wire miso_in,
    output reg mosi_out,
    output reg miso_out
);

reg mosi_reg, miso_reg;

always @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
        mosi_reg <= 1'b0;
        miso_reg <= 1'b0;
    end else begin
        mosi_reg <= mosi_in;
        miso_reg <= miso_in;
    end
end

always @(posedge clk) begin
    mosi_out <= mosi_reg;
    miso_out <= miso_reg;
end

endmodule

module testbench;
    reg clk, rst_n, mosi_in, miso_in;
    wire sclk, mosi_out, miso_out;

    sclk_gen sclk_gen_inst (
        .clk(clk),
        .rst_n(rst_n),
        .sclk(sclk)
    );

    spi_master spi_master_inst (
        .clk(clk),
        .rst_n(rst_n),
        .mosi_in(mosi_in),
        .miso_in(miso_in),
        .mosi_out(mosi_out),
        .miso_out(miso_out)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 1'b0;
        rst_n = 1'b0;
        mosi_in = 1'b0;
        miso_in = 1'b0;

        #20 rst_n = 1'b1;
        #10 mosi_in = 1'b1;
        #10 miso_in = 1'b1;
        #100 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b mosi_in=%b miso_in=%b sclk=%b mosi_out=%b miso_out=%b"", 
                 $time, clk, rst_n, mosi_in, miso_in, sclk, mosi_out, miso_out);
    end
endmodule",True,86,True,True,True,True,0.7,True,7.795946836471558,16.64805841445923,"Design SPI master supporting mode 0 (CPOL=0, CPHA=0). Include SCLK generation, MOSI/MISO handling. Include testbench.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph TD
    CLK[Clock] --> SCLK_GEN(SCLK Generation)
    RST[Reset] --> SCLK_GEN
    SCLK_GEN --> SCLK[SCLK Output]
    SPI_MASTER(SPI Master) --> SCLK_GEN
    MOSI_IN[MOSI Input] --> SPI_MASTER
    SPI_MASTER --> MOSI_OUT[MOSI Output]
    MISO_IN[MISO Input] --> SPI_MASTER
    SPI_MASTER --> MISO_OUT[MISO Output]
    SPI_MASTER --> TESTBENCH
    TESTBENCH --> CLK
    TESTBENCH --> RST
    TESTBENCH --> MOSI_IN
    TESTBENCH --> MISO_OUT
    TESTBENCH --> SCLK
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module sclk_gen(
    input wire clk,
    input wire rst_n,
    output reg sclk
);

    reg [1:0] clk_div;

    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            clk_div <= 2'b00;
            sclk <= 1'b0;
        end
        else begin
            clk_div <= clk_div + 1'b1;
            sclk <= clk_div[1];
        end
    end

endmodule

module spi_master(
    input wire clk,
    input wire rst_n,
    input wire mosi_in,
    input wire miso_in,
    output reg mosi_out,
    output reg miso_out
);

    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            mosi_out <= 1'b0;
            miso_out <= 1'b0;
        end
        else begin
            mosi_out <= mosi_in;
            miso_out <= miso_in;
        end
    end

endmodule

module testbench;
    reg clk;
    reg rst_n;
    reg mosi_in;
    wire mosi_out;
    reg miso_in;
    wire miso_out;
    wire sclk;

    sclk_gen sclk_inst(
        .clk(clk),
        .rst_n(rst_n),
        .sclk(sclk)
    );

    spi_master spi_inst(
        .clk(clk),
        .rst_n(rst_n),
        .mosi_in(mosi_in),
        .miso_in(miso_in),
        .mosi_out(mosi_out),
        .miso_out(miso_out)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 1'b0;
        rst_n = 1'b0;
        mosi_in = 1'b0;
        miso_in = 1'b0;

        #20 rst_n = 1'b1;
        #10 mosi_in = 1'b1;
        #100 mosi_in = 1'b0;
        #20 miso_in = 1'b1;
        #20 miso_in = 1'b0;
        #50 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b mosi_in=%b miso_in=%b mosi_out=%b miso_out=%b sclk=%b"", 
                 $time, clk, rst_n, mosi_in, miso_in, mosi_out, miso_out, sclk);
    end
endmodule",True,93,True,True,True,True,0.7,True,10.042319297790527,11.76256513595581,prompt_only,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
