circuit_name,category,complexity,original_prompt,model,prompt_only_verilog,prompt_only_generation_success,prompt_only_lines_of_code,prompt_only_has_testbench,prompt_only_compilation_success,prompt_only_simulation_success,prompt_only_vae_verdict,prompt_only_vae_confidence,prompt_only_consensus_anomalous,prompt_only_generation_time,prompt_only_simulation_time,mermaid_only_mermaid,mermaid_only_verilog,mermaid_only_generation_success,mermaid_only_lines_of_code,mermaid_only_has_testbench,mermaid_only_compilation_success,mermaid_only_simulation_success,mermaid_only_vae_verdict,mermaid_only_vae_confidence,mermaid_only_consensus_anomalous,mermaid_only_generation_time,mermaid_only_simulation_time,combined_prompt,combined_verilog,combined_generation_success,combined_lines_of_code,combined_has_testbench,combined_compilation_success,combined_simulation_success,combined_vae_verdict,combined_vae_confidence,combined_consensus_anomalous,combined_generation_time,combined_simulation_time,best_approach,correctness_ranking,simulation_ranking
combined,Combinational,simple,"Design a 2-to-1 multiplexer with inputs a, b, select sel, and output out. Include testbench testing all combinations.",claude,"`timescale 1ns/1ps

module mux2to1(
    input wire a,
    input wire b,
    input wire sel,
    output reg out
);

always @(*) begin
    case(sel)
        1'b0: out = a;
        1'b1: out = b;
    endcase
end

endmodule

module testbench;
    reg a, b, sel;
    wire out;
    
    mux2to1 dut(
        .a(a),
        .b(b),
        .sel(sel),
        .out(out)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        // Test all input combinations
        a = 0; b = 0; sel = 0; #10;
        a = 0; b = 0; sel = 1; #10;
        a = 0; b = 1; sel = 0; #10;
        a = 0; b = 1; sel = 1; #10;
        a = 1; b = 0; sel = 0; #10;
        a = 1; b = 0; sel = 1; #10;
        a = 1; b = 1; sel = 0; #10;
        a = 1; b = 1; sel = 1; #10;
        
        $finish;
    end
    
    initial begin
        $monitor(""Time=%0t a=%b b=%b sel=%b out=%b"",
                 $time, a, b, sel, out);
    end
endmodule",True,51,True,True,True,False,0.4,False,5.072850942611694,5.814389705657959,"graph LR
    A[Input A] --> MUX{2:1 MUX}
    B[Input B] --> MUX
    SEL[Select] -->|Control| MUX
    MUX --> OUT[Output]
    TB[[Testbench]]
    TB -->|Test Vector 1| A
    TB -->|Test Vector 2| B
    TB -->|Test Vector 3| SEL
    OUT -->|Verify| TB
    subgraph Test_Cases
        TV1[sel=0: out=a]
        TV2[sel=1: out=b]
    end","`timescale 1ns/1ps

module mux2to1 (
    input wire clk,
    input wire rst_n,
    input wire a,
    input wire b,
    input wire sel,
    output reg out
);

always @(posedge clk or negedge rst_n) begin
    if (!rst_n)
        out <= 1'b0;
    else
        out <= sel ? b : a;
end

endmodule

module testbench;
    reg clk, rst_n;
    reg a, b, sel;
    wire out;
    
    mux2to1 dut (
        .clk(clk),
        .rst_n(rst_n),
        .a(a),
        .b(b),
        .sel(sel),
        .out(out)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 0;
        rst_n = 0;
        a = 0;
        b = 0;
        sel = 0;
        
        #10 rst_n = 1;
        
        // Test Vector 1: sel=0, out should follow a
        #10 a = 1; b = 0; sel = 0;
        #10 a = 0;
        
        // Test Vector 2: sel=1, out should follow b
        #10 a = 0; b = 1; sel = 1;
        #10 b = 0;
        
        // Additional test cases
        #10 a = 1; b = 1; sel = 0;
        #10 sel = 1;
        
        #10 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t rst_n=%b a=%b b=%b sel=%b out=%b"",
                 $time, rst_n, a, b, sel, out);
    end
endmodule",True,68,True,True,True,False,0.4,False,9.371949911117554,7.35366415977478,"Design a 2-to-1 multiplexer with inputs a, b, select sel, and output out. Include testbench testing all combinations.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph LR
    A[Input A] --> MUX{2:1 MUX}
    B[Input B] --> MUX
    SEL[Select] -->|Control| MUX
    MUX --> OUT[Output]
    TB[[Testbench]]
    TB -->|Test Vector 1| A
    TB -->|Test Vector 2| B
    TB -->|Test Vector 3| SEL
    OUT -->|Verify| TB
    subgraph Test_Cases
        TV1[sel=0: out=a]
        TV2[sel=1: out=b]
    end
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module mux2to1 (
    input wire a,
    input wire b,
    input wire sel,
    output reg out
);

always @(*) begin
    case(sel)
        1'b0: out = a;
        1'b1: out = b;
        default: out = 1'bx;
    endcase
end

endmodule

module testbench;
    reg a, b, sel;
    wire out;
    
    mux2to1 dut (
        .a(a),
        .b(b),
        .sel(sel),
        .out(out)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        // Test Vector 1: sel=0, expect out=a
        a = 1'b1; b = 1'b0; sel = 1'b0;
        #10;
        
        // Test Vector 2: sel=1, expect out=b
        a = 1'b1; b = 1'b0; sel = 1'b1;
        #10;
        
        // Additional combinations
        a = 1'b0; b = 1'b1; sel = 1'b0;
        #10;
        a = 1'b0; b = 1'b1; sel = 1'b1;
        #10;
        
        $finish;
    end
    
    initial begin
        $monitor(""Time=%0t a=%b b=%b sel=%b out=%b"", 
                 $time, a, b, sel, out);
    end
endmodule",True,56,True,True,True,False,0.4,False,5.121696472167969,5.717268466949463,tie,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,Combinational,simple,"Design a 2-to-1 multiplexer with inputs a, b, select sel, and output out. Include testbench testing all combinations.",gpt-4o,"`timescale 1ns/1ps

module mux2to1(
    input wire a,
    input wire b,
    input wire sel,
    output wire out
);

assign out = sel ? b : a;

endmodule

module testbench;
    reg a, b, sel;
    wire out;

    mux2to1 dut (
        .a(a),
        .b(b),
        .sel(sel),
        .out(out)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        a = 1'b0; b = 1'b0; sel = 1'b0;
        #10 a = 1'b0; b = 1'b1; sel = 1'b0;
        #10 a = 1'b1; b = 1'b0; sel = 1'b0;
        #10 a = 1'b1; b = 1'b1; sel = 1'b0;
        #10 a = 1'b0; b = 1'b0; sel = 1'b1;
        #10 a = 1'b0; b = 1'b1; sel = 1'b1;
        #10 a = 1'b1; b = 1'b0; sel = 1'b1;
        #10 a = 1'b1; b = 1'b1; sel = 1'b1;
        #10 $finish;
    end

    initial begin
        $monitor(""Time=%0t a=%b b=%b sel=%b out=%b"",
                 $time, a, b, sel, out);
    end
endmodule",True,44,True,True,True,False,0.4,False,19.398520708084106,10.01602029800415,"graph LR
    SEL[sel] --> MUX{2-to-1 MUX}
    A[a] --> MUX
    B[b] --> MUX
    MUX --> OUT[out]

    subgraph Testbench
        direction LR
        TA[Input a] --> MUX
        TB[Input b] --> MUX
        TSEL[Select sel] --> MUX
        MUX --> TOUT[Output out]
    end","`timescale 1ns/1ps

module mux_2_to_1(
    input wire a,
    input wire b,
    input wire sel,
    output reg out
);
    always @(*) begin
        if (sel)
            out = b;
        else
            out = a;
    end
endmodule

module testbench;
    reg a, b, sel;
    wire out;
    
    mux_2_to_1 dut (
        .a(a),
        .b(b),
        .sel(sel),
        .out(out)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        a = 1'b0; b = 1'b0; sel = 1'b0;
        
        #10 a = 1'b1;
        #10 sel = 1'b1;
        #10 b = 1'b1;
        #10 sel = 1'b0;
        #10 $finish;
    end
    
    initial begin
        $monitor(""Time=%0t a=%b b=%b sel=%b out=%b"", 
                 $time, a, b, sel, out);
    end
endmodule",True,45,True,True,True,False,0.4,False,8.218109369277954,11.637311458587646,"Design a 2-to-1 multiplexer with inputs a, b, select sel, and output out. Include testbench testing all combinations.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph LR
    SEL[sel] --> MUX{2-to-1 MUX}
    A[a] --> MUX
    B[b] --> MUX
    MUX --> OUT[out]

    subgraph Testbench
        direction LR
        TA[Input a] --> MUX
        TB[Input b] --> MUX
        TSEL[Select sel] --> MUX
        MUX --> TOUT[Output out]
    end
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module mux_2to1(
    input wire a,
    input wire b,
    input wire sel,
    output reg out
);

always @(*) begin
    if (sel)
        out = b;
    else
        out = a;
end

endmodule

module testbench;
    reg a, b, sel;
    wire out;
    
    mux_2to1 dut (
        .a(a),
        .b(b),
        .sel(sel),
        .out(out)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        a = 1'b0;
        b = 1'b0;
        sel = 1'b0;
        
        #10 a = 1'b1; b = 1'b0; sel = 1'b0;
        #10 a = 1'b0; b = 1'b1; sel = 1'b0;
        #10 a = 1'b1; b = 1'b1; sel = 1'b0;
        #10 a = 1'b0; b = 1'b0; sel = 1'b1;
        #10 a = 1'b1; b = 1'b0; sel = 1'b1;
        #10 a = 1'b0; b = 1'b1; sel = 1'b1;
        #10 a = 1'b1; b = 1'b1; sel = 1'b1;
        #10 $finish;
    end
    
    initial begin
        $monitor(""Time=%0t a=%b b=%b sel=%b out=%b"", 
                 $time, a, b, sel, out);
    end
endmodule",True,52,True,True,True,False,0.4,False,3.844966411590576,6.669715881347656,tie,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,Sequential,simple,"Create a D flip-flop with clock, reset, input d, and output q. Include testbench with timing verification.",claude,"`timescale 1ns/1ps

module dff(
    input wire clk,
    input wire rst_n,
    input wire d,
    output reg q
);

always @(posedge clk or negedge rst_n) begin
    if (!rst_n)
        q <= 1'b0;
    else
        q <= d;
end

endmodule

module testbench;
    reg clk, rst_n, d;
    wire q;
    
    dff dut (
        .clk(clk),
        .rst_n(rst_n),
        .d(d),
        .q(q)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst_n = 1'b0;
        d = 1'b0;
        
        #20 rst_n = 1'b1;
        
        #10 d = 1'b1;
        #10 d = 1'b0;
        #10 d = 1'b1;
        
        #10 rst_n = 1'b0;
        #10 rst_n = 1'b1;
        
        #20 d = 1'b0;
        #20 d = 1'b1;
        
        #20 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b d=%b q=%b"",
                 $time, clk, rst_n, d, q);
    end
endmodule",True,59,True,True,True,True,0.7,True,5.090116739273071,6.728388547897339,"graph LR
    CLK[Clock] --> DFF[[D Flip-Flop]]
    RST[Reset] --> DFF
    D[Data In] --> DFF
    DFF --> Q[Output Q]
    TB[Testbench] --> |Test Vectors| D
    CLK --> |Clock Stimulus| TB
    RST --> |Reset Control| TB
    Q --> |Verify| TV(Timing Verification)
    TB --> |Expected Values| TV
    TV --> |Pass/Fail| RESULT[Test Results]
    CLK --> |Clock Edge Check| TV
    RST --> |Reset Timing| TV","`timescale 1ns/1ps

module dff(
    input wire clk,
    input wire rst,
    input wire d,
    output reg q
);

always @(posedge clk or posedge rst) begin
    if (rst)
        q <= 1'b0;
    else
        q <= d;
end

endmodule

module testbench;
    reg clk, rst, d;
    wire q;
    reg expected_q;
    reg pass;
    
    dff dut (
        .clk(clk),
        .rst(rst),
        .d(d),
        .q(q)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 0;
        rst = 1;
        d = 0;
        pass = 1;
        
        #10 rst = 0;
        
        // Test Case 1
        d = 1;
        #10 expected_q = 1;
        if (q !== expected_q) begin
            $display(""Test 1 Failed: Expected %b, Got %b"", expected_q, q);
            pass = 0;
        end
        
        // Test Case 2
        d = 0;
        #10 expected_q = 0;
        if (q !== expected_q) begin
            $display(""Test 2 Failed: Expected %b, Got %b"", expected_q, q);
            pass = 0;
        end
        
        // Reset Test
        #10 rst = 1;
        expected_q = 0;
        if (q !== expected_q) begin
            $display(""Reset Test Failed: Expected %b, Got %b"", expected_q, q);
            pass = 0;
        end
        
        #10;
        if (pass)
            $display(""All tests passed!"");
        else
            $display(""Some tests failed!"");
            
        $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t clk=%b rst=%b d=%b q=%b"", 
                 $time, clk, rst, d, q);
    end
endmodule",True,82,True,True,True,False,0.3,False,10.456235408782959,6.831692934036255,"Create a D flip-flop with clock, reset, input d, and output q. Include testbench with timing verification.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph LR
    CLK[Clock] --> DFF[[D Flip-Flop]]
    RST[Reset] --> DFF
    D[Data In] --> DFF
    DFF --> Q[Output Q]
    TB[Testbench] --> |Test Vectors| D
    CLK --> |Clock Stimulus| TB
    RST --> |Reset Control| TB
    Q --> |Verify| TV(Timing Verification)
    TB --> |Expected Values| TV
    TV --> |Pass/Fail| RESULT[Test Results]
    CLK --> |Clock Edge Check| TV
    RST --> |Reset Timing| TV
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

// D Flip-flop with async reset
module dff(
    input wire clk,
    input wire rst,
    input wire d,
    output reg q
);

always @(posedge clk or posedge rst) begin
    if (rst)
        q <= 1'b0;
    else
        q <= d;
end

endmodule

module testbench;
    reg clk, rst, d;
    wire q;
    reg [31:0] errors;
    reg expected_q;
    
    dff dut (
        .clk(clk),
        .rst(rst),
        .d(d),
        .q(q)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        // Initialize signals
        clk = 0;
        rst = 1;
        d = 0;
        errors = 0;
        expected_q = 0;
        
        // Test reset
        #10 rst = 1;
        check_output(0);
        
        // Test normal operation
        #10 rst = 0;
        
        // Test pattern
        @(posedge clk) d = 1; expected_q = 1;
        @(posedge clk) check_output(1);
        
        @(posedge clk) d = 0; expected_q = 0;
        @(posedge clk) check_output(0);
        
        // Test async reset during operation
        @(posedge clk) d = 1;
        #2 rst = 1;
        check_output(0);
        
        #50;
        $display(""Test complete with %0d errors"", errors);
        $finish;
    end
    
    // Clock generation
    always #5 clk = ~clk;
    
    // Timing verification task
    task check_output;
        input expected;
        begin
            #1;
            if (q !== expected) begin
                $display(""Error at time %0t: Expected q=%b, got %b"", $time, expected, q);
                errors = errors + 1;
            end
        end
    endtask
    
    // Monitor signals
    initial begin
        $monitor(""Time=%0t rst=%b d=%b q=%b"", $time, rst, d, q);
    end

endmodule",True,88,True,True,True,False,0.3,False,8.056362867355347,6.8265159130096436,tie,mermaid_only > combined > prompt_only,prompt_only > mermaid_only > combined
combined,Sequential,simple,"Create a D flip-flop with clock, reset, input d, and output q. Include testbench with timing verification.",gpt-4o,"`timescale 1ns/1ps

module d_flip_flop(
    input wire clk,
    input wire rst_n,
    input wire d,
    output reg q
);

always @(posedge clk or negedge rst_n) begin
    if (!rst_n)
        q <= 1'b0;
    else
        q <= d;
end

endmodule

module testbench;
    reg clk, rst_n, d;
    wire q;
    
    d_flip_flop dut (
        .clk(clk),
        .rst_n(rst_n),
        .d(d),
        .q(q)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst_n = 1'b0;
        d = 1'b0;
        
        #20 rst_n = 1'b1;
        #10 d = 1'b1;
        #10 d = 1'b0;
        #10 d = 1'b1;
        #10 d = 1'b0;
        #20 rst_n = 1'b0;
        #10 rst_n = 1'b1;
        #50 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b d=%b q=%b"", 
                 $time, clk, rst_n, d, q);
    end
endmodule",True,54,True,True,True,True,0.7,True,3.9293649196624756,10.007088661193848,"graph LR
    CLK[Clock] --> FF((D Flip-Flop))
    RST[Reset] --> FF
    D[Input D] --> FF
    FF --> Q[Output Q]
    
    subgraph Testbench
        CLK_TB[Clock] --> FF_TB((D Flip-Flop))
        RST_TB[Reset] --> FF_TB
        D_TB[Input D] --> FF_TB
        FF_TB --> Q_TB[Output Q]
        Timing_Verification{Timing Verification}
        CLK_TB --> Timing_Verification
        Q_TB --> Timing_Verification
    end","`timescale 1ns/1ps

module d_flip_flop(
    input wire clk,
    input wire rst,
    input wire d,
    output reg q
);

always @(posedge clk or posedge rst) begin
    if (rst)
        q <= 1'b0;
    else
        q <= d;
end

endmodule

module testbench;
    reg clk_tb, rst_tb, d_tb;
    wire q_tb;

    d_flip_flop dut (
        .clk(clk_tb),
        .rst(rst_tb),
        .d(d_tb),
        .q(q_tb)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk_tb = 1'b0;
        rst_tb = 1'b0;
        d_tb = 1'b0;

        #20 rst_tb = 1'b1;
        #10 rst_tb = 1'b0;
        #10 d_tb = 1'b1;
        #20 d_tb = 1'b0;
        #10 d_tb = 1'b1;
        #30 rst_tb = 1'b1;
        #10 rst_tb = 1'b0;
        #50 $finish;
    end

    always #5 clk_tb = ~clk_tb;

    initial begin
        $monitor(""Time=%0t clk_tb=%b rst_tb=%b d_tb=%b q_tb=%b"", 
                 $time, clk_tb, rst_tb, d_tb, q_tb);
    end
endmodule",True,54,True,True,True,True,0.7,True,6.218816041946411,9.82569432258606,"Create a D flip-flop with clock, reset, input d, and output q. Include testbench with timing verification.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph LR
    CLK[Clock] --> FF((D Flip-Flop))
    RST[Reset] --> FF
    D[Input D] --> FF
    FF --> Q[Output Q]
    
    subgraph Testbench
        CLK_TB[Clock] --> FF_TB((D Flip-Flop))
        RST_TB[Reset] --> FF_TB
        D_TB[Input D] --> FF_TB
        FF_TB --> Q_TB[Output Q]
        Timing_Verification{Timing Verification}
        CLK_TB --> Timing_Verification
        Q_TB --> Timing_Verification
    end
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module d_flip_flop (
    input wire clk,
    input wire rst,
    input wire d,
    output reg q
);

always @(posedge clk or posedge rst) begin
    if (rst)
        q <= 1'b0;
    else
        q <= d;
end

endmodule

module testbench;
    reg clk_tb, rst_tb, d_tb;
    wire q_tb;

    d_flip_flop uut (
        .clk(clk_tb),
        .rst(rst_tb),
        .d(d_tb),
        .q(q_tb)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk_tb = 1'b0;
        rst_tb = 1'b0;
        d_tb = 1'b0;
        
        #20 rst_tb = 1'b1;
        #10 rst_tb = 1'b0;
        #10 d_tb = 1'b1;
        #40 d_tb = 1'b0;
        #50 $finish;
    end
    
    always #5 clk_tb = ~clk_tb;
    
    initial begin
        $monitor(""Time=%0t clk_tb=%b rst_tb=%b d_tb=%b q_tb=%b"", 
                 $time, clk_tb, rst_tb, d_tb, q_tb);
    end
endmodule",True,51,True,True,True,False,0.3,False,3.9512650966644287,9.720752477645874,combined,combined > prompt_only > mermaid_only,prompt_only > mermaid_only > combined
combined,Sequential,simple,"Design a 4-bit synchronous counter with clock, reset, enable, and count[3:0]. Include testbench.",claude,"`timescale 1ns/1ps

module counter(
    input wire clk,
    input wire rst_n, 
    input wire enable,
    output reg [3:0] count
);

always @(posedge clk or negedge rst_n) begin
    if (!rst_n)
        count <= 4'b0000;
    else if (enable)
        count <= count + 1'b1;
end

endmodule

module testbench;
    reg clk, rst_n, enable;
    wire [3:0] count;
    
    counter dut (
        .clk(clk),
        .rst_n(rst_n),
        .enable(enable),
        .count(count)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst_n = 1'b0;
        enable = 1'b0;
        
        #20 rst_n = 1'b1;
        #10 enable = 1'b1;
        #100 enable = 1'b0;
        #20 rst_n = 1'b0;
        #20 rst_n = 1'b1;
        #50 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b enable=%b count=%d"", 
                 $time, clk, rst_n, enable, count);
    end
endmodule",True,52,True,True,True,False,0.3,False,4.641635894775391,8.648768424987793,"graph TD
    CLK[Clock] --> CNT[[Counter Register]]
    RST[Reset] --> CNT
    EN[Enable] --> CTRL(Control Logic)
    CTRL --> CNT
    CNT --> INC(Increment Logic)
    INC --> CNT
    CNT --> OUT[Count[3:0]]
    
    TB1[Test Clock Gen] --> TBCLK[TB Clock]
    TB2[Test Reset Gen] --> TBRST[TB Reset]
    TB3[Test Enable Gen] --> TBEN[TB Enable]
    
    TBCLK --> COMP{Compare}
    TBRST --> COMP
    TBEN --> COMP
    OUT --> COMP
    COMP --> RES[Test Results]","`timescale 1ns/1ps

module counter(
    input wire clk,
    input wire rst_n,
    input wire enable,
    output reg [3:0] count
);

always @(posedge clk or negedge rst_n) begin
    if (!rst_n)
        count <= 4'b0000;
    else if (enable)
        count <= count + 1'b1;
end

endmodule

module testbench;
    reg clk, rst_n, enable;
    wire [3:0] count;
    reg [3:0] expected_count;
    
    counter dut (
        .clk(clk),
        .rst_n(rst_n),
        .enable(enable),
        .count(count)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst_n = 1'b0;
        enable = 1'b0;
        expected_count = 4'b0000;
        
        #20 rst_n = 1'b1;
        #10 enable = 1'b1;
        #160 enable = 1'b0;
        #20 rst_n = 1'b0;
        #20 rst_n = 1'b1;
        #50 $finish;
    end
    
    always #5 clk = ~clk;
    
    always @(posedge clk) begin
        if (enable && rst_n)
            expected_count <= expected_count + 1'b1;
        else if (!rst_n)
            expected_count <= 4'b0000;
            
        if (count !== expected_count)
            $display(""Error at time %0t: count=%h expected=%h"", 
                     $time, count, expected_count);
    end
    
    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b enable=%b count=%h expected=%h"", 
                 $time, clk, rst_n, enable, count, expected_count);
    end
endmodule",True,65,True,True,True,True,0.7,True,10.322127103805542,6.34351658821106,"Design a 4-bit synchronous counter with clock, reset, enable, and count[3:0]. Include testbench.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph TD
    CLK[Clock] --> CNT[[Counter Register]]
    RST[Reset] --> CNT
    EN[Enable] --> CTRL(Control Logic)
    CTRL --> CNT
    CNT --> INC(Increment Logic)
    INC --> CNT
    CNT --> OUT[Count[3:0]]
    
    TB1[Test Clock Gen] --> TBCLK[TB Clock]
    TB2[Test Reset Gen] --> TBRST[TB Reset]
    TB3[Test Enable Gen] --> TBEN[TB Enable]
    
    TBCLK --> COMP{Compare}
    TBRST --> COMP
    TBEN --> COMP
    OUT --> COMP
    COMP --> RES[Test Results]
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module counter(
    input wire clk,
    input wire rst_n,
    input wire enable,
    output reg [3:0] count
);

always @(posedge clk or negedge rst_n) begin
    if (!rst_n)
        count <= 4'b0000;
    else if (enable)
        count <= count + 1'b1;
end

endmodule

module testbench;
    reg clk, rst_n, enable;
    wire [3:0] count;
    reg [3:0] expected_count;
    reg test_passed;
    
    counter dut (
        .clk(clk),
        .rst_n(rst_n),
        .enable(enable),
        .count(count)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst_n = 1'b0;
        enable = 1'b0;
        expected_count = 4'b0000;
        test_passed = 1'b1;
        
        #20 rst_n = 1'b1;
        #10 enable = 1'b1;
        
        repeat(16) begin
            @(posedge clk);
            if (count !== expected_count) begin
                $display(""Error: count=%d, expected=%d"", count, expected_count);
                test_passed = 1'b0;
            end
            expected_count = expected_count + 1'b1;
        end
        
        #10 enable = 1'b0;
        #20 rst_n = 1'b0;
        
        if (count !== 4'b0000) begin
            $display(""Error: Reset failed. count=%d"", count);
            test_passed = 1'b0;
        end
        
        #20 $display(""Test %s"", test_passed ? ""PASSED"" : ""FAILED"");
        $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b enable=%b count=%d"", 
                 $time, clk, rst_n, enable, count);
    end
endmodule",True,72,True,True,True,False,0.3,False,6.857871770858765,8.121213436126709,tie,prompt_only > combined > mermaid_only,prompt_only > mermaid_only > combined
combined,Sequential,simple,"Design a 4-bit synchronous counter with clock, reset, enable, and count[3:0]. Include testbench.",gpt-4o,"`timescale 1ns/1ps

module counter(
    input wire clk,
    input wire rst_n,
    input wire enable,
    output reg [3:0] count
);

always @(posedge clk or negedge rst_n) begin
    if (!rst_n)
        count <= 4'b0000;
    else if (enable)
        count <= count + 1'b1;
end

endmodule

module testbench;
    reg clk, rst_n, enable;
    wire [3:0] count;
    
    counter dut (
        .clk(clk),
        .rst_n(rst_n),
        .enable(enable),
        .count(count)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst_n = 1'b0;
        enable = 1'b0;
        
        #20 rst_n = 1'b1;
        #10 enable = 1'b1;
        #100 enable = 1'b0;
        #20 rst_n = 1'b0;
        #20 rst_n = 1'b1;
        #50 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b enable=%b count=%d"", 
                 $time, clk, rst_n, enable, count);
    end
endmodule",True,52,True,True,True,False,0.3,False,2.0673587322235107,11.026336431503296,"graph LR
    CLK[Clock] --> CNT[Counter Logic]
    RST[Reset] --> CNT
    EN[Enable] --> CNT
    CNT --> COUNT[[count[3:0]]]
    subgraph Testbench
        TB_CLK[TB Clock] --> CNT
        TB_RST[TB Reset] --> CNT
        TB_EN[TB Enable] --> CNT
        TB_CNT_OUT[TB Counter Output] --> COUNT
    end","`timescale 1ns/1ps

module counter(
    input wire clk,
    input wire rst,
    input wire en,
    output reg [3:0] count
);

always @(posedge clk or posedge rst) begin
    if (rst)
        count <= 4'b0000;
    else if (en)
        count <= count + 1'b1;
end

endmodule

module testbench;
    reg tb_clk, tb_rst, tb_en;
    wire [3:0] tb_count;
    
    counter dut (
        .clk(tb_clk),
        .rst(tb_rst),
        .en(tb_en),
        .count(tb_count)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        tb_clk = 1'b0;
        tb_rst = 1'b1;
        tb_en = 1'b0;
        
        #20 tb_rst = 1'b0;
        #10 tb_en = 1'b1;
        #100 tb_en = 1'b0;
        #20 tb_rst = 1'b1;
        #20 tb_rst = 1'b0;
        #50 $finish;
    end
    
    always #5 tb_clk = ~tb_clk;
    
    initial begin
        $monitor(""Time=%0t tb_clk=%b tb_rst=%b tb_en=%b tb_count=%d"", 
                 $time, tb_clk, tb_rst, tb_en, tb_count);
    end
endmodule",True,52,True,True,True,False,0.3,False,5.591508388519287,14.078351736068726,"Design a 4-bit synchronous counter with clock, reset, enable, and count[3:0]. Include testbench.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph LR
    CLK[Clock] --> CNT[Counter Logic]
    RST[Reset] --> CNT
    EN[Enable] --> CNT
    CNT --> COUNT[[count[3:0]]]
    subgraph Testbench
        TB_CLK[TB Clock] --> CNT
        TB_RST[TB Reset] --> CNT
        TB_EN[TB Enable] --> CNT
        TB_CNT_OUT[TB Counter Output] --> COUNT
    end
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module counter(
    input wire clk,
    input wire rst,
    input wire enable,
    output reg [3:0] count
);

always @(posedge clk or posedge rst) begin
    if (rst)
        count <= 4'b0000;
    else if (enable)
        count <= count + 1'b1;
end

endmodule

module testbench;
    reg tb_clk, tb_rst, tb_enable;
    wire [3:0] tb_count;
    
    counter dut (
        .clk(tb_clk),
        .rst(tb_rst),
        .enable(tb_enable),
        .count(tb_count)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        tb_clk = 1'b0;
        tb_rst = 1'b1;
        tb_enable = 1'b0;
        
        #20 tb_rst = 1'b0;
        #10 tb_enable = 1'b1;
        #100 tb_enable = 1'b0;
        #20 tb_rst = 1'b1;
        #20 tb_rst = 1'b0;
        #50 $finish;
    end
    
    always #5 tb_clk = ~tb_clk;
    
    initial begin
        $monitor(""Time=%0t tb_clk=%b tb_rst=%b tb_enable=%b tb_count=%d"", 
                 $time, tb_clk, tb_rst, tb_enable, tb_count);
    end
endmodule",True,52,True,True,True,False,0.3,False,2.721445322036743,11.052101850509644,tie,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,Combinational,simple,"Create a full adder with inputs a, b, cin and outputs sum, cout. Include testbench with all 8 cases.",claude,"`timescale 1ns/1ps

module full_adder(
    input wire a,
    input wire b,
    input wire cin,
    output wire sum,
    output wire cout
);

assign sum = a ^ b ^ cin;
assign cout = (a & b) | (cin & (a ^ b));

endmodule

module testbench;
    reg a, b, cin;
    wire sum, cout;
    
    full_adder dut (
        .a(a),
        .b(b),
        .cin(cin),
        .sum(sum),
        .cout(cout)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        // Test all 8 cases
        {a, b, cin} = 3'b000; #10;
        {a, b, cin} = 3'b001; #10;
        {a, b, cin} = 3'b010; #10;
        {a, b, cin} = 3'b011; #10;
        {a, b, cin} = 3'b100; #10;
        {a, b, cin} = 3'b101; #10;
        {a, b, cin} = 3'b110; #10;
        {a, b, cin} = 3'b111; #10;
        
        $finish;
    end
    
    initial begin
        $monitor(""Time=%0t a=%b b=%b cin=%b sum=%b cout=%b"",
                 $time, a, b, cin, sum, cout);
    end
endmodule",True,49,True,True,True,False,0.4,False,4.815223217010498,6.65227484703064,"graph TD
    A[Input A] --> FA((Full Adder))
    B[Input B] --> FA
    CIN[Carry In] --> FA
    FA --> SUM[Sum Out]
    FA --> COUT[Carry Out]
    
    TB[[Test Cases]]
    TB -->|Case 0| T0{A=0 B=0 CIN=0<br/>SUM=0 COUT=0}
    TB -->|Case 1| T1{A=0 B=0 CIN=1<br/>SUM=1 COUT=0}
    TB -->|Case 2| T2{A=0 B=1 CIN=0<br/>SUM=1 COUT=0}
    TB -->|Case 3| T3{A=0 B=1 CIN=1<br/>SUM=0 COUT=1}
    TB -->|Case 4| T4{A=1 B=0 CIN=0<br/>SUM=1 COUT=0}
    TB -->|Case 5| T5{A=1 B=0 CIN=1<br/>SUM=0 COUT=1}
    TB -->|Case 6| T6{A=1 B=1 CIN=0<br/>SUM=0 COUT=1}
    TB -->|Case 7| T7{A=1 B=1 CIN=1<br/>SUM=1 COUT=1}","`timescale 1ns/1ps

module full_adder(
    input wire a,
    input wire b,
    input wire cin,
    output wire sum,
    output wire cout
);

assign sum = a ^ b ^ cin;
assign cout = (a & b) | (b & cin) | (a & cin);

endmodule

module testbench;
    reg a, b, cin;
    wire sum, cout;
    
    full_adder dut(
        .a(a),
        .b(b),
        .cin(cin),
        .sum(sum),
        .cout(cout)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        // Test Case 0
        a = 0; b = 0; cin = 0;
        #10;
        
        // Test Case 1
        a = 0; b = 0; cin = 1;
        #10;
        
        // Test Case 2
        a = 0; b = 1; cin = 0;
        #10;
        
        // Test Case 3
        a = 0; b = 1; cin = 1;
        #10;
        
        // Test Case 4
        a = 1; b = 0; cin = 0;
        #10;
        
        // Test Case 5
        a = 1; b = 0; cin = 1;
        #10;
        
        // Test Case 6
        a = 1; b = 1; cin = 0;
        #10;
        
        // Test Case 7
        a = 1; b = 1; cin = 1;
        #10;
        
        $finish;
    end
    
    initial begin
        $monitor(""Time=%0t a=%b b=%b cin=%b sum=%b cout=%b"",
                 $time, a, b, cin, sum, cout);
    end
endmodule",True,71,True,True,True,False,0.4,False,10.309022426605225,6.876396179199219,"Create a full adder with inputs a, b, cin and outputs sum, cout. Include testbench with all 8 cases.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph TD
    A[Input A] --> FA((Full Adder))
    B[Input B] --> FA
    CIN[Carry In] --> FA
    FA --> SUM[Sum Out]
    FA --> COUT[Carry Out]
    
    TB[[Test Cases]]
    TB -->|Case 0| T0{A=0 B=0 CIN=0<br/>SUM=0 COUT=0}
    TB -->|Case 1| T1{A=0 B=0 CIN=1<br/>SUM=1 COUT=0}
    TB -->|Case 2| T2{A=0 B=1 CIN=0<br/>SUM=1 COUT=0}
    TB -->|Case 3| T3{A=0 B=1 CIN=1<br/>SUM=0 COUT=1}
    TB -->|Case 4| T4{A=1 B=0 CIN=0<br/>SUM=1 COUT=0}
    TB -->|Case 5| T5{A=1 B=0 CIN=1<br/>SUM=0 COUT=1}
    TB -->|Case 6| T6{A=1 B=1 CIN=0<br/>SUM=0 COUT=1}
    TB -->|Case 7| T7{A=1 B=1 CIN=1<br/>SUM=1 COUT=1}
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module full_adder (
    input wire a,
    input wire b,
    input wire cin,
    output reg sum,
    output reg cout
);

always @(*) begin
    sum = a ^ b ^ cin;
    cout = (a & b) | (b & cin) | (a & cin);
end

endmodule

module testbench;
    reg a, b, cin;
    wire sum, cout;
    
    full_adder dut (
        .a(a),
        .b(b),
        .cin(cin),
        .sum(sum),
        .cout(cout)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        // Case 0
        a = 0; b = 0; cin = 0;
        #10;
        
        // Case 1
        a = 0; b = 0; cin = 1;
        #10;
        
        // Case 2
        a = 0; b = 1; cin = 0;
        #10;
        
        // Case 3
        a = 0; b = 1; cin = 1;
        #10;
        
        // Case 4
        a = 1; b = 0; cin = 0;
        #10;
        
        // Case 5
        a = 1; b = 0; cin = 1;
        #10;
        
        // Case 6
        a = 1; b = 1; cin = 0;
        #10;
        
        // Case 7
        a = 1; b = 1; cin = 1;
        #10;
        
        $finish;
    end
    
    initial begin
        $monitor(""Time=%0t a=%b b=%b cin=%b sum=%b cout=%b"",
                 $time, a, b, cin, sum, cout);
    end
endmodule",True,73,True,True,True,False,0.4,False,5.868601322174072,6.574101448059082,tie,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,Combinational,simple,"Create a full adder with inputs a, b, cin and outputs sum, cout. Include testbench with all 8 cases.",gpt-4o,"`timescale 1ns/1ps

module full_adder(
    input wire a,
    input wire b,
    input wire cin,
    output wire sum,
    output wire cout
);
    assign sum = a ^ b ^ cin;
    assign cout = (a & b) | (b & cin) | (a & cin);
endmodule

module testbench;
    reg a, b, cin;
    wire sum, cout;
    
    full_adder dut (
        .a(a),
        .b(b),
        .cin(cin),
        .sum(sum),
        .cout(cout)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        // Test all 8 cases
        a = 0; b = 0; cin = 0;
        #10 a = 0; b = 0; cin = 1;
        #10 a = 0; b = 1; cin = 0;
        #10 a = 0; b = 1; cin = 1;
        #10 a = 1; b = 0; cin = 0;
        #10 a = 1; b = 0; cin = 1;
        #10 a = 1; b = 1; cin = 0;
        #10 a = 1; b = 1; cin = 1;
        #10 $finish;
    end
    
    initial begin
        $monitor(""Time=%0t a=%b b=%b cin=%b sum=%b cout=%b"", 
                 $time, a, b, cin, sum, cout);
    end
endmodule",True,46,True,True,True,False,0.4,False,5.533104181289673,10.743786096572876,"graph LR
    A[a] --> XOR1((XOR))
    B[b] --> XOR1
    Cin[cin] --> XOR2((XOR))
    XOR1 --> XOR2
    XOR2 --> SUM[sum]
    
    A --> AND1((AND))
    B --> AND1
    XOR1 --> AND2((AND))
    Cin --> AND2
    
    AND1 --> OR1((OR))
    AND2 --> OR1
    OR1 --> Cout[cout]
    
    subgraph Testbench
        TB1[000] --> SUM
        TB2[001] --> SUM
        TB3[010] --> SUM
        TB4[011] --> SUM
        TB5[100] --> SUM
        TB6[101] --> SUM
        TB7[110] --> SUM
        TB8[111] --> SUM
    end","`timescale 1ns/1ps

module full_adder(
    input wire a,
    input wire b,
    input wire cin,
    output wire sum,
    output wire cout
);

wire xor1_out, and1_out, and2_out;

// XOR gates
assign xor1_out = a ^ b;
assign sum = xor1_out ^ cin;

// AND gates
assign and1_out = a & b;
assign and2_out = xor1_out & cin;

// OR gate
assign cout = and1_out | and2_out;

endmodule

module testbench;
    reg [2:0] tb_input;
    wire sum, cout;

    full_adder dut (
        .a(tb_input[2]),
        .b(tb_input[1]),
        .cin(tb_input[0]),
        .sum(sum),
        .cout(cout)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        tb_input = 3'b000;
        #10 tb_input = 3'b001;
        #10 tb_input = 3'b010;
        #10 tb_input = 3'b011;
        #10 tb_input = 3'b100;
        #10 tb_input = 3'b101;
        #10 tb_input = 3'b110;
        #10 tb_input = 3'b111;
        #10 $finish;
    end

    initial begin
        $monitor(""Time=%0t tb_input=%b sum=%b cout=%b"", 
                 $time, tb_input, sum, cout);
    end
endmodule",True,57,True,True,True,False,0.4,False,9.219407796859741,5.861372709274292,"Create a full adder with inputs a, b, cin and outputs sum, cout. Include testbench with all 8 cases.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph LR
    A[a] --> XOR1((XOR))
    B[b] --> XOR1
    Cin[cin] --> XOR2((XOR))
    XOR1 --> XOR2
    XOR2 --> SUM[sum]
    
    A --> AND1((AND))
    B --> AND1
    XOR1 --> AND2((AND))
    Cin --> AND2
    
    AND1 --> OR1((OR))
    AND2 --> OR1
    OR1 --> Cout[cout]
    
    subgraph Testbench
        TB1[000] --> SUM
        TB2[001] --> SUM
        TB3[010] --> SUM
        TB4[011] --> SUM
        TB5[100] --> SUM
        TB6[101] --> SUM
        TB7[110] --> SUM
        TB8[111] --> SUM
    end
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module full_adder(
    input wire a,
    input wire b,
    input wire cin,
    output wire sum,
    output wire cout
);

wire xor1_out, and1_out, and2_out;

assign xor1_out = a ^ b;
assign xor2_out = xor1_out ^ cin;
assign sum = xor2_out;

assign and1_out = a & b;
assign and2_out = xor1_out & cin;

assign cout = and1_out | and2_out;

endmodule

module testbench;
    reg a, b, cin;
    wire sum, cout;
    
    full_adder dut (
        .a(a),
        .b(b),
        .cin(cin),
        .sum(sum),
        .cout(cout)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        a = 0; b = 0; cin = 0;
        #10;
        
        a = 0; b = 0; cin = 1;
        #10;
        
        a = 0; b = 1; cin = 0;
        #10;
        
        a = 0; b = 1; cin = 1;
        #10;
        
        a = 1; b = 0; cin = 0;
        #10;
        
        a = 1; b = 0; cin = 1;
        #10;
        
        a = 1; b = 1; cin = 0;
        #10;
        
        a = 1; b = 1; cin = 1;
        #10;
        
        $finish;
    end
    
    initial begin
        $monitor(""Time=%0t a=%b b=%b cin=%b sum=%b cout=%b"", 
                 $time, a, b, cin, sum, cout);
    end
endmodule",True,71,True,True,True,False,0.4,False,8.230077266693115,9.46899127960205,tie,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,Combinational,simple,"Design a 2-bit comparator with inputs a[1:0], b[1:0] and outputs eq, gt, lt. Include testbench.",claude,"`timescale 1ns/1ps

module comparator(
    input wire [1:0] a,
    input wire [1:0] b,
    output reg eq,
    output reg gt,
    output reg lt
);

always @(*) begin
    eq = (a == b);
    gt = (a > b);
    lt = (a < b);
end

endmodule

module testbench;
    reg [1:0] a, b;
    wire eq, gt, lt;
    
    comparator dut (
        .a(a),
        .b(b),
        .eq(eq),
        .gt(gt),
        .lt(lt)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        // Test all combinations
        a = 2'b00; b = 2'b00; #10;
        a = 2'b00; b = 2'b01; #10;
        a = 2'b00; b = 2'b10; #10;
        a = 2'b00; b = 2'b11; #10;
        a = 2'b01; b = 2'b00; #10;
        a = 2'b01; b = 2'b01; #10;
        a = 2'b01; b = 2'b10; #10;
        a = 2'b01; b = 2'b11; #10;
        a = 2'b10; b = 2'b00; #10;
        a = 2'b10; b = 2'b01; #10;
        a = 2'b10; b = 2'b10; #10;
        a = 2'b10; b = 2'b11; #10;
        a = 2'b11; b = 2'b00; #10;
        a = 2'b11; b = 2'b01; #10;
        a = 2'b11; b = 2'b10; #10;
        a = 2'b11; b = 2'b11; #10;
        
        $finish;
    end
    
    initial begin
        $monitor(""Time=%0t a=%b b=%b eq=%b gt=%b lt=%b"",
                 $time, a, b, eq, gt, lt);
    end
endmodule",True,60,True,True,True,False,0.4,False,6.74526047706604,10.992374420166016,"graph LR
    A0[a0] --> COMP_LOGIC((Comparator<br/>Logic))
    A1[a1] --> COMP_LOGIC
    B0[b0] --> COMP_LOGIC
    B1[b1] --> COMP_LOGIC
    COMP_LOGIC --> EQ[eq]
    COMP_LOGIC --> GT[gt]
    COMP_LOGIC --> LT[lt]
    TB[Testbench] -.-> A0
    TB -.-> A1
    TB -.-> B0
    TB -.-> B1
    EQ -.-> TB_CHECK{Verification}
    GT -.-> TB_CHECK
    LT -.-> TB_CHECK
    TB_CHECK -.-> TB_RESULT[Test Results]","`timescale 1ns/1ps

module comparator(
    input wire clk,
    input wire rst_n,
    input wire a0,
    input wire a1,
    input wire b0,
    input wire b1,
    output reg eq,
    output reg gt,
    output reg lt
);

wire [1:0] a = {a1, a0};
wire [1:0] b = {b1, b0};

always @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
        eq <= 1'b0;
        gt <= 1'b0;
        lt <= 1'b0;
    end else begin
        eq <= (a == b);
        gt <= (a > b);
        lt <= (a < b);
    end
end

endmodule

module testbench;
    reg clk;
    reg rst_n;
    reg a0, a1, b0, b1;
    wire eq, gt, lt;
    
    comparator dut (
        .clk(clk),
        .rst_n(rst_n),
        .a0(a0),
        .a1(a1),
        .b0(b0),
        .b1(b1),
        .eq(eq),
        .gt(gt),
        .lt(lt)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst_n = 1'b0;
        a0 = 1'b0; a1 = 1'b0;
        b0 = 1'b0; b1 = 1'b0;
        
        #10 rst_n = 1'b1;
        
        #10 {a1,a0} = 2'b00; {b1,b0} = 2'b00;
        #10 {a1,a0} = 2'b01; {b1,b0} = 2'b00;
        #10 {a1,a0} = 2'b10; {b1,b0} = 2'b11;
        #10 {a1,a0} = 2'b11; {b1,b0} = 2'b01;
        
        #10 rst_n = 1'b0;
        #10 rst_n = 1'b1;
        #10 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t rst_n=%b a=%b%b b=%b%b eq=%b gt=%b lt=%b"",
                 $time, rst_n, a1, a0, b1, b0, eq, gt, lt);
    end
endmodule",True,77,True,True,True,False,0.3,False,11.807713985443115,6.972761392593384,"Design a 2-bit comparator with inputs a[1:0], b[1:0] and outputs eq, gt, lt. Include testbench.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph LR
    A0[a0] --> COMP_LOGIC((Comparator<br/>Logic))
    A1[a1] --> COMP_LOGIC
    B0[b0] --> COMP_LOGIC
    B1[b1] --> COMP_LOGIC
    COMP_LOGIC --> EQ[eq]
    COMP_LOGIC --> GT[gt]
    COMP_LOGIC --> LT[lt]
    TB[Testbench] -.-> A0
    TB -.-> A1
    TB -.-> B0
    TB -.-> B1
    EQ -.-> TB_CHECK{Verification}
    GT -.-> TB_CHECK
    LT -.-> TB_CHECK
    TB_CHECK -.-> TB_RESULT[Test Results]
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module comparator(
    input wire [1:0] a,
    input wire [1:0] b,
    output reg eq,
    output reg gt,
    output reg lt
);

always @(*) begin
    if (a == b) begin
        eq = 1'b1;
        gt = 1'b0;
        lt = 1'b0;
    end
    else if (a > b) begin
        eq = 1'b0;
        gt = 1'b1;
        lt = 1'b0;
    end
    else begin
        eq = 1'b0;
        gt = 1'b0;
        lt = 1'b1;
    end
end

endmodule

module testbench;
    reg [1:0] a;
    reg [1:0] b;
    wire eq, gt, lt;

    comparator dut (
        .a(a),
        .b(b),
        .eq(eq),
        .gt(gt),
        .lt(lt)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        // Test all combinations
        a = 2'b00; b = 2'b00; #10;
        a = 2'b00; b = 2'b01; #10;
        a = 2'b00; b = 2'b10; #10;
        a = 2'b00; b = 2'b11; #10;
        a = 2'b01; b = 2'b00; #10;
        a = 2'b01; b = 2'b01; #10;
        a = 2'b01; b = 2'b10; #10;
        a = 2'b01; b = 2'b11; #10;
        a = 2'b10; b = 2'b00; #10;
        a = 2'b10; b = 2'b01; #10;
        a = 2'b10; b = 2'b10; #10;
        a = 2'b10; b = 2'b11; #10;
        a = 2'b11; b = 2'b00; #10;
        a = 2'b11; b = 2'b01; #10;
        a = 2'b11; b = 2'b10; #10;
        a = 2'b11; b = 2'b11; #10;

        $finish;
    end

    initial begin
        $monitor(""Time=%0t a=%b b=%b eq=%b gt=%b lt=%b"", 
                 $time, a, b, eq, gt, lt);
    end

endmodule",True,74,True,True,True,False,0.4,False,7.743446111679077,7.935215950012207,tie,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,Combinational,simple,"Design a 2-bit comparator with inputs a[1:0], b[1:0] and outputs eq, gt, lt. Include testbench.",gpt-4o,"`timescale 1ns/1ps

module comparator(
    input wire [1:0] a,
    input wire [1:0] b,
    output reg eq,
    output reg gt,
    output reg lt
);

always @(*) begin
    if (a > b) begin
        gt = 1'b1;
        eq = 1'b0;
        lt = 1'b0;
    end else if (a < b) begin
        gt = 1'b0;
        eq = 1'b0;
        lt = 1'b1;
    end else begin
        gt = 1'b0;
        eq = 1'b1;
        lt = 1'b0;
    end
end

endmodule

module testbench;
    reg [1:0] a, b;
    wire eq, gt, lt;

    comparator dut (
        .a(a),
        .b(b),
        .eq(eq),
        .gt(gt),
        .lt(lt)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        a = 2'b00; b = 2'b00;
        #10 a = 2'b01; b = 2'b00;
        #10 a = 2'b10; b = 2'b11;
        #10 a = 2'b11; b = 2'b01;
        #10 a = 2'b01; b = 2'b10;
        #10 $finish;
    end

    initial begin
        $monitor(""Time=%0t a=%b b=%b eq=%b gt=%b lt=%b"", 
                 $time, a, b, eq, gt, lt);
    end
endmodule",True,57,True,True,True,False,0.4,False,4.909188747406006,6.145854234695435,"graph LR
    a[[a[1:0]]] --> COMP((Comparator))
    b[[b[1:0]]] --> COMP
    COMP --> eq[eq]
    COMP --> gt[gt]
    COMP --> lt[lt]
    subgraph Testbench
        a_gen[Generate a[1:0]] --> a
        b_gen[Generate b[1:0]] --> b
        eq_check[Check eq] <-- eq
        gt_check[Check gt] <-- gt
        lt_check[Check lt] <-- lt
    end","`timescale 1ns/1ps

module comparator(
    input wire [1:0] a,
    input wire [1:0] b,
    output reg eq,
    output reg gt,
    output reg lt
);

always @(a or b) begin
    if (a == b) begin
        eq = 1'b1;
        gt = 1'b0;
        lt = 1'b0;
    end else if (a > b) begin
        eq = 1'b0;
        gt = 1'b1;
        lt = 1'b0;
    end else begin
        eq = 1'b0;
        gt = 1'b0;
        lt = 1'b1;
    end
end

endmodule

module testbench;
    reg [1:0] a;
    reg [1:0] b;
    wire eq;
    wire gt;
    wire lt;

    comparator dut (
        .a(a),
        .b(b),
        .eq(eq),
        .gt(gt),
        .lt(lt)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        a = 2'b00;
        b = 2'b00;
        #10 a = 2'b01; b = 2'b00;
        #10 a = 2'b10; b = 2'b11;
        #10 a = 2'b11; b = 2'b11;
        #10 $finish;
    end

    initial begin
        $monitor(""Time=%0t a=%b b=%b eq=%b gt=%b lt=%b"", 
                 $time, a, b, eq, gt, lt);
    end
endmodule",True,60,True,True,True,False,0.4,False,6.403857231140137,8.030915021896362,"Design a 2-bit comparator with inputs a[1:0], b[1:0] and outputs eq, gt, lt. Include testbench.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph LR
    a[[a[1:0]]] --> COMP((Comparator))
    b[[b[1:0]]] --> COMP
    COMP --> eq[eq]
    COMP --> gt[gt]
    COMP --> lt[lt]
    subgraph Testbench
        a_gen[Generate a[1:0]] --> a
        b_gen[Generate b[1:0]] --> b
        eq_check[Check eq] <-- eq
        gt_check[Check gt] <-- gt
        lt_check[Check lt] <-- lt
    end
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module comparator(
    input wire [1:0] a,
    input wire [1:0] b,
    output reg eq,
    output reg gt,
    output reg lt
);

always @(*) begin
    if (a == b) begin
        eq = 1'b1;
        gt = 1'b0;
        lt = 1'b0;
    end else if (a > b) begin
        eq = 1'b0;
        gt = 1'b1;
        lt = 1'b0;
    end else begin
        eq = 1'b0;
        gt = 1'b0;
        lt = 1'b1;
    end
end

endmodule

module testbench;
    reg [1:0] a, b;
    wire eq, gt, lt;

    comparator dut (
        .a(a),
        .b(b),
        .eq(eq),
        .gt(gt),
        .lt(lt)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        a = 2'b00; b = 2'b00;
        #10 a = 2'b01; b = 2'b00;
        #10 a = 2'b10; b = 2'b01;
        #10 a = 2'b11; b = 2'b10;
        #10 a = 2'b11; b = 2'b11;
        #10 a = 2'b10; b = 2'b11;
        #10 a = 2'b01; b = 2'b10;
        #10 a = 2'b00; b = 2'b01;
        #10 $finish;
    end

    initial begin
        $monitor(""Time=%0t a=%b b=%b eq=%b gt=%b lt=%b"", 
                 $time, a, b, eq, gt, lt);
    end
endmodule",True,60,True,True,True,False,0.4,False,4.928371906280518,8.158618688583374,tie,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,Arithmetic,medium,"Design a 4-bit ALU supporting ADD, SUB, AND, OR operations. Inputs: a[3:0], b[3:0], op[1:0]. Outputs: result[3:0], zero. Include testbench.",claude,"`timescale 1ns/1ps

module alu(
    input wire [3:0] a,
    input wire [3:0] b,
    input wire [1:0] op,
    output reg [3:0] result,
    output wire zero
);

always @(*) begin
    case(op)
        2'b00: result = a + b;    // ADD
        2'b01: result = a - b;    // SUB
        2'b10: result = a & b;    // AND
        2'b11: result = a | b;    // OR
        default: result = 4'b0000;
    endcase
end

assign zero = (result == 4'b0000);

endmodule

module testbench;
    reg [3:0] a, b;
    reg [1:0] op;
    wire [3:0] result;
    wire zero;
    
    alu dut (
        .a(a),
        .b(b),
        .op(op),
        .result(result),
        .zero(zero)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        // Test ADD
        a = 4'h5; b = 4'h3; op = 2'b00;
        #10;
        
        // Test SUB
        a = 4'h7; b = 4'h4; op = 2'b01;
        #10;
        
        // Test AND
        a = 4'hF; b = 4'h3; op = 2'b10;
        #10;
        
        // Test OR
        a = 4'h5; b = 4'h2; op = 2'b11;
        #10;
        
        // Test zero flag
        a = 4'h0; b = 4'h0; op = 2'b00;
        #10;
        
        $finish;
    end
    
    initial begin
        $monitor(""Time=%0t a=%h b=%h op=%b result=%h zero=%b"",
                 $time, a, b, op, result, zero);
    end
endmodule",True,70,True,True,True,False,0.4,False,6.489026308059692,6.711488485336304,"graph LR
    A[a[3:0]] --> ALU((4-bit ALU))
    B[b[3:0]] --> ALU
    OP[op[1:0]] --> CTRL((Control Decoder))
    CTRL --> ALU
    ALU --> RES[result[3:0]]
    ALU --> ZERO((Zero Detect))
    ZERO --> Z[zero]
    TB[[Testbench]] -.-> A
    TB -.-> B
    TB -.-> OP
    TB -.-> RES
    TB -.-> Z
    subgraph Operations
        ADD{ADD}
        SUB{SUB}
        AND{AND}
        OR{OR}
    end
    CTRL --> Operations
    Operations --> ALU
    CLK[Clock] --> TB
    RST[Reset] --> TB","`timescale 1ns/1ps

module alu_top (
    input wire clk,
    input wire rst_n,
    input wire [3:0] a,
    input wire [3:0] b,
    input wire [1:0] op,
    output reg [3:0] result,
    output reg zero
);

wire [3:0] alu_out;
reg [3:0] alu_ctrl;

always @(*) begin
    case(op)
        2'b00: alu_ctrl = 4'b0000; // ADD
        2'b01: alu_ctrl = 4'b0001; // SUB
        2'b10: alu_ctrl = 4'b0010; // AND
        2'b11: alu_ctrl = 4'b0011; // OR
        default: alu_ctrl = 4'b0000;
    endcase
end

always @(*) begin
    case(alu_ctrl)
        4'b0000: alu_out = a + b;
        4'b0001: alu_out = a - b;
        4'b0010: alu_out = a & b;
        4'b0011: alu_out = a | b;
        default: alu_out = 4'b0000;
    endcase
end

always @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
        result <= 4'b0000;
        zero <= 1'b0;
    end else begin
        result <= alu_out;
        zero <= (alu_out == 4'b0000);
    end
end

endmodule

module testbench;
    reg clk;
    reg rst_n;
    reg [3:0] a;
    reg [3:0] b;
    reg [1:0] op;
    wire [3:0] result;
    wire zero;

    alu_top dut (
        .clk(clk),
        .rst_n(rst_n),
        .a(a),
        .b(b),
        .op(op),
        .result(result),
        .zero(zero)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 1'b0;
        rst_n = 1'b0;
        a = 1'b0;
        b = 1'b0;
        op = 1'b0;

        #10 rst_n = 1'b1;

        // Test ADD
        #10 a = 4'h3; b = 4'h4; op = 2'b00;
        
        // Test SUB
        #10 a = 4'h5; b = 4'h5; op = 2'b01;
        
        // Test AND
        #10 a = 4'h7; b = 4'h3; op = 2'b10;
        
        // Test OR
        #10 a = 4'h6; b = 4'h9; op = 2'b11;

        #10 rst_n = 1'b0;
        #10 rst_n = 1'b1;
        #10 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t rst_n=%b a=%h b=%h op=%b result=%h zero=%b"",
                 $time, rst_n, a, b, op, result, zero);
    end
endmodule",True,102,True,False,False,,0.0,,13.685104370117188,0.010050773620605469,"Design a 4-bit ALU supporting ADD, SUB, AND, OR operations. Inputs: a[3:0], b[3:0], op[1:0]. Outputs: result[3:0], zero. Include testbench.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph LR
    A[a[3:0]] --> ALU((4-bit ALU))
    B[b[3:0]] --> ALU
    OP[op[1:0]] --> CTRL((Control Decoder))
    CTRL --> ALU
    ALU --> RES[result[3:0]]
    ALU --> ZERO((Zero Detect))
    ZERO --> Z[zero]
    TB[[Testbench]] -.-> A
    TB -.-> B
    TB -.-> OP
    TB -.-> RES
    TB -.-> Z
    subgraph Operations
        ADD{ADD}
        SUB{SUB}
        AND{AND}
        OR{OR}
    end
    CTRL --> Operations
    Operations --> ALU
    CLK[Clock] --> TB
    RST[Reset] --> TB
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module alu(
    input wire [3:0] a,
    input wire [3:0] b,
    input wire [1:0] op,
    output reg [3:0] result,
    output wire zero
);

wire [3:0] alu_out;

always @(*) begin
    case(op)
        2'b00: result = a + b;    // ADD
        2'b01: result = a - b;    // SUB
        2'b10: result = a & b;    // AND
        2'b11: result = a | b;    // OR
        default: result = 4'b0000;
    endcase
end

assign zero = (result == 4'b0000);

endmodule

module testbench;
    reg [3:0] a, b;
    reg [1:0] op;
    reg clk, rst_n;
    wire [3:0] result;
    wire zero;

    alu dut (
        .a(a),
        .b(b),
        .op(op),
        .result(result),
        .zero(zero)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 0;
        rst_n = 0;
        
        // Test ADD
        #10 a = 4'b0011; b = 4'b0010; op = 2'b00;
        
        // Test SUB
        #10 a = 4'b0111; b = 4'b0011; op = 2'b01;
        
        // Test AND
        #10 a = 4'b1100; b = 4'b0110; op = 2'b10;
        
        // Test OR
        #10 a = 4'b1010; b = 4'b0101; op = 2'b11;
        
        // Test zero detection
        #10 a = 4'b0000; b = 4'b0000; op = 2'b00;
        
        #10 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t a=%b b=%b op=%b result=%b zero=%b"",
                 $time, a, b, op, result, zero);
    end
endmodule",True,73,True,True,True,False,0.4,False,8.23984980583191,6.797063827514648,tie,prompt_only > combined > mermaid_only,prompt_only > combined > mermaid_only
combined,Arithmetic,medium,"Design a 4-bit ALU supporting ADD, SUB, AND, OR operations. Inputs: a[3:0], b[3:0], op[1:0]. Outputs: result[3:0], zero. Include testbench.",gpt-4o,"`timescale 1ns/1ps

module alu(
    input wire [3:0] a,
    input wire [3:0] b,
    input wire [1:0] op,
    output reg [3:0] result,
    output reg zero
);

always @(*) begin
    case (op)
        2'b00: result = a + b;  // ADD
        2'b01: result = a - b;  // SUB
        2'b10: result = a & b;  // AND
        2'b11: result = a | b;  // OR
        default: result = 4'b0000;
    endcase
    zero = (result == 4'b0000) ? 1'b1 : 1'b0;
end

endmodule

module testbench;
    reg [3:0] a, b;
    reg [1:0] op;
    wire [3:0] result;
    wire zero;
    
    alu dut (
        .a(a),
        .b(b),
        .op(op),
        .result(result),
        .zero(zero)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        a = 4'b0000; b = 4'b0000; op = 2'b00;
        #10 a = 4'b0101; b = 4'b0011; op = 2'b00;  // ADD
        #10 a = 4'b0101; b = 4'b0011; op = 2'b01;  // SUB
        #10 a = 4'b0101; b = 4'b0011; op = 2'b10;  // AND
        #10 a = 4'b0101; b = 4'b0011; op = 2'b11;  // OR
        #10 a = 4'b0000; b = 4'b0000; op = 2'b00;  // Test zero
        #10 $finish;
    end
    
    initial begin
        $monitor(""Time=%0t a=%b b=%b op=%b result=%b zero=%b"", 
                 $time, a, b, op, result, zero);
    end
endmodule",True,55,True,True,True,False,0.4,False,4.883082151412964,6.65981650352478,"graph TD
    a[[a[3:0]]] --> ALU
    b[[b[3:0]]] --> ALU
    op[[op[1:0]]] --> CTRL
    CTRL --> ALU
    ALU --> result[[result[3:0]]]
    ALU --> zero[[zero]]
    
    subgraph ALU [""4-bit ALU""]
        ADD(ADD)
        SUB(SUB)
        AND(AND)
        OR(OR)
        MUX{MUX}
        
        a --> ADD
        b --> ADD
        a --> SUB
        b --> SUB
        a --> AND
        b --> AND
        a --> OR
        b --> OR
        
        ADD --> MUX
        SUB --> MUX
        AND --> MUX
        OR --> MUX
        MUX --> result
        MUX --> zero
    end
    
    subgraph CTRL [""Control Unit""]
        DEC{Decoder}
        op --> DEC
        DEC --> MUX
    end
    
    subgraph TB [""Testbench""]
        CLK[Clock] --> ALU
        RST[Reset] --> ALU
        TB --> a
        TB --> b
        TB --> op
        result --> TB
        zero --> TB
    end","`timescale 1ns/1ps

module alu (
    input wire [3:0] a,
    input wire [3:0] b,
    input wire [1:0] op,
    input wire clk,
    input wire rst_n,
    output reg [3:0] result,
    output reg zero
);

    wire [3:0] add_res, sub_res, and_res, or_res;
    reg [3:0] mux_out;
    reg zero_out;

    // ALU Operations
    assign add_res = a + b;
    assign sub_res = a - b;
    assign and_res = a & b;
    assign or_res = a | b;

    // Control Unit Decoder
    always @(*) begin
        case (op)
            2'b00: mux_out = add_res;
            2'b01: mux_out = sub_res;
            2'b10: mux_out = and_res;
            2'b11: mux_out = or_res;
            default: mux_out = 4'b0000;
        endcase
        zero_out = (mux_out == 4'b0000);
    end

    // Registering the output with one clock delay
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            result <= 4'b0000;
            zero <= 1'b0;
        end else begin
            result <= mux_out;
            zero <= zero_out;
        end
    end

endmodule

module testbench;
    reg [3:0] a;
    reg [3:0] b;
    reg [1:0] op;
    reg clk, rst_n;
    wire [3:0] result;
    wire zero;

    alu dut (
        .a(a),
        .b(b),
        .op(op),
        .clk(clk),
        .rst_n(rst_n),
        .result(result),
        .zero(zero)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 1'b0;
        rst_n = 1'b0;
        a = 4'b0000;
        b = 4'b0000;
        op = 2'b00;

        #20 rst_n = 1'b1;
        #10 a = 4'b0101; b = 4'b0011; op = 2'b00; // ADD
        #10 a = 4'b0110; b = 4'b0011; op = 2'b01; // SUB
        #10 a = 4'b1100; b = 4'b1010; op = 2'b10; // AND
        #10 a = 4'b1100; b = 4'b1010; op = 2'b11; // OR
        #50 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t a=%b b=%b op=%b result=%b zero=%b"", 
                 $time, a, b, op, result, zero);
    end
endmodule",True,90,True,True,True,False,0.4,False,14.43623971939087,16.08445119857788,"Design a 4-bit ALU supporting ADD, SUB, AND, OR operations. Inputs: a[3:0], b[3:0], op[1:0]. Outputs: result[3:0], zero. Include testbench.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph TD
    a[[a[3:0]]] --> ALU
    b[[b[3:0]]] --> ALU
    op[[op[1:0]]] --> CTRL
    CTRL --> ALU
    ALU --> result[[result[3:0]]]
    ALU --> zero[[zero]]
    
    subgraph ALU [""4-bit ALU""]
        ADD(ADD)
        SUB(SUB)
        AND(AND)
        OR(OR)
        MUX{MUX}
        
        a --> ADD
        b --> ADD
        a --> SUB
        b --> SUB
        a --> AND
        b --> AND
        a --> OR
        b --> OR
        
        ADD --> MUX
        SUB --> MUX
        AND --> MUX
        OR --> MUX
        MUX --> result
        MUX --> zero
    end
    
    subgraph CTRL [""Control Unit""]
        DEC{Decoder}
        op --> DEC
        DEC --> MUX
    end
    
    subgraph TB [""Testbench""]
        CLK[Clock] --> ALU
        RST[Reset] --> ALU
        TB --> a
        TB --> b
        TB --> op
        result --> TB
        zero --> TB
    end
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module alu(
    input wire [3:0] a,
    input wire [3:0] b,
    input wire [1:0] op,
    input wire clk,
    input wire rst,
    output reg [3:0] result,
    output reg zero
);

wire [3:0] add_res, sub_res, and_res, or_res;
reg [3:0] alu_out;
wire [1:0] sel;

assign add_res = a + b;
assign sub_res = a - b;
assign and_res = a & b;
assign or_res = a | b;

// Decoder to control MUX
assign sel = op;

always @(*) begin
    case (sel)
        2'b00: alu_out = add_res;
        2'b01: alu_out = sub_res;
        2'b10: alu_out = and_res;
        2'b11: alu_out = or_res;
        default: alu_out = 4'b0000;
    endcase
end

always @(posedge clk or posedge rst) begin
    if (rst) begin
        result <= 4'b0000;
        zero <= 1'b0;
    end else begin
        result <= alu_out;
        zero <= (alu_out == 4'b0000) ? 1'b1 : 1'b0;
    end
end

endmodule

module testbench;
    reg [3:0] a, b;
    reg [1:0] op;
    reg clk, rst;
    wire [3:0] result;
    wire zero;

    alu dut (
        .a(a),
        .b(b),
        .op(op),
        .clk(clk),
        .rst(rst),
        .result(result),
        .zero(zero)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 1'b0;
        rst = 1'b1;
        a = 4'b0000;
        b = 4'b0000;
        op = 2'b00;

        #10 rst = 1'b0;
        #10 a = 4'b0010; b = 4'b0011; op = 2'b00; // ADD
        #10 a = 4'b0100; b = 4'b0011; op = 2'b01; // SUB
        #10 a = 4'b0110; b = 4'b0101; op = 2'b10; // AND
        #10 a = 4'b0111; b = 4'b0001; op = 2'b11; // OR
        #10 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t a=%b b=%b op=%b result=%b zero=%b"", 
                 $time, a, b, op, result, zero);
    end
endmodule",True,88,True,True,True,False,0.4,False,13.638216972351074,11.113327264785767,tie,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,Combinational,medium,"Create an 8:1 multiplexer with input data[7:0], select sel[2:0], and output out. Include testbench.",claude,"`timescale 1ns/1ps

module mux8to1(
    input wire [7:0] data,
    input wire [2:0] sel,
    output reg out
);

always @(*) begin
    case (sel)
        3'b000: out = data[0];
        3'b001: out = data[1];
        3'b010: out = data[2];
        3'b011: out = data[3];
        3'b100: out = data[4];
        3'b101: out = data[5];
        3'b110: out = data[6];
        3'b111: out = data[7];
        default: out = 1'b0;
    endcase
end

endmodule

module testbench;
    reg [7:0] data;
    reg [2:0] sel;
    wire out;

    mux8to1 dut (
        .data(data),
        .sel(sel),
        .out(out)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        data = 8'b10101010;
        
        sel = 3'b000; #10;
        sel = 3'b001; #10;
        sel = 3'b010; #10;
        sel = 3'b011; #10;
        sel = 3'b100; #10;
        sel = 3'b101; #10;
        sel = 3'b110; #10;
        sel = 3'b111; #10;

        data = 8'b11110000;
        
        sel = 3'b000; #10;
        sel = 3'b111; #10;

        $finish;
    end

    initial begin
        $monitor(""Time=%0t data=%b sel=%b out=%b"", 
                 $time, data, sel, out);
    end
endmodule",True,63,True,True,True,False,0.4,False,5.810227155685425,6.700031757354736,"graph LR
    D0[data0] --> MUX{8:1 MUX}
    D1[data1] --> MUX
    D2[data2] --> MUX
    D3[data3] --> MUX
    D4[data4] --> MUX
    D5[data5] --> MUX
    D6[data6] --> MUX
    D7[data7] --> MUX
    S0[sel0] --> MUX
    S1[sel1] --> MUX
    S2[sel2] --> MUX
    MUX --> OUT[out]
    TB[[Testbench]]
    TB --> D0
    TB --> D1
    TB --> D2
    TB --> D3
    TB --> D4
    TB --> D5
    TB --> D6
    TB --> D7
    TB --> S0
    TB --> S1
    TB --> S2","`timescale 1ns/1ps

module mux_8to1 (
    input wire clk,
    input wire rst_n,
    input wire [7:0] data0, data1, data2, data3, data4, data5, data6, data7,
    input wire [2:0] sel,
    output reg [7:0] out
);

always @(posedge clk or negedge rst_n) begin
    if (!rst_n)
        out <= 8'b0;
    else
        case (sel)
            3'b000: out <= data0;
            3'b001: out <= data1;
            3'b010: out <= data2;
            3'b011: out <= data3;
            3'b100: out <= data4;
            3'b101: out <= data5;
            3'b110: out <= data6;
            3'b111: out <= data7;
            default: out <= 8'b0;
        endcase
end

endmodule

module testbench;
    reg clk, rst_n;
    reg [7:0] data0, data1, data2, data3, data4, data5, data6, data7;
    reg [2:0] sel;
    wire [7:0] out;

    mux_8to1 dut (
        .clk(clk),
        .rst_n(rst_n),
        .data0(data0),
        .data1(data1),
        .data2(data2),
        .data3(data3),
        .data4(data4),
        .data5(data5),
        .data6(data6),
        .data7(data7),
        .sel(sel),
        .out(out)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 0;
        rst_n = 0;
        data0 = 8'h11;
        data1 = 8'h22;
        data2 = 8'h33;
        data3 = 8'h44;
        data4 = 8'h55;
        data5 = 8'h66;
        data6 = 8'h77;
        data7 = 8'h88;
        sel = 3'b000;

        #10 rst_n = 1;
        
        #10 sel = 3'b000;
        #10 sel = 3'b001;
        #10 sel = 3'b010;
        #10 sel = 3'b011;
        #10 sel = 3'b100;
        #10 sel = 3'b101;
        #10 sel = 3'b110;
        #10 sel = 3'b111;
        
        #10 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t sel=%b out=%h"", $time, sel, out);
    end
endmodule",True,86,True,True,True,False,0.4,False,11.86991810798645,7.684166669845581,"Create an 8:1 multiplexer with input data[7:0], select sel[2:0], and output out. Include testbench.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph LR
    D0[data0] --> MUX{8:1 MUX}
    D1[data1] --> MUX
    D2[data2] --> MUX
    D3[data3] --> MUX
    D4[data4] --> MUX
    D5[data5] --> MUX
    D6[data6] --> MUX
    D7[data7] --> MUX
    S0[sel0] --> MUX
    S1[sel1] --> MUX
    S2[sel2] --> MUX
    MUX --> OUT[out]
    TB[[Testbench]]
    TB --> D0
    TB --> D1
    TB --> D2
    TB --> D3
    TB --> D4
    TB --> D5
    TB --> D6
    TB --> D7
    TB --> S0
    TB --> S1
    TB --> S2
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module mux8to1 (
    input wire [7:0] data,
    input wire [2:0] sel,
    output reg out
);

always @(*) begin
    case (sel)
        3'b000: out = data[0];
        3'b001: out = data[1];
        3'b010: out = data[2];
        3'b011: out = data[3];
        3'b100: out = data[4];
        3'b101: out = data[5];
        3'b110: out = data[6];
        3'b111: out = data[7];
        default: out = 1'b0;
    endcase
end

endmodule

module testbench;
    reg [7:0] data;
    reg [2:0] sel;
    wire out;

    mux8to1 dut (
        .data(data),
        .sel(sel),
        .out(out)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        data = 8'b10101010;
        sel = 3'b000;
        #10;

        sel = 3'b001;
        #10;

        data = 8'b11001100;
        sel = 3'b010;
        #10;

        sel = 3'b011;
        #10;

        data = 8'b11110000;
        sel = 3'b100;
        #10;

        sel = 3'b101;
        #10;

        sel = 3'b110;
        #10;

        sel = 3'b111;
        #10;

        $finish;
    end

    initial begin
        $monitor(""Time=%0t data=%b sel=%b out=%b"", 
                 $time, data, sel, out);
    end
endmodule",True,74,True,True,True,False,0.4,False,5.683625221252441,6.8737335205078125,tie,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,Combinational,medium,"Create an 8:1 multiplexer with input data[7:0], select sel[2:0], and output out. Include testbench.",gpt-4o,"`timescale 1ns/1ps

module mux8to1(
    input wire [7:0] data,
    input wire [2:0] sel,
    output reg out
);

always @(*) begin
    case (sel)
        3'b000: out = data[0];
        3'b001: out = data[1];
        3'b010: out = data[2];
        3'b011: out = data[3];
        3'b100: out = data[4];
        3'b101: out = data[5];
        3'b110: out = data[6];
        3'b111: out = data[7];
        default: out = 1'b0;
    endcase
end

endmodule

module testbench;
    reg [7:0] data;
    reg [2:0] sel;
    wire out;

    mux8to1 dut (
        .data(data),
        .sel(sel),
        .out(out)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        data = 8'b10101010;
        sel = 3'b000;
        #10 sel = 3'b001;
        #10 sel = 3'b010;
        #10 sel = 3'b011;
        #10 sel = 3'b100;
        #10 sel = 3'b101;
        #10 sel = 3'b110;
        #10 sel = 3'b111;
        #10 $finish;
    end

    initial begin
        $monitor(""Time=%0t sel=%b out=%b"", $time, sel, out);
    end
endmodule",True,55,True,True,True,False,0.4,False,3.6902337074279785,6.3084893226623535,"graph TD
    A[data[7:0]] --> MUX{8:1 MUX}
    B[sel[2:0]] --> MUX
    MUX --> C[out]
    
    subgraph TESTBENCH[Testbench]
        D[data_tb[7:0]] --> E{8:1 MUX TB}
        F[sel_tb[2:0]] --> E
        E --> G[out_tb]
    end","`timescale 1ns/1ps

module mux_8to1(
    input wire [7:0] data,
    input wire [2:0] sel,
    output reg out
);

always @(*) begin
    case (sel)
        3'b000: out = data[0];
        3'b001: out = data[1];
        3'b010: out = data[2];
        3'b011: out = data[3];
        3'b100: out = data[4];
        3'b101: out = data[5];
        3'b110: out = data[6];
        3'b111: out = data[7];
        default: out = 1'b0;
    endcase
end

endmodule

module testbench;
    reg [7:0] data_tb;
    reg [2:0] sel_tb;
    wire out_tb;

    mux_8to1 dut (
        .data(data_tb),
        .sel(sel_tb),
        .out(out_tb)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        data_tb = 8'b10101010;
        sel_tb = 3'b000;
        #10 sel_tb = 3'b001;
        #10 sel_tb = 3'b010;
        #10 sel_tb = 3'b011;
        #10 sel_tb = 3'b100;
        #10 sel_tb = 3'b101;
        #10 sel_tb = 3'b110;
        #10 sel_tb = 3'b111;
        #10 $finish;
    end

    initial begin
        $monitor(""Time=%0t sel_tb=%b out_tb=%b"", $time, sel_tb, out_tb);
    end
endmodule",True,55,True,True,True,False,0.4,False,6.212800741195679,12.565104961395264,"Create an 8:1 multiplexer with input data[7:0], select sel[2:0], and output out. Include testbench.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph TD
    A[data[7:0]] --> MUX{8:1 MUX}
    B[sel[2:0]] --> MUX
    MUX --> C[out]
    
    subgraph TESTBENCH[Testbench]
        D[data_tb[7:0]] --> E{8:1 MUX TB}
        F[sel_tb[2:0]] --> E
        E --> G[out_tb]
    end
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module mux_8to1(
    input wire [7:0] data,
    input wire [2:0] sel,
    output reg out
);

always @(*) begin
    case (sel)
        3'b000: out = data[0];
        3'b001: out = data[1];
        3'b010: out = data[2];
        3'b011: out = data[3];
        3'b100: out = data[4];
        3'b101: out = data[5];
        3'b110: out = data[6];
        3'b111: out = data[7];
        default: out = 1'b0;
    endcase
end

endmodule

module testbench;
    reg [7:0] data_tb;
    reg [2:0] sel_tb;
    wire out_tb;
    
    mux_8to1 dut (
        .data(data_tb),
        .sel(sel_tb),
        .out(out_tb)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        data_tb = 8'b10101010;
        sel_tb = 3'b000;
        
        #10 sel_tb = 3'b001;
        #10 sel_tb = 3'b010;
        #10 sel_tb = 3'b011;
        #10 sel_tb = 3'b100;
        #10 sel_tb = 3'b101;
        #10 sel_tb = 3'b110;
        #10 sel_tb = 3'b111;
        #10 $finish;
    end
    
    initial begin
        $monitor(""Time=%0t data_tb=%b sel_tb=%b out_tb=%b"", 
                 $time, data_tb, sel_tb, out_tb);
    end
endmodule",True,57,True,True,True,False,0.4,False,3.5458102226257324,10.601929664611816,tie,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,State Machine,medium,Design an FSM detecting pattern 1011 in serial input with overlapping detection. Include testbench with sequence: 10110111011.,claude,"`timescale 1ns/1ps

module sequence_detector(
    input wire clk,
    input wire rst_n,
    input wire data_in,
    output reg pattern_found
);

reg [2:0] state;
reg [2:0] next_state;

parameter S0 = 3'b000;
parameter S1 = 3'b001;
parameter S2 = 3'b010;
parameter S3 = 3'b011;

always @(posedge clk or negedge rst_n) begin
    if (!rst_n)
        state <= S0;
    else
        state <= next_state;
end

always @(*) begin
    case (state)
        S0: next_state = (data_in) ? S1 : S0;
        S1: next_state = (data_in) ? S1 : S2;
        S2: next_state = (data_in) ? S3 : S0;
        S3: next_state = (data_in) ? S1 : S2;
        default: next_state = S0;
    endcase
end

always @(posedge clk or negedge rst_n) begin
    if (!rst_n)
        pattern_found <= 1'b0;
    else
        pattern_found <= (state == S3) && (data_in == 1'b1);
end

endmodule

module testbench;
    reg clk;
    reg rst_n;
    reg data_in;
    wire pattern_found;
    
    sequence_detector dut (
        .clk(clk),
        .rst_n(rst_n),
        .data_in(data_in),
        .pattern_found(pattern_found)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 0;
        rst_n = 0;
        data_in = 0;
        
        #10 rst_n = 1;
        
        // Test sequence: 10110111011
        #10 data_in = 1;
        #10 data_in = 0;
        #10 data_in = 1;
        #10 data_in = 1;
        #10 data_in = 0;
        #10 data_in = 1;
        #10 data_in = 1;
        #10 data_in = 1;
        #10 data_in = 0;
        #10 data_in = 1;
        #10 data_in = 1;
        
        #20 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t rst_n=%b data_in=%b pattern_found=%b"", 
                 $time, rst_n, data_in, pattern_found);
    end
endmodule",True,89,True,True,True,False,0.3,False,8.322700023651123,8.444913148880005,"graph LR
    CLK[Clock] --> FSM((FSM Core))
    RST[Reset] --> FSM
    DIN[Serial Input] --> FSM
    FSM --> OUT[Pattern Detected]
    TB[[TestBench]]
    TB --> |10110111011| DIN
    
    subgraph States
    S0((Idle)) --> |1| S1
    S1 --> |0| S2
    S2 --> |1| S3
    S3 --> |1| S4
    S4 --> |1| S1
    S1 --> |1| S1
    S2 --> |1| S1
    S3 --> |0| S2
    S4 --> |0| S2
    S0 --> |0| S0
    end","`timescale 1ns/1ps

module pattern_detector(
    input wire clk,
    input wire rst,
    input wire din,
    output reg pattern_detected
);

// State encoding
parameter S0 = 3'b000;  // Idle
parameter S1 = 3'b001;
parameter S2 = 3'b010;
parameter S3 = 3'b011;
parameter S4 = 3'b100;

reg [2:0] state, next_state;

always @(posedge clk or posedge rst) begin
    if (rst)
        state <= S0;
    else
        state <= next_state;
end

always @(*) begin
    case (state)
        S0: next_state = (din) ? S1 : S0;
        S1: next_state = (din) ? S1 : S2;
        S2: next_state = (din) ? S3 : S2;
        S3: next_state = (din) ? S4 : S2;
        S4: next_state = (din) ? S1 : S2;
        default: next_state = S0;
    endcase
end

always @(posedge clk or posedge rst) begin
    if (rst)
        pattern_detected <= 1'b0;
    else
        pattern_detected <= (state == S4 && din == 1'b1);
end

endmodule

module testbench;
    reg clk, rst, din;
    wire pattern_detected;
    
    pattern_detector dut (
        .clk(clk),
        .rst(rst),
        .din(din),
        .pattern_detected(pattern_detected)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 0;
        rst = 1;
        din = 0;
        
        #10 rst = 0;
        
        // Test pattern: 10110111011
        #10 din = 1;
        #10 din = 0;
        #10 din = 1;
        #10 din = 1;
        #10 din = 0;
        #10 din = 1;
        #10 din = 1;
        #10 din = 1;
        #10 din = 0;
        #10 din = 1;
        #10 din = 1;
        
        #20 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t rst=%b din=%b pattern_detected=%b"",
                 $time, rst, din, pattern_detected);
    end
endmodule",True,89,True,True,True,False,0.3,False,12.502469062805176,7.72623872756958,"Design an FSM detecting pattern 1011 in serial input with overlapping detection. Include testbench with sequence: 10110111011.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph LR
    CLK[Clock] --> FSM((FSM Core))
    RST[Reset] --> FSM
    DIN[Serial Input] --> FSM
    FSM --> OUT[Pattern Detected]
    TB[[TestBench]]
    TB --> |10110111011| DIN
    
    subgraph States
    S0((Idle)) --> |1| S1
    S1 --> |0| S2
    S2 --> |1| S3
    S3 --> |1| S4
    S4 --> |1| S1
    S1 --> |1| S1
    S2 --> |1| S1
    S3 --> |0| S2
    S4 --> |0| S2
    S0 --> |0| S0
    end
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module pattern_detect(
    input wire clk,
    input wire rst,
    input wire din,
    output reg pattern_found
);

reg [2:0] state, next_state;
parameter S0 = 3'b000;
parameter S1 = 3'b001;
parameter S2 = 3'b010;
parameter S3 = 3'b011;
parameter S4 = 3'b100;

always @(posedge clk or posedge rst) begin
    if (rst)
        state <= S0;
    else
        state <= next_state;
end

always @(state or din) begin
    case (state)
        S0: next_state = din ? S1 : S0;
        S1: next_state = din ? S1 : S2;
        S2: next_state = din ? S3 : S0;
        S3: next_state = din ? S4 : S2;
        S4: next_state = din ? S1 : S2;
        default: next_state = S0;
    endcase
end

always @(state) begin
    pattern_found = (state == S4);
end

endmodule

module testbench;
    reg clk, rst, din;
    wire pattern_found;
    
    pattern_detect dut (
        .clk(clk),
        .rst(rst),
        .din(din),
        .pattern_found(pattern_found)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 0;
        rst = 1;
        din = 0;
        
        #10 rst = 0;
        
        // Test sequence: 10110111011
        #10 din = 1;
        #10 din = 0;
        #10 din = 1;
        #10 din = 1;
        #10 din = 0;
        #10 din = 1;
        #10 din = 1;
        #10 din = 1;
        #10 din = 0;
        #10 din = 1;
        #10 din = 1;
        
        #20 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t rst=%b din=%b pattern_found=%b state=%d"", 
                 $time, rst, din, pattern_found, dut.state);
    end
endmodule",True,84,True,True,True,False,0.4,False,7.825361490249634,7.756831169128418,tie,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,State Machine,medium,Design an FSM detecting pattern 1011 in serial input with overlapping detection. Include testbench with sequence: 10110111011.,gpt-4o,"`timescale 1ns/1ps

module fsm_1011_detector(
    input wire clk,
    input wire rst_n,
    input wire serial_in,
    output reg detected
);

    typedef enum reg [2:0] {
        IDLE  = 3'b000,
        S1    = 3'b001,
        S10   = 3'b010,
        S101  = 3'b011,
        S1011 = 3'b100
    } state_t;

    reg [2:0] current_state, next_state;

    always @(posedge clk or negedge rst_n) begin
        if (!rst_n)
            current_state <= IDLE;
        else
            current_state <= next_state;
    end

    always @(*) begin
        next_state = IDLE; // Default state
        detected = 1'b0; // Default output
        case (current_state)
            IDLE: begin
                if (serial_in)
                    next_state = S1;
                else
                    next_state = IDLE;
            end
            S1: begin
                if (!serial_in)
                    next_state = S10;
                else
                    next_state = S1;
            end
            S10: begin
                if (serial_in)
                    next_state = S101;
                else
                    next_state = IDLE;
            end
            S101: begin
                if (serial_in) begin
                    next_state = S1011;
                    detected = 1'b1;
                end
                else
                    next_state = S10;
            end
            S1011: begin
                if (serial_in)
                    next_state = S1;
                else
                    next_state = S10;
            end
            default: next_state = IDLE;
        endcase
    end

endmodule

module testbench;
    reg clk, rst_n, serial_in;
    wire detected;

    fsm_1011_detector dut (
        .clk(clk),
        .rst_n(rst_n),
        .serial_in(serial_in),
        .detected(detected)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 1'b0;
        rst_n = 1'b0;
        serial_in = 1'b0;

        #20 rst_n = 1'b1;

        #10 serial_in = 1'b1; // Input sequence: 10110111011
        #10 serial_in = 1'b0;
        #10 serial_in = 1'b1;
        #10 serial_in = 1'b1;
        #10 serial_in = 1'b0;
        #10 serial_in = 1'b1;
        #10 serial_in = 1'b1;
        #10 serial_in = 1'b1;
        #10 serial_in = 1'b0;
        #10 serial_in = 1'b1;
        #10 serial_in = 1'b1;

        #50 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b serial_in=%b detected=%b"", 
                 $time, clk, rst_n, serial_in, detected);
    end
endmodule",True,111,True,True,True,True,0.7,True,9.261283874511719,11.737549543380737,"graph LR
    CLK[Clock] --> FSM((FSM))
    RST[Reset] --> FSM
    INP[Serial Input] --> FSM
    FSM --> OUT[Pattern Detected]
    classDef state fill:#f9f,stroke:#333,stroke-width:2px;
    class FSM state;
    TB[Testbench Sequence] --> FSM
    TB[Testbench Sequence] --> INP
    TB[Testbench Sequence] -.->|10110111011| FSM
    TB -.->|10110111011| INP","`timescale 1ns/1ps

module fsm(
    input wire clk,
    input wire rst_n,
    input wire serial_in,
    output reg pattern_detected
);

    reg [10:0] shift_reg;

    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            shift_reg <= 11'b0;
            pattern_detected <= 1'b0;
        end else begin
            shift_reg <= {shift_reg[9:0], serial_in};
            if (shift_reg == 11'b10110111011)
                pattern_detected <= 1'b1;
            else
                pattern_detected <= 1'b0;
        end
    end

endmodule

module testbench;
    reg clk, rst_n;
    reg serial_in;
    wire pattern_detected;

    fsm dut (
        .clk(clk),
        .rst_n(rst_n),
        .serial_in(serial_in),
        .pattern_detected(pattern_detected)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 1'b0;
        rst_n = 1'b0;
        serial_in = 1'b0;

        #20 rst_n = 1'b1;
        
        // Test sequence: 10110111011
        #10 serial_in = 1'b1;
        #10 serial_in = 1'b0;
        #10 serial_in = 1'b1;
        #10 serial_in = 1'b1;
        #10 serial_in = 1'b0;
        #10 serial_in = 1'b1;
        #10 serial_in = 1'b1;
        #10 serial_in = 1'b1;
        #10 serial_in = 1'b0;
        #10 serial_in = 1'b1;
        #10 serial_in = 1'b1;

        #20 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b serial_in=%b pattern_detected=%b"", 
                 $time, clk, rst_n, serial_in, pattern_detected);
    end
endmodule",True,71,True,True,True,True,0.7,True,9.456484079360962,12.464861869812012,"Design an FSM detecting pattern 1011 in serial input with overlapping detection. Include testbench with sequence: 10110111011.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph LR
    CLK[Clock] --> FSM((FSM))
    RST[Reset] --> FSM
    INP[Serial Input] --> FSM
    FSM --> OUT[Pattern Detected]
    classDef state fill:#f9f,stroke:#333,stroke-width:2px;
    class FSM state;
    TB[Testbench Sequence] --> FSM
    TB[Testbench Sequence] --> INP
    TB[Testbench Sequence] -.->|10110111011| FSM
    TB -.->|10110111011| INP
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module fsm_pattern_detector(
    input wire clk,
    input wire rst_n,
    input wire serial_in,
    output reg pattern_detected
);
    
    typedef enum reg [2:0] {
        STATE_IDLE = 3'b000,
        STATE_S1   = 3'b001,
        STATE_S10  = 3'b010,
        STATE_S101 = 3'b011,
        STATE_S1011 = 3'b100
    } state_t;
    
    reg [2:0] current_state, next_state;
    
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n)
            current_state <= STATE_IDLE;
        else
            current_state <= next_state;
    end
    
    always @(*) begin
        next_state = current_state;
        pattern_detected = 1'b0;
        case (current_state)
            STATE_IDLE: begin
                if (serial_in)
                    next_state = STATE_S1;
            end
            STATE_S1: begin
                if (!serial_in)
                    next_state = STATE_S10;
                else
                    next_state = STATE_S1;
            end
            STATE_S10: begin
                if (serial_in)
                    next_state = STATE_S101;
                else
                    next_state = STATE_IDLE;
            end
            STATE_S101: begin
                if (serial_in) begin
                    next_state = STATE_S1011;
                    pattern_detected = 1'b1;
                end else
                    next_state = STATE_S10;
            end
            STATE_S1011: begin
                if (serial_in)
                    next_state = STATE_S1;
                else
                    next_state = STATE_S10;
            end
            default: next_state = STATE_IDLE;
        endcase
    end
    
endmodule

module testbench;
    reg clk, rst_n, serial_in;
    wire pattern_detected;
    
    fsm_pattern_detector uut (
        .clk(clk),
        .rst_n(rst_n),
        .serial_in(serial_in),
        .pattern_detected(pattern_detected)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst_n = 1'b0;
        serial_in = 1'b0;
        
        #20 rst_n = 1'b1;
        #10 serial_in = 1'b1; // 1
        #10 serial_in = 1'b0; // 0
        #10 serial_in = 1'b1; // 1
        #10 serial_in = 1'b1; // 1
        #10 serial_in = 1'b0; // 0
        #10 serial_in = 1'b1; // 1
        #10 serial_in = 1'b1; // 1
        #10 serial_in = 1'b1; // 1
        #10 serial_in = 1'b0; // 0
        #10 serial_in = 1'b1; // 1
        #50 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b serial_in=%b pattern_detected=%b"", 
                 $time, clk, rst_n, serial_in, pattern_detected);
    end
endmodule",True,105,True,True,True,True,0.7,True,8.493446111679077,17.405513525009155,prompt_only,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,Sequential,medium,"Create a 4-bit PISO shift register with clock, reset, load, parallel input[3:0], and serial output. Include testbench.",claude,"`timescale 1ns/1ps

module piso_shift_reg(
    input wire clk,
    input wire rst_n,
    input wire load,
    input wire [3:0] parallel_in,
    output wire serial_out
);

reg [3:0] shift_reg;

assign serial_out = shift_reg[3];

always @(posedge clk or negedge rst_n) begin
    if (!rst_n)
        shift_reg <= 4'b0000;
    else if (load)
        shift_reg <= parallel_in;
    else
        shift_reg <= {shift_reg[2:0], 1'b0};
end

endmodule

module testbench;
    reg clk, rst_n, load;
    reg [3:0] parallel_in;
    wire serial_out;
    
    piso_shift_reg dut (
        .clk(clk),
        .rst_n(rst_n),
        .load(load),
        .parallel_in(parallel_in),
        .serial_out(serial_out)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 0;
        rst_n = 0;
        load = 0;
        parallel_in = 4'b0000;
        
        #20 rst_n = 1;
        #10 parallel_in = 4'b1101;
        #10 load = 1;
        #10 load = 0;
        
        #80 parallel_in = 4'b1011;
        #10 load = 1;
        #10 load = 0;
        
        #50 rst_n = 0;
        #20 rst_n = 1;
        #50 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t rst_n=%b load=%b parallel_in=%b serial_out=%b shift_reg=%b"",
                 $time, rst_n, load, parallel_in, serial_out, dut.shift_reg);
    end
endmodule",True,68,True,True,True,False,0.4,False,6.479583978652954,7.627809762954712,"graph LR
    CLK[Clock] --> REG[[4-bit Register]]
    RST[Reset] --> REG
    LOAD[Load] --> MUX
    PIN0[Parallel In 0] --> MUX0{MUX 0}
    PIN1[Parallel In 1] --> MUX1{MUX 1}
    PIN2[Parallel In 2] --> MUX2{MUX 2}
    PIN3[Parallel In 3] --> MUX3{MUX 3}
    MUX0 --> REG
    MUX1 --> REG
    MUX2 --> REG
    MUX3 --> REG
    REG --> SOUT[Serial Out]
    REG --> FB[Feedback]
    FB --> MUX0
    FB --> MUX1
    FB --> MUX2
    FB --> MUX3
    TB[Testbench] --> CLK
    TB --> RST
    TB --> LOAD
    TB --> PIN0
    TB --> PIN1
    TB --> PIN2
    TB --> PIN3
    SOUT --> TB","`timescale 1ns/1ps

module shift_reg (
    input wire clk,
    input wire rst,
    input wire load,
    input wire [3:0] parallel_in,
    output wire serial_out
);

reg [3:0] reg_data;

always @(posedge clk or posedge rst) begin
    if (rst)
        reg_data <= 4'b0000;
    else if (load)
        reg_data <= parallel_in;
    else
        reg_data <= {reg_data[2:0], reg_data[3]};
end

assign serial_out = reg_data[3];

endmodule

module testbench;
    reg clk, rst, load;
    reg [3:0] parallel_in;
    wire serial_out;

    shift_reg dut (
        .clk(clk),
        .rst(rst),
        .load(load),
        .parallel_in(parallel_in),
        .serial_out(serial_out)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 0;
        rst = 1;
        load = 0;
        parallel_in = 4'b0000;

        #10 rst = 0;
        #10 parallel_in = 4'b1010;
        #10 load = 1;
        #10 load = 0;
        #40 parallel_in = 4'b1111;
        #10 load = 1;
        #10 load = 0;
        #40 rst = 1;
        #10 rst = 0;
        #20 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t rst=%b load=%b parallel_in=%b serial_out=%b reg_data=%b"",
                 $time, rst, load, parallel_in, serial_out, dut.reg_data);
    end
endmodule",True,66,True,True,True,False,0.4,False,10.211044788360596,7.972641706466675,"Create a 4-bit PISO shift register with clock, reset, load, parallel input[3:0], and serial output. Include testbench.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph LR
    CLK[Clock] --> REG[[4-bit Register]]
    RST[Reset] --> REG
    LOAD[Load] --> MUX
    PIN0[Parallel In 0] --> MUX0{MUX 0}
    PIN1[Parallel In 1] --> MUX1{MUX 1}
    PIN2[Parallel In 2] --> MUX2{MUX 2}
    PIN3[Parallel In 3] --> MUX3{MUX 3}
    MUX0 --> REG
    MUX1 --> REG
    MUX2 --> REG
    MUX3 --> REG
    REG --> SOUT[Serial Out]
    REG --> FB[Feedback]
    FB --> MUX0
    FB --> MUX1
    FB --> MUX2
    FB --> MUX3
    TB[Testbench] --> CLK
    TB --> RST
    TB --> LOAD
    TB --> PIN0
    TB --> PIN1
    TB --> PIN2
    TB --> PIN3
    SOUT --> TB
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module piso_register(
    input wire clk,
    input wire rst,
    input wire load,
    input wire [3:0] parallel_in,
    output wire serial_out
);

reg [3:0] shift_reg;

assign serial_out = shift_reg[0];

always @(posedge clk or posedge rst) begin
    if (rst)
        shift_reg <= 4'b0000;
    else if (load)
        shift_reg <= parallel_in;
    else
        shift_reg <= {1'b0, shift_reg[3:1]};
end

endmodule

module testbench;
    reg clk;
    reg rst;
    reg load;
    reg [3:0] parallel_in;
    wire serial_out;

    piso_register dut (
        .clk(clk),
        .rst(rst),
        .load(load),
        .parallel_in(parallel_in),
        .serial_out(serial_out)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 0;
        rst = 1;
        load = 0;
        parallel_in = 4'b0000;

        #10 rst = 0;
        
        #10 parallel_in = 4'b1101;
        load = 1;
        #10 load = 0;
        
        #40 parallel_in = 4'b1010;
        load = 1;
        #10 load = 0;
        
        #40 rst = 1;
        #10 rst = 0;
        
        #20 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t rst=%b load=%b parallel_in=%b serial_out=%b shift_reg=%b"",
                 $time, rst, load, parallel_in, serial_out, dut.shift_reg);
    end
endmodule",True,72,True,True,True,False,0.4,False,6.406193017959595,7.618454217910767,tie,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,Sequential,medium,"Create a 4-bit PISO shift register with clock, reset, load, parallel input[3:0], and serial output. Include testbench.",gpt-4o,"`timescale 1ns/1ps

module piso_shift_register(
    input wire clk,
    input wire rst_n,
    input wire load,
    input wire [3:0] parallel_in,
    output reg serial_out
);
    reg [3:0] shift_reg;

    always @(posedge clk or negedge rst_n) begin
        if (!rst_n)
            shift_reg <= 4'b0000;
        else if (load)
            shift_reg <= parallel_in;
        else
            shift_reg <= {shift_reg[2:0], 1'b0};
    end

    always @(posedge clk or negedge rst_n) begin
        if (!rst_n)
            serial_out <= 1'b0;
        else
            serial_out <= shift_reg[3];
    end
endmodule

module testbench;
    reg clk, rst_n, load;
    reg [3:0] parallel_in;
    wire serial_out;

    piso_shift_register dut (
        .clk(clk),
        .rst_n(rst_n),
        .load(load),
        .parallel_in(parallel_in),
        .serial_out(serial_out)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 1'b0;
        rst_n = 1'b0;
        load = 1'b0;
        parallel_in = 4'b0000;

        #20 rst_n = 1'b1;
        #10 load = 1'b1; parallel_in = 4'b1010;
        #10 load = 1'b0;
        #40 rst_n = 1'b0;
        #10 rst_n = 1'b1;
        #50 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b load=%b parallel_in=%b serial_out=%b"", 
                 $time, clk, rst_n, load, parallel_in, serial_out);
    end
endmodule",True,65,True,True,True,True,0.7,True,4.62093448638916,12.008396863937378,"graph LR
    CLK[Clock] --> SHIFTREG
    RST[Reset] --> SHIFTREG
    LOAD[Load] --> SHIFTREG
    PI[Parallel Input[3:0]] --> SHIFTREG
    SHIFTREG[[4-bit PISO Shift Register]]
    SHIFTREG --> SO[Serial Output]

    subgraph TESTBENCH
        CLK --> TB
        RST --> TB
        LOAD --> TB
        PI --> TB
        TB[Testing Logic] --> SHIFTREG
        SHIFTREG --> SO_TB[Serial Output Test]
    end","`timescale 1ns/1ps

module piso_shift_register(
    input wire clk,
    input wire rst_n,
    input wire load,
    input wire [3:0] parallel_in,
    output reg serial_out
);
    reg [3:0] shift_reg;
    
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n)
            shift_reg <= 4'b0000;
        else if (load)
            shift_reg <= parallel_in;
        else
            shift_reg <= {shift_reg[2:0], 1'b0};
    end
    
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n)
            serial_out <= 1'b0;
        else
            serial_out <= shift_reg[3];
    end
    
endmodule

module testbench;
    reg clk, rst_n, load;
    reg [3:0] parallel_in;
    wire serial_out;
    
    piso_shift_register dut (
        .clk(clk),
        .rst_n(rst_n),
        .load(load),
        .parallel_in(parallel_in),
        .serial_out(serial_out)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst_n = 1'b0;
        load = 1'b0;
        parallel_in = 4'b0000;
        
        #20 rst_n = 1'b1;
        #10 load = 1'b1; parallel_in = 4'b1010;
        #10 load = 1'b0;
        #100 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b load=%b parallel_in=%b serial_out=%b"", 
                 $time, clk, rst_n, load, parallel_in, serial_out);
    end
endmodule",True,64,True,True,True,True,0.7,True,9.559152603149414,12.555867433547974,"Create a 4-bit PISO shift register with clock, reset, load, parallel input[3:0], and serial output. Include testbench.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph LR
    CLK[Clock] --> SHIFTREG
    RST[Reset] --> SHIFTREG
    LOAD[Load] --> SHIFTREG
    PI[Parallel Input[3:0]] --> SHIFTREG
    SHIFTREG[[4-bit PISO Shift Register]]
    SHIFTREG --> SO[Serial Output]

    subgraph TESTBENCH
        CLK --> TB
        RST --> TB
        LOAD --> TB
        PI --> TB
        TB[Testing Logic] --> SHIFTREG
        SHIFTREG --> SO_TB[Serial Output Test]
    end
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module piso_shift_register(
    input wire clk,
    input wire rst,
    input wire load,
    input wire [3:0] parallel_in,
    output reg serial_out
);

    reg [3:0] shift_reg;

    always @(posedge clk or posedge rst) begin
        if (rst) begin
            shift_reg <= 4'b0000;
        end else if (load) begin
            shift_reg <= parallel_in;
        end else begin
            shift_reg <= {shift_reg[2:0], 1'b0};
        end
    end

    always @(posedge clk or posedge rst) begin
        if (rst) begin
            serial_out <= 1'b0;
        end else begin
            serial_out <= shift_reg[3];
        end
    end

endmodule

module testbench;
    reg clk, rst, load;
    reg [3:0] parallel_in;
    wire serial_out;

    piso_shift_register dut (
        .clk(clk),
        .rst(rst),
        .load(load),
        .parallel_in(parallel_in),
        .serial_out(serial_out)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 1'b0;
        rst = 1'b1;
        load = 1'b0;
        parallel_in = 4'b1010;

        #15 rst = 1'b0;
        #10 load = 1'b1;
        #10 load = 1'b0;
        #100 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t clk=%b rst=%b load=%b parallel_in=%b serial_out=%b"", 
                 $time, clk, rst, load, parallel_in, serial_out);
    end
endmodule",True,67,True,True,True,True,0.75,True,4.977772235870361,13.362767457962036,prompt_only,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,Combinational,medium,"Design a 4-to-2 priority encoder with input in[3:0], output out[1:0], and valid bit. Highest bit has priority. Include testbench.",claude,"`timescale 1ns/1ps

module priority_encoder(
    input wire [3:0] in,
    output reg [1:0] out,
    output reg valid
);

always @(*) begin
    casez(in)
        4'b1???: begin 
            out = 2'b11;
            valid = 1'b1;
        end
        4'b01??: begin
            out = 2'b10;
            valid = 1'b1;
        end
        4'b001?: begin
            out = 2'b01;
            valid = 1'b1;
        end
        4'b0001: begin
            out = 2'b00;
            valid = 1'b1;
        end
        default: begin
            out = 2'b00;
            valid = 1'b0;
        end
    endcase
end

endmodule

module testbench;
    reg [3:0] in;
    wire [1:0] out;
    wire valid;
    
    priority_encoder dut (
        .in(in),
        .out(out),
        .valid(valid)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        in = 4'b0000;
        #10 in = 4'b0001;
        #10 in = 4'b0010;
        #10 in = 4'b0100;
        #10 in = 4'b1000;
        #10 in = 4'b1100;
        #10 in = 4'b0110;
        #10 in = 4'b0011;
        #10 in = 4'b0000;
        #10 $finish;
    end
    
    initial begin
        $monitor(""Time=%0t in=%b out=%b valid=%b"", 
                 $time, in, out, valid);
    end
endmodule",True,67,True,True,True,False,0.4,False,6.06097412109375,7.904860258102417,"graph LR
    IN0[in[0]] --> PENC((Priority Encoder))
    IN1[in[1]] --> PENC
    IN2[in[2]] --> PENC
    IN3[in[3]] --> PENC
    PENC --> OUT[out[1:0]]
    PENC --> VALID[valid]
    TB[Testbench] -.-> IN0
    TB -.-> IN1
    TB -.-> IN2
    TB -.-> IN3
    OUT -.-> TB
    VALID -.-> TB
    CLK[Clock] --> TB
    RST[Reset] --> TB
    LOGIC{Priority Logic}
    PENC --> LOGIC
    LOGIC --> |if in[3]=1|OUT1[[out=3]]
    LOGIC --> |if in[2]=1|OUT2[[out=2]]
    LOGIC --> |if in[1]=1|OUT3[[out=1]]
    LOGIC --> |if in[0]=1|OUT4[[out=0]]","`timescale 1ns/1ps

module priority_encoder(
    input wire clk,
    input wire rst_n,
    input wire [3:0] in,
    output reg [1:0] out,
    output reg valid
);

always @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
        out <= 2'b00;
        valid <= 1'b0;
    end
    else begin
        valid <= |in;
        if (in[3])
            out <= 2'b11;
        else if (in[2])
            out <= 2'b10;
        else if (in[1])
            out <= 2'b01;
        else if (in[0])
            out <= 2'b00;
        else
            out <= 2'b00;
    end
end

endmodule

module testbench;
    reg clk, rst_n;
    reg [3:0] in;
    wire [1:0] out;
    wire valid;
    
    priority_encoder dut (
        .clk(clk),
        .rst_n(rst_n),
        .in(in),
        .out(out),
        .valid(valid)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 0;
        rst_n = 0;
        in = 4'b0000;
        
        #10 rst_n = 1;
        
        #10 in = 4'b0001;
        #10 in = 4'b0010;
        #10 in = 4'b0100;
        #10 in = 4'b1000;
        #10 in = 4'b1111;
        #10 in = 4'b0000;
        
        #10 rst_n = 0;
        #10 rst_n = 1;
        
        #20 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t rst_n=%b in=%b out=%b valid=%b"",
                 $time, rst_n, in, out, valid);
    end
endmodule",True,76,True,True,True,True,0.8,True,11.04414415359497,7.7338879108428955,"Design a 4-to-2 priority encoder with input in[3:0], output out[1:0], and valid bit. Highest bit has priority. Include testbench.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph LR
    IN0[in[0]] --> PENC((Priority Encoder))
    IN1[in[1]] --> PENC
    IN2[in[2]] --> PENC
    IN3[in[3]] --> PENC
    PENC --> OUT[out[1:0]]
    PENC --> VALID[valid]
    TB[Testbench] -.-> IN0
    TB -.-> IN1
    TB -.-> IN2
    TB -.-> IN3
    OUT -.-> TB
    VALID -.-> TB
    CLK[Clock] --> TB
    RST[Reset] --> TB
    LOGIC{Priority Logic}
    PENC --> LOGIC
    LOGIC --> |if in[3]=1|OUT1[[out=3]]
    LOGIC --> |if in[2]=1|OUT2[[out=2]]
    LOGIC --> |if in[1]=1|OUT3[[out=1]]
    LOGIC --> |if in[0]=1|OUT4[[out=0]]
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module priority_encoder(
    input wire [3:0] in,
    output reg [1:0] out,
    output reg valid
);

always @(*) begin
    if (in[3]) begin
        out = 2'b11;
        valid = 1'b1;
    end
    else if (in[2]) begin
        out = 2'b10;
        valid = 1'b1;
    end
    else if (in[1]) begin
        out = 2'b01;
        valid = 1'b1;
    end
    else if (in[0]) begin
        out = 2'b00;
        valid = 1'b1;
    end
    else begin
        out = 2'b00;
        valid = 1'b0;
    end
end

endmodule

module testbench;
    reg [3:0] in;
    wire [1:0] out;
    wire valid;
    reg clk;
    reg rst_n;
    
    priority_encoder dut (
        .in(in),
        .out(out),
        .valid(valid)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 0;
        rst_n = 0;
        in = 4'b0000;
        
        #10 rst_n = 1;
        
        // Test all priority cases
        #10 in = 4'b0001;  // Expect out=0
        #10 in = 4'b0010;  // Expect out=1
        #10 in = 4'b0100;  // Expect out=2
        #10 in = 4'b1000;  // Expect out=3
        #10 in = 4'b1111;  // Expect out=3 (priority)
        #10 in = 4'b0110;  // Expect out=2 (priority)
        #10 in = 4'b0000;  // Expect valid=0
        
        #10 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t in=%b out=%b valid=%b"", 
                 $time, in, out, valid);
    end
endmodule",True,75,True,True,True,False,0.4,False,7.367887020111084,7.299716234207153,tie,prompt_only > combined > mermaid_only,prompt_only > mermaid_only > combined
combined,Combinational,medium,"Design a 4-to-2 priority encoder with input in[3:0], output out[1:0], and valid bit. Highest bit has priority. Include testbench.",gpt-4o,"`timescale 1ns/1ps

module priority_encoder(
    input wire [3:0] in,
    output reg [1:0] out,
    output reg valid
);

always @(*) begin
    valid = 1'b0;
    out = 2'b00;
    if (in[3]) begin
        out = 2'b11;
        valid = 1'b1;
    end else if (in[2]) begin
        out = 2'b10;
        valid = 1'b1;
    end else if (in[1]) begin
        out = 2'b01;
        valid = 1'b1;
    end else if (in[0]) begin
        out = 2'b00;
        valid = 1'b1;
    end
end

endmodule

module testbench;
    reg [3:0] in;
    wire [1:0] out;
    wire valid;
    
    priority_encoder dut (
        .in(in),
        .out(out),
        .valid(valid)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        in = 4'b0000;
        #10 in = 4'b0001;
        #10 in = 4'b0010;
        #10 in = 4'b0100;
        #10 in = 4'b1000;
        #10 in = 4'b1100;
        #10 in = 4'b1110;
        #10 in = 4'b1111;
        #10 $finish;
    end
    
    initial begin
        $monitor(""Time=%0t in=%b out=%b valid=%b"", 
                 $time, in, out, valid);
    end
endmodule",True,59,True,True,True,False,0.4,False,4.729225158691406,8.64876651763916,"graph TD
    CLK[Clock] --> ENCODER(4-to-2 Priority Encoder)
    RST[Reset] --> ENCODER
    IN[in[3:0]] --> ENCODER
    ENCODER --> OUT[out[1:0]]
    ENCODER --> VALID[Valid Bit]
    
    TB[Testbench] --> CLK
    TB --> RST
    TB --> IN
    OUT --> TB
    VALID --> TB","`timescale 1ns/1ps

module priority_encoder(
    input wire clk,
    input wire rst,
    input wire [3:0] in,
    output reg [1:0] out,
    output reg valid
);

always @(posedge clk or posedge rst) begin
    if (rst) begin
        out <= 2'b00;
        valid <= 1'b0;
    end else begin
        casez(in)
            4'b0000: begin
                out <= 2'b00;
                valid <= 1'b0;
            end
            4'b0001: begin
                out <= 2'b00;
                valid <= 1'b1;
            end
            4'b001?: begin
                out <= 2'b01;
                valid <= 1'b1;
            end
            4'b01??: begin
                out <= 2'b10;
                valid <= 1'b1;
            end
            4'b1???: begin
                out <= 2'b11;
                valid <= 1'b1;
            end
            default: begin
                out <= 2'b00;
                valid <= 1'b0;
            end
        endcase
    end
end

endmodule

module testbench;
    reg clk, rst;
    reg [3:0] in;
    wire [1:0] out;
    wire valid;

    priority_encoder dut (
        .clk(clk),
        .rst(rst),
        .in(in),
        .out(out),
        .valid(valid)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst = 1'b1;
        in = 4'b0000;
        
        #20 rst = 1'b0;
        #10 in = 4'b0001;
        #10 in = 4'b0010;
        #10 in = 4'b0100;
        #10 in = 4'b1000;
        #10 in = 4'b1010;
        #10 in = 4'b0000;
        #50 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t clk=%b rst=%b in=%b out=%b valid=%b"", 
                 $time, clk, rst, in, out, valid);
    end
endmodule",True,85,True,True,True,True,0.7,True,8.927025079727173,12.433197975158691,"Design a 4-to-2 priority encoder with input in[3:0], output out[1:0], and valid bit. Highest bit has priority. Include testbench.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph TD
    CLK[Clock] --> ENCODER(4-to-2 Priority Encoder)
    RST[Reset] --> ENCODER
    IN[in[3:0]] --> ENCODER
    ENCODER --> OUT[out[1:0]]
    ENCODER --> VALID[Valid Bit]
    
    TB[Testbench] --> CLK
    TB --> RST
    TB --> IN
    OUT --> TB
    VALID --> TB
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module priority_encoder(
    input wire clk,
    input wire rst,
    input wire [3:0] in,
    output reg [1:0] out,
    output reg valid
);

always @(posedge clk or posedge rst) begin
    if (rst) begin
        out <= 2'b00;
        valid <= 1'b0;
    end else begin
        casez (in)
            4'b1???: begin
                out <= 2'b11;
                valid <= 1'b1;
            end
            4'b01??: begin
                out <= 2'b10;
                valid <= 1'b1;
            end
            4'b001?: begin
                out <= 2'b01;
                valid <= 1'b1;
            end
            4'b0001: begin
                out <= 2'b00;
                valid <= 1'b1;
            end
            default: begin
                out <= 2'b00;
                valid <= 1'b0;
            end
        endcase
    end
end

endmodule

module testbench;
    reg clk;
    reg rst;
    reg [3:0] in;
    wire [1:0] out;
    wire valid;

    priority_encoder dut (
        .clk(clk),
        .rst(rst),
        .in(in),
        .out(out),
        .valid(valid)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst = 1'b1;
        in = 4'b0000;
        
        #15 rst = 1'b0;
        #10 in = 4'b0001;
        #10 in = 4'b0010;
        #10 in = 4'b0100;
        #10 in = 4'b1000;
        #10 in = 4'b1100;
        #10 in = 4'b1010;
        #10 in = 4'b1001;
        #10 in = 4'b0000;
        #10 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t clk=%b rst=%b in=%b out=%b valid=%b"", 
                 $time, clk, rst, in, out, valid);
    end
endmodule",True,84,True,True,True,True,0.7,True,5.843646287918091,9.724039554595947,prompt_only,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,State Machine,complex,"Design a traffic light FSM with 4 states: NS_GREEN, NS_YELLOW, EW_GREEN, EW_YELLOW. Inputs: clk, rst, emergency. Outputs: ns_light[1:0], ew_light[1:0]. Timing: GREEN=8 cycles, YELLOW=2 cycles. Emergency makes both RED. Include testbench.",claude,"`timescale 1ns/1ps

module traffic_light (
    input wire clk,
    input wire rst,
    input wire emergency,
    output reg [1:0] ns_light,
    output reg [1:0] ew_light
);

parameter [1:0] RED = 2'b00;
parameter [1:0] YELLOW = 2'b01;
parameter [1:0] GREEN = 2'b10;

parameter [1:0] NS_GREEN = 2'b00;
parameter [1:0] NS_YELLOW = 2'b01;
parameter [1:0] EW_GREEN = 2'b10;
parameter [1:0] EW_YELLOW = 2'b11;

reg [1:0] state;
reg [3:0] timer;

always @(posedge clk or posedge rst) begin
    if (rst) begin
        state <= NS_GREEN;
        timer <= 4'd0;
        ns_light <= GREEN;
        ew_light <= RED;
    end
    else if (emergency) begin
        ns_light <= RED;
        ew_light <= RED;
    end
    else begin
        case (state)
            NS_GREEN: begin
                if (timer == 4'd7) begin
                    state <= NS_YELLOW;
                    timer <= 4'd0;
                    ns_light <= YELLOW;
                end
                else begin
                    timer <= timer + 1'b1;
                    ns_light <= GREEN;
                    ew_light <= RED;
                end
            end
            
            NS_YELLOW: begin
                if (timer == 4'd1) begin
                    state <= EW_GREEN;
                    timer <= 4'd0;
                    ns_light <= RED;
                    ew_light <= GREEN;
                end
                else begin
                    timer <= timer + 1'b1;
                    ns_light <= YELLOW;
                    ew_light <= RED;
                end
            end
            
            EW_GREEN: begin
                if (timer == 4'd7) begin
                    state <= EW_YELLOW;
                    timer <= 4'd0;
                    ew_light <= YELLOW;
                end
                else begin
                    timer <= timer + 1'b1;
                    ns_light <= RED;
                    ew_light <= GREEN;
                end
            end
            
            EW_YELLOW: begin
                if (timer == 4'd1) begin
                    state <= NS_GREEN;
                    timer <= 4'd0;
                    ns_light <= GREEN;
                    ew_light <= RED;
                end
                else begin
                    timer <= timer + 1'b1;
                    ns_light <= RED;
                    ew_light <= YELLOW;
                end
            end
        endcase
    end
end

endmodule

module testbench;
    reg clk;
    reg rst;
    reg emergency;
    wire [1:0] ns_light;
    wire [1:0] ew_light;
    
    traffic_light dut (
        .clk(clk),
        .rst(rst),
        .emergency(emergency),
        .ns_light(ns_light),
        .ew_light(ew_light)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 0;
        rst = 1;
        emergency = 0;
        
        #10 rst = 0;
        
        // Normal operation
        #100
        
        // Test emergency
        emergency = 1;
        #20
        emergency = 0;
        
        // Continue normal operation
        #100
        
        $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t rst=%b emergency=%b ns_light=%b ew_light=%b"",
                 $time, rst, emergency, ns_light, ew_light);
    end
endmodule",True,140,True,True,True,True,0.8,True,11.458735466003418,6.774467945098877,"graph LR
    CLK[Clock] --> FSM((Traffic Light FSM))
    RST[Reset] --> FSM
    EMG[Emergency] --> FSM
    
    FSM --> CNT[[Counter]]
    CLK --> CNT
    CNT --> FSM
    
    FSM --> NS[ns_light[1:0]]
    FSM --> EW[ew_light[1:0]]
    
    TB[Testbench] --> CLK
    TB --> RST
    TB --> EMG
    TB -.->|Monitor| NS
    TB -.->|Monitor| EW
    
    subgraph States
        S1[NS_GREEN]
        S2[NS_YELLOW]
        S3[EW_GREEN]
        S4[EW_YELLOW]
    end
    
    subgraph Timing
        T1[GREEN=8]
        T2[YELLOW=2]
    end","`timescale 1ns/1ps

// Traffic Light Controller with FSM and Counter
module traffic_controller(
    input wire clk,
    input wire rst,
    input wire emergency,
    output reg [1:0] ns_light,
    output reg [1:0] ew_light
);

// State definitions
parameter NS_GREEN  = 2'b00;
parameter NS_YELLOW = 2'b01;
parameter EW_GREEN  = 2'b10;
parameter EW_YELLOW = 2'b11;

// Light color definitions
parameter GREEN  = 2'b01;
parameter YELLOW = 2'b10;
parameter RED    = 2'b11;

reg [1:0] state, next_state;
reg [3:0] counter;

// Counter logic
always @(posedge clk or posedge rst) begin
    if (rst)
        counter <= 4'd0;
    else if (state != next_state)
        counter <= 4'd0;
    else if ((state == NS_GREEN) || (state == EW_GREEN))
        counter <= (counter == 4'd8) ? 4'd0 : counter + 1'b1;
    else
        counter <= (counter == 4'd2) ? 4'd0 : counter + 1'b1;
end

// State register
always @(posedge clk or posedge rst) begin
    if (rst)
        state <= NS_GREEN;
    else
        state <= next_state;
end

// Next state logic
always @(*) begin
    case (state)
        NS_GREEN: 
            next_state = ((counter == 4'd8) || emergency) ? NS_YELLOW : NS_GREEN;
        NS_YELLOW:
            next_state = (counter == 4'd2) ? EW_GREEN : NS_YELLOW;
        EW_GREEN:
            next_state = ((counter == 4'd8) || emergency) ? EW_YELLOW : EW_GREEN;
        EW_YELLOW:
            next_state = (counter == 4'd2) ? NS_GREEN : EW_YELLOW;
        default:
            next_state = NS_GREEN;
    endcase
end

// Output logic
always @(*) begin
    case (state)
        NS_GREEN: begin
            ns_light = GREEN;
            ew_light = RED;
        end
        NS_YELLOW: begin
            ns_light = YELLOW;
            ew_light = RED;
        end
        EW_GREEN: begin
            ns_light = RED;
            ew_light = GREEN;
        end
        EW_YELLOW: begin
            ns_light = RED;
            ew_light = YELLOW;
        end
        default: begin
            ns_light = RED;
            ew_light = RED;
        end
    endcase
end

endmodule

module testbench;
    reg clk, rst, emergency;
    wire [1:0] ns_light, ew_light;
    
    traffic_controller dut (
        .clk(clk),
        .rst(rst),
        .emergency(emergency),
        .ns_light(ns_light),
        .ew_light(ew_light)
    );
    
    initial begin
        $dumpfile(""traffic.vcd"");
        $dumpvars(0, testbench);
        
        clk = 0;
        rst = 1;
        emergency = 0;
        
        #10 rst = 0;
        #100 emergency = 1;
        #10 emergency = 0;
        #200 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t rst=%b emergency=%b ns_light=%b ew_light=%b"",
                 $time, rst, emergency, ns_light, ew_light);
    end
endmodule",True,122,True,True,True,,0.0,,14.834031105041504,0.016176223754882812,"Design a traffic light FSM with 4 states: NS_GREEN, NS_YELLOW, EW_GREEN, EW_YELLOW. Inputs: clk, rst, emergency. Outputs: ns_light[1:0], ew_light[1:0]. Timing: GREEN=8 cycles, YELLOW=2 cycles. Emergency makes both RED. Include testbench.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph LR
    CLK[Clock] --> FSM((Traffic Light FSM))
    RST[Reset] --> FSM
    EMG[Emergency] --> FSM
    
    FSM --> CNT[[Counter]]
    CLK --> CNT
    CNT --> FSM
    
    FSM --> NS[ns_light[1:0]]
    FSM --> EW[ew_light[1:0]]
    
    TB[Testbench] --> CLK
    TB --> RST
    TB --> EMG
    TB -.->|Monitor| NS
    TB -.->|Monitor| EW
    
    subgraph States
        S1[NS_GREEN]
        S2[NS_YELLOW]
        S3[EW_GREEN]
        S4[EW_YELLOW]
    end
    
    subgraph Timing
        T1[GREEN=8]
        T2[YELLOW=2]
    end
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module traffic_light(
    input wire clk,
    input wire rst,
    input wire emergency,
    output reg [1:0] ns_light,
    output reg [1:0] ew_light
);

localparam RED = 2'b00;
localparam GREEN = 2'b01;
localparam YELLOW = 2'b10;

localparam NS_GREEN = 2'b00;
localparam NS_YELLOW = 2'b01;
localparam EW_GREEN = 2'b10;
localparam EW_YELLOW = 2'b11;

reg [1:0] state, next_state;
reg [3:0] counter;

always @(posedge clk or posedge rst) begin
    if (rst) begin
        state <= NS_GREEN;
        counter <= 4'b0000;
    end
    else begin
        state <= next_state;
        if (counter == 4'b0000)
            counter <= (state == NS_GREEN || state == EW_GREEN) ? 4'd8 : 4'd2;
        else
            counter <= counter - 1'b1;
    end
end

always @(*) begin
    if (emergency) begin
        ns_light = RED;
        ew_light = RED;
        next_state = state;
    end
    else begin
        case (state)
            NS_GREEN: begin
                ns_light = GREEN;
                ew_light = RED;
                next_state = (counter == 4'b0001) ? NS_YELLOW : NS_GREEN;
            end
            NS_YELLOW: begin
                ns_light = YELLOW;
                ew_light = RED;
                next_state = (counter == 4'b0001) ? EW_GREEN : NS_YELLOW;
            end
            EW_GREEN: begin
                ns_light = RED;
                ew_light = GREEN;
                next_state = (counter == 4'b0001) ? EW_YELLOW : EW_GREEN;
            end
            EW_YELLOW: begin
                ns_light = RED;
                ew_light = YELLOW;
                next_state = (counter == 4'b0001) ? NS_GREEN : EW_YELLOW;
            end
            default: begin
                ns_light = RED;
                ew_light = RED;
                next_state = NS_GREEN;
            end
        endcase
    end
end

endmodule

module testbench;
    reg clk, rst, emergency;
    wire [1:0] ns_light, ew_light;
    
    traffic_light dut (
        .clk(clk),
        .rst(rst),
        .emergency(emergency),
        .ns_light(ns_light),
        .ew_light(ew_light)
    );
    
    initial begin
        $dumpfile(""traffic.vcd"");
        $dumpvars(0, testbench);
        
        clk = 0;
        rst = 1;
        emergency = 0;
        
        #10 rst = 0;
        
        #100 emergency = 1;
        #20 emergency = 0;
        
        #200 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t ns_light=%b ew_light=%b"", $time, ns_light, ew_light);
    end
endmodule",True,109,True,True,True,,0.0,,10.18862009048462,0.014239072799682617,prompt_only,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,State Machine,complex,"Design a traffic light FSM with 4 states: NS_GREEN, NS_YELLOW, EW_GREEN, EW_YELLOW. Inputs: clk, rst, emergency. Outputs: ns_light[1:0], ew_light[1:0]. Timing: GREEN=8 cycles, YELLOW=2 cycles. Emergency makes both RED. Include testbench.",gpt-4o,"`timescale 1ns/1ps

module traffic_light_fsm(
    input wire clk,
    input wire rst,
    input wire emergency,
    output reg [1:0] ns_light,
    output reg [1:0] ew_light
);

    typedef enum reg [1:0] {
        NS_GREEN = 2'b00,
        NS_YELLOW = 2'b01,
        EW_GREEN = 2'b10,
        EW_YELLOW = 2'b11
    } state_t;

    reg [3:0] counter;
    reg [1:0] state, next_state;

    always @(posedge clk or posedge rst) begin
        if (rst) begin
            state <= NS_GREEN;
            counter <= 4'b0000;
        end else if (emergency) begin
            state <= 2'b11; // Both lights RED during emergency
        end else begin
            state <= next_state;
            counter <= (counter == 4'b1001) ? 4'b0000 : counter + 1'b1;
        end
    end

    always @(*) begin
        case (state)
            NS_GREEN: begin
                ns_light = 2'b01; 
                ew_light = 2'b00;
                if (counter == 4'b0111)
                    next_state = NS_YELLOW;
                else
                    next_state = NS_GREEN;
            end

            NS_YELLOW: begin
                ns_light = 2'b10;
                ew_light = 2'b00;
                if (counter == 4'b1001)
                    next_state = EW_GREEN;
                else
                    next_state = NS_YELLOW;
            end

            EW_GREEN: begin
                ns_light = 2'b00;
                ew_light = 2'b01;
                if (counter == 4'b0111)
                    next_state = EW_YELLOW;
                else
                    next_state = EW_GREEN;
            end

            EW_YELLOW: begin
                ns_light = 2'b00;
                ew_light = 2'b10;
                if (counter == 4'b1001)
                    next_state = NS_GREEN;
                else
                    next_state = EW_YELLOW;
            end

            default: begin
                ns_light = 2'b00;
                ew_light = 2'b00;
                next_state = NS_GREEN;
            end
        endcase
    end
endmodule

module testbench;
    reg clk, rst, emergency;
    wire [1:0] ns_light, ew_light;

    traffic_light_fsm dut (
        .clk(clk),
        .rst(rst),
        .emergency(emergency),
        .ns_light(ns_light),
        .ew_light(ew_light)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 1'b0;
        rst = 1'b1;
        emergency = 1'b0;

        #10 rst = 1'b0;
        #100 emergency = 1'b1;
        #20 emergency = 1'b0;
        #300 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t clk=%b rst=%b emergency=%b ns_light=%b ew_light=%b"", 
                 $time, clk, rst, emergency, ns_light, ew_light);
    end
endmodule",True,112,True,True,True,False,0.3,False,7.623213291168213,8.291471719741821,"graph TD
    CLK[clk] --> FSM
    RST[rst] --> FSM
    EMG[emergency] --> {Emergency?}
    {Emergency?} -->|Yes| NS_RED[NS_LIGHT = RED] & EW_RED[EW_LIGHT = RED]
    {Emergency?} -->|No| FSM(State Transition)
    
    FSM -->|NS_GREEN| NS_GREEN_STATE((NS_GREEN))
    FSM -->|NS_YELLOW| NS_YELLOW_STATE((NS_YELLOW))
    FSM -->|EW_GREEN| EW_GREEN_STATE((EW_GREEN))
    FSM -->|EW_YELLOW| EW_YELLOW_STATE((EW_YELLOW))
    
    NS_GREEN_STATE -->|8 cycles| NS_YELLOW_STATE
    NS_YELLOW_STATE -->|2 cycles| EW_GREEN_STATE
    EW_GREEN_STATE -->|8 cycles| EW_YELLOW_STATE
    EW_YELLOW_STATE -->|2 cycles| NS_GREEN_STATE
    
    NS_GREEN_STATE -->|Output| NS_GREEN_OUT[ns_light[1:0] = GREEN]
    NS_YELLOW_STATE -->|Output| NS_YELLOW_OUT[ns_light[1:0] = YELLOW]
    EW_GREEN_STATE -->|Output| EW_GREEN_OUT[ew_light[1:0] = GREEN]
    EW_YELLOW_STATE -->|Output| EW_YELLOW_OUT[ew_light[1:0] = YELLOW]
    
    NS_RED --> TB[Testbench]
    EW_RED --> TB
    NS_GREEN_OUT --> TB
    NS_YELLOW_OUT --> TB
    EW_GREEN_OUT --> TB
    EW_YELLOW_OUT --> TB","`timescale 1ns/1ps

module traffic_light_fsm(
    input wire clk,
    input wire rst,
    input wire emergency,
    output reg [1:0] ns_light,
    output reg [1:0] ew_light
);

    typedef enum reg [1:0] {
        NS_GREEN = 2'b00,
        NS_YELLOW = 2'b01,
        EW_GREEN = 2'b10,
        EW_YELLOW = 2'b11
    } state_t;

    reg [3:0] cycle_count;
    reg [1:0] current_state, next_state;

    always @(posedge clk or posedge rst) begin
        if (rst) begin
            current_state <= NS_GREEN;
            cycle_count <= 4'b0000;
        end else if (emergency) begin
            current_state <= NS_GREEN;
            ew_light <= 2'b11; // RED
            ns_light <= 2'b11; // RED
        end else begin
            current_state <= next_state;
            if (cycle_count == 4'b1001) // 10 cycles
                cycle_count <= 4'b0000;
            else
                cycle_count <= cycle_count + 1'b1;
        end
    end

    always @(*) begin
        case (current_state)
            NS_GREEN: begin
                ns_light = 2'b01; // GREEN
                ew_light = 2'b11; // RED
                if (cycle_count == 4'b1000) // 8 cycles
                    next_state = NS_YELLOW;
                else
                    next_state = NS_GREEN;
            end

            NS_YELLOW: begin
                ns_light = 2'b10; // YELLOW
                ew_light = 2'b11; // RED
                if (cycle_count == 4'b0010) // 2 cycles
                    next_state = EW_GREEN;
                else
                    next_state = NS_YELLOW;
            end

            EW_GREEN: begin
                ns_light = 2'b11; // RED
                ew_light = 2'b01; // GREEN
                if (cycle_count == 4'b1000) // 8 cycles
                    next_state = EW_YELLOW;
                else
                    next_state = EW_GREEN;
            end

            EW_YELLOW: begin
                ns_light = 2'b11; // RED
                ew_light = 2'b10; // YELLOW
                if (cycle_count == 4'b0010) // 2 cycles
                    next_state = NS_GREEN;
                else
                    next_state = EW_YELLOW;
            end

            default: begin
                ns_light = 2'b11; // RED
                ew_light = 2'b11; // RED
                next_state = NS_GREEN;
            end
        endcase
    end

endmodule

module testbench;
    reg clk, rst, emergency;
    wire [1:0] ns_light, ew_light;
    
    traffic_light_fsm dut (
        .clk(clk),
        .rst(rst),
        .emergency(emergency),
        .ns_light(ns_light),
        .ew_light(ew_light)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst = 1'b1;
        emergency = 1'b0;
        
        #20 rst = 1'b0;
        #200 emergency = 1'b1;
        #20 emergency = 1'b0;
        #400 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t clk=%b rst=%b emergency=%b ns_light=%b ew_light=%b"", 
                 $time, clk, rst, emergency, ns_light, ew_light);
    end
endmodule",True,118,True,True,True,True,0.7,True,17.638197898864746,12.008485555648804,"Design a traffic light FSM with 4 states: NS_GREEN, NS_YELLOW, EW_GREEN, EW_YELLOW. Inputs: clk, rst, emergency. Outputs: ns_light[1:0], ew_light[1:0]. Timing: GREEN=8 cycles, YELLOW=2 cycles. Emergency makes both RED. Include testbench.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph TD
    CLK[clk] --> FSM
    RST[rst] --> FSM
    EMG[emergency] --> {Emergency?}
    {Emergency?} -->|Yes| NS_RED[NS_LIGHT = RED] & EW_RED[EW_LIGHT = RED]
    {Emergency?} -->|No| FSM(State Transition)
    
    FSM -->|NS_GREEN| NS_GREEN_STATE((NS_GREEN))
    FSM -->|NS_YELLOW| NS_YELLOW_STATE((NS_YELLOW))
    FSM -->|EW_GREEN| EW_GREEN_STATE((EW_GREEN))
    FSM -->|EW_YELLOW| EW_YELLOW_STATE((EW_YELLOW))
    
    NS_GREEN_STATE -->|8 cycles| NS_YELLOW_STATE
    NS_YELLOW_STATE -->|2 cycles| EW_GREEN_STATE
    EW_GREEN_STATE -->|8 cycles| EW_YELLOW_STATE
    EW_YELLOW_STATE -->|2 cycles| NS_GREEN_STATE
    
    NS_GREEN_STATE -->|Output| NS_GREEN_OUT[ns_light[1:0] = GREEN]
    NS_YELLOW_STATE -->|Output| NS_YELLOW_OUT[ns_light[1:0] = YELLOW]
    EW_GREEN_STATE -->|Output| EW_GREEN_OUT[ew_light[1:0] = GREEN]
    EW_YELLOW_STATE -->|Output| EW_YELLOW_OUT[ew_light[1:0] = YELLOW]
    
    NS_RED --> TB[Testbench]
    EW_RED --> TB
    NS_GREEN_OUT --> TB
    NS_YELLOW_OUT --> TB
    EW_GREEN_OUT --> TB
    EW_YELLOW_OUT --> TB
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module traffic_light_fsm(
    input wire clk,
    input wire rst,
    input wire emergency,
    output reg [1:0] ns_light,
    output reg [1:0] ew_light
);

    // State encoding
    parameter NS_GREEN = 2'b00, NS_YELLOW = 2'b01,
              EW_GREEN = 2'b10, EW_YELLOW = 2'b11;
    
    // Light encoding
    parameter RED = 2'b00, GREEN = 2'b01, YELLOW = 2'b10;
    
    reg [1:0] state, next_state;
    reg [3:0] cycle_count;

    // State transition and output logic
    always @(posedge clk or posedge rst) begin
        if (rst) begin
            state <= NS_GREEN;
            cycle_count <= 4'd0;
        end else if (emergency) begin
            ns_light <= RED;
            ew_light <= RED;
        end else begin
            state <= next_state;
            cycle_count <= (cycle_count == 4'd9) ? 4'd0 : cycle_count + 1'b1;
        end
    end

    always @(*) begin
        next_state = state; // default state remains the same
        case (state)
            NS_GREEN: begin
                ns_light = GREEN;
                ew_light = RED;
                if (cycle_count == 4'd7) 
                    next_state = NS_YELLOW;
            end
            NS_YELLOW: begin
                ns_light = YELLOW;
                ew_light = RED;
                if (cycle_count == 4'd1) 
                    next_state = EW_GREEN;
            end
            EW_GREEN: begin
                ns_light = RED;
                ew_light = GREEN;
                if (cycle_count == 4'd7) 
                    next_state = EW_YELLOW;
            end
            EW_YELLOW: begin
                ns_light = RED;
                ew_light = YELLOW;
                if (cycle_count == 4'd1) 
                    next_state = NS_GREEN;
            end
        endcase
    end

endmodule

module testbench;
    reg clk, rst, emergency;
    wire [1:0] ns_light, ew_light;

    traffic_light_fsm dut (
        .clk(clk),
        .rst(rst),
        .emergency(emergency),
        .ns_light(ns_light),
        .ew_light(ew_light)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 1'b0;
        rst = 1'b1;
        emergency = 1'b0;
        
        #10 rst = 1'b0;
        #100 emergency = 1'b1;
        #20 emergency = 1'b0;
        #200 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t clk=%b rst=%b emergency=%b ns_light=%b ew_light=%b"", 
                 $time, clk, rst, emergency, ns_light, ew_light);
    end
endmodule",True,99,True,True,True,False,0.3,False,8.342552661895752,10.894976139068604,tie,prompt_only > combined > mermaid_only,prompt_only > mermaid_only > combined
combined,State Machine,complex,"Design UART transmitter with states: IDLE, START, DATA, STOP. Protocol: START(0), 8 data bits LSB-first, STOP(1). Baud rate divider. Include testbench.",claude,"`timescale 1ns/1ps

module uart_tx(
    input wire clk,
    input wire rst_n,
    input wire tx_start,
    input wire [7:0] tx_data,
    output reg tx_out,
    output reg tx_busy
);

parameter IDLE = 2'b00;
parameter START = 2'b01;
parameter DATA = 2'b10;
parameter STOP = 2'b11;

reg [1:0] state;
reg [2:0] bit_count;
reg [7:0] shift_reg;
reg [7:0] baud_count;

always @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
        state <= IDLE;
        tx_out <= 1'b1;
        tx_busy <= 1'b0;
        bit_count <= 3'b000;
        shift_reg <= 8'b0;
        baud_count <= 8'b0;
    end else begin
        case (state)
            IDLE: begin
                if (tx_start) begin
                    state <= START;
                    tx_busy <= 1'b1;
                    shift_reg <= tx_data;
                    baud_count <= 8'b0;
                end else begin
                    tx_out <= 1'b1;
                end
            end
            
            START: begin
                tx_out <= 1'b0;
                if (baud_count == 8'd15) begin
                    state <= DATA;
                    bit_count <= 3'b000;
                    baud_count <= 8'b0;
                end else begin
                    baud_count <= baud_count + 1'b1;
                end
            end
            
            DATA: begin
                tx_out <= shift_reg[0];
                if (baud_count == 8'd15) begin
                    baud_count <= 8'b0;
                    if (bit_count == 3'd7) begin
                        state <= STOP;
                    end else begin
                        bit_count <= bit_count + 1'b1;
                        shift_reg <= {1'b0, shift_reg[7:1]};
                    end
                end else begin
                    baud_count <= baud_count + 1'b1;
                end
            end
            
            STOP: begin
                tx_out <= 1'b1;
                if (baud_count == 8'd15) begin
                    state <= IDLE;
                    tx_busy <= 1'b0;
                    baud_count <= 8'b0;
                end else begin
                    baud_count <= baud_count + 1'b1;
                end
            end
        endcase
    end
end

endmodule

module testbench;
    reg clk;
    reg rst_n;
    reg tx_start;
    reg [7:0] tx_data;
    wire tx_out;
    wire tx_busy;

    uart_tx dut (
        .clk(clk),
        .rst_n(rst_n),
        .tx_start(tx_start),
        .tx_data(tx_data),
        .tx_out(tx_out),
        .tx_busy(tx_busy)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst_n = 1'b0;
        tx_start = 1'b0;
        tx_data = 1'b0;
        
        #20 rst_n = 1'b1;
        #20 tx_data = 8'b10101010;
        #10 tx_start = 1'b1;
        #10 tx_start = 1'b0;
        
        #1000 tx_data = 8'b11110000;
        #10 tx_start = 1'b1;
        #10 tx_start = 1'b0;
        
        #1000 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t rst_n=%b tx_start=%b tx_data=%b tx_out=%b tx_busy=%b"",
                 $time, rst_n, tx_start, tx_data, tx_out, tx_busy);
    end
endmodule",True,129,True,True,True,True,0.7,True,12.361393690109253,8.047415256500244,"graph TD
    CLK[Clock] --> CTRL
    RST[Reset] --> CTRL
    TX_START[TX_START] --> CTRL
    TX_DATA[TX_DATA_IN] --> SHIFT

    CTRL((FSM Control))
    SHIFT[[Shift Register]]
    BAUD((Baud Generator))
    MUX{Data Mux}

    CTRL --> |state|SHIFT
    CTRL --> |enable|BAUD
    BAUD --> |baud_tick|CTRL
    
    SHIFT --> |data|MUX
    MUX --> |tx_out|TX[TX_OUT]

    CTRL --> |select|MUX
    START[START_BIT] --> MUX
    STOP[STOP_BIT] --> MUX

    TB_CLK[Test Clock] -.-> TB[Testbench]
    TB_RST[Test Reset] -.-> TB
    TB -.-> |test_data|TX_DATA
    TB -.-> |start_signal|TX_START
    TB -.-> |verify|TX","`timescale 1ns/1ps

module uart_tx(
    input wire clk,
    input wire rst,
    input wire tx_start,
    input wire [7:0] tx_data_in,
    output reg tx_out
);

// State definitions
parameter IDLE = 2'b00;
parameter START = 2'b01;
parameter DATA = 2'b10;
parameter STOP = 2'b11;

reg [1:0] state, next_state;
reg [7:0] shift_reg;
reg [2:0] bit_count;
reg baud_tick;
reg [3:0] baud_count;

// Baud rate generator (div by 16 for this example)
always @(posedge clk or posedge rst) begin
    if (rst)
        baud_count <= 4'd0;
    else
        baud_count <= baud_count + 1'b1;
end

assign baud_tick = (baud_count == 4'd15);

// Shift register
always @(posedge clk or posedge rst) begin
    if (rst)
        shift_reg <= 8'd0;
    else if (tx_start && state == IDLE)
        shift_reg <= tx_data_in;
    else if (baud_tick && state == DATA)
        shift_reg <= {1'b0, shift_reg[7:1]};
end

// Bit counter
always @(posedge clk or posedge rst) begin
    if (rst)
        bit_count <= 3'd0;
    else if (state == IDLE)
        bit_count <= 3'd0;
    else if (baud_tick && state == DATA)
        bit_count <= bit_count + 1'b1;
end

// State machine
always @(posedge clk or posedge rst) begin
    if (rst)
        state <= IDLE;
    else
        state <= next_state;
end

always @(*) begin
    case (state)
        IDLE: next_state = tx_start ? START : IDLE;
        START: next_state = baud_tick ? DATA : START;
        DATA: next_state = (baud_tick && bit_count == 3'd7) ? STOP : DATA;
        STOP: next_state = baud_tick ? IDLE : STOP;
        default: next_state = IDLE;
    endcase
end

// Output mux
always @(*) begin
    case (state)
        IDLE: tx_out = 1'b1;
        START: tx_out = 1'b0;
        DATA: tx_out = shift_reg[0];
        STOP: tx_out = 1'b1;
        default: tx_out = 1'b1;
    endcase
end

endmodule

module testbench;
    reg clk, rst, tx_start;
    reg [7:0] tx_data_in;
    wire tx_out;
    
    uart_tx dut (
        .clk(clk),
        .rst(rst),
        .tx_start(tx_start),
        .tx_data_in(tx_data_in),
        .tx_out(tx_out)
    );
    
    initial begin
        $dumpfile(""uart.vcd"");
        $dumpvars(0, testbench);
        
        clk = 0;
        rst = 1;
        tx_start = 0;
        tx_data_in = 0;
        
        #20 rst = 0;
        #20 tx_data_in = 8'h55;
        #20 tx_start = 1;
        #20 tx_start = 0;
        
        #1000 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t tx_out=%b"", $time, tx_out);
    end
endmodule",True,119,True,False,False,,0.0,,16.80155634880066,0.010753870010375977,"Design UART transmitter with states: IDLE, START, DATA, STOP. Protocol: START(0), 8 data bits LSB-first, STOP(1). Baud rate divider. Include testbench.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph TD
    CLK[Clock] --> CTRL
    RST[Reset] --> CTRL
    TX_START[TX_START] --> CTRL
    TX_DATA[TX_DATA_IN] --> SHIFT

    CTRL((FSM Control))
    SHIFT[[Shift Register]]
    BAUD((Baud Generator))
    MUX{Data Mux}

    CTRL --> |state|SHIFT
    CTRL --> |enable|BAUD
    BAUD --> |baud_tick|CTRL
    
    SHIFT --> |data|MUX
    MUX --> |tx_out|TX[TX_OUT]

    CTRL --> |select|MUX
    START[START_BIT] --> MUX
    STOP[STOP_BIT] --> MUX

    TB_CLK[Test Clock] -.-> TB[Testbench]
    TB_RST[Test Reset] -.-> TB
    TB -.-> |test_data|TX_DATA
    TB -.-> |start_signal|TX_START
    TB -.-> |verify|TX
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module uart_tx (
    input wire clk,
    input wire rst,
    input wire tx_start,
    input wire [7:0] tx_data_in,
    output wire tx_out
);

localparam IDLE = 2'b00;
localparam START = 2'b01;
localparam DATA = 2'b10;
localparam STOP = 2'b11;

reg [1:0] state, next_state;
reg [7:0] shift_reg;
reg [2:0] bit_counter;
reg shift_load;
reg baud_enable;
reg [2:0] mux_sel;

wire baud_tick;
wire start_bit = 1'b0;
wire stop_bit = 1'b1;

baud_gen baud_gen_inst (
    .clk(clk),
    .rst(rst),
    .enable(baud_enable),
    .baud_tick(baud_tick)
);

always @(posedge clk or posedge rst) begin
    if (rst)
        state <= IDLE;
    else
        state <= next_state;
end

always @(posedge clk) begin
    if (rst) begin
        shift_reg <= 8'h00;
    end
    else if (shift_load) begin
        shift_reg <= tx_data_in;
    end
    else if (baud_tick && state == DATA) begin
        shift_reg <= {1'b0, shift_reg[7:1]};
    end
end

always @(*) begin
    next_state = state;
    baud_enable = 1'b0;
    shift_load = 1'b0;
    mux_sel = 3'b000;
    
    case (state)
        IDLE: begin
            mux_sel = 3'b001;
            if (tx_start) begin
                next_state = START;
                shift_load = 1'b1;
            end
        end
        START: begin
            mux_sel = 3'b010;
            baud_enable = 1'b1;
            if (baud_tick)
                next_state = DATA;
        end
        DATA: begin
            mux_sel = 3'b011;
            baud_enable = 1'b1;
            if (baud_tick && bit_counter == 3'h7)
                next_state = STOP;
        end
        STOP: begin
            mux_sel = 3'b100;
            baud_enable = 1'b1;
            if (baud_tick)
                next_state = IDLE;
        end
    endcase
end

always @(posedge clk or posedge rst) begin
    if (rst)
        bit_counter <= 3'h0;
    else if (state == DATA && baud_tick)
        bit_counter <= bit_counter + 1'b1;
    else if (state == IDLE)
        bit_counter <= 3'h0;
end

mux_4to1 output_mux (
    .sel(mux_sel),
    .in_stop(stop_bit),
    .in_start(start_bit),
    .in_data(shift_reg[0]),
    .in_idle(1'b1),
    .out(tx_out)
);

endmodule

module baud_gen (
    input wire clk,
    input wire rst,
    input wire enable,
    output reg baud_tick
);

reg [7:0] counter;
localparam DIVISOR = 8'd16;

always @(posedge clk or posedge rst) begin
    if (rst) begin
        counter <= 8'd0;
        baud_tick <= 1'b0;
    end
    else if (enable) begin
        if (counter == DIVISOR-1) begin
            counter <= 8'd0;
            baud_tick <= 1'b1;
        end
        else begin
            counter <= counter + 1'b1;
            baud_tick <= 1'b0;
        end
    end
    else begin
        baud_tick <= 1'b0;
    end
end

endmodule

module mux_4to1 (
    input wire [2:0] sel,
    input wire in_idle,
    input wire in_start,
    input wire in_data,
    input wire in_stop,
    output reg out
);

always @(*) begin
    case (sel)
        3'b001: out = in_idle;
        3'b010: out = in_start;
        3'b011: out = in_data;
        3'b100: out = in_stop;
        default: out = in_idle;
    endcase
end

endmodule

module testbench;
    reg clk;
    reg rst;
    reg tx_start;
    reg [7:0] tx_data_in;
    wire tx_out;
    
    uart_tx dut (
        .clk(clk),
        .rst(rst),
        .tx_start(tx_start),
        .tx_data_in(tx_data_in),
        .tx_out(tx_out)
    );
    
    initial begin
        $dumpfile(""uart_tx.vcd"");
        $dumpvars(0, testbench);
        
        clk = 0;
        rst = 1;
        tx_start = 0;
        tx_data_in = 8'h00;
        
        #20 rst = 0;
        #20 tx_data_in = 8'h55;
        #20 tx_start = 1;
        #20 tx_start = 0;
        
        #1000 tx_data_in = 8'hAA;
        #20 tx_start = 1;
        #20 tx_start = 0;
        
        #1000 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t rst=%b tx_start=%b data=0x%h tx=%b"",
                 $time, rst, tx_start, tx_data_in, tx_out);
    end
endmodule",True,203,True,True,True,,0.0,,19.423349380493164,0.015448808670043945,prompt_only,prompt_only > mermaid_only > combined,prompt_only > combined > mermaid_only
combined,State Machine,complex,"Design UART transmitter with states: IDLE, START, DATA, STOP. Protocol: START(0), 8 data bits LSB-first, STOP(1). Baud rate divider. Include testbench.",gpt-4o,"`timescale 1ns/1ps

module uart_tx(
    input wire clk,
    input wire rst_n,
    input wire tx_start,
    input wire [7:0] tx_data,
    output reg tx_out,
    output reg tx_busy
);

    reg [3:0] state;
    reg [3:0] bit_index;
    reg [15:0] baud_counter;
    reg baud_tick;

    parameter IDLE = 4'd0;
    parameter START = 4'd1;
    parameter DATA = 4'd2;
    parameter STOP = 4'd3;
    parameter BAUD_DIV = 16'd10416; // Assuming a specific baud rate divider

    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            state <= IDLE;
            bit_index <= 4'b0;
            baud_counter <= 16'b0;
            tx_out <= 1'b1;
            tx_busy <= 1'b0;
            baud_tick <= 1'b0;
        end else begin
            if (baud_counter == BAUD_DIV) begin
                baud_counter <= 16'b0;
                baud_tick <= 1'b1;
            end else begin
                baud_counter <= baud_counter + 1'b1;
                baud_tick <= 1'b0;
            end

            case (state)
                IDLE: begin
                    tx_out <= 1'b1;
                    tx_busy <= 1'b0;
                    if (tx_start) begin
                        state <= START;
                        tx_busy <= 1'b1;
                    end
                end
                START: begin
                    if (baud_tick) begin
                        tx_out <= 1'b0;
                        state <= DATA;
                        bit_index <= 4'b0;
                    end
                end
                DATA: begin
                    if (baud_tick) begin
                        tx_out <= tx_data[bit_index];
                        if (bit_index == 4'd7) begin
                            state <= STOP;
                        end else begin
                            bit_index <= bit_index + 1'b1;
                        end
                    end
                end
                STOP: begin
                    if (baud_tick) begin
                        tx_out <= 1'b1;
                        state <= IDLE;
                        tx_busy <= 1'b0;
                    end
                end
            endcase
        end
    end
endmodule

module testbench;
    reg clk;
    reg rst_n;
    reg tx_start;
    reg [7:0] tx_data;
    wire tx_out;
    wire tx_busy;

    uart_tx dut (
        .clk(clk),
        .rst_n(rst_n),
        .tx_start(tx_start),
        .tx_data(tx_data),
        .tx_out(tx_out),
        .tx_busy(tx_busy)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 1'b0;
        rst_n = 1'b0;
        tx_start = 1'b0;
        tx_data = 8'b0;

        #20 rst_n = 1'b1;
        #10 tx_data = 8'hA5;
        #10 tx_start = 1'b1;
        #20 tx_start = 1'b0;
        #1000 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b tx_start=%b tx_data=%h tx_out=%b tx_busy=%b"", 
                 $time, clk, rst_n, tx_start, tx_data, tx_out, tx_busy);
    end
endmodule",True,117,True,True,True,True,0.9,True,12.324923753738403,17.558937788009644,"graph LR
    CLK[Clock] --> UART_TX
    RST[Reset] --> UART_TX
    DATA[8-bit Data Input] --> UART_TX
    BAUD_DIV[Baud Rate Divider] --> UART_TX

    subgraph UART_Transmitter
        IDLE_STATE(IDLE State) -->|Start Condition| START_STATE(START State)
        START_STATE -->|Send Start Bit(0)| DATA_STATE(DATA State)
        DATA_STATE -->|Transmit 8 Data Bits LSB-first| STOP_STATE(STOP State)
        STOP_STATE -->|Send Stop Bit(1)| IDLE_STATE
    end
    
    UART_TX( ) --> UART_Transmitter
    TX_OUT[Transmit Output] <-- UART_TX

    subgraph Testbench
        TB_CLK[Clock] --> TB_UART_TX
        TB_RST[Reset] --> TB_UART_TX
        TB_DATA[8-bit Test Data] --> TB_UART_TX
        TB_UART_TX --> TB_TX_OUT[Test Output]
    end

    UART_TX --> TB_UART_TX","`timescale 1ns/1ps

module uart_tx(
    input wire clk,
    input wire rst,
    input wire [7:0] data_in,
    input wire [15:0] baud_div,
    output reg tx_out
);

    reg [3:0] state;
    reg [3:0] bit_index;
    reg [15:0] baud_counter;
    reg [7:0] data_reg;

    localparam STATE_IDLE = 4'd0;
    localparam STATE_START = 4'd1;
    localparam STATE_DATA = 4'd2;
    localparam STATE_STOP = 4'd3;

    always @(posedge clk or posedge rst) begin
        if (rst) begin
            state <= STATE_IDLE;
            tx_out <= 1'b1;
            bit_index <= 4'd0;
            baud_counter <= 16'd0;
            data_reg <= 8'd0;
        end else begin
            case (state)
                STATE_IDLE: begin
                    tx_out <= 1'b1;
                    baud_counter <= 16'd0;
                    if (data_in != 8'b0) begin
                        state <= STATE_START;
                        data_reg <= data_in;
                    end
                end
                STATE_START: begin
                    if (baud_counter == baud_div) begin
                        baud_counter <= 16'd0;
                        tx_out <= 1'b0; // Start bit
                        state <= STATE_DATA;
                        bit_index <= 4'd0;
                    end else begin
                        baud_counter <= baud_counter + 1'b1;
                    end
                end
                STATE_DATA: begin
                    if (baud_counter == baud_div) begin
                        baud_counter <= 16'd0;
                        tx_out <= data_reg[bit_index];
                        if (bit_index == 4'd7) begin
                            state <= STATE_STOP;
                        end else begin
                            bit_index <= bit_index + 1'b1;
                        end
                    end else begin
                        baud_counter <= baud_counter + 1'b1;
                    end
                end
                STATE_STOP: begin
                    if (baud_counter == baud_div) begin
                        baud_counter <= 16'd0;
                        tx_out <= 1'b1; // Stop bit
                        state <= STATE_IDLE;
                    end else begin
                        baud_counter <= baud_counter + 1'b1;
                    end
                end
            endcase
        end
    end

endmodule


module uart_tx_tb;

    reg tb_clk;
    reg tb_rst;
    reg [7:0] tb_data;
    reg [15:0] tb_baud_div;
    wire tb_tx_out;

    uart_tx dut (
        .clk(tb_clk),
        .rst(tb_rst),
        .data_in(tb_data),
        .baud_div(tb_baud_div),
        .tx_out(tb_tx_out)
    );

    initial begin
        $dumpfile(""uart_tx_tb.vcd"");
        $dumpvars(0, uart_tx_tb);

        tb_clk = 1'b0;
        tb_rst = 1'b1;
        tb_data = 8'hA5;
        tb_baud_div = 16'd4;
        
        #20 tb_rst = 1'b0;
        #1000 $finish;
    end

    always #5 tb_clk = ~tb_clk;

endmodule",True,108,False,True,True,,0.0,,14.226836204528809,0.01615738868713379,"Design UART transmitter with states: IDLE, START, DATA, STOP. Protocol: START(0), 8 data bits LSB-first, STOP(1). Baud rate divider. Include testbench.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph LR
    CLK[Clock] --> UART_TX
    RST[Reset] --> UART_TX
    DATA[8-bit Data Input] --> UART_TX
    BAUD_DIV[Baud Rate Divider] --> UART_TX

    subgraph UART_Transmitter
        IDLE_STATE(IDLE State) -->|Start Condition| START_STATE(START State)
        START_STATE -->|Send Start Bit(0)| DATA_STATE(DATA State)
        DATA_STATE -->|Transmit 8 Data Bits LSB-first| STOP_STATE(STOP State)
        STOP_STATE -->|Send Stop Bit(1)| IDLE_STATE
    end
    
    UART_TX( ) --> UART_Transmitter
    TX_OUT[Transmit Output] <-- UART_TX

    subgraph Testbench
        TB_CLK[Clock] --> TB_UART_TX
        TB_RST[Reset] --> TB_UART_TX
        TB_DATA[8-bit Test Data] --> TB_UART_TX
        TB_UART_TX --> TB_TX_OUT[Test Output]
    end

    UART_TX --> TB_UART_TX
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module uart_tx(
    input wire clk,
    input wire rst,
    input wire [7:0] data_in,
    input wire [15:0] baud_div,
    output reg tx_out
);

    reg [3:0] state;
    reg [15:0] baud_counter;
    reg [3:0] bit_counter;
    reg [7:0] shift_reg;

    localparam IDLE_STATE = 4'b0000;
    localparam START_STATE = 4'b0001;
    localparam DATA_STATE = 4'b0010;
    localparam STOP_STATE = 4'b0011;

    always @(posedge clk or posedge rst) begin
        if (rst) begin
            state <= IDLE_STATE;
            tx_out <= 1'b1;
            baud_counter <= 16'b0;
            bit_counter <= 4'b0;
            shift_reg <= 8'b0;
        end else begin
            case (state)
                IDLE_STATE: begin
                    tx_out <= 1'b1;
                    if (/* Start condition */) begin
                        state <= START_STATE;
                        shift_reg <= data_in;
                        bit_counter <= 4'b0;
                    end
                end
                START_STATE: begin
                    if (baud_counter == baud_div) begin
                        baud_counter <= 16'b0;
                        tx_out <= 1'b0; // Start bit
                        state <= DATA_STATE;
                    end else begin
                        baud_counter <= baud_counter + 1'b1;
                    end
                end
                DATA_STATE: begin
                    if (baud_counter == baud_div) begin
                        baud_counter <= 16'b0;
                        tx_out <= shift_reg[0];
                        shift_reg <= shift_reg >> 1;
                        if (bit_counter == 4'd7) begin
                            state <= STOP_STATE;
                        end else begin
                            bit_counter <= bit_counter + 1'b1;
                        end
                    end else begin
                        baud_counter <= baud_counter + 1'b1;
                    end
                end
                STOP_STATE: begin
                    if (baud_counter == baud_div) begin
                        baud_counter <= 16'b0;
                        tx_out <= 1'b1; // Stop bit
                        state <= IDLE_STATE;
                    end else begin
                        baud_counter <= baud_counter + 1'b1;
                    end
                end
            endcase
        end
    end

endmodule

module testbench;
    reg tb_clk, tb_rst;
    reg [7:0] tb_data;
    reg [15:0] tb_baud_div;
    wire tb_tx_out;

    uart_tx tb_uart_tx (
        .clk(tb_clk),
        .rst(tb_rst),
        .data_in(tb_data),
        .baud_div(tb_baud_div),
        .tx_out(tb_tx_out)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        tb_clk = 1'b0;
        tb_rst = 1'b1;
        tb_data = 8'b10101010;
        tb_baud_div = 16'b0000000000001111;

        #20 tb_rst = 1'b0;
        #1000 $finish;
    end

    always #5 tb_clk = ~tb_clk;

    initial begin
        $monitor(""Time=%0t tb_clk=%b tb_rst=%b tb_data=%b tb_tx_out=%b"", 
                 $time, tb_clk, tb_rst, tb_data, tb_tx_out);
    end
endmodule",True,109,True,False,False,,0.0,,9.63186264038086,0.009946823120117188,prompt_only,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,CPU Component,complex,Create 8-register  8-bit register file with dual read ports and single write port. Include testbench with simultaneous operations.,claude,"`timescale 1ns/1ps

module register_file (
    input wire clk,
    input wire rst_n,
    input wire write_enable,
    input wire [2:0] write_addr,
    input wire [7:0] write_data,
    input wire [2:0] read_addr1,
    input wire [2:0] read_addr2,
    output reg [7:0] read_data1,
    output reg [7:0] read_data2
);

reg [7:0] registers [0:7];
integer i;

always @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
        for (i = 0; i < 8; i = i + 1)
            registers[i] <= 8'h00;
    end
    else if (write_enable)
        registers[write_addr] <= write_data;
end

always @(*) begin
    read_data1 = registers[read_addr1];
    read_data2 = registers[read_addr2];
end

endmodule

module testbench;
    reg clk;
    reg rst_n;
    reg write_enable;
    reg [2:0] write_addr;
    reg [7:0] write_data;
    reg [2:0] read_addr1;
    reg [2:0] read_addr2;
    wire [7:0] read_data1;
    wire [7:0] read_data2;

    register_file dut (
        .clk(clk),
        .rst_n(rst_n),
        .write_enable(write_enable),
        .write_addr(write_addr),
        .write_data(write_data),
        .read_addr1(read_addr1),
        .read_addr2(read_addr2),
        .read_data1(read_data1),
        .read_data2(read_data2)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 0;
        rst_n = 0;
        write_enable = 0;
        write_addr = 0;
        write_data = 0;
        read_addr1 = 0;
        read_addr2 = 0;

        #10 rst_n = 1;

        // Write some data
        #10 write_enable = 1;
        write_addr = 3'd0; write_data = 8'hAA;
        #10 write_addr = 3'd1; write_data = 8'hBB;
        #10 write_addr = 3'd2; write_data = 8'hCC;

        // Read while writing
        #10;
        write_addr = 3'd3; write_data = 8'hDD;
        read_addr1 = 3'd1;
        read_addr2 = 3'd2;

        #10 write_enable = 0;

        // Multiple reads
        #10 read_addr1 = 3'd0; read_addr2 = 3'd3;
        #10 read_addr1 = 3'd2; read_addr2 = 3'd1;

        #20 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t rd1=%h rd2=%h"", $time, read_data1, read_data2);
    end
endmodule",True,97,True,True,True,False,0.4,False,10.060570001602173,6.875430345535278,,,False,0,False,False,False,,0.0,,3.810168743133545,0.0,,,False,0,False,False,False,,0.0,,0.0,0.0,prompt_only,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,CPU Component,complex,Create 8-register  8-bit register file with dual read ports and single write port. Include testbench with simultaneous operations.,gpt-4o,"`timescale 1ns/1ps

module regfile(
    input wire clk,
    input wire rst_n,
    input wire [2:0] read_addr1,
    input wire [2:0] read_addr2,
    input wire [2:0] write_addr,
    input wire [7:0] write_data,
    input wire write_enable,
    output reg [7:0] read_data1,
    output reg [7:0] read_data2
);

    reg [7:0] registers [7:0];
    integer i;

    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            for (i = 1'b0; i < 8; i = i + 1)
                registers[i] <= 8'b00000000;
        end else if (write_enable) begin
            registers[write_addr] <= write_data;
        end
    end

    always @(*) begin
        read_data1 = registers[read_addr1];
        read_data2 = registers[read_addr2];
    end

endmodule

module testbench;
    reg clk, rst_n, write_enable;
    reg [2:0] read_addr1, read_addr2, write_addr;
    reg [7:0] write_data;
    wire [7:0] read_data1, read_data2;
    
    regfile dut (
        .clk(clk),
        .rst_n(rst_n),
        .read_addr1(read_addr1),
        .read_addr2(read_addr2),
        .write_addr(write_addr),
        .write_data(write_data),
        .write_enable(write_enable),
        .read_data1(read_data1),
        .read_data2(read_data2)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst_n = 1'b0;
        write_enable = 1'b0;
        read_addr1 = 3'b000;
        read_addr2 = 3'b001;
        write_addr = 3'b000;
        write_data = 8'b00000000;
        
        #20 rst_n = 1'b1;
        #10 write_enable = 1'b1; write_addr = 3'b001; write_data = 8'b11110000;
        #10 write_enable = 1'b0; read_addr1 = 3'b000; read_addr2 = 3'b001;
        #10 write_enable = 1'b1; write_addr = 3'b010; write_data = 8'b10101010;
        #10 write_enable = 1'b0; read_addr1 = 3'b010; read_addr2 = 3'b001;
        #50 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b write_enable=%b write_addr=%b write_data=%b read_addr1=%b read_data1=%b read_addr2=%b read_data2=%b"", 
                 $time, clk, rst_n, write_enable, write_addr, write_data, read_addr1, read_data1, read_addr2, read_data2);
    end
endmodule",True,78,True,True,True,True,0.75,True,11.043756008148193,7.27680516242981,"graph TD
    CLK[Clock] --> [[Register File]]
    RST[Reset] --> [[Register File]]
    
    writeData[Write Data 8-bit] --> ((Write Port))
    writeAddr[Write Address 3-bit] --> ((Write Port))
    writeEnable[Write Enable] --> ((Write Port))
    ((Write Port)) --> [[Register File]]
    
    readAddr1[Read Address 1 3-bit] --> ((Read Port 1))
    ((Read Port 1)) --> readData1[Read Data 1 8-bit]
    ((Read Port 1)) --> [[Register File]]
    
    readAddr2[Read Address 2 3-bit] --> ((Read Port 2))
    ((Read Port 2)) --> readData2[Read Data 2 8-bit]
    ((Read Port 2)) --> [[Register File]]
    
    subgraph Testbench
        CLK --> TB[Simultaneous Operations Test]
        RST --> TB
        TB --> writeData
        TB --> writeAddr
        TB --> writeEnable
        TB --> readAddr1
        TB --> readAddr2
    end","`timescale 1ns/1ps

module register_file(
    input wire clk,
    input wire rst_n,
    input wire [7:0] write_data,
    input wire [2:0] write_addr,
    input wire write_enable,
    input wire [2:0] read_addr1,
    output reg [7:0] read_data1,
    input wire [2:0] read_addr2,
    output reg [7:0] read_data2
);
    reg [7:0] reg_file [0:7];

    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            reg_file[0] <= 8'b0;
            reg_file[1] <= 8'b0;
            reg_file[2] <= 8'b0;
            reg_file[3] <= 8'b0;
            reg_file[4] <= 8'b0;
            reg_file[5] <= 8'b0;
            reg_file[6] <= 8'b0;
            reg_file[7] <= 8'b0;
        end else if (write_enable) begin
            reg_file[write_addr] <= write_data;
        end
    end

    always @(posedge clk) begin
        read_data1 <= reg_file[read_addr1];
        read_data2 <= reg_file[read_addr2];
    end

endmodule

module testbench;
    reg clk, rst_n, write_enable;
    reg [7:0] write_data;
    reg [2:0] write_addr;
    reg [2:0] read_addr1;
    reg [2:0] read_addr2;
    wire [7:0] read_data1;
    wire [7:0] read_data2;

    register_file dut (
        .clk(clk),
        .rst_n(rst_n),
        .write_data(write_data),
        .write_addr(write_addr),
        .write_enable(write_enable),
        .read_addr1(read_addr1),
        .read_data1(read_data1),
        .read_addr2(read_addr2),
        .read_data2(read_data2)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 1'b0;
        rst_n = 1'b0;
        write_enable = 1'b0;
        write_data = 8'b0;
        write_addr = 3'b0;
        read_addr1 = 3'b0;
        read_addr2 = 3'b0;

        #20 rst_n = 1'b1;
        #10 write_enable = 1'b1; write_data = 8'hAA; write_addr = 3'b001;
        #10 write_enable = 1'b0; read_addr1 = 3'b001; read_addr2 = 3'b001;
        #50 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b write_enable=%b write_addr=%b write_data=%h read_addr1=%b read_data1=%h read_addr2=%b read_data2=%h"",
                 $time, clk, rst_n, write_enable, write_addr, write_data, read_addr1, read_data1, read_addr2, read_data2);
    end
endmodule",True,83,True,True,True,True,0.7,True,13.31524395942688,12.866953134536743,"Create 8-register  8-bit register file with dual read ports and single write port. Include testbench with simultaneous operations.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph TD
    CLK[Clock] --> [[Register File]]
    RST[Reset] --> [[Register File]]
    
    writeData[Write Data 8-bit] --> ((Write Port))
    writeAddr[Write Address 3-bit] --> ((Write Port))
    writeEnable[Write Enable] --> ((Write Port))
    ((Write Port)) --> [[Register File]]
    
    readAddr1[Read Address 1 3-bit] --> ((Read Port 1))
    ((Read Port 1)) --> readData1[Read Data 1 8-bit]
    ((Read Port 1)) --> [[Register File]]
    
    readAddr2[Read Address 2 3-bit] --> ((Read Port 2))
    ((Read Port 2)) --> readData2[Read Data 2 8-bit]
    ((Read Port 2)) --> [[Register File]]
    
    subgraph Testbench
        CLK --> TB[Simultaneous Operations Test]
        RST --> TB
        TB --> writeData
        TB --> writeAddr
        TB --> writeEnable
        TB --> readAddr1
        TB --> readAddr2
    end
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module register_file(
    input wire clk,
    input wire rst,
    input wire [2:0] writeAddr,
    input wire [7:0] writeData,
    input wire writeEnable,
    input wire [2:0] readAddr1,
    output reg [7:0] readData1,
    input wire [2:0] readAddr2,
    output reg [7:0] readData2
);

    reg [7:0] registers [7:0];

    always @(posedge clk or posedge rst) begin
        if (rst) begin
            registers[0] <= 8'b0;
            registers[1] <= 8'b0;
            registers[2] <= 8'b0;
            registers[3] <= 8'b0;
            registers[4] <= 8'b0;
            registers[5] <= 8'b0;
            registers[6] <= 8'b0;
            registers[7] <= 8'b0;
        end else if (writeEnable) begin
            registers[writeAddr] <= writeData;
        end
    end

    always @(*) begin
        readData1 = registers[readAddr1];
        readData2 = registers[readAddr2];
    end

endmodule

module testbench;
    reg clk;
    reg rst;
    reg [2:0] writeAddr;
    reg [7:0] writeData;
    reg writeEnable;
    reg [2:0] readAddr1;
    wire [7:0] readData1;
    reg [2:0] readAddr2;
    wire [7:0] readData2;

    register_file dut (
        .clk(clk),
        .rst(rst),
        .writeAddr(writeAddr),
        .writeData(writeData),
        .writeEnable(writeEnable),
        .readAddr1(readAddr1),
        .readData1(readData1),
        .readAddr2(readAddr2),
        .readData2(readData2)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst = 1'b1;
        writeEnable = 1'b0;
        #10 rst = 1'b0;
        
        // Test writing to the register file
        writeData = 8'b10101010;
        writeAddr = 3'b001;
        writeEnable = 1'b1;
        #10 writeEnable = 1'b0;
        
        // Test reading from the register file
        readAddr1 = 3'b001;
        readAddr2 = 3'b000;
        #10;
        
        // Test simultaneous operations
        writeData = 8'b11110000;
        writeAddr = 3'b010;
        writeEnable = 1'b1;
        readAddr1 = 3'b010;
        readAddr2 = 3'b001;
        #10 writeEnable = 1'b0;
        
        #50 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t clk=%b rst=%b writeEnable=%b writeAddr=%d writeData=%b readAddr1=%d readData1=%b readAddr2=%d readData2=%b"", 
                 $time, clk, rst, writeEnable, writeAddr, writeData, readAddr1, readData1, readAddr2, readData2);
    end
endmodule",True,99,True,True,True,True,0.7,True,10.849497079849243,8.530982494354248,prompt_only,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,Advanced Sequential,complex,"Design 8-bit resolution PWM generator with configurable duty cycle. Include testbench with duty cycles: 0%, 25%, 50%, 75%, 100%.",claude,"`timescale 1ns/1ps

module pwm_gen(
    input wire clk,
    input wire rst_n,
    input wire [7:0] duty_cycle,
    output reg pwm_out
);

reg [7:0] counter;

always @(posedge clk or negedge rst_n) begin
    if (!rst_n)
        counter <= 8'h00;
    else
        counter <= counter + 1'b1;
end

always @(posedge clk or negedge rst_n) begin
    if (!rst_n)
        pwm_out <= 1'b0;
    else
        pwm_out <= (counter < duty_cycle);
end

endmodule

module testbench;
    reg clk, rst_n;
    reg [7:0] duty_cycle;
    wire pwm_out;
    
    pwm_gen dut (
        .clk(clk),
        .rst_n(rst_n),
        .duty_cycle(duty_cycle),
        .pwm_out(pwm_out)
    );
    
    initial begin
        $dumpfile(""pwm.vcd"");
        $dumpvars(0, testbench);
        
        clk = 0;
        rst_n = 0;
        duty_cycle = 8'h00;
        
        #20 rst_n = 1;
        
        // Test 0% duty cycle
        #100 duty_cycle = 8'h00;
        
        // Test 25% duty cycle
        #512 duty_cycle = 8'h40;
        
        // Test 50% duty cycle
        #512 duty_cycle = 8'h80;
        
        // Test 75% duty cycle
        #512 duty_cycle = 8'hC0;
        
        // Test 100% duty cycle
        #512 duty_cycle = 8'hFF;
        
        #512 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t rst_n=%b duty_cycle=%d pwm_out=%b"",
                 $time, rst_n, duty_cycle, pwm_out);
    end
endmodule",True,74,True,True,True,,0.0,,6.859354496002197,0.015291929244995117,"graph TD
    CLK[Clock] --> CNT((8-bit Counter))
    RST[Reset] --> CNT
    
    DC[[Duty Cycle Register]] --> COMP((Comparator))
    CNT --> COMP
    
    CFG[Config Input] --> DC
    
    COMP --> PWM_OUT[PWM Output]
    
    TB_DC[[Test Values:<br>0%<br>25%<br>50%<br>75%<br>100%]] --> DC
    
    CLK --> COMP
    RST --> COMP
    
    CNT --> OVF{Overflow}
    OVF --> CNT
    
    DC_VAL[8-bit Value] --> DC
    EN[Enable] --> CNT
    EN --> COMP","`timescale 1ns/1ps

module pwm_gen(
    input wire clk,
    input wire rst_n,
    input wire enable,
    input wire [7:0] duty_cycle,
    output reg pwm_out
);

reg [7:0] counter;
wire overflow;

assign overflow = (counter == 8'hFF);

always @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
        counter <= 8'h00;
        pwm_out <= 1'b0;
    end
    else if (enable) begin
        counter <= overflow ? 8'h00 : counter + 1'b1;
        pwm_out <= (counter < duty_cycle);
    end
end

endmodule

module testbench;
    reg clk, rst_n, enable;
    reg [7:0] duty_cycle;
    wire pwm_out;
    
    pwm_gen dut (
        .clk(clk),
        .rst_n(rst_n),
        .enable(enable),
        .duty_cycle(duty_cycle),
        .pwm_out(pwm_out)
    );
    
    initial begin
        $dumpfile(""pwm.vcd"");
        $dumpvars(0, testbench);
        
        clk = 0;
        rst_n = 0;
        enable = 0;
        duty_cycle = 8'h00;
        
        #20 rst_n = 1;
        #10 enable = 1;
        
        // Test different duty cycles
        duty_cycle = 8'h00;  // 0%
        #512;
        duty_cycle = 8'h40;  // 25%
        #512;
        duty_cycle = 8'h80;  // 50%
        #512;
        duty_cycle = 8'hC0;  // 75%
        #512;
        duty_cycle = 8'hFF;  // 100%
        #512;
        
        #100 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t duty_cycle=%d%% pwm_out=%b"", 
                 $time, (duty_cycle * 100) / 255, pwm_out);
    end
endmodule",True,75,True,True,True,,0.0,,10.71675157546997,0.014861345291137695,"Design 8-bit resolution PWM generator with configurable duty cycle. Include testbench with duty cycles: 0%, 25%, 50%, 75%, 100%.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph TD
    CLK[Clock] --> CNT((8-bit Counter))
    RST[Reset] --> CNT
    
    DC[[Duty Cycle Register]] --> COMP((Comparator))
    CNT --> COMP
    
    CFG[Config Input] --> DC
    
    COMP --> PWM_OUT[PWM Output]
    
    TB_DC[[Test Values:<br>0%<br>25%<br>50%<br>75%<br>100%]] --> DC
    
    CLK --> COMP
    RST --> COMP
    
    CNT --> OVF{Overflow}
    OVF --> CNT
    
    DC_VAL[8-bit Value] --> DC
    EN[Enable] --> CNT
    EN --> COMP
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module pwm_generator(
    input wire clk,
    input wire rst_n,
    input wire enable,
    input wire [7:0] duty_cycle,
    output reg pwm_out
);

reg [7:0] counter;

always @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
        counter <= 8'h00;
    end else if (enable) begin
        counter <= counter + 1'b1;
    end
end

always @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
        pwm_out <= 1'b0;
    end else if (enable) begin
        pwm_out <= (counter < duty_cycle);
    end
end

endmodule

module testbench;
    reg clk;
    reg rst_n;
    reg enable;
    reg [7:0] duty_cycle;
    wire pwm_out;

    pwm_generator dut (
        .clk(clk),
        .rst_n(rst_n),
        .enable(enable),
        .duty_cycle(duty_cycle),
        .pwm_out(pwm_out)
    );

    initial begin
        $dumpfile(""pwm.vcd"");
        $dumpvars(0, testbench);

        clk = 1'b0;
        rst_n = 1'b0;
        enable = 1'b0;
        duty_cycle = 8'h00;

        #20 rst_n = 1'b1;
        #10 enable = 1'b1;

        // Test 0% duty cycle
        duty_cycle = 8'd0;
        #512;

        // Test 25% duty cycle
        duty_cycle = 8'd64;
        #512;

        // Test 50% duty cycle
        duty_cycle = 8'd128;
        #512;

        // Test 75% duty cycle
        duty_cycle = 8'd192;
        #512;

        // Test 100% duty cycle
        duty_cycle = 8'd255;
        #512;

        $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t rst_n=%b enable=%b duty_cycle=%d pwm_out=%b"",
                 $time, rst_n, enable, duty_cycle, pwm_out);
    end

endmodule",True,88,True,True,True,,0.0,,7.263159513473511,0.017310142517089844,prompt_only,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,Advanced Sequential,complex,"Design 8-bit resolution PWM generator with configurable duty cycle. Include testbench with duty cycles: 0%, 25%, 50%, 75%, 100%.",gpt-4o,"`timescale 1ns/1ps

module pwm_generator(
    input wire clk,
    input wire rst_n,
    input wire [7:0] duty_cycle,
    output reg pwm_out
);

reg [7:0] counter;

always @(posedge clk or negedge rst_n) begin
    if (!rst_n)
        counter <= 8'b00000000;
    else
        counter <= counter + 1'b1;
end

always @(posedge clk or negedge rst_n) begin
    if (!rst_n)
        pwm_out <= 1'b0;
    else
        pwm_out <= (counter < duty_cycle) ? 1'b1 : 1'b0;
end

endmodule

module testbench;
    reg clk, rst_n;
    reg [7:0] duty_cycle;
    wire pwm_out;

    pwm_generator dut (
        .clk(clk),
        .rst_n(rst_n),
        .duty_cycle(duty_cycle),
        .pwm_out(pwm_out)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 1'b0;
        rst_n = 1'b0;
        duty_cycle = 8'd0;

        #20 rst_n = 1'b1;
        #10 duty_cycle = 8'd0;     // 0%
        #100 duty_cycle = 8'd64;   // 25%
        #100 duty_cycle = 8'd128;  // 50%
        #100 duty_cycle = 8'd192;  // 75%
        #100 duty_cycle = 8'd255;  // 100%
        #100 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b duty_cycle=%d pwm_out=%b"", 
                 $time, clk, rst_n, duty_cycle, pwm_out);
    end
endmodule",True,63,True,True,True,False,0.3,False,4.971827983856201,8.998534917831421,"graph TD
    CLK[Clock] --> CNT(Counter)
    RST[Reset] --> CNT
    DC[Duty Cycle Input] --> CMP(Comparator)
    CNT --> CMP
    CMP --> PWM[Output PWM Signal]
    subgraph Testbench
        TB0[Testbench 0%] --> DC
        TB25[Testbench 25%] --> DC
        TB50[Testbench 50%] --> DC
        TB75[Testbench 75%] --> DC
        TB100[Testbench 100%] --> DC
    end","`timescale 1ns/1ps

module pwm_generator(
    input wire clk,
    input wire rst_n,
    input wire [7:0] duty_cycle,
    output wire pwm_out
);

reg [7:0] counter;

// Counter logic
always @(posedge clk or negedge rst_n) begin
    if (!rst_n)
        counter <= 8'b00000000;
    else
        counter <= counter + 1'b1;
end

// Comparator logic
assign pwm_out = (counter < duty_cycle) ? 1'b1 : 1'b0;

endmodule

module testbench;
    reg clk, rst_n;
    reg [7:0] duty_cycle;
    wire pwm_out;
    
    pwm_generator dut (
        .clk(clk),
        .rst_n(rst_n),
        .duty_cycle(duty_cycle),
        .pwm_out(pwm_out)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst_n = 1'b0;
        duty_cycle = 8'd0;
        
        #20 rst_n = 1'b1;
        #10 duty_cycle = 8'd0;    // Testbench 0%
        #100 duty_cycle = 8'd64;  // Testbench 25%
        #100 duty_cycle = 8'd128; // Testbench 50%
        #100 duty_cycle = 8'd192; // Testbench 75%
        #100 duty_cycle = 8'd255; // Testbench 100%
        #50 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b duty_cycle=%d pwm_out=%b"", 
                 $time, clk, rst_n, duty_cycle, pwm_out);
    end
endmodule",True,60,True,True,True,False,0.4,False,7.439290285110474,8.862072229385376,"Design 8-bit resolution PWM generator with configurable duty cycle. Include testbench with duty cycles: 0%, 25%, 50%, 75%, 100%.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph TD
    CLK[Clock] --> CNT(Counter)
    RST[Reset] --> CNT
    DC[Duty Cycle Input] --> CMP(Comparator)
    CNT --> CMP
    CMP --> PWM[Output PWM Signal]
    subgraph Testbench
        TB0[Testbench 0%] --> DC
        TB25[Testbench 25%] --> DC
        TB50[Testbench 50%] --> DC
        TB75[Testbench 75%] --> DC
        TB100[Testbench 100%] --> DC
    end
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module pwm_generator(
    input wire clk,
    input wire rst,
    input wire [7:0] duty_cycle,
    output reg pwm_out
);

reg [7:0] counter;

always @(posedge clk or posedge rst) begin
    if (rst)
        counter <= 8'b00000000;
    else
        counter <= counter + 1'b1;
end

always @(posedge clk or posedge rst) begin
    if (rst)
        pwm_out <= 1'b0;
    else
        pwm_out <= (counter < duty_cycle) ? 1'b1 : 1'b0;
end

endmodule

module testbench;
    reg clk;
    reg rst;
    reg [7:0] duty_cycle;
    wire pwm_out;

    pwm_generator dut (
        .clk(clk),
        .rst(rst),
        .duty_cycle(duty_cycle),
        .pwm_out(pwm_out)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 1'b0;
        rst = 1'b1;
        duty_cycle = 8'b00000000;

        #20 rst = 1'b0;

        #100 duty_cycle = 8'd0;     // 0%
        #100 duty_cycle = 8'd64;    // 25%
        #100 duty_cycle = 8'd128;   // 50%
        #100 duty_cycle = 8'd192;   // 75%
        #100 duty_cycle = 8'd255;   // 100%
        #100 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t clk=%b rst=%b duty_cycle=%d pwm_out=%b"",
                 $time, clk, rst, duty_cycle, pwm_out);
    end
endmodule",True,65,True,True,True,False,0.3,False,5.585048198699951,7.992940902709961,tie,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,Protocol,complex,"Design SPI master supporting mode 0 (CPOL=0, CPHA=0). Include SCLK generation, MOSI/MISO handling. Include testbench.",claude,"`timescale 1ns/1ps

module spi_master (
    input wire clk,
    input wire rst_n,
    input wire [7:0] data_in,
    input wire start,
    output reg [7:0] data_out,
    output reg sclk,
    output reg mosi,
    input wire miso,
    output reg busy,
    output reg done
);

reg [3:0] bit_cnt;
reg [7:0] shift_reg;
reg spi_clk_en;

// Clock divider for SCLK
reg [2:0] clk_div;
always @(posedge clk or negedge rst_n) begin
    if (!rst_n)
        clk_div <= 3'b000;
    else
        clk_div <= clk_div + 1'b1;
end

always @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
        sclk <= 1'b0;
        mosi <= 1'b0;
        busy <= 1'b0;
        done <= 1'b0;
        bit_cnt <= 4'h0;
        shift_reg <= 8'h00;
        data_out <= 8'h00;
        spi_clk_en <= 1'b0;
    end
    else begin
        if (start && !busy) begin
            busy <= 1'b1;
            shift_reg <= data_in;
            bit_cnt <= 4'h0;
            done <= 1'b0;
            spi_clk_en <= 1'b1;
        end
        else if (busy) begin
            if (clk_div == 3'b000) begin
                if (bit_cnt == 4'h8) begin
                    busy <= 1'b0;
                    done <= 1'b1;
                    spi_clk_en <= 1'b0;
                end
                else begin
                    sclk <= ~sclk;
                    if (sclk) begin
                        bit_cnt <= bit_cnt + 1'b1;
                        shift_reg <= {shift_reg[6:0], miso};
                    end
                    else begin
                        mosi <= shift_reg[7];
                    end
                end
            end
        end
        
        if (done)
            data_out <= shift_reg;
    end
end

endmodule

module testbench;
    reg clk;
    reg rst_n;
    reg [7:0] data_in;
    reg start;
    wire [7:0] data_out;
    wire sclk;
    wire mosi;
    reg miso;
    wire busy;
    wire done;

    spi_master dut (
        .clk(clk),
        .rst_n(rst_n),
        .data_in(data_in),
        .start(start),
        .data_out(data_out),
        .sclk(sclk),
        .mosi(mosi),
        .miso(miso),
        .busy(busy),
        .done(done)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 0;
        rst_n = 0;
        data_in = 0;
        start = 0;
        miso = 0;

        #20 rst_n = 1;
        #20 data_in = 8'hA5;
        #10 start = 1;
        #10 start = 0;
        
        // Simulate MISO input
        repeat(8) begin
            #32 miso = ~miso;
        end

        #200 data_in = 8'h5A;
        #10 start = 1;
        #10 start = 0;

        repeat(8) begin
            #32 miso = ~miso;
        end

        #200 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t rst_n=%b start=%b data_in=%h data_out=%h busy=%b done=%b"",
                 $time, rst_n, start, data_in, data_out, busy, done);
    end
endmodule",True,137,True,True,True,True,0.9,True,14.46990156173706,8.148719787597656,"graph TD
    CLK[Clock Input] --> CLKGEN(Clock Generator)
    RST[Reset] --> CLKGEN
    CLKGEN --> SCLK[SCLK Output]
    
    TXDATA[[TX Data Register]] --> TXSHIFT(TX Shift Register)
    CLK --> TXSHIFT
    RST --> TXSHIFT
    TXSHIFT --> MOSI[MOSI Output]
    
    MISO[MISO Input] --> RXSHIFT(RX Shift Register)
    CLK --> RXSHIFT
    RST --> RXSHIFT
    RXSHIFT --> RXDATA[[RX Data Register]]
    
    START[Start Signal] --> CTRL(Control Logic)
    CLK --> CTRL
    RST --> CTRL
    CTRL --> BUSY[Busy Signal]
    
    CTRL --> CLKGEN
    CTRL --> TXSHIFT
    CTRL --> RXSHIFT
    
    BITCNT[[Bit Counter]] --> CTRL
    CLK --> BITCNT
    RST --> BITCNT
    
    CS[Chip Select] --> CTRL
    CTRL --> CSout[CS Output]
    
    TB{Testbench}
    TB --> START
    TB --> TXDATA
    TB --> CS
    RXDATA --> TB
    BUSY --> TB","`timescale 1ns/1ps

module spi_controller (
    input wire clk,
    input wire rst,
    input wire start,
    input wire cs,
    input wire miso,
    input wire [7:0] tx_data,
    output reg sclk,
    output reg mosi,
    output reg cs_out,
    output reg busy,
    output reg [7:0] rx_data
);

reg [2:0] bit_count;
reg [7:0] tx_shift;
reg [7:0] rx_shift;
reg clk_en;
reg shift_en;

always @(posedge clk or posedge rst) begin
    if (rst) begin
        sclk <= 1'b0;
        clk_en <= 1'b0;
    end else if (start) begin
        clk_en <= 1'b1;
    end else if (bit_count == 3'b111) begin
        clk_en <= 1'b0;
    end else if (clk_en) begin
        sclk <= ~sclk;
    end
end

always @(posedge clk or posedge rst) begin
    if (rst) begin
        bit_count <= 3'b000;
        busy <= 1'b0;
        cs_out <= 1'b1;
    end else if (start) begin
        bit_count <= 3'b000;
        busy <= 1'b1;
        cs_out <= cs;
    end else if (sclk && bit_count != 3'b111) begin
        bit_count <= bit_count + 1'b1;
    end else if (bit_count == 3'b111) begin
        busy <= 1'b0;
        cs_out <= 1'b1;
    end
end

always @(posedge clk or posedge rst) begin
    if (rst) begin
        tx_shift <= 8'h00;
        mosi <= 1'b0;
    end else if (start) begin
        tx_shift <= tx_data;
        mosi <= tx_data[7];
    end else if (sclk) begin
        tx_shift <= {tx_shift[6:0], 1'b0};
        mosi <= tx_shift[6];
    end
end

always @(posedge clk or posedge rst) begin
    if (rst) begin
        rx_shift <= 8'h00;
        rx_data <= 8'h00;
    end else if (!sclk) begin
        rx_shift <= {rx_shift[6:0], miso};
    end else if (bit_count == 3'b111) begin
        rx_data <= rx_shift;
    end
end

endmodule

module testbench;
    reg clk, rst, start, cs, miso;
    reg [7:0] tx_data;
    wire sclk, mosi, cs_out, busy;
    wire [7:0] rx_data;

    spi_controller dut (
        .clk(clk),
        .rst(rst),
        .start(start),
        .cs(cs),
        .miso(miso),
        .tx_data(tx_data),
        .sclk(sclk),
        .mosi(mosi),
        .cs_out(cs_out),
        .busy(busy),
        .rx_data(rx_data)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 1'b0;
        rst = 1'b1;
        start = 1'b0;
        cs = 1'b1;
        miso = 1'b0;
        tx_data = 8'h00;

        #20 rst = 1'b0;
        #10 tx_data = 8'hA5;
        #10 cs = 1'b0;
        #10 start = 1'b1;
        #10 start = 1'b0;
        
        #200;
        
        tx_data = 8'h5A;
        #10 start = 1'b1;
        #10 start = 1'b0;
        
        #200 $finish;
    end

    always #5 clk = ~clk;
    always #10 miso = ~miso;

    initial begin
        $monitor(""Time=%0t rst=%b start=%b cs=%b busy=%b tx_data=%h rx_data=%h"",
                 $time, rst, start, cs, busy, tx_data, rx_data);
    end
endmodule",True,132,True,True,True,True,0.9,True,18.065239191055298,7.857707738876343,"Design SPI master supporting mode 0 (CPOL=0, CPHA=0). Include SCLK generation, MOSI/MISO handling. Include testbench.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph TD
    CLK[Clock Input] --> CLKGEN(Clock Generator)
    RST[Reset] --> CLKGEN
    CLKGEN --> SCLK[SCLK Output]
    
    TXDATA[[TX Data Register]] --> TXSHIFT(TX Shift Register)
    CLK --> TXSHIFT
    RST --> TXSHIFT
    TXSHIFT --> MOSI[MOSI Output]
    
    MISO[MISO Input] --> RXSHIFT(RX Shift Register)
    CLK --> RXSHIFT
    RST --> RXSHIFT
    RXSHIFT --> RXDATA[[RX Data Register]]
    
    START[Start Signal] --> CTRL(Control Logic)
    CLK --> CTRL
    RST --> CTRL
    CTRL --> BUSY[Busy Signal]
    
    CTRL --> CLKGEN
    CTRL --> TXSHIFT
    CTRL --> RXSHIFT
    
    BITCNT[[Bit Counter]] --> CTRL
    CLK --> BITCNT
    RST --> BITCNT
    
    CS[Chip Select] --> CTRL
    CTRL --> CSout[CS Output]
    
    TB{Testbench}
    TB --> START
    TB --> TXDATA
    TB --> CS
    RXDATA --> TB
    BUSY --> TB
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module spi_master (
    input wire clk,
    input wire rst,
    input wire start,
    input wire cs,
    input wire [7:0] tx_data,
    input wire miso,
    output reg mosi,
    output reg sclk,
    output reg cs_out,
    output reg busy,
    output reg [7:0] rx_data
);

reg [3:0] bit_counter;
reg [7:0] tx_shift_reg;
reg [7:0] rx_shift_reg;
reg sclk_en;

// Clock generator
always @(posedge clk or posedge rst) begin
    if (rst)
        sclk <= 1'b0;
    else if (sclk_en)
        sclk <= ~sclk;
end

// Control logic
reg [2:0] state;
parameter IDLE = 3'b000;
parameter SETUP = 3'b001;
parameter TRANSFER = 3'b010;
parameter FINISH = 3'b011;

always @(posedge clk or posedge rst) begin
    if (rst) begin
        state <= IDLE;
        busy <= 1'b0;
        sclk_en <= 1'b0;
        bit_counter <= 4'd0;
        cs_out <= 1'b1;
    end else begin
        case (state)
            IDLE: begin
                if (start && !cs) begin
                    state <= SETUP;
                    busy <= 1'b1;
                    cs_out <= 1'b0;
                end
            end
            
            SETUP: begin
                sclk_en <= 1'b1;
                tx_shift_reg <= tx_data;
                state <= TRANSFER;
            end
            
            TRANSFER: begin
                if (bit_counter == 4'd8) begin
                    state <= FINISH;
                    sclk_en <= 1'b0;
                end
            end
            
            FINISH: begin
                busy <= 1'b0;
                cs_out <= 1'b1;
                state <= IDLE;
            end
        endcase
    end
end

// TX shift register
always @(posedge clk or posedge rst) begin
    if (rst) begin
        mosi <= 1'b0;
        tx_shift_reg <= 8'd0;
    end else if (state == TRANSFER && !sclk) begin
        mosi <= tx_shift_reg[7];
        tx_shift_reg <= {tx_shift_reg[6:0], 1'b0};
    end
end

// RX shift register
always @(posedge clk or posedge rst) begin
    if (rst) begin
        rx_shift_reg <= 8'd0;
        rx_data <= 8'd0;
    end else if (state == TRANSFER && sclk) begin
        rx_shift_reg <= {rx_shift_reg[6:0], miso};
        if (bit_counter == 4'd8)
            rx_data <= {rx_shift_reg[6:0], miso};
    end
end

// Bit counter
always @(posedge clk or posedge rst) begin
    if (rst)
        bit_counter <= 4'd0;
    else if (state == SETUP)
        bit_counter <= 4'd0;
    else if (state == TRANSFER && !sclk)
        bit_counter <= bit_counter + 1'b1;
end

endmodule

module testbench;
    reg clk;
    reg rst;
    reg start;
    reg cs;
    reg [7:0] tx_data;
    reg miso;
    wire mosi;
    wire sclk;
    wire cs_out;
    wire busy;
    wire [7:0] rx_data;

    spi_master dut (
        .clk(clk),
        .rst(rst),
        .start(start),
        .cs(cs),
        .tx_data(tx_data),
        .miso(miso),
        .mosi(mosi),
        .sclk(sclk),
        .cs_out(cs_out),
        .busy(busy),
        .rx_data(rx_data)
    );

    initial begin
        $dumpfile(""spi.vcd"");
        $dumpvars(0, testbench);

        clk = 1'b0;
        rst = 1'b1;
        start = 1'b0;
        cs = 1'b1;
        tx_data = 8'h00;
        miso = 1'b0;

        #20 rst = 1'b0;
        #10 cs = 1'b0;
        tx_data = 8'hA5;
        start = 1'b1;
        #10 start = 1'b0;

        // Generate test MISO data
        repeat(8) begin
            #20 miso = ~miso;
        end

        #100;
        
        // Second transfer
        tx_data = 8'h5A;
        start = 1'b1;
        #10 start = 1'b0;

        repeat(8) begin
            #20 miso = ~miso;
        end

        #100 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t rst=%b start=%b cs=%b tx_data=%h rx_data=%h busy=%b"",
                 $time, rst, start, cs, tx_data, rx_data, busy);
    end
endmodule",True,180,True,True,True,,0.0,,16.903194904327393,0.02045130729675293,prompt_only,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,Protocol,complex,"Design SPI master supporting mode 0 (CPOL=0, CPHA=0). Include SCLK generation, MOSI/MISO handling. Include testbench.",gpt-4o,"`timescale 1ns/1ps

module spi_master(
    input wire clk,
    input wire rst_n,
    input wire enable,
    input wire mosi,
    output reg miso,
    output reg sclk,
    output reg [7:0] data_out
);

reg [2:0] bit_count;
reg [7:0] shift_reg;

always @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
        bit_count <= 3'b000;
        shift_reg <= 8'b00000000;
        sclk <= 1'b0;
        miso <= 1'b0;
    end else if (enable) begin
        sclk <= ~sclk;
        if (sclk) begin
            shift_reg <= {shift_reg[6:0], mosi};
            bit_count <= bit_count + 1'b1;
            if (bit_count == 3'b111) begin
                data_out <= shift_reg;
                bit_count <= 3'b000;
            end
        end
    end
end

endmodule

module testbench;
    reg clk;
    reg rst_n;
    reg enable;
    reg mosi;
    wire miso;
    wire sclk;
    wire [7:0] data_out;

    spi_master dut (
        .clk(clk),
        .rst_n(rst_n),
        .enable(enable),
        .mosi(mosi),
        .miso(miso),
        .sclk(sclk),
        .data_out(data_out)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 1'b0;
        rst_n = 1'b0;
        enable = 1'b0;
        mosi = 1'b0;

        #20 rst_n = 1'b1;
        #10 enable = 1'b1;
        #80 mosi = 1'b1; // Sending a sequence of bits
        #10 mosi = 1'b0;
        #10 mosi = 1'b1;
        #10 mosi = 1'b0;
        #10 mosi = 1'b1;
        #10 mosi = 1'b0;
        #10 mosi = 1'b1;
        #10 mosi = 1'b0;
        #10 mosi = 1'b1;
        #20 enable = 1'b0;
        #20 rst_n = 1'b0;
        #20 rst_n = 1'b1;
        #50 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b enable=%b mosi=%b sclk=%b miso=%b data_out=%b"", 
                 $time, clk, rst_n, enable, mosi, sclk, miso, data_out);
    end
endmodule",True,88,True,True,True,True,0.9,True,5.537526369094849,12.775567770004272,"graph TD
    CLK[Clock] --> SCLK_GEN(SCLK Generation)
    RST[Reset] --> SPI_MASTER(SPI Master)
    SPI_MASTER --> SCLK_GEN
    SCLK_GEN --> SCLK[SCLK Output]
    MOSI_IN[MOSI Input] --> SPI_MASTER
    SPI_MASTER --> MOSI_OUT[MOSI Output]
    MISO_IN[MISO Input] --> SPI_MASTER
    SPI_MASTER --> MISO_OUT[MISO Output]
    TESTBENCH[Testbench]
    TESTBENCH --> SPI_MASTER
    TESTBENCH --> MOSI_IN
    TESTBENCH --> MISO_IN
    SCLK --> TESTBENCH
    MOSI_OUT --> TESTBENCH
    MISO_OUT --> TESTBENCH","`timescale 1ns/1ps

module spi_master(
    input wire clk,
    input wire rst,
    input wire mosi_in,
    input wire miso_in,
    output reg mosi_out,
    output reg miso_out
);

    reg mosi_reg, miso_reg;

    always @(posedge clk or posedge rst) begin
        if (rst) begin
            mosi_reg <= 1'b0;
            miso_reg <= 1'b0;
        end else begin
            mosi_reg <= mosi_in;
            miso_reg <= miso_in;
        end
    end

    always @(posedge clk) begin
        mosi_out <= mosi_reg;
        miso_out <= miso_reg;
    end

endmodule

module sclk_gen(
    input wire clk,
    input wire rst,
    output reg sclk
);

    always @(posedge clk or posedge rst) begin
        if (rst)
            sclk <= 1'b0;
        else
            sclk <= ~sclk;
    end

endmodule

module testbench;
    reg clk, rst;
    reg mosi_in, miso_in;
    wire mosi_out, miso_out, sclk;

    spi_master spi_master_inst (
        .clk(clk),
        .rst(rst),
        .mosi_in(mosi_in),
        .miso_in(miso_in),
        .mosi_out(mosi_out),
        .miso_out(miso_out)
    );

    sclk_gen sclk_gen_inst (
        .clk(clk),
        .rst(rst),
        .sclk(sclk)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 1'b0;
        rst = 1'b0;
        mosi_in = 1'b0;
        miso_in = 1'b0;

        #20 rst = 1'b1;
        #10 rst = 1'b0;
        #100 mosi_in = 1'b1;
        #100 miso_in = 1'b1;
        #100 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t clk=%b rst=%b mosi_in=%b miso_in=%b mosi_out=%b miso_out=%b sclk=%b"", 
                 $time, clk, rst, mosi_in, miso_in, mosi_out, miso_out, sclk);
    end
endmodule",True,88,True,True,True,False,0.3,False,8.640114545822144,13.546810865402222,"Design SPI master supporting mode 0 (CPOL=0, CPHA=0). Include SCLK generation, MOSI/MISO handling. Include testbench.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph TD
    CLK[Clock] --> SCLK_GEN(SCLK Generation)
    RST[Reset] --> SPI_MASTER(SPI Master)
    SPI_MASTER --> SCLK_GEN
    SCLK_GEN --> SCLK[SCLK Output]
    MOSI_IN[MOSI Input] --> SPI_MASTER
    SPI_MASTER --> MOSI_OUT[MOSI Output]
    MISO_IN[MISO Input] --> SPI_MASTER
    SPI_MASTER --> MISO_OUT[MISO Output]
    TESTBENCH[Testbench]
    TESTBENCH --> SPI_MASTER
    TESTBENCH --> MOSI_IN
    TESTBENCH --> MISO_IN
    SCLK --> TESTBENCH
    MOSI_OUT --> TESTBENCH
    MISO_OUT --> TESTBENCH
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module spi_master(
    input wire clk,
    input wire rst_n,
    input wire mosi_in,
    input wire miso_in,
    output reg mosi_out,
    output reg miso_out,
    output wire sclk
);
    wire sclk_internal;
    
    // Instantiate SCLK Generation Module
    sclk_generation sclk_gen_inst (
        .clk(clk),
        .rst_n(rst_n),
        .sclk(sclk_internal)
    );
    
    assign sclk = sclk_internal;
    
    // SPI Master Logic
    always @(posedge sclk_internal or negedge rst_n) begin
        if (!rst_n) begin
            mosi_out <= 1'b0;
            miso_out <= 1'b0;
        end else begin
            // SPI Master operation for Mode 0 (CPOL=0, CPHA=0)
            mosi_out <= mosi_in;
            miso_out <= miso_in;
        end
    end
endmodule

module sclk_generation(
    input wire clk,
    input wire rst_n,
    output reg sclk
);
    reg [7:0] counter;
    
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            counter <= 8'b0;
            sclk <= 1'b0;
        end else begin
            counter <= counter + 1'b1;
            if (counter == 8'b11111111) begin
                sclk <= ~sclk;
                counter <= 8'b0;
            end
        end
    end
endmodule

module testbench;
    reg clk, rst_n;
    reg mosi_in, miso_in;
    wire mosi_out, miso_out, sclk;
    
    spi_master dut (
        .clk(clk),
        .rst_n(rst_n),
        .mosi_in(mosi_in),
        .miso_in(miso_in),
        .mosi_out(mosi_out),
        .miso_out(miso_out),
        .sclk(sclk)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst_n = 1'b0;
        mosi_in = 1'b0;
        miso_in = 1'b0;
        
        #20 rst_n = 1'b1;
        #10 mosi_in = 1'b1;
        #10 miso_in = 1'b1;
        #200 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b mosi_in=%b miso_in=%b mosi_out=%b miso_out=%b sclk=%b"", 
                 $time, clk, rst_n, mosi_in, miso_in, mosi_out, miso_out, sclk);
    end
endmodule",True,93,True,True,True,True,0.9,True,6.456880331039429,18.340302228927612,mermaid_only,mermaid_only > prompt_only > combined,prompt_only > mermaid_only > combined
