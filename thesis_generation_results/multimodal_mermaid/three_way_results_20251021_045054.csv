circuit_name,category,complexity,original_prompt,model,prompt_only_verilog,prompt_only_generation_success,prompt_only_lines_of_code,prompt_only_has_testbench,prompt_only_compilation_success,prompt_only_simulation_success,prompt_only_vae_verdict,prompt_only_vae_confidence,prompt_only_consensus_anomalous,prompt_only_generation_time,prompt_only_simulation_time,mermaid_only_mermaid,mermaid_only_verilog,mermaid_only_generation_success,mermaid_only_lines_of_code,mermaid_only_has_testbench,mermaid_only_compilation_success,mermaid_only_simulation_success,mermaid_only_vae_verdict,mermaid_only_vae_confidence,mermaid_only_consensus_anomalous,mermaid_only_generation_time,mermaid_only_simulation_time,combined_prompt,combined_verilog,combined_generation_success,combined_lines_of_code,combined_has_testbench,combined_compilation_success,combined_simulation_success,combined_vae_verdict,combined_vae_confidence,combined_consensus_anomalous,combined_generation_time,combined_simulation_time,best_approach,correctness_ranking,simulation_ranking
combined,Combinational,simple,"Design a 2-to-1 multiplexer with inputs a, b, select sel, and output out. Include testbench testing all combinations.",claude,"`timescale 1ns/1ps

module mux2to1(
    input wire a,
    input wire b,
    input wire sel,
    output reg out
);

always @(*) begin
    case (sel)
        1'b0: out = a;
        1'b1: out = b;
    endcase
end

endmodule

module testbench;
    reg a, b, sel;
    wire out;
    
    mux2to1 dut (
        .a(a),
        .b(b),
        .sel(sel),
        .out(out)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        // Test all input combinations
        a = 0; b = 0; sel = 0; #10;
        a = 0; b = 0; sel = 1; #10;
        a = 0; b = 1; sel = 0; #10;
        a = 0; b = 1; sel = 1; #10;
        a = 1; b = 0; sel = 0; #10;
        a = 1; b = 0; sel = 1; #10;
        a = 1; b = 1; sel = 0; #10;
        a = 1; b = 1; sel = 1; #10;
        
        $finish;
    end
    
    initial begin
        $monitor(""Time=%0t a=%b b=%b sel=%b out=%b"", 
                 $time, a, b, sel, out);
    end
endmodule",True,51,True,True,True,False,0.4,False,5.582083225250244,6.616332292556763,"graph LR
    A[Input A] --> MUX{2:1 MUX}
    B[Input B] --> MUX
    SEL[Select] --> MUX
    MUX --> OUT[Output]
    TBSTART[[Testbench]] --> |Test 1: sel=0, a=0, b=0| TB1[Test 1]
    TBSTART --> |Test 2: sel=0, a=0, b=1| TB2[Test 2]
    TBSTART --> |Test 3: sel=0, a=1, b=0| TB3[Test 3]
    TBSTART --> |Test 4: sel=0, a=1, b=1| TB4[Test 4]
    TBSTART --> |Test 5: sel=1, a=0, b=0| TB5[Test 5]
    TBSTART --> |Test 6: sel=1, a=0, b=1| TB6[Test 6]
    TBSTART --> |Test 7: sel=1, a=1, b=0| TB7[Test 7]
    TBSTART --> |Test 8: sel=1, a=1, b=1| TB8[Test 8]","`timescale 1ns/1ps

module mux2to1(
    input wire clk,
    input wire rst_n,
    input wire a,
    input wire b,
    input wire sel,
    output reg out
);

always @(posedge clk or negedge rst_n) begin
    if (!rst_n)
        out <= 1'b0;
    else
        out <= sel ? b : a;
end

endmodule

module testbench;
    reg clk, rst_n, a, b, sel;
    wire out;

    mux2to1 dut (
        .clk(clk),
        .rst_n(rst_n),
        .a(a),
        .b(b),
        .sel(sel),
        .out(out)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 0;
        rst_n = 0;
        #10 rst_n = 1;

        // Test 1: sel=0, a=0, b=0
        sel = 0; a = 0; b = 0; #10;
        
        // Test 2: sel=0, a=0, b=1
        sel = 0; a = 0; b = 1; #10;
        
        // Test 3: sel=0, a=1, b=0
        sel = 0; a = 1; b = 0; #10;
        
        // Test 4: sel=0, a=1, b=1
        sel = 0; a = 1; b = 1; #10;
        
        // Test 5: sel=1, a=0, b=0
        sel = 1; a = 0; b = 0; #10;
        
        // Test 6: sel=1, a=0, b=1
        sel = 1; a = 0; b = 1; #10;
        
        // Test 7: sel=1, a=1, b=0
        sel = 1; a = 1; b = 0; #10;
        
        // Test 8: sel=1, a=1, b=1
        sel = 1; a = 1; b = 1; #10;
        
        $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t sel=%b a=%b b=%b out=%b"", 
                 $time, sel, a, b, out);
    end
endmodule",True,75,True,True,True,False,0.3,False,11.929781913757324,8.474225759506226,"Design a 2-to-1 multiplexer with inputs a, b, select sel, and output out. Include testbench testing all combinations.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph LR
    A[Input A] --> MUX{2:1 MUX}
    B[Input B] --> MUX
    SEL[Select] --> MUX
    MUX --> OUT[Output]
    TBSTART[[Testbench]] --> |Test 1: sel=0, a=0, b=0| TB1[Test 1]
    TBSTART --> |Test 2: sel=0, a=0, b=1| TB2[Test 2]
    TBSTART --> |Test 3: sel=0, a=1, b=0| TB3[Test 3]
    TBSTART --> |Test 4: sel=0, a=1, b=1| TB4[Test 4]
    TBSTART --> |Test 5: sel=1, a=0, b=0| TB5[Test 5]
    TBSTART --> |Test 6: sel=1, a=0, b=1| TB6[Test 6]
    TBSTART --> |Test 7: sel=1, a=1, b=0| TB7[Test 7]
    TBSTART --> |Test 8: sel=1, a=1, b=1| TB8[Test 8]
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module mux_2to1 (
    input wire a,
    input wire b,
    input wire sel,
    output reg out
);

always @(*) begin
    if (sel)
        out = b;
    else 
        out = a;
end

endmodule

module testbench;
    reg a, b, sel;
    wire out;
    
    mux_2to1 dut (
        .a(a),
        .b(b),
        .sel(sel),
        .out(out)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        // Test 1: sel=0, a=0, b=0
        sel = 0; a = 0; b = 0; #10;
        // Test 2: sel=0, a=0, b=1
        sel = 0; a = 0; b = 1; #10;
        // Test 3: sel=0, a=1, b=0
        sel = 0; a = 1; b = 0; #10;
        // Test 4: sel=0, a=1, b=1
        sel = 0; a = 1; b = 1; #10;
        // Test 5: sel=1, a=0, b=0
        sel = 1; a = 0; b = 0; #10;
        // Test 6: sel=1, a=0, b=1
        sel = 1; a = 0; b = 1; #10;
        // Test 7: sel=1, a=1, b=0
        sel = 1; a = 1; b = 0; #10;
        // Test 8: sel=1, a=1, b=1
        sel = 1; a = 1; b = 1; #10;
        
        $finish;
    end
    
    initial begin
        $monitor(""Time=%0t sel=%b a=%b b=%b out=%b"", $time, sel, a, b, out);
    end
endmodule",True,57,True,True,True,False,0.4,False,6.163544416427612,5.585997581481934,tie,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,Combinational,simple,"Design a 2-to-1 multiplexer with inputs a, b, select sel, and output out. Include testbench testing all combinations.",gpt-4o,"`timescale 1ns/1ps

module mux2to1(
    input wire a,
    input wire b,
    input wire sel,
    output wire out
);

assign out = sel ? b : a;

endmodule

module testbench;
    reg a, b, sel;
    wire out;
    
    mux2to1 dut (
        .a(a),
        .b(b),
        .sel(sel),
        .out(out)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        a = 1'b0; b = 1'b0; sel = 1'b0;
        #10 a = 1'b0; b = 1'b1; sel = 1'b0;
        #10 a = 1'b1; b = 1'b0; sel = 1'b0;
        #10 a = 1'b1; b = 1'b1; sel = 1'b0;
        #10 a = 1'b0; b = 1'b0; sel = 1'b1;
        #10 a = 1'b0; b = 1'b1; sel = 1'b1;
        #10 a = 1'b1; b = 1'b0; sel = 1'b1;
        #10 a = 1'b1; b = 1'b1; sel = 1'b1;
        #10 $finish;
    end
    
    initial begin
        $monitor(""Time=%0t a=%b b=%b sel=%b out=%b"", 
                 $time, a, b, sel, out);
    end
endmodule",True,44,True,True,True,False,0.4,False,4.000114679336548,4.065738201141357,"graph LR
    A[a] --> MUX{2-to-1 MUX}
    B[b] --> MUX
    SEL[sel] --> MUX
    MUX --> OUT[out]

    subgraph Testbench
        TA[a Test] --> A
        TB[b Test] --> B
        TSEL[sel Test] --> SEL
        OUT --> TOUT[Output Test]
    end","`timescale 1ns/1ps

module mux_2_to_1(
    input wire a,
    input wire b,
    input wire sel,
    output reg out
);

always @(*) begin
    if (sel)
        out = b;
    else
        out = a;
end

endmodule

module testbench;
    reg a, b, sel;
    wire out;
    
    mux_2_to_1 dut (
        .a(a),
        .b(b),
        .sel(sel),
        .out(out)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        a = 1'b0;
        b = 1'b0;
        sel = 1'b0;
        
        #10 a = 1'b1;
        #10 sel = 1'b1;
        #10 b = 1'b1;
        #10 sel = 1'b0;
        #10 a = 1'b0;
        #10 $finish;
    end

    initial begin
        $monitor(""Time=%0t a=%b b=%b sel=%b out=%b"", 
                 $time, a, b, sel, out);
    end
endmodule",True,50,True,True,True,False,0.4,False,9.380470037460327,7.540354013442993,"Design a 2-to-1 multiplexer with inputs a, b, select sel, and output out. Include testbench testing all combinations.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph LR
    A[a] --> MUX{2-to-1 MUX}
    B[b] --> MUX
    SEL[sel] --> MUX
    MUX --> OUT[out]

    subgraph Testbench
        TA[a Test] --> A
        TB[b Test] --> B
        TSEL[sel Test] --> SEL
        OUT --> TOUT[Output Test]
    end
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module mux2to1(
    input wire a,
    input wire b,
    input wire sel,
    output reg out
);

always @(*) begin
    if (sel)
        out = b;
    else
        out = a;
end

endmodule

module testbench;
    reg a, b, sel;
    wire out;

    mux2to1 dut (
        .a(a),
        .b(b),
        .sel(sel),
        .out(out)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        a = 1'b0; b = 1'b0; sel = 1'b0;
        #10 a = 1'b0; b = 1'b1; sel = 1'b0;
        #10 a = 1'b1; b = 1'b0; sel = 1'b0;
        #10 a = 1'b1; b = 1'b1; sel = 1'b0;
        #10 a = 1'b0; b = 1'b0; sel = 1'b1;
        #10 a = 1'b0; b = 1'b1; sel = 1'b1;
        #10 a = 1'b1; b = 1'b0; sel = 1'b1;
        #10 a = 1'b1; b = 1'b1; sel = 1'b1;
        #10 $finish;
    end

    initial begin
        $monitor(""Time=%0t a=%b b=%b sel=%b out=%b"", 
                 $time, a, b, sel, out);
    end
endmodule",True,49,True,True,True,False,0.4,False,4.125452280044556,4.945791959762573,tie,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,Sequential,simple,"Create a D flip-flop with clock, reset, input d, and output q. Include testbench with timing verification.",claude,"`timescale 1ns/1ps

module dff(
    input wire clk,
    input wire rst_n,
    input wire d,
    output reg q
);

always @(posedge clk or negedge rst_n) begin
    if (!rst_n)
        q <= 1'b0;
    else
        q <= d;
end

endmodule

module testbench;
    reg clk, rst_n, d;
    wire q;
    
    dff dut (
        .clk(clk),
        .rst_n(rst_n),
        .d(d),
        .q(q)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst_n = 1'b0;
        d = 1'b0;
        
        #20 rst_n = 1'b1;
        #10 d = 1'b1;
        #10 d = 1'b0;
        #10 d = 1'b1;
        #20 rst_n = 1'b0;
        #20 rst_n = 1'b1;
        #50 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b d=%b q=%b"", 
                 $time, clk, rst_n, d, q);
    end
endmodule",True,53,True,True,True,True,0.7,True,4.725173234939575,8.173987865447998,"graph LR
    CLK[Clock] --> DFF[[D Flip-Flop]]
    RST[Reset] --> DFF
    D[Data Input] --> DFF
    DFF --> Q[Output Q]
    TB[Testbench] --> |verify_timing| DFF
    CLK --> |clock_check| TB
    D --> |input_check| TB
    Q --> |output_verify| TB
    RST --> |reset_check| TB
    TB --> |setup_time| TS{Setup Check}
    TB --> |hold_time| TH{Hold Check}
    TS --> |pass/fail| R[Results]
    TH --> |pass/fail| R","`timescale 1ns/1ps

module dff(
    input wire clk,
    input wire rst,
    input wire d,
    output reg q
);

always @(posedge clk or posedge rst) begin
    if (rst)
        q <= 1'b0;
    else
        q <= d;
end

endmodule

module testbench;
    reg clk, rst, d;
    wire q;
    
    dff dut (
        .clk(clk),
        .rst(rst),
        .d(d),
        .q(q)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 0;
        rst = 1;
        d = 0;
        
        #10 rst = 0;
        
        // Test data transitions
        #10 d = 1;
        #10 d = 0;
        #10 d = 1;
        
        // Test reset during operation
        #10 rst = 1;
        #10 rst = 0;
        
        // Setup and hold time tests
        #5 d = 0;
        #1 d = 1;  // Change near clock edge
        #9 d = 0;
        
        #50 $finish;
    end
    
    always #5 clk = ~clk;
    
    // Timing checks
    initial begin
        $monitor(""Time=%0t clk=%b rst=%b d=%b q=%b"",
                 $time, clk, rst, d, q);
                 
        // Check setup time
        #1;
        if ($time < 0.1)
            $display(""Setup time violation!"");
            
        // Check hold time
        #1;
        if ($time < 0.1)
            $display(""Hold time violation!"");
    end
endmodule",True,74,True,True,True,False,0.3,False,9.677706956863403,8.068538427352905,"Create a D flip-flop with clock, reset, input d, and output q. Include testbench with timing verification.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph LR
    CLK[Clock] --> DFF[[D Flip-Flop]]
    RST[Reset] --> DFF
    D[Data Input] --> DFF
    DFF --> Q[Output Q]
    TB[Testbench] --> |verify_timing| DFF
    CLK --> |clock_check| TB
    D --> |input_check| TB
    Q --> |output_verify| TB
    RST --> |reset_check| TB
    TB --> |setup_time| TS{Setup Check}
    TB --> |hold_time| TH{Hold Check}
    TS --> |pass/fail| R[Results]
    TH --> |pass/fail| R
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module dff (
    input wire clk,
    input wire rst,
    input wire d,
    output reg q
);

always @(posedge clk or posedge rst) begin
    if (rst)
        q <= 1'b0;
    else
        q <= d;
end

endmodule

module testbench;
    reg clk, rst, d;
    wire q;
    reg setup_pass, hold_pass;
    time last_data_change, last_clock_edge;
    parameter SETUP_TIME = 2;
    parameter HOLD_TIME = 1;

    dff dut (
        .clk(clk),
        .rst(rst),
        .d(d),
        .q(q)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 0;
        rst = 1;
        d = 0;
        setup_pass = 1;
        hold_pass = 1;
        
        #10 rst = 0;
        
        // Test sequence
        #10 d = 1;
        #10 d = 0;
        #10 d = 1;
        #10 d = 0;
        
        #50;
        
        if (setup_pass && hold_pass)
            $display(""Timing checks PASSED"");
        else
            $display(""Timing checks FAILED"");
            
        $finish;
    end

    always #5 clk = ~clk;

    always @(d) begin
        last_data_change = $time;
    end

    always @(posedge clk) begin
        last_clock_edge = $time;
        if ((last_clock_edge - last_data_change) < SETUP_TIME)
            setup_pass = 0;
    end

    always @(posedge clk) begin
        #1;
        if ((($time - last_clock_edge) < HOLD_TIME) && (d !== $past(d)))
            hold_pass = 0;
    end

    initial begin
        $monitor(""Time=%0t clk=%b rst=%b d=%b q=%b"", 
                 $time, clk, rst, d, q);
    end
endmodule",True,84,True,False,False,,0.0,,7.96891713142395,0.016471385955810547,mermaid_only,mermaid_only > prompt_only > combined,prompt_only > mermaid_only > combined
combined,Sequential,simple,"Create a D flip-flop with clock, reset, input d, and output q. Include testbench with timing verification.",gpt-4o,"`timescale 1ns/1ps

module d_flip_flop (
    input wire clk,
    input wire rst_n,
    input wire d,
    output reg q
);

always @(posedge clk or negedge rst_n) begin
    if (!rst_n)
        q <= 1'b0;
    else
        q <= d;
end

endmodule

module testbench;
    reg clk, rst_n, d;
    wire q;
    
    d_flip_flop dut (
        .clk(clk),
        .rst_n(rst_n),
        .d(d),
        .q(q)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst_n = 1'b0;
        d = 1'b0;
        
        #20 rst_n = 1'b1;
        #10 d = 1'b1;
        #10 d = 1'b0;
        #10 d = 1'b1;
        #10 d = 1'b0;
        #20 rst_n = 1'b0;
        #20 rst_n = 1'b1;
        #50 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b d=%b q=%b"", 
                 $time, clk, rst_n, d, q);
    end
endmodule",True,54,True,True,True,True,0.7,True,3.213291883468628,10.383866548538208,"graph TD
    CLK[Clock] --> DFF[[D Flip-Flop]]
    RST[Reset] --> DFF
    D[Input D] --> DFF
    DFF --> Q[Output Q]
    
    subgraph Testbench
        CLK_TB[Clock] --> DFF_TB[[D Flip-Flop]]
        RST_TB[Reset] --> DFF_TB
        D_TB[Input D] --> DFF_TB
        DFF_TB --> Q_TB[Output Q]
        DFF_TB -- Timing Verification --> Timing_Check{Timing Verification}
        Timing_Check -- Pass/Fail --> Result[Verification Result]
    end","`timescale 1ns/1ps

module d_flip_flop(
    input wire clk,
    input wire rst,
    input wire d,
    output reg q
);

always @(posedge clk or posedge rst) begin
    if (rst)
        q <= 1'b0;
    else
        q <= d;
end

endmodule

module testbench;
    reg clk, rst, d;
    wire q;
    
    d_flip_flop dut (
        .clk(clk),
        .rst(rst),
        .d(d),
        .q(q)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst = 1'b0;
        d = 1'b0;
        
        #10 rst = 1'b1;
        #10 rst = 1'b0;
        
        #10 d = 1'b1;
        #20 d = 1'b0;
        #30 d = 1'b1;
        
        #50 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t clk=%b rst=%b d=%b q=%b"", 
                 $time, clk, rst, d, q);
    end
endmodule",True,54,True,True,True,True,0.7,True,6.040816068649292,5.690143823623657,"Create a D flip-flop with clock, reset, input d, and output q. Include testbench with timing verification.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph TD
    CLK[Clock] --> DFF[[D Flip-Flop]]
    RST[Reset] --> DFF
    D[Input D] --> DFF
    DFF --> Q[Output Q]
    
    subgraph Testbench
        CLK_TB[Clock] --> DFF_TB[[D Flip-Flop]]
        RST_TB[Reset] --> DFF_TB
        D_TB[Input D] --> DFF_TB
        DFF_TB --> Q_TB[Output Q]
        DFF_TB -- Timing Verification --> Timing_Check{Timing Verification}
        Timing_Check -- Pass/Fail --> Result[Verification Result]
    end
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module d_flip_flop(
    input wire clk,
    input wire rst,
    input wire d,
    output reg q
);

always @(posedge clk or posedge rst) begin
    if (rst)
        q <= 1'b0;
    else
        q <= d;
end

endmodule

module testbench;
    reg clk_tb, rst_tb, d_tb;
    wire q_tb;

    d_flip_flop dut (
        .clk(clk_tb),
        .rst(rst_tb),
        .d(d_tb),
        .q(q_tb)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk_tb = 1'b0;
        rst_tb = 1'b0;
        d_tb = 1'b0;

        #10 rst_tb = 1'b1;
        #10 rst_tb = 1'b0;
        #10 d_tb = 1'b1;
        #20 d_tb = 1'b0;
        #20 d_tb = 1'b1;
        #10 rst_tb = 1'b1;
        #10 rst_tb = 1'b0;
        #30 $finish;
    end

    always #5 clk_tb = ~clk_tb;

    initial begin
        $monitor(""Time=%0t clk_tb=%b rst_tb=%b d_tb=%b q_tb=%b"", 
                 $time, clk_tb, rst_tb, d_tb, q_tb);
    end
endmodule",True,54,True,True,True,True,0.7,True,2.7213664054870605,9.06937289237976,prompt_only,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,Sequential,simple,"Design a 4-bit synchronous counter with clock, reset, enable, and count[3:0]. Include testbench.",claude,"`timescale 1ns/1ps

module counter(
    input wire clk,
    input wire rst_n,
    input wire enable,
    output reg [3:0] count
);

always @(posedge clk or negedge rst_n) begin
    if (!rst_n)
        count <= 4'b0000;
    else if (enable)
        count <= count + 1'b1;
end

endmodule

module testbench;
    reg clk, rst_n, enable;
    wire [3:0] count;
    
    counter dut (
        .clk(clk),
        .rst_n(rst_n),
        .enable(enable),
        .count(count)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst_n = 1'b0;
        enable = 1'b0;
        
        #20 rst_n = 1'b1;
        #10 enable = 1'b1;
        #100 enable = 1'b0;
        #20 rst_n = 1'b0;
        #20 rst_n = 1'b1;
        #50 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b enable=%b count=%d"", 
                 $time, clk, rst_n, enable, count);
    end
endmodule",True,52,True,True,True,False,0.3,False,4.520278215408325,7.876854419708252,"graph LR
    CLK[Clock] --> COUNTER[[4-bit Counter]]
    RST[Reset] --> COUNTER
    EN[Enable] --> COUNTER
    COUNTER --> OUT[Count[3:0]]
    COUNTER --> TB[[Testbench]]
    CLK --> TB
    RST --> TB
    EN --> TB
    TB --> STIM[Test Stimulus]
    TB --> CHECK{Verification}
    CHECK --> PASS[Pass/Fail]
    STIM --> |Test Vectors| COUNTER
    OUT --> |Expected Values| CHECK","`timescale 1ns/1ps

module counter(
    input wire clk,
    input wire rst_n,
    input wire enable,
    output reg [3:0] count
);

always @(posedge clk or negedge rst_n) begin
    if (!rst_n)
        count <= 4'b0000;
    else if (enable)
        count <= count + 1'b1;
end

endmodule

module testbench;
    reg clk, rst_n, enable;
    wire [3:0] count;
    
    counter dut (
        .clk(clk),
        .rst_n(rst_n),
        .enable(enable),
        .count(count)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst_n = 1'b0;
        enable = 1'b0;
        
        #20 rst_n = 1'b1;
        #10 enable = 1'b1;
        #160 enable = 1'b0;
        #20 rst_n = 1'b0;
        #20 rst_n = 1'b1;
        #50 $finish;
    end
    
    always #5 clk = ~clk;
    
    reg [3:0] expected;
    always @(posedge clk) begin
        if (!rst_n)
            expected = 4'b0000;
        else if (enable)
            expected = count + 1'b1;
            
        if (enable) begin
            if (count !== expected && !rst_n)
                $display(""ERROR: Count=%d, Expected=%d"", count, expected);
        end
    end
    
    initial begin
        $monitor(""Time=%0t rst_n=%b en=%b count=%d"", 
                 $time, rst_n, enable, count);
    end
endmodule",True,65,True,True,True,False,0.4,False,9.056687116622925,7.078573226928711,"Design a 4-bit synchronous counter with clock, reset, enable, and count[3:0]. Include testbench.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph LR
    CLK[Clock] --> COUNTER[[4-bit Counter]]
    RST[Reset] --> COUNTER
    EN[Enable] --> COUNTER
    COUNTER --> OUT[Count[3:0]]
    COUNTER --> TB[[Testbench]]
    CLK --> TB
    RST --> TB
    EN --> TB
    TB --> STIM[Test Stimulus]
    TB --> CHECK{Verification}
    CHECK --> PASS[Pass/Fail]
    STIM --> |Test Vectors| COUNTER
    OUT --> |Expected Values| CHECK
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module counter(
    input wire clk,
    input wire rst_n,
    input wire enable,
    output reg [3:0] count
);

always @(posedge clk or negedge rst_n) begin
    if (!rst_n)
        count <= 4'b0000;
    else if (enable)
        count <= count + 1'b1;
end

endmodule

module testbench;
    reg clk, rst_n, enable;
    wire [3:0] count;
    reg [3:0] expected_count;
    reg test_pass;
    
    counter dut (
        .clk(clk),
        .rst_n(rst_n),
        .enable(enable),
        .count(count)
    );
    
    initial begin
        $dumpfile(""counter_tb.vcd"");
        $dumpvars(0, testbench);
        
        clk = 0;
        rst_n = 0;
        enable = 0;
        expected_count = 0;
        test_pass = 1;
        
        // Test Reset
        #10 rst_n = 0;
        if (count !== 4'b0000) begin
            $display(""TEST FAILED: Reset not working"");
            test_pass = 0;
        end
        
        // Test Counting
        #10 rst_n = 1;
        enable = 1;
        
        repeat(16) begin
            @(posedge clk);
            expected_count = (expected_count + 1) & 4'hF;
            #1;
            if (count !== expected_count) begin
                $display(""TEST FAILED: Count mismatch. Expected %d, Got %d"", expected_count, count);
                test_pass = 0;
            end
        end
        
        // Test Enable
        enable = 0;
        #20;
        if (count !== expected_count) begin
            $display(""TEST FAILED: Counter counting while disabled"");
            test_pass = 0;
        end
        
        if (test_pass)
            $display(""All tests PASSED!"");
        else
            $display(""Some tests FAILED!"");
            
        #10 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t rst_n=%b enable=%b count=%b"", $time, rst_n, enable, count);
    end
endmodule",True,84,True,True,True,,0.0,,7.842102289199829,0.01864910125732422,tie,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,Sequential,simple,"Design a 4-bit synchronous counter with clock, reset, enable, and count[3:0]. Include testbench.",gpt-4o,"`timescale 1ns/1ps

module counter(
    input wire clk,
    input wire rst_n,
    input wire enable,
    output reg [3:0] count
);

always @(posedge clk or negedge rst_n) begin
    if (!rst_n)
        count <= 4'b0000;
    else if (enable)
        count <= count + 1'b1;
end

endmodule

module testbench;
    reg clk, rst_n, enable;
    wire [3:0] count;
    
    counter dut (
        .clk(clk),
        .rst_n(rst_n),
        .enable(enable),
        .count(count)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst_n = 1'b0;
        enable = 1'b0;
        
        #20 rst_n = 1'b1;
        #10 enable = 1'b1;
        #100 enable = 1'b0;
        #20 rst_n = 1'b0;
        #20 rst_n = 1'b1;
        #50 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b enable=%b count=%d"", 
                 $time, clk, rst_n, enable, count);
    end
endmodule",True,52,True,True,True,False,0.3,False,3.532214403152466,11.050388813018799,"graph TD
    CLK[Clock] --> COUNTER((4-bit Counter))
    RST[Reset] --> COUNTER
    EN[Enable] --> COUNTER
    COUNTER --> CNT[[Count[3:0]]]
    
    subgraph Testbench
        CLK_TB[Clock] --> TBPROC((Test Logic))
        RST_TB[Reset] --> TBPROC
        EN_TB[Enable] --> TBPROC
        TBPROC --> CLK
        TBPROC --> RST
        TBPROC --> EN
        CNT --> TBPROC
    end","`timescale 1ns/1ps

module counter(
    input wire clk,
    input wire rst_n,
    input wire enable,
    output reg [3:0] count
);

always @(posedge clk or negedge rst_n) begin
    if (!rst_n)
        count <= 4'b0000;
    else if (enable)
        count <= count + 1'b1;
end

endmodule

module testbench;
    reg clk, rst_n, enable;
    wire [3:0] count;
    
    counter dut (
        .clk(clk),
        .rst_n(rst_n),
        .enable(enable),
        .count(count)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst_n = 1'b0;
        enable = 1'b0;
        
        #20 rst_n = 1'b1;
        #10 enable = 1'b1;
        #100 enable = 1'b0;
        #20 rst_n = 1'b0;
        #20 rst_n = 1'b1;
        #50 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b enable=%b count=%d"", 
                 $time, clk, rst_n, enable, count);
    end
endmodule",True,52,True,True,True,False,0.3,False,4.882889270782471,7.427410364151001,"Design a 4-bit synchronous counter with clock, reset, enable, and count[3:0]. Include testbench.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph TD
    CLK[Clock] --> COUNTER((4-bit Counter))
    RST[Reset] --> COUNTER
    EN[Enable] --> COUNTER
    COUNTER --> CNT[[Count[3:0]]]
    
    subgraph Testbench
        CLK_TB[Clock] --> TBPROC((Test Logic))
        RST_TB[Reset] --> TBPROC
        EN_TB[Enable] --> TBPROC
        TBPROC --> CLK
        TBPROC --> RST
        TBPROC --> EN
        CNT --> TBPROC
    end
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module counter(
    input wire clk,
    input wire rst_n,
    input wire enable,
    output reg [3:0] count
);

always @(posedge clk or negedge rst_n) begin
    if (!rst_n)
        count <= 4'b0000;
    else if (enable)
        count <= count + 1'b1;
end

endmodule

module testbench;
    reg clk, rst_n, enable;
    wire [3:0] count;
    
    counter dut (
        .clk(clk),
        .rst_n(rst_n),
        .enable(enable),
        .count(count)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst_n = 1'b0;
        enable = 1'b0;
        
        #20 rst_n = 1'b1;
        #10 enable = 1'b1;
        #100 enable = 1'b0;
        #20 rst_n = 1'b0;
        #20 rst_n = 1'b1;
        #50 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b enable=%b count=%d"", 
                 $time, clk, rst_n, enable, count);
    end
endmodule",True,52,True,True,True,False,0.3,False,4.909193754196167,8.013405084609985,tie,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,Combinational,simple,"Create a full adder with inputs a, b, cin and outputs sum, cout. Include testbench with all 8 cases.",claude,"`timescale 1ns/1ps

module full_adder (
    input wire a,
    input wire b,
    input wire cin,
    output wire sum,
    output wire cout
);

    assign sum = a ^ b ^ cin;
    assign cout = (a & b) | (b & cin) | (a & cin);

endmodule

module testbench;
    reg a, b, cin;
    wire sum, cout;

    full_adder dut (
        .a(a),
        .b(b),
        .cin(cin),
        .sum(sum),
        .cout(cout)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        // Test all 8 input combinations
        {a, b, cin} = 3'b000; #10;
        {a, b, cin} = 3'b001; #10;
        {a, b, cin} = 3'b010; #10;
        {a, b, cin} = 3'b011; #10;
        {a, b, cin} = 3'b100; #10;
        {a, b, cin} = 3'b101; #10;
        {a, b, cin} = 3'b110; #10;
        {a, b, cin} = 3'b111; #10;

        $finish;
    end

    initial begin
        $monitor(""Time=%0t a=%b b=%b cin=%b sum=%b cout=%b"",
                 $time, a, b, cin, sum, cout);
    end

endmodule",True,50,True,True,True,False,0.4,False,4.597170829772949,6.271662473678589,"graph LR
    A[Input A] --> FA((Full Adder))
    B[Input B] --> FA
    CIN[Carry In] --> FA
    FA --> SUM[Sum Out]
    FA --> COUT[Carry Out]
    TB[[Test Cases]]
    TB --> |000|TC1{0,0}
    TB --> |001|TC2{0,1}
    TB --> |010|TC3{0,1}
    TB --> |011|TC4{1,0}
    TB --> |100|TC5{0,1}
    TB --> |101|TC6{1,0}
    TB --> |110|TC7{1,0}
    TB --> |111|TC8{1,1}","`timescale 1ns/1ps

module full_adder(
    input wire a,
    input wire b,
    input wire cin,
    output wire sum,
    output wire cout
);

    assign sum = a ^ b ^ cin;
    assign cout = (a & b) | (b & cin) | (a & cin);

endmodule

module testbench;
    reg a, b, cin;
    wire sum, cout;

    full_adder dut (
        .a(a),
        .b(b),
        .cin(cin),
        .sum(sum),
        .cout(cout)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        // Test case 1: 000
        a = 0; b = 0; cin = 0;
        #10;
        
        // Test case 2: 001
        a = 0; b = 0; cin = 1;
        #10;
        
        // Test case 3: 010
        a = 0; b = 1; cin = 0;
        #10;
        
        // Test case 4: 011
        a = 0; b = 1; cin = 1;
        #10;
        
        // Test case 5: 100
        a = 1; b = 0; cin = 0;
        #10;
        
        // Test case 6: 101
        a = 1; b = 0; cin = 1;
        #10;
        
        // Test case 7: 110
        a = 1; b = 1; cin = 0;
        #10;
        
        // Test case 8: 111
        a = 1; b = 1; cin = 1;
        #10;
        
        $finish;
    end

    initial begin
        $monitor(""Time=%0t a=%b b=%b cin=%b sum=%b cout=%b"",
                 $time, a, b, cin, sum, cout);
    end

endmodule",True,72,True,True,True,False,0.4,False,8.976425647735596,6.5802528858184814,"Create a full adder with inputs a, b, cin and outputs sum, cout. Include testbench with all 8 cases.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph LR
    A[Input A] --> FA((Full Adder))
    B[Input B] --> FA
    CIN[Carry In] --> FA
    FA --> SUM[Sum Out]
    FA --> COUT[Carry Out]
    TB[[Test Cases]]
    TB --> |000|TC1{0,0}
    TB --> |001|TC2{0,1}
    TB --> |010|TC3{0,1}
    TB --> |011|TC4{1,0}
    TB --> |100|TC5{0,1}
    TB --> |101|TC6{1,0}
    TB --> |110|TC7{1,0}
    TB --> |111|TC8{1,1}
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module full_adder(
    input wire a,
    input wire b,
    input wire cin,
    output wire sum,
    output wire cout
);

assign sum = a ^ b ^ cin;
assign cout = (a & b) | (cin & (a ^ b));

endmodule

module testbench;
    reg a, b, cin;
    wire sum, cout;

    full_adder dut(
        .a(a),
        .b(b),
        .cin(cin),
        .sum(sum),
        .cout(cout)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        // Test case 000
        a = 0; b = 0; cin = 0;
        #10;

        // Test case 001
        a = 0; b = 0; cin = 1;
        #10;

        // Test case 010
        a = 0; b = 1; cin = 0;
        #10;

        // Test case 011
        a = 0; b = 1; cin = 1;
        #10;

        // Test case 100
        a = 1; b = 0; cin = 0;
        #10;

        // Test case 101
        a = 1; b = 0; cin = 1;
        #10;

        // Test case 110
        a = 1; b = 1; cin = 0;
        #10;

        // Test case 111
        a = 1; b = 1; cin = 1;
        #10;

        $finish;
    end

    initial begin
        $monitor(""Time=%0t a=%b b=%b cin=%b sum=%b cout=%b"",
                 $time, a, b, cin, sum, cout);
    end

endmodule",True,72,True,True,True,False,0.4,False,5.8380231857299805,6.804457187652588,tie,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,Combinational,simple,"Create a full adder with inputs a, b, cin and outputs sum, cout. Include testbench with all 8 cases.",gpt-4o,"`timescale 1ns/1ps

module full_adder(
    input wire a,
    input wire b,
    input wire cin,
    output wire sum,
    output wire cout
);

assign sum = a ^ b ^ cin;
assign cout = (a & b) | (b & cin) | (cin & a);

endmodule

module testbench;
    reg a, b, cin;
    wire sum, cout;
    
    full_adder dut (
        .a(a),
        .b(b),
        .cin(cin),
        .sum(sum),
        .cout(cout)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        $monitor(""Time=%0t a=%b b=%b cin=%b | sum=%b cout=%b"", $time, a, b, cin, sum, cout);
        
        // Test all 8 cases
        a = 0; b = 0; cin = 0; #10;
        a = 0; b = 0; cin = 1; #10;
        a = 0; b = 1; cin = 0; #10;
        a = 0; b = 1; cin = 1; #10;
        a = 1; b = 0; cin = 0; #10;
        a = 1; b = 0; cin = 1; #10;
        a = 1; b = 1; cin = 0; #10;
        a = 1; b = 1; cin = 1; #10;
        
        $finish;
    end
endmodule",True,46,True,True,True,False,0.4,False,3.8407137393951416,8.567553281784058,"graph TD
    A[a] --> FA(Full Adder)
    B[b] --> FA
    CIN[cin] --> FA
    FA --> SUM[sum]
    FA --> COUT[cout]
    
    TB[Testbench]
    TB --> A
    TB --> B
    TB --> CIN
    
    TB --> |Test Case 0| FA
    TB --> |Test Case 1| FA
    TB --> |Test Case 2| FA
    TB --> |Test Case 3| FA
    TB --> |Test Case 4| FA
    TB --> |Test Case 5| FA
    TB --> |Test Case 6| FA
    TB --> |Test Case 7| FA","`timescale 1ns/1ps

module full_adder (
    input wire a,
    input wire b,
    input wire cin,
    output reg sum,
    output reg cout
);

always @(*) begin
    {cout, sum} = a + b + cin;
end

endmodule

module testbench;
    reg a, b, cin;
    wire sum, cout;
    
    full_adder dut (
        .a(a),
        .b(b),
        .cin(cin),
        .sum(sum),
        .cout(cout)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        $monitor(""Time=%0t a=%b b=%b cin=%b sum=%b cout=%b"", 
                 $time, a, b, cin, sum, cout);
        
        // Test Case 0
        a = 1'b0; b = 1'b0; cin = 1'b0;
        #10;
        
        // Test Case 1
        a = 1'b0; b = 1'b0; cin = 1'b1;
        #10;
        
        // Test Case 2
        a = 1'b0; b = 1'b1; cin = 1'b0;
        #10;
        
        // Test Case 3
        a = 1'b0; b = 1'b1; cin = 1'b1;
        #10;
        
        // Test Case 4
        a = 1'b1; b = 1'b0; cin = 1'b0;
        #10;
        
        // Test Case 5
        a = 1'b1; b = 1'b0; cin = 1'b1;
        #10;
        
        // Test Case 6
        a = 1'b1; b = 1'b1; cin = 1'b0;
        #10;
        
        // Test Case 7
        a = 1'b1; b = 1'b1; cin = 1'b1;
        #10;
        
        $finish;
    end
endmodule",True,70,True,True,True,False,0.4,False,6.696339845657349,6.24729061126709,"Create a full adder with inputs a, b, cin and outputs sum, cout. Include testbench with all 8 cases.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph TD
    A[a] --> FA(Full Adder)
    B[b] --> FA
    CIN[cin] --> FA
    FA --> SUM[sum]
    FA --> COUT[cout]
    
    TB[Testbench]
    TB --> A
    TB --> B
    TB --> CIN
    
    TB --> |Test Case 0| FA
    TB --> |Test Case 1| FA
    TB --> |Test Case 2| FA
    TB --> |Test Case 3| FA
    TB --> |Test Case 4| FA
    TB --> |Test Case 5| FA
    TB --> |Test Case 6| FA
    TB --> |Test Case 7| FA
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module full_adder(
    input wire a,
    input wire b,
    input wire cin,
    output wire sum,
    output wire cout
);
    assign sum = a ^ b ^ cin;
    assign cout = (a & b) | (b & cin) | (a & cin);
endmodule

module testbench;
    reg a, b, cin;
    wire sum, cout;
    
    full_adder fa (
        .a(a),
        .b(b),
        .cin(cin),
        .sum(sum),
        .cout(cout)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        // Test Case 0
        a = 0; b = 0; cin = 0;
        #10;
        
        // Test Case 1
        a = 0; b = 0; cin = 1;
        #10;
        
        // Test Case 2
        a = 0; b = 1; cin = 0;
        #10;
        
        // Test Case 3
        a = 0; b = 1; cin = 1;
        #10;
        
        // Test Case 4
        a = 1; b = 0; cin = 0;
        #10;
        
        // Test Case 5
        a = 1; b = 0; cin = 1;
        #10;
        
        // Test Case 6
        a = 1; b = 1; cin = 0;
        #10;
        
        // Test Case 7
        a = 1; b = 1; cin = 1;
        #10;
        
        $finish;
    end
    
    initial begin
        $monitor(""Time=%0t a=%b b=%b cin=%b sum=%b cout=%b"", 
                 $time, a, b, cin, sum, cout);
    end
endmodule",True,69,True,True,True,False,0.4,False,2.378126382827759,10.038571834564209,tie,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,Combinational,simple,"Design a 2-bit comparator with inputs a[1:0], b[1:0] and outputs eq, gt, lt. Include testbench.",claude,"`timescale 1ns/1ps

module comparator(
    input wire [1:0] a,
    input wire [1:0] b,
    output reg eq,
    output reg gt,
    output reg lt
);

always @(*) begin
    if (a == b) begin
        eq = 1'b1;
        gt = 1'b0;
        lt = 1'b0;
    end
    else if (a > b) begin
        eq = 1'b0;
        gt = 1'b1;
        lt = 1'b0;
    end
    else begin
        eq = 1'b0;
        gt = 1'b0;
        lt = 1'b1;
    end
end

endmodule

module testbench;
    reg [1:0] a, b;
    wire eq, gt, lt;

    comparator dut (
        .a(a),
        .b(b),
        .eq(eq),
        .gt(gt),
        .lt(lt)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        a = 2'b00; b = 2'b00; #10;
        a = 2'b01; b = 2'b00; #10;
        a = 2'b00; b = 2'b01; #10;
        a = 2'b10; b = 2'b01; #10;
        a = 2'b01; b = 2'b11; #10;
        a = 2'b11; b = 2'b11; #10;
        
        $finish;
    end

    initial begin
        $monitor(""Time=%0t a=%b b=%b eq=%b gt=%b lt=%b"", 
                 $time, a, b, eq, gt, lt);
    end
endmodule",True,61,True,True,True,False,0.4,False,5.833402156829834,5.963788032531738,"graph LR
    A[a1:a0] --> COMP((2-bit Comparator))
    B[b1:b0] --> COMP
    COMP --> EQ[eq]
    COMP --> GT[gt]
    COMP --> LT[lt]
    TB[Testbench] -.-> |Test Vectors| A
    TB -.-> |Test Vectors| B
    TB -.-> |Verify| EQ
    TB -.-> |Verify| GT
    TB -.-> |Verify| LT
    COMP --> |a=b| EQ
    COMP --> |a>b| GT
    COMP --> |a<b| LT
    A --> |a[1]| COMP
    A --> |a[0]| COMP
    B --> |b[1]| COMP
    B --> |b[0]| COMP","`timescale 1ns/1ps

module comparator_2bit (
    input wire [1:0] a,
    input wire [1:0] b,
    output reg eq,
    output reg gt,
    output reg lt
);

always @(*) begin
    if (a == b) begin
        eq = 1'b1;
        gt = 1'b0;
        lt = 1'b0;
    end
    else if (a > b) begin
        eq = 1'b0;
        gt = 1'b1;
        lt = 1'b0;
    end
    else begin
        eq = 1'b0;
        gt = 1'b0;
        lt = 1'b1;
    end
end

endmodule

module testbench;
    reg [1:0] a;
    reg [1:0] b;
    wire eq, gt, lt;
    
    comparator_2bit dut (
        .a(a),
        .b(b),
        .eq(eq),
        .gt(gt),
        .lt(lt)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        // Test all combinations
        a = 2'b00; b = 2'b00; #10;
        a = 2'b00; b = 2'b01; #10;
        a = 2'b00; b = 2'b10; #10;
        a = 2'b00; b = 2'b11; #10;
        a = 2'b01; b = 2'b00; #10;
        a = 2'b01; b = 2'b01; #10;
        a = 2'b01; b = 2'b10; #10;
        a = 2'b01; b = 2'b11; #10;
        a = 2'b10; b = 2'b00; #10;
        a = 2'b10; b = 2'b01; #10;
        a = 2'b10; b = 2'b10; #10;
        a = 2'b10; b = 2'b11; #10;
        a = 2'b11; b = 2'b00; #10;
        a = 2'b11; b = 2'b01; #10;
        a = 2'b11; b = 2'b10; #10;
        a = 2'b11; b = 2'b11; #10;
        
        $finish;
    end
    
    initial begin
        $monitor(""Time=%0t a=%b b=%b eq=%b gt=%b lt=%b"",
                 $time, a, b, eq, gt, lt);
    end
endmodule",True,73,True,True,True,False,0.4,False,11.667264699935913,8.165016889572144,"Design a 2-bit comparator with inputs a[1:0], b[1:0] and outputs eq, gt, lt. Include testbench.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph LR
    A[a1:a0] --> COMP((2-bit Comparator))
    B[b1:b0] --> COMP
    COMP --> EQ[eq]
    COMP --> GT[gt]
    COMP --> LT[lt]
    TB[Testbench] -.-> |Test Vectors| A
    TB -.-> |Test Vectors| B
    TB -.-> |Verify| EQ
    TB -.-> |Verify| GT
    TB -.-> |Verify| LT
    COMP --> |a=b| EQ
    COMP --> |a>b| GT
    COMP --> |a<b| LT
    A --> |a[1]| COMP
    A --> |a[0]| COMP
    B --> |b[1]| COMP
    B --> |b[0]| COMP
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module comparator_2bit(
    input wire [1:0] a,
    input wire [1:0] b,
    output reg eq,
    output reg gt,
    output reg lt
);

always @(*) begin
    eq = (a == b);
    gt = (a > b);
    lt = (a < b);
end

endmodule

module testbench;
    reg [1:0] a;
    reg [1:0] b;
    wire eq, gt, lt;

    comparator_2bit dut(
        .a(a),
        .b(b),
        .eq(eq),
        .gt(gt),
        .lt(lt)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        // Test all combinations
        a = 2'b00; b = 2'b00; #10;
        a = 2'b00; b = 2'b01; #10;
        a = 2'b00; b = 2'b10; #10;
        a = 2'b00; b = 2'b11; #10;
        a = 2'b01; b = 2'b00; #10;
        a = 2'b01; b = 2'b01; #10;
        a = 2'b01; b = 2'b10; #10;
        a = 2'b01; b = 2'b11; #10;
        a = 2'b10; b = 2'b00; #10;
        a = 2'b10; b = 2'b01; #10;
        a = 2'b10; b = 2'b10; #10;
        a = 2'b10; b = 2'b11; #10;
        a = 2'b11; b = 2'b00; #10;
        a = 2'b11; b = 2'b01; #10;
        a = 2'b11; b = 2'b10; #10;
        a = 2'b11; b = 2'b11; #10;

        $finish;
    end

    initial begin
        $monitor(""Time=%0t a=%b b=%b eq=%b gt=%b lt=%b"",
                 $time, a, b, eq, gt, lt);
    end
endmodule",True,61,True,True,True,False,0.4,False,7.046471357345581,6.034769058227539,tie,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,Combinational,simple,"Design a 2-bit comparator with inputs a[1:0], b[1:0] and outputs eq, gt, lt. Include testbench.",gpt-4o,"`timescale 1ns/1ps

module comparator_2bit(
    input wire [1:0] a,
    input wire [1:0] b,
    output reg eq,
    output reg gt,
    output reg lt
);

always @(*) begin
    if (a == b) begin
        eq = 1'b1;
        gt = 1'b0;
        lt = 1'b0;
    end else if (a > b) begin
        eq = 1'b0;
        gt = 1'b1;
        lt = 1'b0;
    end else begin
        eq = 1'b0;
        gt = 1'b0;
        lt = 1'b1;
    end
end

endmodule

module testbench;
    reg [1:0] a, b;
    wire eq, gt, lt;
    
    comparator_2bit dut (
        .a(a),
        .b(b),
        .eq(eq),
        .gt(gt),
        .lt(lt)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        a = 2'b00; b = 2'b00;
        #10 a = 2'b01; b = 2'b00;
        #10 a = 2'b10; b = 2'b01;
        #10 a = 2'b11; b = 2'b10;
        #10 a = 2'b11; b = 2'b11;
        #10 a = 2'b10; b = 2'b11;
        #10 a = 2'b01; b = 2'b10;
        #10 a = 2'b00; b = 2'b01;
        #10 $finish;
    end
    
    initial begin
        $monitor(""Time=%0t a=%b b=%b eq=%b gt=%b lt=%b"", 
                 $time, a, b, eq, gt, lt);
    end
endmodule",True,60,True,True,True,False,0.4,False,4.521495819091797,8.1786630153656,"graph LR
    A[a[1:0] Input] --> CMP(Comparator)
    B[b[1:0] Input] --> CMP
    CMP --> EQ[eq Output]
    CMP --> GT[gt Output]
    CMP --> LT[lt Output]

    subgraph Testbench
        TB_CLK[Clock] --> TB[Comparator Testbench]
        TB_RST[Reset] --> TB
        TB --> A
        TB --> B
        EQ --> TB
        GT --> TB
        LT --> TB
    end","`timescale 1ns/1ps

module comparator(
    input wire [1:0] a,
    input wire [1:0] b,
    output reg eq,
    output reg gt,
    output reg lt
);

always @(*) begin
    if (a == b) begin
        eq = 1'b1;
        gt = 1'b0;
        lt = 1'b0;
    end else if (a > b) begin
        eq = 1'b0;
        gt = 1'b1;
        lt = 1'b0;
    end else begin
        eq = 1'b0;
        gt = 1'b0;
        lt = 1'b1;
    end
end

endmodule

module testbench;
    reg [1:0] a, b;
    wire eq, gt, lt;
    reg clk, rst;

    comparator dut (
        .a(a),
        .b(b),
        .eq(eq),
        .gt(gt),
        .lt(lt)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 1'b0;
        rst = 1'b0;
        a = 2'b00;
        b = 2'b00;

        #20 rst = 1'b1;
        #10 a = 2'b01; b = 2'b10;
        #10 a = 2'b10; b = 2'b01;
        #10 a = 2'b11; b = 2'b11;
        #50 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t a=%b b=%b eq=%b gt=%b lt=%b"", 
                 $time, a, b, eq, gt, lt);
    end
endmodule",True,64,True,True,True,False,0.4,False,7.4638917446136475,6.816079139709473,"Design a 2-bit comparator with inputs a[1:0], b[1:0] and outputs eq, gt, lt. Include testbench.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph LR
    A[a[1:0] Input] --> CMP(Comparator)
    B[b[1:0] Input] --> CMP
    CMP --> EQ[eq Output]
    CMP --> GT[gt Output]
    CMP --> LT[lt Output]

    subgraph Testbench
        TB_CLK[Clock] --> TB[Comparator Testbench]
        TB_RST[Reset] --> TB
        TB --> A
        TB --> B
        EQ --> TB
        GT --> TB
        LT --> TB
    end
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module comparator(
    input wire [1:0] a,
    input wire [1:0] b,
    output reg eq,
    output reg gt,
    output reg lt
);

always @(*) begin
    if (a == b) begin
        eq = 1'b1;
        gt = 1'b0;
        lt = 1'b0;
    end else if (a > b) begin
        eq = 1'b0;
        gt = 1'b1;
        lt = 1'b0;
    end else begin
        eq = 1'b0;
        gt = 1'b0;
        lt = 1'b1;
    end
end

endmodule

module testbench;
    reg [1:0] a, b;
    wire eq, gt, lt;
    reg clk, rst;

    comparator dut (
        .a(a),
        .b(b),
        .eq(eq),
        .gt(gt),
        .lt(lt)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 1'b0;
        rst = 1'b0;
        a = 2'b00;
        b = 2'b00;

        #10 rst = 1'b1;
        #10 a = 2'b01; b = 2'b00;
        #10 a = 2'b11; b = 2'b10;
        #10 a = 2'b10; b = 2'b10;
        #10 a = 2'b00; b = 2'b11;
        #10 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t a=%b b=%b eq=%b gt=%b lt=%b"", 
                 $time, a, b, eq, gt, lt);
    end
endmodule",True,65,True,True,True,False,0.4,False,4.369592189788818,7.926532745361328,tie,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,Arithmetic,medium,"Design a 4-bit ALU supporting ADD, SUB, AND, OR operations. Inputs: a[3:0], b[3:0], op[1:0]. Outputs: result[3:0], zero. Include testbench.",claude,"`timescale 1ns/1ps

module alu(
    input wire [3:0] a,
    input wire [3:0] b,
    input wire [1:0] op,
    output reg [3:0] result,
    output wire zero
);

always @(*) begin
    case(op)
        2'b00: result = a + b;    // ADD
        2'b01: result = a - b;    // SUB
        2'b10: result = a & b;    // AND
        2'b11: result = a | b;    // OR
        default: result = 4'b0000;
    endcase
end

assign zero = (result == 4'b0000);

endmodule

module testbench;
    reg [3:0] a, b;
    reg [1:0] op;
    wire [3:0] result;
    wire zero;
    
    alu dut (
        .a(a),
        .b(b),
        .op(op),
        .result(result),
        .zero(zero)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        // Test ADD
        a = 4'b0011; b = 4'b0010; op = 2'b00;
        #10;
        
        // Test SUB
        a = 4'b0011; b = 4'b0011; op = 2'b01;
        #10;
        
        // Test AND
        a = 4'b1111; b = 4'b0011; op = 2'b10;
        #10;
        
        // Test OR
        a = 4'b1100; b = 4'b0011; op = 2'b11;
        #10;
        
        $finish;
    end
    
    initial begin
        $monitor(""Time=%0t a=%b b=%b op=%b result=%b zero=%b"",
                 $time, a, b, op, result, zero);
    end
endmodule",True,66,True,True,True,False,0.4,False,6.664813280105591,5.705673456192017,"graph LR
    A[a_input 3:0] --> ALU((ALU Core))
    B[b_input 3:0] --> ALU
    OP[op_sel 1:0] --> ALU
    CLK[Clock] --> TB[[Testbench]]
    RST[Reset] --> TB
    
    ALU --> RES[result 3:0]
    ALU --> ZERO[zero]
    
    subgraph ALU_OPS{ALU Operations}
        ADD((ADD))
        SUB((SUB))
        AND((AND))
        OR((OR))
    end
    
    ALU_OPS -.-> ALU
    
    TB --> A
    TB --> B
    TB --> OP
    RES --> TB
    ZERO --> TB
    
    subgraph CTRL{Control Logic}
        OP --> |00|ADD
        OP --> |01|SUB
        OP --> |10|AND
        OP --> |11|OR
    end","`timescale 1ns/1ps

module alu(
    input wire clk,
    input wire rst_n,
    input wire [3:0] a_input,
    input wire [3:0] b_input,
    input wire [1:0] op_sel,
    output reg [3:0] result,
    output reg zero
);

always @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
        result <= 4'b0000;
        zero <= 1'b0;
    end
    else begin
        case (op_sel)
            2'b00: result <= a_input + b_input;
            2'b01: result <= a_input - b_input;
            2'b10: result <= a_input & b_input;
            2'b11: result <= a_input | b_input;
            default: result <= 4'b0000;
        endcase
        zero <= (result == 4'b0000);
    end
end

endmodule

module testbench;
    reg clk, rst_n;
    reg [3:0] a_input, b_input;
    reg [1:0] op_sel;
    wire [3:0] result;
    wire zero;

    alu dut (
        .clk(clk),
        .rst_n(rst_n),
        .a_input(a_input),
        .b_input(b_input),
        .op_sel(op_sel),
        .result(result),
        .zero(zero)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 0;
        rst_n = 0;
        a_input = 0;
        b_input = 0;
        op_sel = 0;
        
        #10 rst_n = 1;
        
        // Test ADD
        #10 a_input = 4'h5; b_input = 4'h3; op_sel = 2'b00;
        
        // Test SUB
        #10 a_input = 4'h7; b_input = 4'h4; op_sel = 2'b01;
        
        // Test AND
        #10 a_input = 4'hF; b_input = 4'h3; op_sel = 2'b10;
        
        // Test OR
        #10 a_input = 4'h5; b_input = 4'hA; op_sel = 2'b11;
        
        #10 rst_n = 0;
        #10 rst_n = 1;
        #10 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t rst_n=%b op=%b a=%h b=%h result=%h zero=%b"",
                 $time, rst_n, op_sel, a_input, b_input, result, zero);
    end
endmodule",True,84,True,True,True,False,0.4,False,12.715473890304565,8.066789388656616,"Design a 4-bit ALU supporting ADD, SUB, AND, OR operations. Inputs: a[3:0], b[3:0], op[1:0]. Outputs: result[3:0], zero. Include testbench.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph LR
    A[a_input 3:0] --> ALU((ALU Core))
    B[b_input 3:0] --> ALU
    OP[op_sel 1:0] --> ALU
    CLK[Clock] --> TB[[Testbench]]
    RST[Reset] --> TB
    
    ALU --> RES[result 3:0]
    ALU --> ZERO[zero]
    
    subgraph ALU_OPS{ALU Operations}
        ADD((ADD))
        SUB((SUB))
        AND((AND))
        OR((OR))
    end
    
    ALU_OPS -.-> ALU
    
    TB --> A
    TB --> B
    TB --> OP
    RES --> TB
    ZERO --> TB
    
    subgraph CTRL{Control Logic}
        OP --> |00|ADD
        OP --> |01|SUB
        OP --> |10|AND
        OP --> |11|OR
    end
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module alu(
    input wire [3:0] a_input,
    input wire [3:0] b_input,
    input wire [1:0] op_sel,
    output reg [3:0] result,
    output wire zero
);

assign zero = (result == 4'b0000);

always @(*) begin
    case(op_sel)
        2'b00: result = a_input + b_input;    // ADD
        2'b01: result = a_input - b_input;    // SUB
        2'b10: result = a_input & b_input;    // AND
        2'b11: result = a_input | b_input;    // OR
        default: result = 4'b0000;
    endcase
end

endmodule

module testbench;
    reg [3:0] a_input;
    reg [3:0] b_input;
    reg [1:0] op_sel;
    reg clk;
    reg rst;
    wire [3:0] result;
    wire zero;

    alu dut(
        .a_input(a_input),
        .b_input(b_input),
        .op_sel(op_sel),
        .result(result),
        .zero(zero)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 0;
        rst = 1;
        a_input = 0;
        b_input = 0;
        op_sel = 0;

        #10 rst = 0;

        // Test ADD
        #10 a_input = 4'b0011; b_input = 4'b0010; op_sel = 2'b00;
        
        // Test SUB
        #10 a_input = 4'b0111; b_input = 4'b0011; op_sel = 2'b01;
        
        // Test AND
        #10 a_input = 4'b1111; b_input = 4'b0011; op_sel = 2'b10;
        
        // Test OR
        #10 a_input = 4'b1100; b_input = 4'b0011; op_sel = 2'b11;
        
        // Test zero flag
        #10 a_input = 4'b0000; b_input = 4'b0000; op_sel = 2'b00;

        #10 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t op_sel=%b a=%b b=%b result=%b zero=%b"",
                 $time, op_sel, a_input, b_input, result, zero);
    end

endmodule",True,79,True,True,True,False,0.4,False,8.667042970657349,6.364039182662964,tie,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,Arithmetic,medium,"Design a 4-bit ALU supporting ADD, SUB, AND, OR operations. Inputs: a[3:0], b[3:0], op[1:0]. Outputs: result[3:0], zero. Include testbench.",gpt-4o,"`timescale 1ns/1ps

module alu(
    input wire [3:0] a,
    input wire [3:0] b,
    input wire [1:0] op,
    output reg [3:0] result,
    output reg zero
);

always @(*) begin
    case(op)
        2'b00: result = a + b;   // ADD
        2'b01: result = a - b;   // SUB
        2'b10: result = a & b;   // AND
        2'b11: result = a | b;   // OR
        default: result = 4'b0000;
    endcase
    zero = (result == 4'b0000);
end

endmodule

module testbench;
    reg [3:0] a, b;
    reg [1:0] op;
    wire [3:0] result;
    wire zero;

    alu dut (
        .a(a),
        .b(b),
        .op(op),
        .result(result),
        .zero(zero)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        a = 4'b0000; b = 4'b0000; op = 2'b00;
        #10 a = 4'b0011; b = 4'b0001; op = 2'b00; // ADD
        #10 a = 4'b0011; b = 4'b0001; op = 2'b01; // SUB
        #10 a = 4'b0011; b = 4'b0101; op = 2'b10; // AND
        #10 a = 4'b0011; b = 4'b0101; op = 2'b11; // OR
        #10 a = 4'b0001; b = 4'b0001; op = 2'b01; // Result should be zero
        #10 $finish;
    end

    initial begin
        $monitor(""Time=%0t a=%b b=%b op=%b result=%b zero=%b"", 
                 $time, a, b, op, result, zero);
    end
endmodule",True,55,True,True,True,False,0.4,False,4.924435377120972,5.216399908065796,"graph LR
    a[a[3:0]] --> ALU
    b[b[3:0]] --> ALU
    op[op[1:0]] --> ALU
    ALU((4-bit ALU)) --> result[result[3:0]]
    ALU --> zero[zero]
    subgraph TESTBENCH
        TB_a[a[3:0]]
        TB_b[b[3:0]]
        TB_op[op[1:0]]
        TB_result[result[3:0]]
        TB_zero[zero]
        TB_CLK[Clock]
        TB_RST[Reset]
        TB_a --> ALU
        TB_b --> ALU
        TB_op --> ALU
        TB_CLK --> ALU
        TB_RST --> ALU
        result --> TB_result
        zero --> TB_zero
    end","`timescale 1ns/1ps

module alu(
    input wire [3:0] a,
    input wire [3:0] b,
    input wire [1:0] op,
    input wire clk,
    input wire rst_n,
    output reg [3:0] result,
    output reg zero
);

always @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
        result <= 4'b0000;
        zero <= 1'b0;
    end else begin
        case (op)
            2'b00: result <= a + b;
            2'b01: result <= a - b;
            2'b10: result <= a & b;
            2'b11: result <= a | b;
            default: result <= 4'b0000;
        endcase
        zero <= (result == 4'b0000);
    end
end

endmodule

module testbench;
    reg [3:0] a, b;
    reg [1:0] op;
    reg clk, rst_n;
    wire [3:0] result;
    wire zero;
    
    alu dut (
        .a(a),
        .b(b),
        .op(op),
        .clk(clk),
        .rst_n(rst_n),
        .result(result),
        .zero(zero)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst_n = 1'b0;
        a = 4'b0000;
        b = 4'b0000;
        op = 2'b00;
        
        #20 rst_n = 1'b1;
        #10 a = 4'b0011; b = 4'b0001; op = 2'b00; // Add
        #10 a = 4'b0100; b = 4'b0010; op = 2'b01; // Subtract
        #10 a = 4'b1100; b = 4'b1010; op = 2'b10; // AND
        #10 a = 4'b1100; b = 4'b1010; op = 2'b11; // OR
        #50 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t a=%b b=%b op=%b result=%b zero=%b"", 
                 $time, a, b, op, result, zero);
    end
endmodule",True,72,True,True,True,False,0.4,False,10.649894952774048,9.192128658294678,"Design a 4-bit ALU supporting ADD, SUB, AND, OR operations. Inputs: a[3:0], b[3:0], op[1:0]. Outputs: result[3:0], zero. Include testbench.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph LR
    a[a[3:0]] --> ALU
    b[b[3:0]] --> ALU
    op[op[1:0]] --> ALU
    ALU((4-bit ALU)) --> result[result[3:0]]
    ALU --> zero[zero]
    subgraph TESTBENCH
        TB_a[a[3:0]]
        TB_b[b[3:0]]
        TB_op[op[1:0]]
        TB_result[result[3:0]]
        TB_zero[zero]
        TB_CLK[Clock]
        TB_RST[Reset]
        TB_a --> ALU
        TB_b --> ALU
        TB_op --> ALU
        TB_CLK --> ALU
        TB_RST --> ALU
        result --> TB_result
        zero --> TB_zero
    end
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module alu(
    input wire [3:0] a,
    input wire [3:0] b,
    input wire [1:0] op,
    output reg [3:0] result,
    output reg zero
);

always @(*) begin
    case(op)
        2'b00: result = a + b;    // ADD
        2'b01: result = a - b;    // SUB
        2'b10: result = a & b;    // AND
        2'b11: result = a | b;    // OR
        default: result = 4'b0000;
    endcase
    zero = (result == 4'b0000);
end

endmodule

module testbench;
    reg [3:0] TB_a;
    reg [3:0] TB_b;
    reg [1:0] TB_op;
    wire [3:0] TB_result;
    wire TB_zero;
    reg TB_CLK, TB_RST;

    alu dut (
        .a(TB_a),
        .b(TB_b),
        .op(TB_op),
        .result(TB_result),
        .zero(TB_zero)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        TB_a = 4'b0000;
        TB_b = 4'b0000;
        TB_op = 2'b00;
        TB_CLK = 1'b0;
        TB_RST = 1'b0;

        #20 TB_RST = 1'b1;
        #10 TB_a = 4'b0011; TB_b = 4'b0001; TB_op = 2'b00; // Test ADD
        #10 TB_a = 4'b0100; TB_b = 4'b0001; TB_op = 2'b01; // Test SUB
        #10 TB_a = 4'b0011; TB_b = 4'b0101; TB_op = 2'b10; // Test AND
        #10 TB_a = 4'b0011; TB_b = 4'b0101; TB_op = 2'b11; // Test OR
        #10 $finish;
    end

    always #5 TB_CLK = ~TB_CLK;

    initial begin
        $monitor(""Time=%0t a=%b b=%b op=%b result=%b zero=%b"", 
                 $time, TB_a, TB_b, TB_op, TB_result, TB_zero);
    end
endmodule",True,64,True,True,True,False,0.4,False,7.062194108963013,8.260209560394287,tie,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,Combinational,medium,"Create an 8:1 multiplexer with input data[7:0], select sel[2:0], and output out. Include testbench.",claude,"`timescale 1ns/1ps

module mux8to1(
    input wire [7:0] data,
    input wire [2:0] sel,
    output reg out
);

always @(*) begin
    case (sel)
        3'b000: out = data[0];
        3'b001: out = data[1];
        3'b010: out = data[2];
        3'b011: out = data[3];
        3'b100: out = data[4];
        3'b101: out = data[5];
        3'b110: out = data[6];
        3'b111: out = data[7];
        default: out = 1'b0;
    endcase
end

endmodule

module testbench;
    reg [7:0] data;
    reg [2:0] sel;
    wire out;
    
    mux8to1 dut (
        .data(data),
        .sel(sel),
        .out(out)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        data = 8'b10101010;
        
        sel = 3'b000;
        #10;
        sel = 3'b001;
        #10;
        sel = 3'b010;
        #10;
        sel = 3'b011;
        #10;
        sel = 3'b100;
        #10;
        sel = 3'b101;
        #10;
        sel = 3'b110;
        #10;
        sel = 3'b111;
        #10;
        
        $finish;
    end
    
    initial begin
        $monitor(""Time=%0t data=%b sel=%b out=%b"", 
                 $time, data, sel, out);
    end
endmodule",True,66,True,True,True,False,0.4,False,5.6631529331207275,6.873729228973389,"graph LR
    D0[Data[0]] --> MUX
    D1[Data[1]] --> MUX
    D2[Data[2]] --> MUX
    D3[Data[3]] --> MUX
    D4[Data[4]] --> MUX
    D5[Data[5]] --> MUX
    D6[Data[6]] --> MUX
    D7[Data[7]] --> MUX
    SEL0[Sel[0]] --> MUX{8:1 MUX}
    SEL1[Sel[1]] --> MUX
    SEL2[Sel[2]] --> MUX
    MUX --> OUT[Out]
    TB[[Testbench]]
    TB --> D0
    TB --> D1
    TB --> D2
    TB --> D3
    TB --> D4
    TB --> D5
    TB --> D6
    TB --> D7
    TB --> SEL0
    TB --> SEL1
    TB --> SEL2","`timescale 1ns/1ps

module mux8to1(
    input wire clk,
    input wire rst_n,
    input wire [7:0] data,
    input wire [2:0] sel,
    output reg out
);

always @(posedge clk or negedge rst_n) begin
    if (!rst_n)
        out <= 1'b0;
    else
        case (sel)
            3'b000: out <= data[0];
            3'b001: out <= data[1];
            3'b010: out <= data[2];
            3'b011: out <= data[3];
            3'b100: out <= data[4];
            3'b101: out <= data[5];
            3'b110: out <= data[6];
            3'b111: out <= data[7];
            default: out <= 1'b0;
        endcase
end

endmodule

module testbench;
    reg clk, rst_n;
    reg [7:0] data;
    reg [2:0] sel;
    wire out;
    
    mux8to1 dut (
        .clk(clk),
        .rst_n(rst_n),
        .data(data),
        .sel(sel),
        .out(out)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 0;
        rst_n = 0;
        data = 8'b10101010;
        sel = 3'b000;
        
        #10 rst_n = 1;
        
        #10 sel = 3'b001;
        #10 sel = 3'b010;
        #10 sel = 3'b011;
        #10 sel = 3'b100;
        #10 sel = 3'b101;
        #10 sel = 3'b110;
        #10 sel = 3'b111;
        
        #10 data = 8'b11001100;
        
        #10 sel = 3'b000;
        #10 sel = 3'b001;
        #10 sel = 3'b010;
        #10 sel = 3'b011;
        
        #10 rst_n = 0;
        #10 rst_n = 1;
        
        #10 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t rst_n=%b data=%b sel=%b out=%b"",
                 $time, rst_n, data, sel, out);
    end
endmodule",True,82,True,True,True,True,0.7,True,11.459935188293457,6.967705726623535,"Create an 8:1 multiplexer with input data[7:0], select sel[2:0], and output out. Include testbench.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph LR
    D0[Data[0]] --> MUX
    D1[Data[1]] --> MUX
    D2[Data[2]] --> MUX
    D3[Data[3]] --> MUX
    D4[Data[4]] --> MUX
    D5[Data[5]] --> MUX
    D6[Data[6]] --> MUX
    D7[Data[7]] --> MUX
    SEL0[Sel[0]] --> MUX{8:1 MUX}
    SEL1[Sel[1]] --> MUX
    SEL2[Sel[2]] --> MUX
    MUX --> OUT[Out]
    TB[[Testbench]]
    TB --> D0
    TB --> D1
    TB --> D2
    TB --> D3
    TB --> D4
    TB --> D5
    TB --> D6
    TB --> D7
    TB --> SEL0
    TB --> SEL1
    TB --> SEL2
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module mux8to1(
    input wire [7:0] data,
    input wire [2:0] sel,
    output reg out
);

always @(*) begin
    case(sel)
        3'b000: out = data[0];
        3'b001: out = data[1];
        3'b010: out = data[2];
        3'b011: out = data[3];
        3'b100: out = data[4];
        3'b101: out = data[5];
        3'b110: out = data[6];
        3'b111: out = data[7];
        default: out = data[0];
    endcase
end

endmodule

module testbench;
    reg [7:0] data;
    reg [2:0] sel;
    wire out;

    mux8to1 dut(
        .data(data),
        .sel(sel),
        .out(out)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        data = 8'b10101010;
        sel = 3'b000;
        #10;

        for(sel = 0; sel < 8; sel = sel + 1) begin
            #10;
        end

        data = 8'b11110000;
        sel = 3'b000;
        #10;

        for(sel = 0; sel < 8; sel = sel + 1) begin
            #10;
        end

        #10 $finish;
    end

    initial begin
        $monitor(""Time=%0t data=%b sel=%b out=%b"", 
                 $time, data, sel, out);
    end

endmodule",True,64,True,False,False,,0.0,,5.951965093612671,62.39730215072632,prompt_only,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,Combinational,medium,"Create an 8:1 multiplexer with input data[7:0], select sel[2:0], and output out. Include testbench.",gpt-4o,"`timescale 1ns/1ps

module mux8to1(
    input wire [7:0] data,
    input wire [2:0] sel,
    output reg out
);

always @(*) begin
    case (sel)
        3'b000: out = data[0];
        3'b001: out = data[1];
        3'b010: out = data[2];
        3'b011: out = data[3];
        3'b100: out = data[4];
        3'b101: out = data[5];
        3'b110: out = data[6];
        3'b111: out = data[7];
        default: out = 1'b0;
    endcase
end

endmodule

module testbench;
    reg [7:0] data;
    reg [2:0] sel;
    wire out;
    
    mux8to1 dut (
        .data(data),
        .sel(sel),
        .out(out)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        data = 8'b10101010;
        sel = 3'b000;
        
        #10 sel = 3'b001;
        #10 sel = 3'b010;
        #10 sel = 3'b011;
        #10 sel = 3'b100;
        #10 sel = 3'b101;
        #10 sel = 3'b110;
        #10 sel = 3'b111;
        #10 $finish;
    end
    
    initial begin
        $monitor(""Time=%0t sel=%b out=%b"", $time, sel, out);
    end
endmodule",True,56,True,True,True,False,0.4,False,4.372917890548706,10.925446033477783,"graph TD
    CLK[Clock]
    RST[Reset]
    DATA[Input Data (data[7:0])] --> MUX{8:1 Multiplexer}
    SEL[Select Lines (sel[2:0])] --> MUX
    MUX --> OUT[Output (out)]
    CLK --> MUX
    RST --> MUX

    subgraph Testbench
        TB_CLK[Clock] --> CLK
        TB_RST[Reset] --> RST
        TB_DATA[Test Data (test_data[7:0])] --> DATA
        TB_SEL[Test Select (test_sel[2:0])] --> SEL
        OUT --> TB_OUT[Observed Output]
    end","`timescale 1ns/1ps

module multiplexer(
    input wire clk,
    input wire rst,
    input wire [7:0] data,
    input wire [2:0] sel,
    output reg [7:0] out
);

always @(posedge clk or posedge rst) begin
    if (rst)
        out <= 8'b0;
    else begin
        case (sel)
            3'b000: out <= data;
            3'b001: out <= data;
            3'b010: out <= data;
            3'b011: out <= data;
            3'b100: out <= data;
            3'b101: out <= data;
            3'b110: out <= data;
            3'b111: out <= data;
            default: out <= 8'b0;
        endcase
    end
end

endmodule

module testbench;
    reg tb_clk, tb_rst;
    reg [7:0] test_data;
    reg [2:0] test_sel;
    wire [7:0] tb_out;
    
    multiplexer dut (
        .clk(tb_clk),
        .rst(tb_rst),
        .data(test_data),
        .sel(test_sel),
        .out(tb_out)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        tb_clk = 1'b0;
        tb_rst = 1'b1;
        test_data = 8'b0;
        test_sel = 3'b0;
        
        #20 tb_rst = 1'b0;
        
        #10 test_data = 8'b10101010; test_sel = 3'b010;
        #10 test_sel = 3'b101;
        #10 test_sel = 3'b111;
        
        #50 $finish;
    end
    
    always #5 tb_clk = ~tb_clk;
    
    initial begin
        $monitor(""Time=%0t tb_clk=%b tb_rst=%b test_data=%b test_sel=%b tb_out=%b"", 
                 $time, tb_clk, tb_rst, test_data, test_sel, tb_out);
    end
endmodule",True,69,True,True,True,True,0.7,True,10.276241779327393,9.311743021011353,"Create an 8:1 multiplexer with input data[7:0], select sel[2:0], and output out. Include testbench.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph TD
    CLK[Clock]
    RST[Reset]
    DATA[Input Data (data[7:0])] --> MUX{8:1 Multiplexer}
    SEL[Select Lines (sel[2:0])] --> MUX
    MUX --> OUT[Output (out)]
    CLK --> MUX
    RST --> MUX

    subgraph Testbench
        TB_CLK[Clock] --> CLK
        TB_RST[Reset] --> RST
        TB_DATA[Test Data (test_data[7:0])] --> DATA
        TB_SEL[Test Select (test_sel[2:0])] --> SEL
        OUT --> TB_OUT[Observed Output]
    end
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module multiplexer_8to1(
    input wire clk,
    input wire rst,
    input wire [7:0] data,
    input wire [2:0] sel,
    output reg out
);

always @(posedge clk or posedge rst) begin
    if (rst)
        out <= 1'b0;
    else begin
        case (sel)
            3'b000: out <= data[0];
            3'b001: out <= data[1];
            3'b010: out <= data[2];
            3'b011: out <= data[3];
            3'b100: out <= data[4];
            3'b101: out <= data[5];
            3'b110: out <= data[6];
            3'b111: out <= data[7];
            default: out <= 1'b0;
        endcase
    end
end

endmodule

module testbench;
    reg tb_clk;
    reg tb_rst;
    reg [7:0] test_data;
    reg [2:0] test_sel;
    wire tb_out;
    
    multiplexer_8to1 dut (
        .clk(tb_clk),
        .rst(tb_rst),
        .data(test_data),
        .sel(test_sel),
        .out(tb_out)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        tb_clk = 1'b0;
        tb_rst = 1'b1;
        test_data = 8'b00000000;
        test_sel = 3'b000;
        
        #10 tb_rst = 1'b0;
        #10 test_data = 8'b10101010; test_sel = 3'b000;
        #10 test_sel = 3'b001;
        #10 test_sel = 3'b010;
        #10 test_sel = 3'b011;
        #10 test_sel = 3'b100;
        #10 test_sel = 3'b101;
        #10 test_sel = 3'b110;
        #10 test_sel = 3'b111;
        #10 $finish;
    end
    
    always #5 tb_clk = ~tb_clk;
    
    initial begin
        $monitor(""Time=%0t tb_clk=%b tb_rst=%b test_data=%b test_sel=%b tb_out=%b"", 
                 $time, tb_clk, tb_rst, test_data, test_sel, tb_out);
    end
endmodule",True,73,True,True,True,True,0.7,True,11.11998462677002,7.8983681201934814,prompt_only,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,State Machine,medium,Design an FSM detecting pattern 1011 in serial input with overlapping detection. Include testbench with sequence: 10110111011.,claude,"`timescale 1ns/1ps

module pattern_detector(
    input wire clk,
    input wire rst_n,
    input wire data_in,
    output reg pattern_found
);

reg [2:0] state;
reg [2:0] next_state;

parameter S0 = 3'b000;
parameter S1 = 3'b001;
parameter S2 = 3'b010;
parameter S3 = 3'b011;
parameter S4 = 3'b100;

always @(posedge clk or negedge rst_n) begin
    if (!rst_n)
        state <= S0;
    else
        state <= next_state;
end

always @(*) begin
    next_state = state;
    case (state)
        S0: next_state = (data_in) ? S1 : S0;
        S1: next_state = (data_in) ? S1 : S2;
        S2: next_state = (data_in) ? S3 : S0;
        S3: next_state = (data_in) ? S4 : S2;
        S4: next_state = (data_in) ? S1 : S2;
        default: next_state = S0;
    endcase
end

always @(posedge clk or negedge rst_n) begin
    if (!rst_n)
        pattern_found <= 1'b0;
    else
        pattern_found <= (state == S3 && data_in == 1'b1);
end

endmodule

module testbench;
    reg clk;
    reg rst_n;
    reg data_in;
    wire pattern_found;
    
    pattern_detector dut (
        .clk(clk),
        .rst_n(rst_n),
        .data_in(data_in),
        .pattern_found(pattern_found)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 0;
        rst_n = 0;
        data_in = 0;
        
        #10 rst_n = 1;
        
        // Test sequence: 10110111011
        #10 data_in = 1;
        #10 data_in = 0;
        #10 data_in = 1;
        #10 data_in = 1;
        #10 data_in = 0;
        #10 data_in = 1;
        #10 data_in = 1;
        #10 data_in = 1;
        #10 data_in = 0;
        #10 data_in = 1;
        #10 data_in = 1;
        
        #20 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t rst_n=%b data_in=%b pattern_found=%b"",
                 $time, rst_n, data_in, pattern_found);
    end
endmodule",True,92,True,True,True,False,0.3,False,9.03289270401001,6.746225595474243,"graph TD
    CLK[Clock Input] --> FSM((FSM Core))
    RST[Reset] --> FSM
    DIN[Serial Input] --> FSM
    FSM --> DOUT[Pattern Detect Out]
    
    TBGEN[[Test Sequence: 10110111011]] --> DIN
    
    S0((State: IDLE)) --> |1| S1
    S1((State: Got1)) --> |0| S2
    S2((State: Got10)) --> |1| S3
    S3((State: Got101)) --> |1| S4
    S4((State: Got1011)) --> |1| S1
    S4 --> |0| S2
    S3 --> |0| S2
    S2 --> |1| S1
    S1 --> |1| S1
    S0 --> |0| S0","`timescale 1ns/1ps

module pattern_detect(
    input wire clk,
    input wire rst,
    input wire din,
    output reg dout
);

// State encoding
parameter IDLE    = 3'b000;
parameter GOT1    = 3'b001;
parameter GOT10   = 3'b010;
parameter GOT101  = 3'b011;
parameter GOT1011 = 3'b100;

reg [2:0] state, next_state;

// State register
always @(posedge clk or posedge rst) begin
    if (rst)
        state <= IDLE;
    else
        state <= next_state;
end

// Next state logic
always @(*) begin
    case (state)
        IDLE: begin
            next_state = (din) ? GOT1 : IDLE;
        end
        GOT1: begin
            next_state = (din) ? GOT1 : GOT10;
        end
        GOT10: begin
            next_state = (din) ? GOT1 : GOT10;
        end
        GOT101: begin
            next_state = (din) ? GOT1011 : GOT10;
        end
        GOT1011: begin
            next_state = (din) ? GOT1 : GOT10;
        end
        default: begin
            next_state = IDLE;
        end
    endcase
end

// Output logic
always @(posedge clk or posedge rst) begin
    if (rst)
        dout <= 1'b0;
    else
        dout <= (state == GOT1011);
end

endmodule

module testbench;
    reg clk, rst, din;
    wire dout;
    
    pattern_detect dut (
        .clk(clk),
        .rst(rst),
        .din(din),
        .dout(dout)
    );
    
    // Test sequence: 10110111011
    reg [10:0] test_sequence = 11'b10110111011;
    integer i;
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 0;
        rst = 1;
        din = 0;
        
        #10 rst = 0;
        
        for(i = 10; i >= 0; i = i - 1) begin
            @(posedge clk);
            din = test_sequence[i];
        end
        
        #20 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t rst=%b din=%b dout=%b state=%d"", 
                 $time, rst, din, dout, dut.state);
    end
endmodule",True,100,True,True,True,True,0.9,True,12.591097831726074,8.189654350280762,"Design an FSM detecting pattern 1011 in serial input with overlapping detection. Include testbench with sequence: 10110111011.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph TD
    CLK[Clock Input] --> FSM((FSM Core))
    RST[Reset] --> FSM
    DIN[Serial Input] --> FSM
    FSM --> DOUT[Pattern Detect Out]
    
    TBGEN[[Test Sequence: 10110111011]] --> DIN
    
    S0((State: IDLE)) --> |1| S1
    S1((State: Got1)) --> |0| S2
    S2((State: Got10)) --> |1| S3
    S3((State: Got101)) --> |1| S4
    S4((State: Got1011)) --> |1| S1
    S4 --> |0| S2
    S3 --> |0| S2
    S2 --> |1| S1
    S1 --> |1| S1
    S0 --> |0| S0
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module pattern_detect (
    input wire clk,
    input wire rst,
    input wire din,
    output reg dout
);

reg [2:0] state, next_state;

parameter IDLE = 3'd0;
parameter GOT1 = 3'd1;
parameter GOT10 = 3'd2;
parameter GOT101 = 3'd3;
parameter GOT1011 = 3'd4;

always @(posedge clk or posedge rst) begin
    if (rst)
        state <= IDLE;
    else
        state <= next_state;
end

always @(*) begin
    case (state)
        IDLE: next_state = din ? GOT1 : IDLE;
        GOT1: next_state = din ? GOT1 : GOT10;
        GOT10: next_state = din ? GOT101 : IDLE;
        GOT101: next_state = din ? GOT1011 : GOT10;
        GOT1011: next_state = din ? GOT1 : GOT10;
        default: next_state = IDLE;
    endcase
end

always @(*) begin
    dout = (state == GOT1011);
end

endmodule

module testbench;
    reg clk, rst, din;
    wire dout;
    
    pattern_detect dut (
        .clk(clk),
        .rst(rst),
        .din(din),
        .dout(dout)
    );
    
    reg [10:0] test_seq = 11'b10110111011;
    integer i;
    
    initial begin
        $dumpfile(""pattern_detect.vcd"");
        $dumpvars(0, testbench);
        
        clk = 0;
        rst = 1;
        din = 0;
        
        #10 rst = 0;
        
        for(i = 10; i >= 0; i = i - 1) begin
            din = test_seq[i];
            #10;
        end
        
        #10 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t rst=%b din=%b dout=%b state=%d"", 
                 $time, rst, din, dout, dut.state);
    end
endmodule",True,80,True,True,True,,0.0,,7.339776515960693,0.02539801597595215,prompt_only,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,State Machine,medium,Design an FSM detecting pattern 1011 in serial input with overlapping detection. Include testbench with sequence: 10110111011.,gpt-4o,"`timescale 1ns/1ps

module fsm_1011_detector(
    input wire clk,
    input wire rst_n,
    input wire serial_in,
    output reg pattern_detected
);

    typedef enum reg [2:0] {S0, S1, S2, S3, S4} state_t;
    reg [2:0] current_state, next_state;

    always @(posedge clk or negedge rst_n) begin
        if (!rst_n)
            current_state <= S0;
        else
            current_state <= next_state;
    end

    always @(*) begin
        next_state = current_state;
        pattern_detected = 1'b0;
        case (current_state)
            S0: if (serial_in) next_state = S1;
            S1: if (!serial_in) next_state = S2;
            S2: if (serial_in) next_state = S3;
            S3: if (serial_in) begin
                    next_state = S4;
                    pattern_detected = 1'b1;
                end else begin
                    next_state = S2;
                end
            S4: if (serial_in) next_state = S1;
                else next_state = S2;
            default: next_state = S0;
        endcase
    end

endmodule

module testbench;
    reg clk, rst_n, serial_in;
    wire pattern_detected;

    fsm_1011_detector dut (
        .clk(clk),
        .rst_n(rst_n),
        .serial_in(serial_in),
        .pattern_detected(pattern_detected)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 1'b0;
        rst_n = 1'b0;
        serial_in = 1'b0;

        #20 rst_n = 1'b1;
        
        // Test sequence: 10110111011
        #10 serial_in = 1'b1;
        #10 serial_in = 1'b0;
        #10 serial_in = 1'b1;
        #10 serial_in = 1'b1;
        #10 serial_in = 1'b0;
        #10 serial_in = 1'b1;
        #10 serial_in = 1'b1;
        #10 serial_in = 1'b1;
        #10 serial_in = 1'b0;
        #10 serial_in = 1'b1;
        #10 serial_in = 1'b1;
        
        #10 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b serial_in=%b pattern_detected=%b"", 
                 $time, clk, rst_n, serial_in, pattern_detected);
    end
endmodule",True,84,True,True,True,True,0.7,True,8.109901905059814,7.813251256942749,"graph LR
    CLK[Clock] --> S0((S0))
    RST[Reset] --> S0
    IN[Serial Input] --> S0
    S0 -- ""1"" --> S1((S1))
    S0 -- ""0"" --> S0
    S1 -- ""0"" --> S2((S2))
    S1 -- ""1"" --> S1
    S2 -- ""1"" --> S3((S3))
    S2 -- ""0"" --> S0
    S3 -- ""1"" --> S4((S4))
    S3 -- ""0"" --> S2
    S4 -- ""1"" --> S1
    S4 -- ""0"" --> S2
    S4 --> OUT[Pattern Detected]
    CLK --> S1
    CLK --> S2
    CLK --> S3
    CLK --> S4
    RST --> S1
    RST --> S2
    RST --> S3
    RST --> S4","`timescale 1ns/1ps

module pattern_detector(
    input wire clk,
    input wire rst,
    input wire serial_in,
    output reg pattern_detected
);

    // State encoding
    typedef enum reg [2:0] {
        S0 = 3'b000,
        S1 = 3'b001,
        S2 = 3'b010,
        S3 = 3'b011,
        S4 = 3'b100
    } state_t;

    reg [2:0] current_state, next_state;

    // State transition logic
    always @(posedge clk or posedge rst) begin
        if (rst) begin
            current_state <= S0;
        end else begin
            current_state <= next_state;
        end
    end

    // Next state logic
    always @(*) begin
        case (current_state)
            S0: if (serial_in) next_state = S1; else next_state = S0;
            S1: if (serial_in) next_state = S1; else next_state = S2;
            S2: if (serial_in) next_state = S3; else next_state = S0;
            S3: if (serial_in) next_state = S4; else next_state = S2;
            S4: if (serial_in) next_state = S1; else next_state = S2;
            default: next_state = S0;
        endcase
    end

    // Output logic
    always @(posedge clk or posedge rst) begin
        if (rst) begin
            pattern_detected <= 1'b0;
        end else begin
            if (current_state == S4)
                pattern_detected <= 1'b1;
            else
                pattern_detected <= 1'b0;
        end
    end

endmodule

module testbench;
    reg clk, rst, serial_in;
    wire pattern_detected;

    pattern_detector dut (
        .clk(clk),
        .rst(rst),
        .serial_in(serial_in),
        .pattern_detected(pattern_detected)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 1'b0;
        rst = 1'b0;
        serial_in = 1'b0;

        #15 rst = 1'b1;
        #10 rst = 1'b0;

        // Stimulus for testing
        #10 serial_in = 1'b1;
        #10 serial_in = 1'b0;
        #10 serial_in = 1'b1;
        #10 serial_in = 1'b1;
        #10 serial_in = 1'b0;
        #10 serial_in = 1'b1;
        #10 serial_in = 1'b1;
        #10 serial_in = 1'b0;
        #10 serial_in = 1'b1;
        #10 serial_in = 1'b1;
        #10 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t clk=%b rst=%b serial_in=%b pattern_detected=%b"", 
                 $time, clk, rst, serial_in, pattern_detected);
    end
endmodule",True,98,True,True,True,True,0.75,True,11.811339378356934,10.91435194015503,"Design an FSM detecting pattern 1011 in serial input with overlapping detection. Include testbench with sequence: 10110111011.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph LR
    CLK[Clock] --> S0((S0))
    RST[Reset] --> S0
    IN[Serial Input] --> S0
    S0 -- ""1"" --> S1((S1))
    S0 -- ""0"" --> S0
    S1 -- ""0"" --> S2((S2))
    S1 -- ""1"" --> S1
    S2 -- ""1"" --> S3((S3))
    S2 -- ""0"" --> S0
    S3 -- ""1"" --> S4((S4))
    S3 -- ""0"" --> S2
    S4 -- ""1"" --> S1
    S4 -- ""0"" --> S2
    S4 --> OUT[Pattern Detected]
    CLK --> S1
    CLK --> S2
    CLK --> S3
    CLK --> S4
    RST --> S1
    RST --> S2
    RST --> S3
    RST --> S4
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module fsm_1011(
    input wire clk,
    input wire rst,
    input wire serial_in,
    output reg pattern_detected
);

    typedef enum reg [2:0] {
        S0 = 3'b000,
        S1 = 3'b001,
        S2 = 3'b010,
        S3 = 3'b011,
        S4 = 3'b100
    } state_t;

    state_t current_state, next_state;

    always @(posedge clk or posedge rst) begin
        if (rst)
            current_state <= S0;
        else
            current_state <= next_state;
    end

    always @(*) begin
        next_state = current_state;
        pattern_detected = 1'b0;
        case (current_state)
            S0: begin
                if (serial_in)
                    next_state = S1;
            end
            S1: begin
                if (!serial_in)
                    next_state = S2;
            end
            S2: begin
                if (serial_in)
                    next_state = S3;
                else
                    next_state = S0;
            end
            S3: begin
                if (serial_in)
                    next_state = S4;
                else
                    next_state = S2;
            end
            S4: begin
                if (serial_in)
                    next_state = S1;
                else
                    next_state = S2;
                pattern_detected = 1'b1;
            end
            default: next_state = S0;
        endcase
    end

endmodule

module testbench;
    reg clk, rst, serial_in;
    wire pattern_detected;

    fsm_1011 dut (
        .clk(clk),
        .rst(rst),
        .serial_in(serial_in),
        .pattern_detected(pattern_detected)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 1'b0;
        rst = 1'b1;
        serial_in = 1'b0;

        #10 rst = 1'b0;
        #10 serial_in = 1'b1; // 1
        #10 serial_in = 1'b0; // 0
        #10 serial_in = 1'b1; // 1
        #10 serial_in = 1'b1; // 1
        #10 serial_in = 1'b0; // 0
        #10 serial_in = 1'b1; // 1
        #10 serial_in = 1'b1; // 1
        #10 serial_in = 1'b1; // 1
        #10 serial_in = 1'b0; // 0
        #10 serial_in = 1'b1; // 1
        #10 serial_in = 1'b1; // 1
        #10 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t clk=%b rst=%b serial_in=%b pattern_detected=%b"",
                 $time, clk, rst, serial_in, pattern_detected);
    end
endmodule",True,104,True,True,True,True,0.7,True,11.042647123336792,16.36320948600769,prompt_only,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,Sequential,medium,"Create a 4-bit PISO shift register with clock, reset, load, parallel input[3:0], and serial output. Include testbench.",claude,"`timescale 1ns/1ps

module piso_reg(
    input wire clk,
    input wire rst_n,
    input wire load,
    input wire [3:0] data_in,
    output reg serial_out
);

reg [3:0] shift_reg;

always @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
        shift_reg <= 4'b0000;
        serial_out <= 1'b0;
    end
    else if (load)
        shift_reg <= data_in;
    else begin
        serial_out <= shift_reg[3];
        shift_reg <= {shift_reg[2:0], 1'b0};
    end
end

endmodule

module testbench;
    reg clk, rst_n, load;
    reg [3:0] data_in;
    wire serial_out;
    
    piso_reg dut (
        .clk(clk),
        .rst_n(rst_n),
        .load(load),
        .data_in(data_in),
        .serial_out(serial_out)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 0;
        rst_n = 0;
        load = 0;
        data_in = 4'b0000;
        
        #10 rst_n = 1;
        #10 data_in = 4'b1010;
        load = 1;
        #10 load = 0;
        
        #40 data_in = 4'b1111;
        load = 1;
        #10 load = 0;
        
        #40 rst_n = 0;
        #10 rst_n = 1;
        
        #40 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t rst_n=%b load=%b data_in=%b serial_out=%b"",
                 $time, rst_n, load, data_in, serial_out);
    end
endmodule",True,71,True,True,True,False,0.3,False,7.397663831710815,8.485796928405762,"graph LR
    CLK[Clock] --> PISO[[PISO Register]]
    RST[Reset] --> PISO
    LD[Load] --> PISO
    PIN0[P_IN[0]] --> PISO
    PIN1[P_IN[1]] --> PISO
    PIN2[P_IN[2]] --> PISO
    PIN3[P_IN[3]] --> PISO
    PISO --> SOUT[Serial Out]
    
    subgraph TestBench
    TB_CLK[TB Clock Gen] --> CLK
    TB_RST[TB Reset Gen] --> RST
    TB_LD[TB Load Gen] --> LD
    TB_PIN[TB Parallel Data] --> PIN0
    TB_PIN --> PIN1
    TB_PIN --> PIN2
    TB_PIN --> PIN3
    SOUT --> TB_CHECK{TB Verification}
    end","`timescale 1ns/1ps

module piso_reg (
    input wire clk,
    input wire rst,
    input wire load,
    input wire [3:0] p_in,
    output reg s_out
);

reg [3:0] shift_reg;

always @(posedge clk or posedge rst) begin
    if (rst) begin
        shift_reg <= 4'b0000;
        s_out <= 1'b0;
    end
    else if (load) begin
        shift_reg <= p_in;
        s_out <= p_in[3];
    end
    else begin
        shift_reg <= {shift_reg[2:0], 1'b0};
        s_out <= shift_reg[3];
    end
end

endmodule

module testbench;
    reg clk, rst, load;
    reg [3:0] p_in;
    wire s_out;

    piso_reg dut (
        .clk(clk),
        .rst(rst),
        .load(load),
        .p_in(p_in),
        .s_out(s_out)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 0;
        rst = 1;
        load = 0;
        p_in = 4'b0000;

        #20 rst = 0;
        #10 p_in = 4'b1010;
        #10 load = 1;
        #10 load = 0;
        #40 p_in = 4'b1111;
        #10 load = 1;
        #10 load = 0;
        #40 rst = 1;
        #20 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t rst=%b load=%b p_in=%b s_out=%b"", 
                 $time, rst, load, p_in, s_out);
    end
endmodule",True,69,True,True,True,False,0.3,False,9.901315212249756,7.925556659698486,"Create a 4-bit PISO shift register with clock, reset, load, parallel input[3:0], and serial output. Include testbench.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph LR
    CLK[Clock] --> PISO[[PISO Register]]
    RST[Reset] --> PISO
    LD[Load] --> PISO
    PIN0[P_IN[0]] --> PISO
    PIN1[P_IN[1]] --> PISO
    PIN2[P_IN[2]] --> PISO
    PIN3[P_IN[3]] --> PISO
    PISO --> SOUT[Serial Out]
    
    subgraph TestBench
    TB_CLK[TB Clock Gen] --> CLK
    TB_RST[TB Reset Gen] --> RST
    TB_LD[TB Load Gen] --> LD
    TB_PIN[TB Parallel Data] --> PIN0
    TB_PIN --> PIN1
    TB_PIN --> PIN2
    TB_PIN --> PIN3
    SOUT --> TB_CHECK{TB Verification}
    end
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module piso_reg (
    input wire clk,
    input wire rst,
    input wire load,
    input wire [3:0] p_in,
    output reg s_out
);

reg [3:0] shift_reg;

always @(posedge clk or posedge rst) begin
    if (rst) begin
        shift_reg <= 4'b0000;
        s_out <= 1'b0;
    end
    else if (load)
        shift_reg <= p_in;
    else begin
        s_out <= shift_reg[3];
        shift_reg <= {shift_reg[2:0], 1'b0};
    end
end

endmodule

module testbench;
    reg clk, rst, load;
    reg [3:0] p_in;
    wire s_out;

    piso_reg dut (
        .clk(clk),
        .rst(rst),
        .load(load),
        .p_in(p_in),
        .s_out(s_out)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 0;
        rst = 1;
        load = 0;
        p_in = 4'b0000;

        #10 rst = 0;
        
        #10 p_in = 4'b1010;
        load = 1;
        #10 load = 0;
        
        #40 p_in = 4'b1111;
        load = 1;
        #10 load = 0;
        
        #40 rst = 1;
        #10 rst = 0;
        
        #20 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t rst=%b load=%b p_in=%b s_out=%b"", 
                 $time, rst, load, p_in, s_out);
    end
endmodule",True,72,True,True,True,False,0.3,False,6.565978050231934,7.4535181522369385,tie,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,Sequential,medium,"Create a 4-bit PISO shift register with clock, reset, load, parallel input[3:0], and serial output. Include testbench.",gpt-4o,"`timescale 1ns/1ps

module piso_shift_register(
    input wire clk,
    input wire rst_n,
    input wire load,
    input wire [3:0] parallel_in,
    output reg serial_out
);

    reg [3:0] shift_reg;

    always @(posedge clk or negedge rst_n) begin
        if (!rst_n)
            shift_reg <= 4'b0000;
        else if (load)
            shift_reg <= parallel_in;
        else
            shift_reg <= {shift_reg[2:0], 1'b0}; // Shift left and append 0
    end

    always @(posedge clk or negedge rst_n) begin
        if (!rst_n)
            serial_out <= 1'b0;
        else
            serial_out <= shift_reg[3]; // MSB as serial output
    end

endmodule

module testbench;
    reg clk, rst_n, load;
    reg [3:0] parallel_in;
    wire serial_out;
    
    piso_shift_register dut (
        .clk(clk),
        .rst_n(rst_n),
        .load(load),
        .parallel_in(parallel_in),
        .serial_out(serial_out)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst_n = 1'b0;
        load = 1'b0;
        parallel_in = 4'b0000;
        
        #20 rst_n = 1'b1;
        #10 load = 1'b1; parallel_in = 4'b1010;
        #10 load = 1'b0;
        #80 load = 1'b1; parallel_in = 4'b1100;
        #10 load = 1'b0;
        #50 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b load=%b parallel_in=%b serial_out=%b"", 
                 $time, clk, rst_n, load, parallel_in, serial_out);
    end
endmodule",True,67,True,True,True,True,0.7,True,4.794742584228516,11.568994283676147,"graph LR
    CLK[Clock] --> REG[[4-bit PISO Shift Register]]
    RST[Reset] --> REG
    LOAD[Load] --> REG
    PI[Parallel Input[3:0]] --> REG
    REG --> SO[Serial Output]
    subgraph Testbench
        TB_CLK[Clock] --> REG
        TB_RST[Reset] --> REG
        TB_LOAD[Load] --> REG
        TB_PI[Parallel Input[3:0]] --> REG
        REG --> TB_SO[Serial Output]
    end","`timescale 1ns/1ps

module piso_shift_register(
    input wire clk,
    input wire rst,
    input wire load,
    input wire [3:0] parallel_in,
    output reg serial_out
);

    reg [3:0] shift_reg;

    always @(posedge clk or posedge rst) begin
        if (rst)
            shift_reg <= 4'b0000;
        else if (load)
            shift_reg <= parallel_in;
        else
            shift_reg <= {shift_reg[2:0], 1'b0};
    end

    always @(posedge clk or posedge rst) begin
        if (rst)
            serial_out <= 1'b0;
        else
            serial_out <= shift_reg[3];
    end

endmodule

module testbench;
    reg clk, rst, load;
    reg [3:0] parallel_in;
    wire serial_out;

    piso_shift_register dut (
        .clk(clk),
        .rst(rst),
        .load(load),
        .parallel_in(parallel_in),
        .serial_out(serial_out)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 1'b0;
        rst = 1'b1;
        load = 1'b0;
        parallel_in = 4'b0000;

        #10 rst = 1'b0;
        #10 load = 1'b1; parallel_in = 4'b1010;
        #10 load = 1'b0;
        #80 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t clk=%b rst=%b load=%b parallel_in=%b serial_out=%b"", 
                 $time, clk, rst, load, parallel_in, serial_out);
    end
endmodule",True,65,True,True,True,True,0.7,True,7.201076984405518,17.54115104675293,"Create a 4-bit PISO shift register with clock, reset, load, parallel input[3:0], and serial output. Include testbench.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph LR
    CLK[Clock] --> REG[[4-bit PISO Shift Register]]
    RST[Reset] --> REG
    LOAD[Load] --> REG
    PI[Parallel Input[3:0]] --> REG
    REG --> SO[Serial Output]
    subgraph Testbench
        TB_CLK[Clock] --> REG
        TB_RST[Reset] --> REG
        TB_LOAD[Load] --> REG
        TB_PI[Parallel Input[3:0]] --> REG
        REG --> TB_SO[Serial Output]
    end
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module piso_shift_register(
    input wire clk,
    input wire rst_n,
    input wire load,
    input wire [3:0] parallel_in,
    output reg serial_out
);

    reg [3:0] shift_reg;

    always @(posedge clk or negedge rst_n) begin
        if (!rst_n)
            shift_reg <= 4'b0000;
        else if (load)
            shift_reg <= parallel_in;
        else
            shift_reg <= {shift_reg[2:0], 1'b0}; // Shift left
    end

    always @(posedge clk or negedge rst_n) begin
        if (!rst_n)
            serial_out <= 1'b0;
        else
            serial_out <= shift_reg[3];
    end

endmodule

module testbench;
    reg clk, rst_n, load;
    reg [3:0] parallel_in;
    wire serial_out;
    
    piso_shift_register dut (
        .clk(clk),
        .rst_n(rst_n),
        .load(load),
        .parallel_in(parallel_in),
        .serial_out(serial_out)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst_n = 1'b0;
        load = 1'b0;
        parallel_in = 4'b0000;
        
        #20 rst_n = 1'b1;
        #10 load = 1'b1;
        parallel_in = 4'b1010;
        #10 load = 1'b0;
        #100 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b load=%b parallel_in=%b serial_out=%b"", 
                 $time, clk, rst_n, load, parallel_in, serial_out);
    end
endmodule",True,66,True,True,True,True,0.7,True,3.867368221282959,22.579843044281006,prompt_only,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,Combinational,medium,"Design a 4-to-2 priority encoder with input in[3:0], output out[1:0], and valid bit. Highest bit has priority. Include testbench.",claude,"`timescale 1ns/1ps

module priority_encoder(
    input wire [3:0] in,
    output reg [1:0] out,
    output reg valid
);

always @(*) begin
    casex(in)
        4'b1xxx: begin
            out = 2'b11;
            valid = 1'b1;
        end
        4'b01xx: begin
            out = 2'b10;
            valid = 1'b1;
        end
        4'b001x: begin
            out = 2'b01;
            valid = 1'b1;
        end
        4'b0001: begin
            out = 2'b00;
            valid = 1'b1;
        end
        default: begin
            out = 2'b00;
            valid = 1'b0;
        end
    endcase
end

endmodule

module testbench;
    reg [3:0] in;
    wire [1:0] out;
    wire valid;

    priority_encoder dut (
        .in(in),
        .out(out),
        .valid(valid)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        in = 4'b0000; #10;
        in = 4'b0001; #10;
        in = 4'b0010; #10;
        in = 4'b0100; #10;
        in = 4'b1000; #10;
        in = 4'b1100; #10;
        in = 4'b1110; #10;
        in = 4'b1111; #10;
        in = 4'b0000; #10;
        
        $finish;
    end

    initial begin
        $monitor(""Time=%0t in=%b out=%b valid=%b"", 
                 $time, in, out, valid);
    end
endmodule",True,68,True,True,True,False,0.4,False,5.984340667724609,6.283989906311035,"graph LR
    IN4[in[3:0]] --> PRI(Priority Logic)
    PRI --> ENC(Encoder Logic)
    ENC --> OUT2[out[1:0]]
    PRI --> VALID[valid]

    subgraph Priority_Encoder
        PRI --> |if in[3]=1| ENC1(""out=11"")
        PRI --> |if in[2]=1| ENC2(""out=10"")
        PRI --> |if in[1]=1| ENC3(""out=01"")
        PRI --> |if in[0]=1| ENC4(""out=00"")
    end

    subgraph Testbench
        TB[Test Vectors] --> |in[3:0]| PRI
        TB --> |Expected out[1:0]| CMP{Compare}
        OUT2 --> CMP
        CMP --> RESULT[Test Result]
    end","`timescale 1ns/1ps

module priority_encoder(
    input wire [3:0] in,
    input wire clk,
    input wire rst_n,
    output reg [1:0] out,
    output reg valid
);

always @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
        out <= 2'b00;
        valid <= 1'b0;
    end
    else begin
        valid <= |in;
        if (in[3])
            out <= 2'b11;
        else if (in[2])
            out <= 2'b10;
        else if (in[1])
            out <= 2'b01;
        else if (in[0])
            out <= 2'b00;
        else
            out <= 2'b00;
    end
end

endmodule

module testbench;
    reg [3:0] in;
    reg clk, rst_n;
    wire [1:0] out;
    wire valid;
    reg [1:0] expected;
    
    priority_encoder dut (
        .in(in),
        .clk(clk),
        .rst_n(rst_n),
        .out(out),
        .valid(valid)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 0;
        rst_n = 0;
        in = 4'b0000;
        
        #10 rst_n = 1;
        
        // Test vectors
        #10 in = 4'b1000; expected = 2'b11;
        #10 in = 4'b0100; expected = 2'b10;
        #10 in = 4'b0010; expected = 2'b01;
        #10 in = 4'b0001; expected = 2'b00;
        #10 in = 4'b1100; expected = 2'b11;
        #10 in = 4'b0000; expected = 2'b00;
        
        #20 $finish;
    end
    
    always #5 clk = ~clk;
    
    always @(posedge clk) begin
        if (rst_n) begin
            if (out !== expected)
                $display(""Error: input=%b, expected=%b, got=%b"", in, expected, out);
        end
    end
    
    initial begin
        $monitor(""Time=%0t rst_n=%b in=%b out=%b valid=%b"", 
                 $time, rst_n, in, out, valid);
    end
endmodule",True,82,True,True,True,True,0.8,True,13.553030967712402,8.132941961288452,"Design a 4-to-2 priority encoder with input in[3:0], output out[1:0], and valid bit. Highest bit has priority. Include testbench.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph LR
    IN4[in[3:0]] --> PRI(Priority Logic)
    PRI --> ENC(Encoder Logic)
    ENC --> OUT2[out[1:0]]
    PRI --> VALID[valid]

    subgraph Priority_Encoder
        PRI --> |if in[3]=1| ENC1(""out=11"")
        PRI --> |if in[2]=1| ENC2(""out=10"")
        PRI --> |if in[1]=1| ENC3(""out=01"")
        PRI --> |if in[0]=1| ENC4(""out=00"")
    end

    subgraph Testbench
        TB[Test Vectors] --> |in[3:0]| PRI
        TB --> |Expected out[1:0]| CMP{Compare}
        OUT2 --> CMP
        CMP --> RESULT[Test Result]
    end
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module priority_encoder(
    input wire [3:0] in,
    output reg [1:0] out,
    output reg valid
);

always @(*) begin
    valid = |in;
    if(in[3])
        out = 2'b11;
    else if(in[2])
        out = 2'b10;
    else if(in[1])
        out = 2'b01;
    else if(in[0])
        out = 2'b00;
    else
        out = 2'b00;
end

endmodule

module testbench;
    reg [3:0] in;
    wire [1:0] out;
    wire valid;
    reg [1:0] expected;
    reg [3:0] test_vector;
    integer i, errors;

    priority_encoder dut(
        .in(in),
        .out(out),
        .valid(valid)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        errors = 0;
        
        // Test all input combinations
        for(i = 0; i < 16; i = i + 1) begin
            in = i;
            #1;
            
            if(in[3]) expected = 2'b11;
            else if(in[2]) expected = 2'b10;
            else if(in[1]) expected = 2'b01;
            else if(in[0]) expected = 2'b00;
            else expected = 2'b00;
            
            if(out !== expected || valid !== |in) begin
                $display(""Error: input=%b, expected out=%b valid=%b, got out=%b valid=%b"",
                        in, expected, |in, out, valid);
                errors = errors + 1;
            end
        end

        if(errors == 0)
            $display(""All tests passed!"");
        else
            $display(""%d tests failed."", errors);
            
        #10 $finish;
    end

    initial begin
        $monitor(""Time=%0t in=%b out=%b valid=%b"", $time, in, out, valid);
    end

endmodule",True,75,True,True,True,False,0.4,False,7.444803237915039,7.623448371887207,tie,prompt_only > combined > mermaid_only,prompt_only > mermaid_only > combined
combined,Combinational,medium,"Design a 4-to-2 priority encoder with input in[3:0], output out[1:0], and valid bit. Highest bit has priority. Include testbench.",gpt-4o,"`timescale 1ns/1ps

module priority_encoder_4to2(
    input wire [3:0] in,
    output reg [1:0] out,
    output reg valid
);

always @(in) begin
    valid = 1'b0;
    out = 2'b00;

    if (in[3]) begin
        valid = 1'b1;
        out = 2'b11;
    end else if (in[2]) begin
        valid = 1'b1;
        out = 2'b10;
    end else if (in[1]) begin
        valid = 1'b1;
        out = 2'b01;
    end else if (in[0]) begin
        valid = 1'b1;
        out = 2'b00;
    end
end

endmodule

module testbench;
    reg [3:0] in;
    wire [1:0] out;
    wire valid;

    priority_encoder_4to2 dut (
        .in(in),
        .out(out),
        .valid(valid)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        in = 4'b0000;
        #10 in = 4'b0001;
        #10 in = 4'b0010;
        #10 in = 4'b0100;
        #10 in = 4'b1000;
        #10 in = 4'b1100;
        #10 in = 4'b0011;
        #10 in = 4'b1111;
        #10 $finish;
    end

    initial begin
        $monitor(""Time=%0t in=4'b%b out=2'b%b valid=%b"", 
                 $time, in, out, valid);
    end
endmodule",True,60,True,True,True,False,0.4,False,4.678126335144043,11.922560214996338,"graph TD
    IN[in[3:0]] --> ENC(Priority Encoder)
    ENC --> OUT[out[1:0]]
    ENC --> VALID{Valid Bit}
    TEST[Testbench] --> IN
    CLK[Clock] --> ENC
    RST[Reset] --> ENC
    IN --> TEST
    OUT --> TEST
    VALID --> TEST","`timescale 1ns/1ps

module priority_encoder (
    input wire [3:0] in,
    input wire clk,
    input wire rst,
    output reg [1:0] out,
    output reg valid
);

always @(posedge clk or posedge rst) begin
    if (rst) begin
        out <= 2'b00;
        valid <= 1'b0;
    end else begin
        casez (in)
            4'b0001: begin
                out <= 2'b00;
                valid <= 1'b1;
            end
            4'b001?: begin
                out <= 2'b01;
                valid <= 1'b1;
            end
            4'b01??: begin
                out <= 2'b10;
                valid <= 1'b1;
            end
            4'b1???: begin
                out <= 2'b11;
                valid <= 1'b1;
            end
            default: begin
                out <= 2'b00;
                valid <= 1'b0;
            end
        endcase
    end
end

endmodule

module testbench;
    reg [3:0] in;
    reg clk, rst;
    wire [1:0] out;
    wire valid;
    
    priority_encoder dut (
        .in(in),
        .clk(clk),
        .rst(rst),
        .out(out),
        .valid(valid)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst = 1'b1;
        in = 4'b0000;
        
        #10 rst = 1'b0;
        #10 in = 4'b1000;
        #10 in = 4'b0100;
        #10 in = 4'b0010;
        #10 in = 4'b0001;
        #10 in = 4'b0000;
        #50 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t clk=%b rst=%b in=%b out=%b valid=%b"", 
                 $time, clk, rst, in, out, valid);
    end
endmodule",True,80,True,True,True,False,0.3,False,9.462668657302856,8.234467267990112,"Design a 4-to-2 priority encoder with input in[3:0], output out[1:0], and valid bit. Highest bit has priority. Include testbench.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph TD
    IN[in[3:0]] --> ENC(Priority Encoder)
    ENC --> OUT[out[1:0]]
    ENC --> VALID{Valid Bit}
    TEST[Testbench] --> IN
    CLK[Clock] --> ENC
    RST[Reset] --> ENC
    IN --> TEST
    OUT --> TEST
    VALID --> TEST
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module priority_encoder(
    input wire [3:0] in,
    input wire clk,
    input wire rst,
    output reg [1:0] out,
    output reg valid
);

always @(posedge clk or posedge rst) begin
    if (rst) begin
        out <= 2'b00;
        valid <= 1'b0;
    end else begin
        casez (in)
            4'b1???: begin
                out <= 2'b11;
                valid <= 1'b1;
            end
            4'b01??: begin
                out <= 2'b10;
                valid <= 1'b1;
            end
            4'b001?: begin
                out <= 2'b01;
                valid <= 1'b1;
            end
            4'b0001: begin
                out <= 2'b00;
                valid <= 1'b1;
            end
            default: begin
                out <= 2'b00;
                valid <= 1'b0;
            end
        endcase
    end
end

endmodule

module testbench;
    reg [3:0] in;
    reg clk, rst;
    wire [1:0] out;
    wire valid;

    priority_encoder dut (
        .in(in),
        .clk(clk),
        .rst(rst),
        .out(out),
        .valid(valid)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 1'b0;
        rst = 1'b0;
        in = 4'b0000;

        #10 rst = 1'b1;
        #10 rst = 1'b0;
        #10 in = 4'b0001;
        #10 in = 4'b0010;
        #10 in = 4'b0100;
        #10 in = 4'b1000;
        #10 in = 4'b1100;
        #10 in = 4'b1110;
        #10 in = 4'b1111;
        #10 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t in=%b out=%b valid=%b"", 
                 $time, in, out, valid);
    end
endmodule",True,83,True,True,True,False,0.4,False,10.597601652145386,16.437116622924805,tie,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,State Machine,complex,"Design a traffic light FSM with 4 states: NS_GREEN, NS_YELLOW, EW_GREEN, EW_YELLOW. Inputs: clk, rst, emergency. Outputs: ns_light[1:0], ew_light[1:0]. Timing: GREEN=8 cycles, YELLOW=2 cycles. Emergency makes both RED. Include testbench.",claude,"`timescale 1ns/1ps

module traffic_light (
    input wire clk,
    input wire rst,
    input wire emergency,
    output reg [1:0] ns_light,
    output reg [1:0] ew_light
);

parameter [1:0] RED = 2'b00;
parameter [1:0] YELLOW = 2'b01;
parameter [1:0] GREEN = 2'b10;

parameter [1:0] NS_GREEN = 2'b00;
parameter [1:0] NS_YELLOW = 2'b01;
parameter [1:0] EW_GREEN = 2'b10;
parameter [1:0] EW_YELLOW = 2'b11;

reg [1:0] state;
reg [3:0] timer;

always @(posedge clk or posedge rst) begin
    if (rst) begin
        state <= NS_GREEN;
        timer <= 4'd0;
        ns_light <= GREEN;
        ew_light <= RED;
    end
    else if (emergency) begin
        ns_light <= RED;
        ew_light <= RED;
        state <= NS_GREEN;
        timer <= 4'd0;
    end
    else begin
        case (state)
            NS_GREEN: begin
                if (timer == 4'd7) begin
                    state <= NS_YELLOW;
                    timer <= 4'd0;
                    ns_light <= YELLOW;
                end
                else begin
                    timer <= timer + 1'b1;
                end
            end
            
            NS_YELLOW: begin
                if (timer == 4'd1) begin
                    state <= EW_GREEN;
                    timer <= 4'd0;
                    ns_light <= RED;
                    ew_light <= GREEN;
                end
                else begin
                    timer <= timer + 1'b1;
                end
            end
            
            EW_GREEN: begin
                if (timer == 4'd7) begin
                    state <= EW_YELLOW;
                    timer <= 4'd0;
                    ew_light <= YELLOW;
                end
                else begin
                    timer <= timer + 1'b1;
                end
            end
            
            EW_YELLOW: begin
                if (timer == 4'd1) begin
                    state <= NS_GREEN;
                    timer <= 4'd0;
                    ew_light <= RED;
                    ns_light <= GREEN;
                end
                else begin
                    timer <= timer + 1'b1;
                end
            end
        endcase
    end
end

endmodule

module testbench;
    reg clk;
    reg rst;
    reg emergency;
    wire [1:0] ns_light;
    wire [1:0] ew_light;

    traffic_light dut (
        .clk(clk),
        .rst(rst),
        .emergency(emergency),
        .ns_light(ns_light),
        .ew_light(ew_light)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 0;
        rst = 1;
        emergency = 0;
        
        #10 rst = 0;
        
        #100 emergency = 1;
        #20 emergency = 0;
        
        #200 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t rst=%b emergency=%b ns_light=%b ew_light=%b"", 
                 $time, rst, emergency, ns_light, ew_light);
    end
endmodule",True,126,True,True,True,False,0.4,False,12.336881399154663,7.933764934539795,"graph LR
    CLK[Clock] --> FSM((Traffic FSM))
    RST[Reset] --> FSM
    EMG[Emergency] --> FSM
    FSM --> CNTRL((Timer Control))
    CNTRL --> FSM
    FSM --> CNT[[Cycle Counter]]
    CNT --> FSM
    FSM --> NS[NS_Light[1:0]]
    FSM --> EW[EW_Light[1:0]]
    TCFG[[Timing Config<br/>GREEN=8<br/>YELLOW=2]] --> CNTRL
    DEC{State Decoder} --> FSM
    FSM --> DEC
    TB[[Testbench<br/>-Clock Gen<br/>-Reset Seq<br/>-EMG Stim]] --> CLK
    TB --> RST
    TB --> EMG
    NS --> TB
    EW --> TB
    CLK --> CNT","`timescale 1ns/1ps

module traffic_fsm (
    input wire clk,
    input wire rst,
    input wire emg,
    output reg [1:0] ns_light,
    output reg [1:0] ew_light
);

reg [2:0] state;
reg [3:0] cycle_cnt;
parameter GREEN = 8;
parameter YELLOW = 2;

// State definitions
parameter NS_GREEN = 3'd0;
parameter NS_YELLOW = 3'd1;
parameter EW_GREEN = 3'd2;
parameter EW_YELLOW = 3'd3;
parameter EMG_ALL_RED = 3'd4;

// Light encodings
parameter RED = 2'b00;
parameter YELLOW_LIGHT = 2'b01;
parameter GREEN_LIGHT = 2'b10;

always @(posedge clk or posedge rst) begin
    if (rst) begin
        state <= NS_GREEN;
        cycle_cnt <= 4'd0;
        ns_light <= GREEN_LIGHT;
        ew_light <= RED;
    end
    else begin
        case (state)
            NS_GREEN: begin
                if (emg) begin
                    state <= EMG_ALL_RED;
                    ns_light <= RED;
                    ew_light <= RED;
                    cycle_cnt <= 4'd0;
                end
                else if (cycle_cnt >= GREEN-1) begin
                    state <= NS_YELLOW;
                    ns_light <= YELLOW_LIGHT;
                    cycle_cnt <= 4'd0;
                end
                else begin
                    cycle_cnt <= cycle_cnt + 1'b1;
                end
            end

            NS_YELLOW: begin
                if (emg) begin
                    state <= EMG_ALL_RED;
                    ns_light <= RED;
                    ew_light <= RED;
                    cycle_cnt <= 4'd0;
                end
                else if (cycle_cnt >= YELLOW-1) begin
                    state <= EW_GREEN;
                    ns_light <= RED;
                    ew_light <= GREEN_LIGHT;
                    cycle_cnt <= 4'd0;
                end
                else begin
                    cycle_cnt <= cycle_cnt + 1'b1;
                end
            end

            EW_GREEN: begin
                if (emg) begin
                    state <= EMG_ALL_RED;
                    ns_light <= RED;
                    ew_light <= RED;
                    cycle_cnt <= 4'd0;
                end
                else if (cycle_cnt >= GREEN-1) begin
                    state <= EW_YELLOW;
                    ew_light <= YELLOW_LIGHT;
                    cycle_cnt <= 4'd0;
                end
                else begin
                    cycle_cnt <= cycle_cnt + 1'b1;
                end
            end

            EW_YELLOW: begin
                if (emg) begin
                    state <= EMG_ALL_RED;
                    ns_light <= RED;
                    ew_light <= RED;
                    cycle_cnt <= 4'd0;
                end
                else if (cycle_cnt >= YELLOW-1) begin
                    state <= NS_GREEN;
                    ns_light <= GREEN_LIGHT;
                    ew_light <= RED;
                    cycle_cnt <= 4'd0;
                end
                else begin
                    cycle_cnt <= cycle_cnt + 1'b1;
                end
            end

            EMG_ALL_RED: begin
                if (!emg) begin
                    state <= NS_GREEN;
                    ns_light <= GREEN_LIGHT;
                    ew_light <= RED;
                    cycle_cnt <= 4'd0;
                end
            end
        endcase
    end
end

endmodule

module testbench;
    reg clk, rst, emg;
    wire [1:0] ns_light, ew_light;

    traffic_fsm dut (
        .clk(clk),
        .rst(rst),
        .emg(emg),
        .ns_light(ns_light),
        .ew_light(ew_light)
    );

    initial begin
        $dumpfile(""traffic.vcd"");
        $dumpvars(0, testbench);

        clk = 0;
        rst = 1;
        emg = 0;

        #10 rst = 0;
        #100 emg = 1;
        #30 emg = 0;
        #200 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t rst=%b emg=%b ns_light=%b ew_light=%b"",
                 $time, rst, emg, ns_light, ew_light);
    end
endmodule",True,153,True,True,True,,0.0,,18.005433320999146,0.016779422760009766,"Design a traffic light FSM with 4 states: NS_GREEN, NS_YELLOW, EW_GREEN, EW_YELLOW. Inputs: clk, rst, emergency. Outputs: ns_light[1:0], ew_light[1:0]. Timing: GREEN=8 cycles, YELLOW=2 cycles. Emergency makes both RED. Include testbench.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph LR
    CLK[Clock] --> FSM((Traffic FSM))
    RST[Reset] --> FSM
    EMG[Emergency] --> FSM
    FSM --> CNTRL((Timer Control))
    CNTRL --> FSM
    FSM --> CNT[[Cycle Counter]]
    CNT --> FSM
    FSM --> NS[NS_Light[1:0]]
    FSM --> EW[EW_Light[1:0]]
    TCFG[[Timing Config<br/>GREEN=8<br/>YELLOW=2]] --> CNTRL
    DEC{State Decoder} --> FSM
    FSM --> DEC
    TB[[Testbench<br/>-Clock Gen<br/>-Reset Seq<br/>-EMG Stim]] --> CLK
    TB --> RST
    TB --> EMG
    NS --> TB
    EW --> TB
    CLK --> CNT
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module traffic_fsm (
    input wire clk,
    input wire rst,
    input wire emergency,
    output reg [1:0] ns_light,
    output reg [1:0] ew_light
);

parameter [1:0] RED = 2'b00;
parameter [1:0] YELLOW = 2'b01;
parameter [1:0] GREEN = 2'b10;

parameter [1:0] NS_GREEN_STATE = 2'b00;
parameter [1:0] NS_YELLOW_STATE = 2'b01;
parameter [1:0] EW_GREEN_STATE = 2'b10;
parameter [1:0] EW_YELLOW_STATE = 2'b11;

reg [1:0] state, next_state;
reg [3:0] counter;
wire timer_done;

parameter GREEN_TIME = 4'd8;
parameter YELLOW_TIME = 4'd2;

assign timer_done = (state == NS_GREEN_STATE || state == EW_GREEN_STATE) ? 
                   (counter >= GREEN_TIME - 1) :
                   (counter >= YELLOW_TIME - 1);

always @(posedge clk or posedge rst) begin
    if (rst) begin
        state <= NS_GREEN_STATE;
        counter <= 4'd0;
    end
    else if (emergency) begin
        state <= NS_GREEN_STATE;
        counter <= 4'd0;
    end
    else begin
        if (timer_done) begin
            state <= next_state;
            counter <= 4'd0;
        end
        else begin
            counter <= counter + 1'b1;
        end
    end
end

always @(*) begin
    case (state)
        NS_GREEN_STATE: next_state = NS_YELLOW_STATE;
        NS_YELLOW_STATE: next_state = EW_GREEN_STATE;
        EW_GREEN_STATE: next_state = EW_YELLOW_STATE;
        EW_YELLOW_STATE: next_state = NS_GREEN_STATE;
        default: next_state = NS_GREEN_STATE;
    endcase
end

always @(*) begin
    if (emergency) begin
        ns_light = RED;
        ew_light = RED;
    end
    else begin
        case (state)
            NS_GREEN_STATE: begin
                ns_light = GREEN;
                ew_light = RED;
            end
            NS_YELLOW_STATE: begin
                ns_light = YELLOW;
                ew_light = RED;
            end
            EW_GREEN_STATE: begin
                ns_light = RED;
                ew_light = GREEN;
            end
            EW_YELLOW_STATE: begin
                ns_light = RED;
                ew_light = YELLOW;
            end
            default: begin
                ns_light = RED;
                ew_light = RED;
            end
        endcase
    end
end

endmodule

module testbench;
    reg clk, rst, emergency;
    wire [1:0] ns_light, ew_light;
    
    traffic_fsm dut (
        .clk(clk),
        .rst(rst),
        .emergency(emergency),
        .ns_light(ns_light),
        .ew_light(ew_light)
    );
    
    initial begin
        $dumpfile(""traffic.vcd"");
        $dumpvars(0, testbench);
        
        clk = 0;
        rst = 1;
        emergency = 0;
        
        #10 rst = 0;
        
        #100 emergency = 1;
        #20 emergency = 0;
        
        #200 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t rst=%b emergency=%b ns_light=%b ew_light=%b"", 
                 $time, rst, emergency, ns_light, ew_light);
    end
endmodule",True,128,True,True,True,,0.0,,12.03232455253601,0.018156766891479492,prompt_only,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,State Machine,complex,"Design a traffic light FSM with 4 states: NS_GREEN, NS_YELLOW, EW_GREEN, EW_YELLOW. Inputs: clk, rst, emergency. Outputs: ns_light[1:0], ew_light[1:0]. Timing: GREEN=8 cycles, YELLOW=2 cycles. Emergency makes both RED. Include testbench.",gpt-4o,"`timescale 1ns/1ps

module traffic_light_fsm(
    input wire clk,
    input wire rst,
    input wire emergency,
    output reg [1:0] ns_light,
    output reg [1:0] ew_light
);

    // State encoding
    parameter NS_GREEN = 2'b00;
    parameter NS_YELLOW = 2'b01;
    parameter EW_GREEN = 2'b10;
    parameter EW_YELLOW = 2'b11;
    
    reg [1:0] state, next_state;
    reg [3:0] timer;

    // State transition logic
    always @(posedge clk or posedge rst) begin
        if (rst)
            state <= NS_GREEN;
        else
            state <= next_state;
    end

    // Next state and output logic
    always @(*) begin
        if (emergency) begin
            next_state = NS_GREEN; // Both RED
            ns_light = 2'b00;
            ew_light = 2'b00;
        end
        else begin
            case (state)
                NS_GREEN: begin
                    ns_light = 2'b10; // Green
                    ew_light = 2'b00; // Red
                    if (timer == 4'd7)
                        next_state = NS_YELLOW;
                    else
                        next_state = NS_GREEN;
                end
                NS_YELLOW: begin
                    ns_light = 2'b01; // Yellow
                    ew_light = 2'b00; // Red
                    if (timer == 4'd1)
                        next_state = EW_GREEN;
                    else
                        next_state = NS_YELLOW;
                end
                EW_GREEN: begin
                    ns_light = 2'b00; // Red
                    ew_light = 2'b10; // Green
                    if (timer == 4'd7)
                        next_state = EW_YELLOW;
                    else
                        next_state = EW_GREEN;
                end
                EW_YELLOW: begin
                    ns_light = 2'b00; // Red
                    ew_light = 2'b01; // Yellow
                    if (timer == 4'd1)
                        next_state = NS_GREEN;
                    else
                        next_state = EW_YELLOW;
                end
                default: begin
                    next_state = NS_GREEN;
                    ns_light = 2'b00;
                    ew_light = 2'b00;
                end
            endcase
        end
    end

    // Timer logic
    always @(posedge clk or posedge rst) begin
        if (rst)
            timer <= 4'd0;
        else if (emergency)
            timer <= 4'd0;
        else if (state == next_state)
            timer <= timer + 1'b1;
        else
            timer <= 4'd0;
    end

endmodule

module testbench;
    reg clk, rst, emergency;
    wire [1:0] ns_light, ew_light;
    
    traffic_light_fsm dut (
        .clk(clk),
        .rst(rst),
        .emergency(emergency),
        .ns_light(ns_light),
        .ew_light(ew_light)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst = 1'b1;
        emergency = 1'b0;
        
        #15 rst = 1'b0;
        #160 emergency = 1'b1;
        #20 emergency = 1'b0;
        #160 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t clk=%b rst=%b emergency=%b ns_light=%b ew_light=%b"", 
                 $time, clk, rst, emergency, ns_light, ew_light);
    end
endmodule",True,124,True,True,True,True,0.7,True,8.848376512527466,10.236706018447876,"graph LR
    CLK[clk] --> FSM
    RST[rst] --> FSM
    EMER[emergency] --> FSM

    FSM((Traffic Light FSM)) --> NS_LIGHT[ns_light[1:0]]
    FSM --> EW_LIGHT[ew_light[1:0]]

    FSM -->|NS_GREEN| NS_GREEN_STATE[NS_GREEN: 8 cycles]
    FSM -->|NS_YELLOW| NS_YELLOW_STATE[NS_YELLOW: 2 cycles]
    FSM -->|EW_GREEN| EW_GREEN_STATE[EW_GREEN: 8 cycles]
    FSM -->|EW_YELLOW| EW_YELLOW_STATE[EW_YELLOW: 2 cycles]
    FSM -->|Emergency| EMERGENCY{Emergency: Both RED}

    subgraph Testbench
        TB_CLK[clk] --> FSM
        TB_RST[rst] --> FSM
        TB_EMER[emergency] --> FSM
        FSM --> TB_NS_LIGHT[ns_light[1:0]]
        FSM --> TB_EW_LIGHT[ew_light[1:0]]
    end","`timescale 1ns/1ps

module traffic_light_fsm(
    input wire clk,
    input wire rst,
    input wire emergency,
    output reg [1:0] ns_light,
    output reg [1:0] ew_light
);

reg [3:0] state;
reg [3:0] next_state;

localparam NS_GREEN = 4'd0,
           NS_YELLOW = 4'd1,
           EW_GREEN = 4'd2,
           EW_YELLOW = 4'd3,
           EMERGENCY = 4'd4;

always @(posedge clk or posedge rst) begin
    if (rst) begin
        state <= NS_GREEN;
    end else begin
        state <= next_state;
    end
end

always @(state or emergency) begin
    case (state)
        NS_GREEN: begin
            ns_light = 2'b10; // Green
            ew_light = 2'b00; // Red
            if (emergency) begin
                next_state = EMERGENCY;
            end else begin
                next_state = NS_YELLOW;
            end
        end
        NS_YELLOW: begin
            ns_light = 2'b01; // Yellow
            ew_light = 2'b00; // Red
            next_state = EW_GREEN;
        end
        EW_GREEN: begin
            ns_light = 2'b00; // Red
            ew_light = 2'b10; // Green
            if (emergency) begin
                next_state = EMERGENCY;
            end else begin
                next_state = EW_YELLOW;
            end
        end
        EW_YELLOW: begin
            ns_light = 2'b00; // Red
            ew_light = 2'b01; // Yellow
            next_state = NS_GREEN;
        end
        EMERGENCY: begin
            ns_light = 2'b00; // Red
            ew_light = 2'b00; // Red
            if (!emergency) begin
                next_state = NS_GREEN;
            end else begin
                next_state = EMERGENCY;
            end
        end
        default: begin
            ns_light = 2'b00;
            ew_light = 2'b00;
            next_state = NS_GREEN;
        end
    endcase
end

endmodule

module testbench;
    reg clk, rst, emergency;
    wire [1:0] ns_light;
    wire [1:0] ew_light;
    
    traffic_light_fsm dut (
        .clk(clk),
        .rst(rst),
        .emergency(emergency),
        .ns_light(ns_light),
        .ew_light(ew_light)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst = 1'b1;
        emergency = 1'b0;
        
        #20 rst = 1'b0;
        #100 emergency = 1'b1;
        #50 emergency = 1'b0;
        #100 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t clk=%b rst=%b emergency=%b ns_light=%b ew_light=%b"", 
                 $time, clk, rst, emergency, ns_light, ew_light);
    end
endmodule",True,110,True,True,True,True,0.7,True,9.967776775360107,10.854434490203857,"Design a traffic light FSM with 4 states: NS_GREEN, NS_YELLOW, EW_GREEN, EW_YELLOW. Inputs: clk, rst, emergency. Outputs: ns_light[1:0], ew_light[1:0]. Timing: GREEN=8 cycles, YELLOW=2 cycles. Emergency makes both RED. Include testbench.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph LR
    CLK[clk] --> FSM
    RST[rst] --> FSM
    EMER[emergency] --> FSM

    FSM((Traffic Light FSM)) --> NS_LIGHT[ns_light[1:0]]
    FSM --> EW_LIGHT[ew_light[1:0]]

    FSM -->|NS_GREEN| NS_GREEN_STATE[NS_GREEN: 8 cycles]
    FSM -->|NS_YELLOW| NS_YELLOW_STATE[NS_YELLOW: 2 cycles]
    FSM -->|EW_GREEN| EW_GREEN_STATE[EW_GREEN: 8 cycles]
    FSM -->|EW_YELLOW| EW_YELLOW_STATE[EW_YELLOW: 2 cycles]
    FSM -->|Emergency| EMERGENCY{Emergency: Both RED}

    subgraph Testbench
        TB_CLK[clk] --> FSM
        TB_RST[rst] --> FSM
        TB_EMER[emergency] --> FSM
        FSM --> TB_NS_LIGHT[ns_light[1:0]]
        FSM --> TB_EW_LIGHT[ew_light[1:0]]
    end
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module traffic_light_fsm(
    input wire clk,
    input wire rst,
    input wire emergency,
    output reg [1:0] ns_light,
    output reg [1:0] ew_light
);

    reg [3:0] state;
    reg [3:0] next_state;
    reg [3:0] cycle_count;

    // State encoding
    localparam NS_GREEN = 4'b0001;
    localparam NS_YELLOW = 4'b0010;
    localparam EW_GREEN = 4'b0100;
    localparam EW_YELLOW = 4'b1000;
    localparam EMERGENCY = 4'b1111;

    // Light encoding
    localparam GREEN = 2'b10;
    localparam YELLOW = 2'b01;
    localparam RED = 2'b00;

    always @(posedge clk or posedge rst) begin
        if (rst) begin
            state <= NS_GREEN;
            cycle_count <= 4'b0000;
        end else if (emergency) begin
            state <= EMERGENCY;
        end else begin
            if (cycle_count == 4'b0000) begin
                state <= next_state;
            end else begin
                cycle_count <= cycle_count - 1'b1;
            end
        end
    end

    always @(*) begin
        case(state)
            NS_GREEN: begin
                ns_light = GREEN;
                ew_light = RED;
                if (cycle_count == 4'b0000) begin
                    next_state = NS_YELLOW;
                    cycle_count = 4'd7; // 8 cycles total
                end
            end
            NS_YELLOW: begin
                ns_light = YELLOW;
                ew_light = RED;
                if (cycle_count == 4'b0000) begin
                    next_state = EW_GREEN;
                    cycle_count = 4'd1; // 2 cycles total
                end
            end
            EW_GREEN: begin
                ns_light = RED;
                ew_light = GREEN;
                if (cycle_count == 4'b0000) begin
                    next_state = EW_YELLOW;
                    cycle_count = 4'd7; // 8 cycles total
                end
            end
            EW_YELLOW: begin
                ns_light = RED;
                ew_light = YELLOW;
                if (cycle_count == 4'b0000) begin
                    next_state = NS_GREEN;
                    cycle_count = 4'd1; // 2 cycles total
                end
            end
            EMERGENCY: begin
                ns_light = RED;
                ew_light = RED;
            end
            default: begin
                ns_light = RED;
                ew_light = RED;
                next_state = NS_GREEN;
                cycle_count = 4'b0000;
            end
        endcase
    end

endmodule

module testbench;
    reg clk, rst, emergency;
    wire [1:0] ns_light, ew_light;
    
    traffic_light_fsm dut (
        .clk(clk),
        .rst(rst),
        .emergency(emergency),
        .ns_light(ns_light),
        .ew_light(ew_light)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst = 1'b1;
        emergency = 1'b0;
        
        #20 rst = 1'b0;
        #160 emergency = 1'b1;
        #20 emergency = 1'b0;
        #160 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t clk=%b rst=%b emergency=%b ns_light=%b ew_light=%b"", 
                 $time, clk, rst, emergency, ns_light, ew_light);
    end
endmodule",True,123,True,True,True,True,0.9,True,8.483299970626831,7.763754606246948,prompt_only,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,State Machine,complex,"Design UART transmitter with states: IDLE, START, DATA, STOP. Protocol: START(0), 8 data bits LSB-first, STOP(1). Baud rate divider. Include testbench.",claude,"`timescale 1ns/1ps

module uart_tx (
    input wire clk,
    input wire rst_n,
    input wire tx_start,
    input wire [7:0] tx_data,
    output reg tx_out,
    output reg tx_done
);

parameter IDLE = 2'b00;
parameter START = 2'b01;
parameter DATA = 2'b10;
parameter STOP = 2'b11;

reg [1:0] state;
reg [2:0] bit_count;
reg [7:0] shift_reg;
reg [15:0] baud_count;

parameter BAUD_DIV = 16'd434; // For 115200 baud at 50MHz

always @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
        state <= IDLE;
        tx_out <= 1'b1;
        tx_done <= 1'b0;
        bit_count <= 3'b000;
        shift_reg <= 8'b0;
        baud_count <= 16'b0;
    end
    else begin
        case (state)
            IDLE: begin
                tx_out <= 1'b1;
                tx_done <= 1'b0;
                if (tx_start) begin
                    state <= START;
                    shift_reg <= tx_data;
                    baud_count <= BAUD_DIV;
                end
            end

            START: begin
                tx_out <= 1'b0;
                if (baud_count == 16'b0) begin
                    state <= DATA;
                    bit_count <= 3'b000;
                    baud_count <= BAUD_DIV;
                end
                else
                    baud_count <= baud_count - 1'b1;
            end

            DATA: begin
                tx_out <= shift_reg[0];
                if (baud_count == 16'b0) begin
                    if (bit_count == 3'b111) begin
                        state <= STOP;
                        baud_count <= BAUD_DIV;
                    end
                    else begin
                        bit_count <= bit_count + 1'b1;
                        shift_reg <= {1'b0, shift_reg[7:1]};
                        baud_count <= BAUD_DIV;
                    end
                end
                else
                    baud_count <= baud_count - 1'b1;
            end

            STOP: begin
                tx_out <= 1'b1;
                if (baud_count == 16'b0) begin
                    state <= IDLE;
                    tx_done <= 1'b1;
                end
                else
                    baud_count <= baud_count - 1'b1;
            end
        endcase
    end
end

endmodule

module testbench;
    reg clk;
    reg rst_n;
    reg tx_start;
    reg [7:0] tx_data;
    wire tx_out;
    wire tx_done;

    uart_tx dut (
        .clk(clk),
        .rst_n(rst_n),
        .tx_start(tx_start),
        .tx_data(tx_data),
        .tx_out(tx_out),
        .tx_done(tx_done)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 0;
        rst_n = 0;
        tx_start = 0;
        tx_data = 0;

        #20 rst_n = 1;
        #10 tx_data = 8'h55;
        #10 tx_start = 1;
        #10 tx_start = 0;
        
        wait(tx_done);
        #1000;
        
        tx_data = 8'hAA;
        tx_start = 1;
        #10 tx_start = 0;
        
        wait(tx_done);
        #1000 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t rst_n=%b tx_start=%b tx_data=%h tx_out=%b tx_done=%b"",
                 $time, rst_n, tx_start, tx_data, tx_out, tx_done);
    end
endmodule",True,136,True,True,True,True,0.7,True,13.003029584884644,7.733565092086792,"graph LR
    CLK[Clock] --> UART_TX(UART TX FSM)
    RST[Reset] --> UART_TX
    DIN[Data In] --> [[TX_BUFFER]]
    TX_START[TX Start] --> UART_TX
    [[TX_BUFFER]] --> UART_TX
    CLK --> BAUD_GEN(Baud Rate Generator)
    BAUD_GEN --> UART_TX
    
    UART_TX --> TX_OUT[TX Output]
    UART_TX --> TX_BUSY[TX Busy]
    
    subgraph FSM_STATES
        IDLE{IDLE State} --> START{START Bit}
        START --> DATA{DATA Bits}
        DATA --> STOP{STOP Bit}
        STOP --> IDLE
    end
    
    subgraph TESTBENCH
        TB_CLK[Test Clock] --> TB_CTRL(Test Controller)
        TB_CTRL --> TB_DIN[Test Data]
        TB_CTRL --> TB_START[Test Start]
        TB_OUT[Test Output] --> TB_VERIFY(Verification)
    end","`timescale 1ns/1ps

module uart_tx (
    input wire clk,
    input wire rst,
    input wire tx_start,
    input wire [7:0] tx_buffer,
    input wire baud_tick,
    output reg tx_out,
    output reg tx_busy
);

localparam IDLE = 2'b00;
localparam START = 2'b01;
localparam DATA = 2'b10;
localparam STOP = 2'b11;

reg [1:0] state;
reg [2:0] bit_count;

always @(posedge clk or posedge rst) begin
    if (rst) begin
        state <= IDLE;
        tx_out <= 1'b1;
        tx_busy <= 1'b0;
        bit_count <= 3'b000;
    end
    else begin
        case (state)
            IDLE: begin
                if (tx_start) begin
                    state <= START;
                    tx_busy <= 1'b1;
                    tx_out <= 1'b0;
                end
                else begin
                    tx_out <= 1'b1;
                    tx_busy <= 1'b0;
                end
            end
            
            START: begin
                if (baud_tick) begin
                    state <= DATA;
                    tx_out <= tx_buffer[0];
                    bit_count <= 3'b000;
                end
            end
            
            DATA: begin
                if (baud_tick) begin
                    if (bit_count == 3'b111) begin
                        state <= STOP;
                        tx_out <= 1'b1;
                    end
                    else begin
                        bit_count <= bit_count + 1'b1;
                        tx_out <= tx_buffer[bit_count + 1];
                    end
                end
            end
            
            STOP: begin
                if (baud_tick) begin
                    state <= IDLE;
                end
            end
        endcase
    end
end

endmodule

module baud_generator #(
    parameter BAUD_RATE = 115200,
    parameter CLK_FREQ = 50000000
)(
    input wire clk,
    input wire rst,
    output reg baud_tick
);

localparam DIVIDER = CLK_FREQ/BAUD_RATE;
reg [$clog2(DIVIDER)-1:0] counter;

always @(posedge clk or posedge rst) begin
    if (rst) begin
        counter <= 0;
        baud_tick <= 0;
    end
    else begin
        if (counter == DIVIDER-1) begin
            counter <= 0;
            baud_tick <= 1'b1;
        end
        else begin
            counter <= counter + 1'b1;
            baud_tick <= 1'b0;
        end
    end
end

endmodule

module testbench;
    reg clk;
    reg rst;
    reg tx_start;
    reg [7:0] tx_buffer;
    wire tx_out;
    wire tx_busy;
    wire baud_tick;

    baud_generator #(
        .BAUD_RATE(115200),
        .CLK_FREQ(50000000)
    ) baud_gen (
        .clk(clk),
        .rst(rst),
        .baud_tick(baud_tick)
    );

    uart_tx uart_tx_inst (
        .clk(clk),
        .rst(rst),
        .tx_start(tx_start),
        .tx_buffer(tx_buffer),
        .baud_tick(baud_tick),
        .tx_out(tx_out),
        .tx_busy(tx_busy)
    );

    initial begin
        $dumpfile(""uart_tx.vcd"");
        $dumpvars(0, testbench);
        
        clk = 0;
        rst = 1;
        tx_start = 0;
        tx_buffer = 8'h00;
        
        #20 rst = 0;
        #20 tx_buffer = 8'h55;
        #20 tx_start = 1;
        #20 tx_start = 0;
        
        #5000 $finish;
    end

    always #10 clk = ~clk;

    initial begin
        $monitor(""Time=%0t rst=%b tx_start=%b tx_buffer=%h tx_out=%b tx_busy=%b"",
                 $time, rst, tx_start, tx_buffer, tx_out, tx_busy);
    end
endmodule",True,156,True,True,True,,0.0,,19.397239446640015,0.01744985580444336,"Design UART transmitter with states: IDLE, START, DATA, STOP. Protocol: START(0), 8 data bits LSB-first, STOP(1). Baud rate divider. Include testbench.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph LR
    CLK[Clock] --> UART_TX(UART TX FSM)
    RST[Reset] --> UART_TX
    DIN[Data In] --> [[TX_BUFFER]]
    TX_START[TX Start] --> UART_TX
    [[TX_BUFFER]] --> UART_TX
    CLK --> BAUD_GEN(Baud Rate Generator)
    BAUD_GEN --> UART_TX
    
    UART_TX --> TX_OUT[TX Output]
    UART_TX --> TX_BUSY[TX Busy]
    
    subgraph FSM_STATES
        IDLE{IDLE State} --> START{START Bit}
        START --> DATA{DATA Bits}
        DATA --> STOP{STOP Bit}
        STOP --> IDLE
    end
    
    subgraph TESTBENCH
        TB_CLK[Test Clock] --> TB_CTRL(Test Controller)
        TB_CTRL --> TB_DIN[Test Data]
        TB_CTRL --> TB_START[Test Start]
        TB_OUT[Test Output] --> TB_VERIFY(Verification)
    end
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module uart_tx (
    input wire clk,
    input wire rst,
    input wire tx_start,
    input wire [7:0] data_in,
    output reg tx_out,
    output reg tx_busy
);

localparam IDLE = 2'b00,
           START = 2'b01,
           DATA = 2'b10,
           STOP = 2'b11;

reg [1:0] state;
reg [7:0] tx_data;
reg [2:0] bit_count;
reg baud_tick;
reg [15:0] baud_counter;

// Baud rate generator (9600 baud for 50MHz clock)
localparam BAUD_DIVIDER = 16'd5208;

always @(posedge clk or posedge rst) begin
    if (rst) begin
        baud_counter <= 16'd0;
        baud_tick <= 1'b0;
    end else begin
        if (baud_counter == BAUD_DIVIDER - 1) begin
            baud_counter <= 16'd0;
            baud_tick <= 1'b1;
        end else begin
            baud_counter <= baud_counter + 1'b1;
            baud_tick <= 1'b0;
        end
    end
end

// UART TX FSM
always @(posedge clk or posedge rst) begin
    if (rst) begin
        state <= IDLE;
        tx_out <= 1'b1;
        tx_busy <= 1'b0;
        bit_count <= 3'd0;
        tx_data <= 8'd0;
    end else begin
        case (state)
            IDLE: begin
                if (tx_start) begin
                    state <= START;
                    tx_busy <= 1'b1;
                    tx_data <= data_in;
                end
                tx_out <= 1'b1;
            end

            START: begin
                if (baud_tick) begin
                    state <= DATA;
                    tx_out <= 1'b0;
                    bit_count <= 3'd0;
                end
            end

            DATA: begin
                if (baud_tick) begin
                    if (bit_count == 3'd7) begin
                        state <= STOP;
                    end else begin
                        bit_count <= bit_count + 1'b1;
                    end
                    tx_out <= tx_data[bit_count];
                end
            end

            STOP: begin
                if (baud_tick) begin
                    state <= IDLE;
                    tx_out <= 1'b1;
                    tx_busy <= 1'b0;
                end
            end
        endcase
    end
end

endmodule

module uart_tx_tb;
    reg clk;
    reg rst;
    reg tx_start;
    reg [7:0] data_in;
    wire tx_out;
    wire tx_busy;

    uart_tx dut (
        .clk(clk),
        .rst(rst),
        .tx_start(tx_start),
        .data_in(data_in),
        .tx_out(tx_out),
        .tx_busy(tx_busy)
    );

    initial begin
        $dumpfile(""uart_tx.vcd"");
        $dumpvars(0, uart_tx_tb);

        clk = 1'b0;
        rst = 1'b1;
        tx_start = 1'b0;
        data_in = 8'h00;

        #100 rst = 1'b0;
        
        // Test transmission of 'A' (0x41)
        #100;
        data_in = 8'h41;
        tx_start = 1'b1;
        #10;
        tx_start = 1'b0;
        
        // Wait for transmission to complete
        wait (!tx_busy);
        
        // Test transmission of '1' (0x31)
        #1000;
        data_in = 8'h31;
        tx_start = 1'b1;
        #10;
        tx_start = 1'b0;
        
        // Wait for transmission to complete
        wait (!tx_busy);
        
        #2000 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t rst=%b tx_start=%b data_in=%h tx_out=%b tx_busy=%b"",
                 $time, rst, tx_start, data_in, tx_out, tx_busy);
    end
endmodule",True,149,False,True,True,,0.0,,13.65723204612732,0.23815441131591797,prompt_only,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,State Machine,complex,"Design UART transmitter with states: IDLE, START, DATA, STOP. Protocol: START(0), 8 data bits LSB-first, STOP(1). Baud rate divider. Include testbench.",gpt-4o,"`timescale 1ns/1ps

module uart_tx(
    input wire clk,
    input wire rst_n,
    input wire tx_start,
    input wire [7:0] tx_data,
    output reg tx_serial,
    output reg tx_busy
);

    reg [3:0] state;
    reg [3:0] bit_index;
    reg [15:0] baud_counter;
    reg baud_tick;
    
    parameter IDLE = 4'd0;
    parameter START = 4'd1;
    parameter DATA = 4'd2;
    parameter STOP = 4'd3;
    parameter BAUD_DIV = 16'd5208; // Example value for 9600 baud rate with 50MHz clock

    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            state <= IDLE;
            tx_serial <= 1'b1;
            tx_busy <= 1'b0;
            bit_index <= 4'd0;
            baud_counter <= 16'd0;
            baud_tick <= 1'b0;
        end else begin
            baud_tick <= 1'b0;
            if (baud_counter == BAUD_DIV) begin
                baud_counter <= 16'd0;
                baud_tick <= 1'b1;
            end else begin
                baud_counter <= baud_counter + 1'b1;
            end

            case (state)
                IDLE: begin
                    tx_serial <= 1'b1;
                    tx_busy <= 1'b0;
                    if (tx_start) begin
                        state <= START;
                        tx_busy <= 1'b1;
                    end
                end
                START: begin
                    if (baud_tick) begin
                        tx_serial <= 1'b0;
                        state <= DATA;
                        bit_index <= 4'd0;
                    end
                end
                DATA: begin
                    if (baud_tick) begin
                        tx_serial <= tx_data[bit_index];
                        if (bit_index == 4'd7) begin
                            state <= STOP;
                        end else begin
                            bit_index <= bit_index + 1'b1;
                        end
                    end
                end
                STOP: begin
                    if (baud_tick) begin
                        tx_serial <= 1'b1;
                        state <= IDLE;
                    end
                end
            endcase
        end
    end

endmodule

module testbench;
    reg clk, rst_n, tx_start;
    reg [7:0] tx_data;
    wire tx_serial, tx_busy;

    uart_tx dut (
        .clk(clk),
        .rst_n(rst_n),
        .tx_start(tx_start),
        .tx_data(tx_data),
        .tx_serial(tx_serial),
        .tx_busy(tx_busy)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 1'b0;
        rst_n = 1'b0;
        tx_start = 1'b0;
        tx_data = 8'b10101010;

        #20 rst_n = 1'b1;
        #10 tx_start = 1'b1;
        #10 tx_start = 1'b0;
        #1000 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b tx_start=%b tx_data=%b tx_serial=%b tx_busy=%b"", 
                 $time, clk, rst_n, tx_start, tx_data, tx_serial, tx_busy);
    end
endmodule",True,113,True,True,True,True,0.9,True,25.10636854171753,9.508700370788574,"graph TD
    CLK[Clock] --> PROC[UART Transmitter]
    RST[Reset] --> PROC
    BAUD[Baud Rate Divider] --> PROC
    DATA_IN[Data Input] --> PROC

    subgraph UART_Transmitter
        IDLE_STATE(IDLE State)
        START_STATE(START State)
        DATA_STATE(DATA State)
        STOP_STATE(STOP State)
        
        PROC --> IDLE_STATE
        IDLE_STATE -->|start_signal| START_STATE
        START_STATE -->|start_bit(0)| DATA_STATE
        DATA_STATE -->|8_data_bits| STOP_STATE
        STOP_STATE -->|stop_bit(1)| IDLE_STATE
    end

    PROC --> DATA_OUT[Data Output]","`timescale 1ns/1ps

module uart_transmitter(
    input wire clk,
    input wire rst_n,
    input wire baud_rate,
    input wire [7:0] data_in,
    output reg data_out
);

    reg [1:0] state, next_state;
    reg [3:0] bit_count;
    reg [7:0] data_buffer;
    reg start_signal, send_bit;

    localparam IDLE_STATE = 2'b00;
    localparam START_STATE = 2'b01;
    localparam DATA_STATE = 2'b10;
    localparam STOP_STATE = 2'b11;

    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            state <= IDLE_STATE;
            bit_count <= 4'b0000;
            data_out <= 1'b1;
        end else begin
            state <= next_state;
            if (send_bit) begin
                bit_count <= bit_count + 1'b1;
            end
        end
    end

    always @(*) begin
        next_state = state;
        send_bit = 1'b0;
        data_out = 1'b1;

        case (state)
            IDLE_STATE: begin
                if (start_signal) begin
                    next_state = START_STATE;
                    data_buffer = data_in;
                end
            end
            START_STATE: begin
                data_out = 1'b0; // Start bit
                next_state = DATA_STATE;
                send_bit = 1'b1;
            end
            DATA_STATE: begin
                data_out = data_buffer[0];
                data_buffer = data_buffer >> 1;
                if (bit_count == 4'b0111) begin
                    next_state = STOP_STATE;
                end else begin
                    send_bit = 1'b1;
                end
            end
            STOP_STATE: begin
                data_out = 1'b1; // Stop bit
                next_state = IDLE_STATE;
            end
            default: next_state = IDLE_STATE;
        endcase
    end

endmodule

module testbench;
    reg clk, rst_n, start_signal;
    reg [7:0] data_in;
    wire data_out;
    
    uart_transmitter dut (
        .clk(clk),
        .rst_n(rst_n),
        .baud_rate(1'b1),
        .data_in(data_in),
        .data_out(data_out)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst_n = 1'b0;
        start_signal = 1'b0;
        data_in = 8'b10101010;
        
        #20 rst_n = 1'b1;
        #10 start_signal = 1'b1;
        #10 start_signal = 1'b0;
        #200 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b data_out=%b"", 
                 $time, clk, rst_n, data_out);
    end
endmodule",True,104,True,True,True,True,0.9,True,11.048115015029907,11.786391496658325,"Design UART transmitter with states: IDLE, START, DATA, STOP. Protocol: START(0), 8 data bits LSB-first, STOP(1). Baud rate divider. Include testbench.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph TD
    CLK[Clock] --> PROC[UART Transmitter]
    RST[Reset] --> PROC
    BAUD[Baud Rate Divider] --> PROC
    DATA_IN[Data Input] --> PROC

    subgraph UART_Transmitter
        IDLE_STATE(IDLE State)
        START_STATE(START State)
        DATA_STATE(DATA State)
        STOP_STATE(STOP State)
        
        PROC --> IDLE_STATE
        IDLE_STATE -->|start_signal| START_STATE
        START_STATE -->|start_bit(0)| DATA_STATE
        DATA_STATE -->|8_data_bits| STOP_STATE
        STOP_STATE -->|stop_bit(1)| IDLE_STATE
    end

    PROC --> DATA_OUT[Data Output]
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module uart_transmitter(
    input wire clk,
    input wire rst,
    input wire baud_tick,
    input wire [7:0] data_in,
    input wire start_signal,
    output reg data_out
);

    // State encoding
    parameter IDLE_STATE  = 2'b00;
    parameter START_STATE = 2'b01;
    parameter DATA_STATE  = 2'b10;
    parameter STOP_STATE  = 2'b11;

    reg [1:0] state, next_state;
    reg [2:0] bit_counter;
    reg [7:0] shift_reg;

    always @(posedge clk or posedge rst) begin
        if (rst) begin
            state <= IDLE_STATE;
            bit_counter <= 3'b000;
            shift_reg <= 8'b0;
            data_out <= 1'b1;
        end else begin
            if (baud_tick) begin
                state <= next_state;
                case (state)
                    IDLE_STATE: begin
                        if (start_signal) begin
                            shift_reg <= data_in;
                            data_out <= 1'b0; // Start bit
                        end
                    end
                    START_STATE: begin
                        data_out <= shift_reg[0]; // Send LSB first
                        shift_reg <= shift_reg >> 1;
                    end
                    DATA_STATE: begin
                        data_out <= shift_reg[0];
                        shift_reg <= shift_reg >> 1;
                        bit_counter <= bit_counter + 1'b1;
                    end
                    STOP_STATE: begin
                        data_out <= 1'b1; // Stop bit
                    end
                endcase
            end
        end
    end

    always @(*) begin
        next_state = state;
        case (state)
            IDLE_STATE: begin
                if (start_signal)
                    next_state = START_STATE;
            end
            START_STATE: begin
                next_state = DATA_STATE;
            end
            DATA_STATE: begin
                if (bit_counter == 3'b111)
                    next_state = STOP_STATE;
            end
            STOP_STATE: begin
                next_state = IDLE_STATE;
            end
        endcase
    end

endmodule

module testbench;
    reg clk, rst, start_signal, baud_tick;
    reg [7:0] data_in;
    wire data_out;

    uart_transmitter dut (
        .clk(clk),
        .rst(rst),
        .baud_tick(baud_tick),
        .data_in(data_in),
        .start_signal(start_signal),
        .data_out(data_out)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 1'b0;
        rst = 1'b1;
        start_signal = 1'b0;
        baud_tick = 1'b0;
        data_in = 8'b10101010;

        #15 rst = 1'b0;
        #10 start_signal = 1'b1; 
        #10 baud_tick = 1'b1; 
        #10 baud_tick = 1'b0;
        #80 baud_tick = 1'b1;
        #10 baud_tick = 1'b0;
        #80 baud_tick = 1'b1;
        #10 baud_tick = 1'b0;
        #80 baud_tick = 1'b1;
        #10 baud_tick = 1'b0;
        #80 baud_tick = 1'b1;
        #10 baud_tick = 1'b0;
        #80 baud_tick = 1'b1;
        #10 baud_tick = 1'b0;
        #80 baud_tick = 1'b1;
        #10 baud_tick = 1'b0;
        #80 baud_tick = 1'b1;
        #10 baud_tick = 1'b0;
        #80 baud_tick = 1'b1;
        #10 baud_tick = 1'b0;
        #80 baud_tick = 1'b1;
        #10 baud_tick = 1'b0;
        #80 baud_tick = 1'b1;
        #10 baud_tick = 1'b0;
        #80 baud_tick = 1'b1;
        #10 baud_tick = 1'b0;
        #80 baud_tick = 1'b1;
        #10 baud_tick = 1'b0;
        #50 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t clk=%b rst=%b start_signal=%b data_in=%b data_out=%b"", 
                 $time, clk, rst, start_signal, data_in, data_out);
    end
endmodule",True,138,True,True,True,True,0.7,True,16.54727864265442,12.250807762145996,prompt_only,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,CPU Component,complex,Create 8-register  8-bit register file with dual read ports and single write port. Include testbench with simultaneous operations.,claude,"`timescale 1ns/1ps

module register_file(
    input wire clk,
    input wire rst_n,
    input wire write_en,
    input wire [2:0] write_addr,
    input wire [7:0] write_data,
    input wire [2:0] read_addr1,
    input wire [2:0] read_addr2,
    output reg [7:0] read_data1,
    output reg [7:0] read_data2
);

reg [7:0] registers [0:7];
integer i;

always @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
        for (i = 0; i < 8; i = i + 1) begin
            registers[i] <= 8'b0;
        end
    end
    else if (write_en) begin
        registers[write_addr] <= write_data;
    end
end

always @(*) begin
    read_data1 = registers[read_addr1];
    read_data2 = registers[read_addr2];
end

endmodule

module testbench;
    reg clk, rst_n, write_en;
    reg [2:0] write_addr, read_addr1, read_addr2;
    reg [7:0] write_data;
    wire [7:0] read_data1, read_data2;

    register_file dut (
        .clk(clk),
        .rst_n(rst_n),
        .write_en(write_en),
        .write_addr(write_addr),
        .write_data(write_data),
        .read_addr1(read_addr1),
        .read_addr2(read_addr2),
        .read_data1(read_data1),
        .read_data2(read_data2)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 0;
        rst_n = 0;
        write_en = 0;
        write_addr = 0;
        write_data = 0;
        read_addr1 = 0;
        read_addr2 = 0;

        #10 rst_n = 1;

        // Write test data
        #10 write_en = 1;
        write_addr = 3'd0; write_data = 8'hAA;
        #10 write_addr = 3'd1; write_data = 8'hBB;
        #10 write_addr = 3'd2; write_data = 8'hCC;

        // Read test
        #10 write_en = 0;
        read_addr1 = 3'd0;
        read_addr2 = 3'd1;
        #10 read_addr1 = 3'd1;
        read_addr2 = 3'd2;

        // Simultaneous read/write
        #10 write_en = 1;
        write_addr = 3'd3;
        write_data = 8'hDD;
        read_addr1 = 3'd2;
        read_addr2 = 3'd0;

        #20 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t rd1=%h rd2=%h"", $time, read_data1, read_data2);
    end
endmodule",True,96,True,True,True,False,0.4,False,10.026632308959961,7.183909893035889,"graph LR
    CLK[Clock] --> RF[[8x8 Register File]]
    RST[Reset] --> RF
    WE[Write Enable] --> RF
    WADDR[Write Address] --> RF
    WDATA[Write Data] --> RF
    RADDR1[Read Address 1] --> RF
    RADDR2[Read Address 2] --> RF
    RF --> RDATA1[Read Data 1]
    RF --> RDATA2[Read Data 2]
    subgraph TB[Testbench]
        WE_TEST[Write Enable Stimulus]
        WADDR_TEST[Write Address Stimulus]
        WDATA_TEST[Write Data Stimulus]
        RA1_TEST[Read Address 1 Stimulus]
        RA2_TEST[Read Address 2 Stimulus]
    end
    WE_TEST --> WE
    WADDR_TEST --> WADDR
    WDATA_TEST --> WDATA
    RA1_TEST --> RADDR1
    RA2_TEST --> RADDR2","`timescale 1ns/1ps

module register_file(
    input wire clk,
    input wire rst,
    input wire we,
    input wire [2:0] waddr,
    input wire [7:0] wdata,
    input wire [2:0] raddr1,
    input wire [2:0] raddr2,
    output reg [7:0] rdata1,
    output reg [7:0] rdata2
);

reg [7:0] registers [0:7];
integer i;

always @(posedge clk or posedge rst) begin
    if (rst) begin
        for (i = 1'b0; i < 8; i = i + 1) begin
            registers[i] <= 8'b0;
        end
    end else begin
        if (we)
            registers[waddr] <= wdata;
        rdata1 <= registers[raddr1];
        rdata2 <= registers[raddr2];
    end
end

endmodule

module testbench;
    reg clk, rst, we;
    reg [2:0] waddr, raddr1, raddr2;
    reg [7:0] wdata;
    wire [7:0] rdata1, rdata2;

    register_file dut (
        .clk(clk),
        .rst(rst),
        .we(we),
        .waddr(waddr),
        .wdata(wdata),
        .raddr1(raddr1),
        .raddr2(raddr2),
        .rdata1(rdata1),
        .rdata2(rdata2)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 1'b0;
        rst = 1'b1;
        we = 1'b0;
        waddr = 1'b0;
        wdata = 1'b0;
        raddr1 = 1'b0;
        raddr2 = 1'b0;

        #20 rst = 1'b0;

        // Write test pattern
        #10 we = 1'b1;
        #10 waddr = 3'h1; wdata = 8'h55;
        #10 waddr = 3'h2; wdata = 8'hAA;
        #10 we = 1'b0;

        // Read test pattern
        #10 raddr1 = 3'h1; raddr2 = 3'h2;
        #20 raddr1 = 3'h2; raddr2 = 3'h1;

        #50 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t rst=%b we=%b waddr=%h wdata=%h raddr1=%h rdata1=%h raddr2=%h rdata2=%h"",
                 $time, rst, we, waddr, wdata, raddr1, rdata1, raddr2, rdata2);
    end
endmodule",True,84,True,True,True,True,0.75,True,12.654834270477295,9.68914794921875,"Create 8-register  8-bit register file with dual read ports and single write port. Include testbench with simultaneous operations.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph LR
    CLK[Clock] --> RF[[8x8 Register File]]
    RST[Reset] --> RF
    WE[Write Enable] --> RF
    WADDR[Write Address] --> RF
    WDATA[Write Data] --> RF
    RADDR1[Read Address 1] --> RF
    RADDR2[Read Address 2] --> RF
    RF --> RDATA1[Read Data 1]
    RF --> RDATA2[Read Data 2]
    subgraph TB[Testbench]
        WE_TEST[Write Enable Stimulus]
        WADDR_TEST[Write Address Stimulus]
        WDATA_TEST[Write Data Stimulus]
        RA1_TEST[Read Address 1 Stimulus]
        RA2_TEST[Read Address 2 Stimulus]
    end
    WE_TEST --> WE
    WADDR_TEST --> WADDR
    WDATA_TEST --> WDATA
    RA1_TEST --> RADDR1
    RA2_TEST --> RADDR2
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module register_file(
    input wire clk,
    input wire rst,
    input wire we,
    input wire [2:0] waddr,
    input wire [7:0] wdata,
    input wire [2:0] raddr1,
    input wire [2:0] raddr2,
    output wire [7:0] rdata1,
    output wire [7:0] rdata2
);

reg [7:0] registers [0:7];
integer i;

assign rdata1 = registers[raddr1];
assign rdata2 = registers[raddr2];

always @(posedge clk or posedge rst) begin
    if (rst) begin
        for (i = 0; i < 8; i = i + 1)
            registers[i] <= 8'b0;
    end
    else if (we) begin
        registers[waddr] <= wdata;
    end
end

endmodule

module testbench;
    reg clk;
    reg rst;
    reg we;
    reg [2:0] waddr;
    reg [7:0] wdata;
    reg [2:0] raddr1;
    reg [2:0] raddr2;
    wire [7:0] rdata1;
    wire [7:0] rdata2;

    register_file dut (
        .clk(clk),
        .rst(rst),
        .we(we),
        .waddr(waddr),
        .wdata(wdata),
        .raddr1(raddr1),
        .raddr2(raddr2),
        .rdata1(rdata1),
        .rdata2(rdata2)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 0;
        rst = 1;
        we = 0;
        waddr = 0;
        wdata = 0;
        raddr1 = 0;
        raddr2 = 0;
        
        #10 rst = 0;
        
        // Write some values
        #10 we = 1; waddr = 3'h0; wdata = 8'h11;
        #10 waddr = 3'h1; wdata = 8'h22;
        #10 waddr = 3'h2; wdata = 8'h33;
        #10 we = 0;
        
        // Read from different addresses
        #10 raddr1 = 3'h0; raddr2 = 3'h1;
        #10 raddr1 = 3'h1; raddr2 = 3'h2;
        #10 raddr1 = 3'h2; raddr2 = 3'h0;
        
        #10 rst = 1;
        #10 rst = 0;
        
        #20 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t rst=%b we=%b waddr=%h wdata=%h raddr1=%h rdata1=%h raddr2=%h rdata2=%h"",
                 $time, rst, we, waddr, wdata, raddr1, rdata1, raddr2, rdata2);
    end

endmodule",True,94,True,True,True,False,0.4,False,10.732896327972412,7.9996373653411865,tie,prompt_only > combined > mermaid_only,prompt_only > mermaid_only > combined
combined,CPU Component,complex,Create 8-register  8-bit register file with dual read ports and single write port. Include testbench with simultaneous operations.,gpt-4o,"`timescale 1ns/1ps

module register_file(
    input wire clk,
    input wire rst_n,
    input wire [2:0] read_addr1,
    input wire [2:0] read_addr2,
    input wire [2:0] write_addr,
    input wire [7:0] write_data,
    input wire write_enable,
    output reg [7:0] read_data1,
    output reg [7:0] read_data2
);

    reg [7:0] registers [7:0];

    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            registers[0] <= 8'b0;
            registers[1] <= 8'b0;
            registers[2] <= 8'b0;
            registers[3] <= 8'b0;
            registers[4] <= 8'b0;
            registers[5] <= 8'b0;
            registers[6] <= 8'b0;
            registers[7] <= 8'b0;
        end else if (write_enable) begin
            registers[write_addr] <= write_data;
        end
    end

    always @(*) begin
        read_data1 = registers[read_addr1];
        read_data2 = registers[read_addr2];
    end

endmodule

module testbench;
    reg clk, rst_n, write_enable;
    reg [2:0] read_addr1, read_addr2, write_addr;
    reg [7:0] write_data;
    wire [7:0] read_data1, read_data2;

    register_file dut (
        .clk(clk),
        .rst_n(rst_n),
        .read_addr1(read_addr1),
        .read_addr2(read_addr2),
        .write_addr(write_addr),
        .write_data(write_data),
        .write_enable(write_enable),
        .read_data1(read_data1),
        .read_data2(read_data2)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 1'b0;
        rst_n = 1'b0;
        write_enable = 1'b0;
        read_addr1 = 3'b000;
        read_addr2 = 3'b000;
        write_addr = 3'b000;
        write_data = 8'b00000000;

        #20 rst_n = 1'b1;
        #10 write_enable = 1'b1; write_addr = 3'b001; write_data = 8'b10101010;
        #10 write_enable = 1'b1; write_addr = 3'b010; write_data = 8'b11001100;
        #10 write_enable = 1'b0; read_addr1 = 3'b001; read_addr2 = 3'b010;
        #20 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b write_enable=%b write_addr=%b write_data=%b read_addr1=%b read_data1=%b read_addr2=%b read_data2=%b"", 
                 $time, clk, rst_n, write_enable, write_addr, write_data, read_addr1, read_data1, read_addr2, read_data2);
    end
endmodule",True,82,True,True,True,True,0.7,True,8.350799798965454,10.482167959213257,"graph LR
    CLK[Clock] --> FILE[[8x8 Register File]]
    RST[Reset] --> FILE
    
    WDATA[Write Data] --> FILE
    WADDR[Write Address] --> FILE
    WEN[Write Enable] --> FILE
    
    R1ADDR[Read Address 1] --> FILE
    R2ADDR[Read Address 2] --> FILE
    
    FILE --> R1DATA[Read Data 1]
    FILE --> R2DATA[Read Data 2]
    
    % Control signals for write operation
    CLK --> WEN
    CLK --> R1ADDR
    CLK --> R2ADDR

    subgraph TESTBENCH
        direction TB
        TESTCLK[Test Clock] --> FILE
        TESTRST[Test Reset] --> FILE
        TESTWDATA[Test Write Data] --> WDATA
        TESTWADDR[Test Write Address] --> WADDR
        TESTWEN[Test Write Enable] --> WEN
        TESTR1ADDR[Test Read Address 1] --> R1ADDR
        TESTR2ADDR[Test Read Address 2] --> R2ADDR
        TESTR1DATA[Test Read Data 1] <-- R1DATA
        TESTR2DATA[Test Read Data 2] <-- R2DATA
    end","`timescale 1ns/1ps

module register_file(
    input wire clk,
    input wire rst_n,
    input wire [7:0] write_data,
    input wire [2:0] write_address,
    input wire write_enable,
    input wire [2:0] read_address_1,
    input wire [2:0] read_address_2,
    output reg [7:0] read_data_1,
    output reg [7:0] read_data_2
);

    reg [7:0] register_file [7:0];
    integer i;

    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            for (i = 1'b0; i < 8; i = i + 1) begin
                register_file[i] <= 8'b0;
            end
        end else if (write_enable) begin
            register_file[write_address] <= write_data;
        end
    end

    always @(posedge clk) begin
        read_data_1 <= register_file[read_address_1];
        read_data_2 <= register_file[read_address_2];
    end

endmodule

module testbench;
    reg test_clk;
    reg test_rst_n;
    reg [7:0] test_write_data;
    reg [2:0] test_write_address;
    reg test_write_enable;
    reg [2:0] test_read_address_1;
    reg [2:0] test_read_address_2;
    wire [7:0] test_read_data_1;
    wire [7:0] test_read_data_2;
    
    register_file dut (
        .clk(test_clk),
        .rst_n(test_rst_n),
        .write_data(test_write_data),
        .write_address(test_write_address),
        .write_enable(test_write_enable),
        .read_address_1(test_read_address_1),
        .read_address_2(test_read_address_2),
        .read_data_1(test_read_data_1),
        .read_data_2(test_read_data_2)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        test_clk = 1'b0;
        test_rst_n = 1'b0;
        test_write_enable = 1'b0;
        test_write_data = 8'b0;
        test_write_address = 3'b0;
        test_read_address_1 = 3'b0;
        test_read_address_2 = 3'b0;
        
        #20 test_rst_n = 1'b1;
        #10 test_write_enable = 1'b1; test_write_data = 8'hAA; test_write_address = 3'b001;
        #10 test_write_enable = 1'b0; test_read_address_1 = 3'b001;
        #10 test_read_address_2 = 3'b001;
        #50 $finish;
    end
    
    always #5 test_clk = ~test_clk;
    
    initial begin
        $monitor(""Time=%0t test_clk=%b test_rst_n=%b test_write_enable=%b test_write_data=%h test_read_data_1=%h test_read_data_2=%h"", 
                 $time, test_clk, test_rst_n, test_write_enable, test_write_data, test_read_data_1, test_read_data_2);
    end
endmodule",True,83,True,True,True,True,0.75,True,12.64707350730896,16.780420780181885,"Create 8-register  8-bit register file with dual read ports and single write port. Include testbench with simultaneous operations.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph LR
    CLK[Clock] --> FILE[[8x8 Register File]]
    RST[Reset] --> FILE
    
    WDATA[Write Data] --> FILE
    WADDR[Write Address] --> FILE
    WEN[Write Enable] --> FILE
    
    R1ADDR[Read Address 1] --> FILE
    R2ADDR[Read Address 2] --> FILE
    
    FILE --> R1DATA[Read Data 1]
    FILE --> R2DATA[Read Data 2]
    
    % Control signals for write operation
    CLK --> WEN
    CLK --> R1ADDR
    CLK --> R2ADDR

    subgraph TESTBENCH
        direction TB
        TESTCLK[Test Clock] --> FILE
        TESTRST[Test Reset] --> FILE
        TESTWDATA[Test Write Data] --> WDATA
        TESTWADDR[Test Write Address] --> WADDR
        TESTWEN[Test Write Enable] --> WEN
        TESTR1ADDR[Test Read Address 1] --> R1ADDR
        TESTR2ADDR[Test Read Address 2] --> R2ADDR
        TESTR1DATA[Test Read Data 1] <-- R1DATA
        TESTR2DATA[Test Read Data 2] <-- R2DATA
    end
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module register_file(
    input wire clk,
    input wire rst,
    input wire [7:0] wdata,
    input wire [2:0] waddr,
    input wire wen,
    input wire [2:0] r1addr,
    input wire [2:0] r2addr,
    output reg [7:0] r1data,
    output reg [7:0] r2data
);

reg [7:0] registers [0:7];

always @(posedge clk or posedge rst) begin
    if (rst) begin
        registers[0] <= 8'b0;
        registers[1] <= 8'b0;
        registers[2] <= 8'b0;
        registers[3] <= 8'b0;
        registers[4] <= 8'b0;
        registers[5] <= 8'b0;
        registers[6] <= 8'b0;
        registers[7] <= 8'b0;
    end else if (wen) begin
        registers[waddr] <= wdata;
    end
end

always @(posedge clk) begin
    r1data <= registers[r1addr];
    r2data <= registers[r2addr];
end

endmodule

module testbench;
    reg testclk;
    reg testrst;
    reg [7:0] testwdata;
    reg [2:0] testwaddr;
    reg testwen;
    reg [2:0] testr1addr;
    reg [2:0] testr2addr;
    wire [7:0] testr1data;
    wire [7:0] testr2data;

    register_file dut (
        .clk(testclk),
        .rst(testrst),
        .wdata(testwdata),
        .waddr(testwaddr),
        .wen(testwen),
        .r1addr(testr1addr),
        .r2addr(testr2addr),
        .r1data(testr1data),
        .r2data(testr2data)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        testclk = 1'b0;
        testrst = 1'b0;
        testwen = 1'b0;
        testwdata = 8'b0;
        testwaddr = 3'b0;
        testr1addr = 3'b0;
        testr2addr = 3'b0;

        #10 testrst = 1'b1;
        #10 testrst = 1'b0;
        #10 testwdata = 8'hA5; testwaddr = 3'b001; testwen = 1'b1;
        #10 testwen = 1'b0;
        #10 testr1addr = 3'b001;
        #10 testr2addr = 3'b001;
        #50 $finish;
    end

    always #5 testclk = ~testclk;

    initial begin
        $monitor(""Time=%0t testclk=%b testrst=%b testwen=%b testr1addr=%d testr2addr=%d testr1data=%h testr2data=%h"",
                 $time, testclk, testrst, testwen, testr1addr, testr2addr, testr1data, testr2data);
    end
endmodule",True,89,True,True,True,False,0.3,False,8.758952617645264,13.729492664337158,combined,combined > prompt_only > mermaid_only,prompt_only > mermaid_only > combined
combined,Advanced Sequential,complex,"Design 8-bit resolution PWM generator with configurable duty cycle. Include testbench with duty cycles: 0%, 25%, 50%, 75%, 100%.",claude,"`timescale 1ns/1ps

module pwm_gen (
    input wire clk,
    input wire rst_n,
    input wire [7:0] duty_cycle,
    output reg pwm_out
);

reg [7:0] counter;

always @(posedge clk or negedge rst_n) begin
    if (!rst_n)
        counter <= 8'b0;
    else
        counter <= counter + 1'b1;
end

always @(posedge clk or negedge rst_n) begin
    if (!rst_n)
        pwm_out <= 1'b0;
    else
        pwm_out <= (counter < duty_cycle);
end

endmodule

module testbench;
    reg clk;
    reg rst_n;
    reg [7:0] duty_cycle;
    wire pwm_out;

    pwm_gen dut (
        .clk(clk),
        .rst_n(rst_n),
        .duty_cycle(duty_cycle),
        .pwm_out(pwm_out)
    );

    initial begin
        $dumpfile(""pwm.vcd"");
        $dumpvars(0, testbench);

        clk = 0;
        rst_n = 0;
        duty_cycle = 8'd0;

        #20 rst_n = 1;

        // Test 0% duty cycle
        duty_cycle = 8'd0;
        #512;

        // Test 25% duty cycle
        duty_cycle = 8'd64;
        #512;

        // Test 50% duty cycle
        duty_cycle = 8'd128;
        #512;

        // Test 75% duty cycle
        duty_cycle = 8'd192;
        #512;

        // Test 100% duty cycle
        duty_cycle = 8'd255;
        #512;

        $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t rst_n=%b duty_cycle=%d pwm_out=%b"",
                 $time, rst_n, duty_cycle, pwm_out);
    end
endmodule",True,80,True,True,True,,0.0,,6.5026469230651855,0.029776573181152344,"graph TD
    CLK[Clock Input] --> CNT((8-bit Counter))
    RST[Reset] --> CNT
    
    DUTY[[8-bit Duty Value]] --> COMP
    CNT --> COMP((Magnitude Comparator))
    
    COMP --> PWM_OUT[PWM Output]
    
    TB_DUTY0[[Duty=0/255]] --> TEST{Test MUX}
    TB_DUTY25[[Duty=64/255]] --> TEST
    TB_DUTY50[[Duty=128/255]] --> TEST
    TB_DUTY75[[Duty=192/255]] --> TEST
    TB_DUTY100[[Duty=255/255]] --> TEST
    
    TEST --> DUTY
    
    SEL[Test Select] --> TEST
    
    CLK --> PWM_OUT
    RST --> PWM_OUT","`timescale 1ns/1ps

module pwm_generator(
    input wire clk,
    input wire rst,
    input wire [2:0] sel,
    output reg pwm_out
);

reg [7:0] counter;
reg [7:0] duty;

// Counter logic
always @(posedge clk or posedge rst) begin
    if (rst)
        counter <= 8'h00;
    else
        counter <= counter + 1'b1;
end

// Duty cycle MUX
always @(*) begin
    case (sel)
        3'd0: duty = 8'd0;    // 0%
        3'd1: duty = 8'd64;   // 25%
        3'd2: duty = 8'd128;  // 50%
        3'd3: duty = 8'd192;  // 75%
        3'd4: duty = 8'd255;  // 100%
        default: duty = 8'd0;
    endcase
end

// PWM output comparator
always @(posedge clk or posedge rst) begin
    if (rst)
        pwm_out <= 1'b0;
    else
        pwm_out <= (counter < duty);
end

endmodule

module testbench;
    reg clk;
    reg rst;
    reg [2:0] sel;
    wire pwm_out;

    pwm_generator dut (
        .clk(clk),
        .rst(rst),
        .sel(sel),
        .pwm_out(pwm_out)
    );

    initial begin
        $dumpfile(""pwm.vcd"");
        $dumpvars(0, testbench);

        clk = 0;
        rst = 1;
        sel = 0;

        #20 rst = 0;

        // Test each duty cycle
        #256 sel = 1;
        #256 sel = 2;
        #256 sel = 3;
        #256 sel = 4;
        
        #256 rst = 1;
        #20 rst = 0;
        #100 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t rst=%b sel=%d duty=%d counter=%d pwm=%b"",
                 $time, rst, sel, dut.duty, dut.counter, pwm_out);
    end
endmodule",True,83,True,True,True,,0.0,,12.16547179222107,0.019498586654663086,"Design 8-bit resolution PWM generator with configurable duty cycle. Include testbench with duty cycles: 0%, 25%, 50%, 75%, 100%.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph TD
    CLK[Clock Input] --> CNT((8-bit Counter))
    RST[Reset] --> CNT
    
    DUTY[[8-bit Duty Value]] --> COMP
    CNT --> COMP((Magnitude Comparator))
    
    COMP --> PWM_OUT[PWM Output]
    
    TB_DUTY0[[Duty=0/255]] --> TEST{Test MUX}
    TB_DUTY25[[Duty=64/255]] --> TEST
    TB_DUTY50[[Duty=128/255]] --> TEST
    TB_DUTY75[[Duty=192/255]] --> TEST
    TB_DUTY100[[Duty=255/255]] --> TEST
    
    TEST --> DUTY
    
    SEL[Test Select] --> TEST
    
    CLK --> PWM_OUT
    RST --> PWM_OUT
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module pwm_gen (
    input wire clk,
    input wire rst,
    input wire [2:0] sel,
    output reg pwm_out
);

reg [7:0] counter;
wire [7:0] duty_value;
wire [7:0] duty_0, duty_25, duty_50, duty_75, duty_100;

assign duty_0 = 8'd0;
assign duty_25 = 8'd64;
assign duty_50 = 8'd128;
assign duty_75 = 8'd192;
assign duty_100 = 8'd255;

always @(posedge clk or posedge rst) begin
    if (rst)
        counter <= 8'd0;
    else
        counter <= counter + 1'b1;
end

reg [7:0] duty_mux;
always @(*) begin
    case(sel)
        3'd0: duty_mux = duty_0;
        3'd1: duty_mux = duty_25;
        3'd2: duty_mux = duty_50;
        3'd3: duty_mux = duty_75;
        3'd4: duty_mux = duty_100;
        default: duty_mux = duty_0;
    endcase
end

always @(posedge clk or posedge rst) begin
    if (rst)
        pwm_out <= 1'b0;
    else
        pwm_out <= (counter < duty_mux);
end

endmodule

module testbench;
    reg clk;
    reg rst;
    reg [2:0] sel;
    wire pwm_out;

    pwm_gen dut (
        .clk(clk),
        .rst(rst),
        .sel(sel),
        .pwm_out(pwm_out)
    );

    initial begin
        $dumpfile(""pwm.vcd"");
        $dumpvars(0, testbench);
        
        clk = 0;
        rst = 1;
        sel = 0;
        
        #20 rst = 0;
        
        #512 sel = 1;
        #512 sel = 2;
        #512 sel = 3;
        #512 sel = 4;
        
        #512 $finish;
    end

    always #1 clk = ~clk;

    initial begin
        $monitor(""Time=%0t rst=%b sel=%d pwm=%b"", 
                 $time, rst, sel, pwm_out);
    end
endmodule",True,85,True,True,True,,0.0,,7.690901517868042,0.01831340789794922,prompt_only,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,Advanced Sequential,complex,"Design 8-bit resolution PWM generator with configurable duty cycle. Include testbench with duty cycles: 0%, 25%, 50%, 75%, 100%.",gpt-4o,"`timescale 1ns/1ps

module pwm_generator(
    input wire clk,
    input wire rst_n,
    input wire [7:0] duty_cycle,
    output reg pwm_out
);

reg [7:0] counter;

always @(posedge clk or negedge rst_n) begin
    if (!rst_n)
        counter <= 8'b0;
    else
        counter <= counter + 1'b1;
end

always @(posedge clk or negedge rst_n) begin
    if (!rst_n)
        pwm_out <= 1'b0;
    else
        pwm_out <= (counter < duty_cycle) ? 1'b1 : 1'b0;
end

endmodule

module testbench;
    reg clk, rst_n;
    reg [7:0] duty_cycle;
    wire pwm_out;

    pwm_generator dut (
        .clk(clk),
        .rst_n(rst_n),
        .duty_cycle(duty_cycle),
        .pwm_out(pwm_out)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 1'b0;
        rst_n = 1'b0;
        duty_cycle = 8'b0;

        #20 rst_n = 1'b1;

        // Test for 0% duty cycle
        duty_cycle = 8'd0;
        #100;

        // Test for 25% duty cycle
        duty_cycle = 8'd64;
        #100;

        // Test for 50% duty cycle
        duty_cycle = 8'd128;
        #100;

        // Test for 75% duty cycle
        duty_cycle = 8'd192;
        #100;

        // Test for 100% duty cycle
        duty_cycle = 8'd255;
        #100;

        #50 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b duty_cycle=%d pwm_out=%b"", 
                 $time, clk, rst_n, duty_cycle, pwm_out);
    end
endmodule",True,79,True,True,True,False,0.3,False,3.998417615890503,9.335641860961914,"graph TD
    CLK[Clock] --> CNTR(Counter)
    RST[Reset] --> CNTR
    CNTR --> CMP(Comparator)
    DUTY[Duty Cycle Config] --> CMP
    CMP --> PWM_OUT[PWM Output]

    subgraph Testbench
        TCLK[Clock] --> TGEN(Test Generator)
        TRST[Reset] --> TGEN
        TGEN --> DUTY
        TGEN --> TPWM_OUT[Test PWM Output]
        
        TGEN -->|0%| DUTY
        TGEN -->|25%| DUTY
        TGEN -->|50%| DUTY
        TGEN -->|75%| DUTY
        TGEN -->|100%| DUTY
    end","`timescale 1ns/1ps

module counter(
    input wire clk,
    input wire rst_n,
    output reg [3:0] count
);

always @(posedge clk or negedge rst_n) begin
    if (!rst_n)
        count <= 4'b0000;
    else
        count <= count + 1'b1;
end

endmodule

module comparator(
    input wire [3:0] counter,
    input wire [3:0] duty_cycle,
    output wire pwm_out
);

assign pwm_out = (counter < duty_cycle);

endmodule

module pwm(
    input wire clk,
    input wire rst_n,
    input wire [3:0] duty_cycle,
    output wire pwm_out
);

wire [3:0] counter;

counter u_counter (
    .clk(clk),
    .rst_n(rst_n),
    .count(counter)
);

comparator u_comparator (
    .counter(counter),
    .duty_cycle(duty_cycle),
    .pwm_out(pwm_out)
);

endmodule

module testbench;
    reg clk, rst_n;
    reg [3:0] duty_cycle;
    wire pwm_out;

    pwm dut (
        .clk(clk),
        .rst_n(rst_n),
        .duty_cycle(duty_cycle),
        .pwm_out(pwm_out)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst_n = 1'b0;
        duty_cycle = 4'b0000;
        
        #20 rst_n = 1'b1;
        
        #20 duty_cycle = 4'b0000; // 0%
        #100 duty_cycle = 4'b0100; // 25%
        #100 duty_cycle = 4'b1000; // 50%
        #100 duty_cycle = 4'b1100; // 75%
        #100 duty_cycle = 4'b1111; // 100%
        
        #100 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b duty_cycle=%d pwm_out=%b"", 
                 $time, clk, rst_n, duty_cycle, pwm_out);
    end
endmodule",True,88,True,True,True,False,0.3,False,9.702806234359741,11.723337650299072,"Design 8-bit resolution PWM generator with configurable duty cycle. Include testbench with duty cycles: 0%, 25%, 50%, 75%, 100%.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph TD
    CLK[Clock] --> CNTR(Counter)
    RST[Reset] --> CNTR
    CNTR --> CMP(Comparator)
    DUTY[Duty Cycle Config] --> CMP
    CMP --> PWM_OUT[PWM Output]

    subgraph Testbench
        TCLK[Clock] --> TGEN(Test Generator)
        TRST[Reset] --> TGEN
        TGEN --> DUTY
        TGEN --> TPWM_OUT[Test PWM Output]
        
        TGEN -->|0%| DUTY
        TGEN -->|25%| DUTY
        TGEN -->|50%| DUTY
        TGEN -->|75%| DUTY
        TGEN -->|100%| DUTY
    end
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module pwm_generator (
    input wire clk,
    input wire rst_n,
    input wire [7:0] duty_cycle,
    output wire pwm_out
);

    reg [7:0] counter;

    always @(posedge clk or negedge rst_n) begin
        if (!rst_n)
            counter <= 8'b00000000;
        else
            counter <= counter + 1'b1;
    end

    assign pwm_out = (counter < duty_cycle) ? 1'b1 : 1'b0;

endmodule

module testbench;
    reg clk, rst_n;
    reg [7:0] duty_cycle;
    wire pwm_out;

    pwm_generator dut (
        .clk(clk),
        .rst_n(rst_n),
        .duty_cycle(duty_cycle),
        .pwm_out(pwm_out)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst_n = 1'b0;
        duty_cycle = 8'b00000000;
        
        #20 rst_n = 1'b1;
        
        // Test 0% duty cycle
        #10 duty_cycle = 8'b00000000;
        #100;
        
        // Test 25% duty cycle
        #10 duty_cycle = 8'b01000000;
        #100;
        
        // Test 50% duty cycle
        #10 duty_cycle = 8'b10000000;
        #100;
        
        // Test 75% duty cycle
        #10 duty_cycle = 8'b11000000;
        #100;
        
        // Test 100% duty cycle
        #10 duty_cycle = 8'b11111111;
        #100;
        
        #50 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b duty_cycle=%d pwm_out=%b"", 
                 $time, clk, rst_n, duty_cycle, pwm_out);
    end
endmodule",True,74,True,True,True,False,0.4,False,5.674955129623413,9.485336780548096,tie,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,Protocol,complex,"Design SPI master supporting mode 0 (CPOL=0, CPHA=0). Include SCLK generation, MOSI/MISO handling. Include testbench.",claude,"`timescale 1ns/1ps

module spi_master (
    input wire clk,
    input wire rst_n,
    input wire start,
    input wire [7:0] data_in,
    input wire miso,
    output reg sclk,
    output reg mosi,
    output reg busy,
    output reg [7:0] data_out
);

reg [3:0] bit_count;
reg [7:0] shift_reg_tx;
reg [7:0] shift_reg_rx;
reg sclk_en;

always @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
        sclk <= 1'b0;
        mosi <= 1'b0;
        busy <= 1'b0;
        bit_count <= 4'b0;
        shift_reg_tx <= 8'b0;
        shift_reg_rx <= 8'b0;
        data_out <= 8'b0;
        sclk_en <= 1'b0;
    end
    else begin
        if (start && !busy) begin
            busy <= 1'b1;
            shift_reg_tx <= data_in;
            bit_count <= 4'b0;
            sclk_en <= 1'b1;
        end
        else if (busy) begin
            if (bit_count == 4'h8) begin
                busy <= 1'b0;
                sclk_en <= 1'b0;
                data_out <= shift_reg_rx;
            end
            else begin
                sclk <= ~sclk;
                if (sclk == 1'b1) begin
                    bit_count <= bit_count + 1'b1;
                    shift_reg_rx <= {shift_reg_rx[6:0], miso};
                end
                else begin
                    mosi <= shift_reg_tx[7];
                    shift_reg_tx <= {shift_reg_tx[6:0], 1'b0};
                end
            end
        end
    end
end

endmodule

module testbench;
    reg clk;
    reg rst_n;
    reg start;
    reg [7:0] data_in;
    reg miso;
    wire sclk;
    wire mosi;
    wire busy;
    wire [7:0] data_out;

    spi_master dut (
        .clk(clk),
        .rst_n(rst_n),
        .start(start),
        .data_in(data_in),
        .miso(miso),
        .sclk(sclk),
        .mosi(mosi),
        .busy(busy),
        .data_out(data_out)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 0;
        rst_n = 0;
        start = 0;
        data_in = 0;
        miso = 0;

        #10 rst_n = 1;
        #10 data_in = 8'hA5;
        #10 start = 1;
        #10 start = 0;
        
        // Generate MISO responses
        repeat(16) begin
            #10 miso = ~miso;
        end

        #100;
        
        // Second transfer
        data_in = 8'h5A;
        start = 1;
        #10 start = 0;
        
        repeat(16) begin
            #10 miso = ~miso;
        end

        #100 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t rst_n=%b start=%b data_in=%h miso=%b sclk=%b mosi=%b busy=%b data_out=%h"",
                 $time, rst_n, start, data_in, miso, sclk, mosi, busy, data_out);
    end
endmodule",True,124,True,True,True,True,0.7,True,12.13326120376587,8.003525733947754,"graph TD
    CLK[Clock Input] --> SCLK_GEN(SCLK Generator)
    RST[Reset] --> SCLK_GEN
    CLK --> FSM(SPI Control FSM)
    RST --> FSM
    
    TX_DATA[[TX Data Register]] --> MOSI_SHIFT(MOSI Shift Register)
    FSM --> MOSI_SHIFT
    SCLK_GEN --> MOSI_SHIFT
    
    MISO_IN[MISO Input] --> MISO_SHIFT(MISO Shift Register)
    FSM --> MISO_SHIFT
    SCLK_GEN --> MISO_SHIFT
    
    MOSI_SHIFT --> MOSI_OUT[MOSI Output]
    MISO_SHIFT --> RX_DATA[[RX Data Register]]
    
    START[Start Transaction] --> FSM
    FSM --> BUSY[Busy Flag]
    
    SCLK_GEN --> SCLK_OUT[SCLK Output]
    
    TB_CLK[TB Clock] -.-> CLK
    TB_RST[TB Reset] -.-> RST
    TB_DATA[TB Test Data] -.-> TX_DATA
    TB_START[TB Start] -.-> START
    MOSI_OUT -.-> TB_MOSI[TB MOSI Monitor]
    SCLK_OUT -.-> TB_SCLK[TB SCLK Monitor]","`timescale 1ns/1ps

module spi_core (
    input wire clk,
    input wire rst,
    input wire start,
    input wire [7:0] tx_data,
    input wire miso_in,
    output reg [7:0] rx_data,
    output reg mosi_out,
    output reg sclk_out,
    output reg busy
);

reg [2:0] state;
reg [2:0] bit_count;
reg [7:0] mosi_shift;
reg [7:0] miso_shift;
reg sclk_en;

localparam IDLE = 3'd0,
           SHIFT = 3'd1,
           DONE = 3'd2;

// SCLK Generator
reg sclk_reg;
always @(posedge clk or posedge rst) begin
    if (rst)
        sclk_reg <= 1'b0;
    else if (sclk_en)
        sclk_reg <= ~sclk_reg;
end

// FSM
always @(posedge clk or posedge rst) begin
    if (rst) begin
        state <= IDLE;
        busy <= 1'b0;
        sclk_en <= 1'b0;
        bit_count <= 3'd0;
    end else begin
        case (state)
            IDLE: begin
                if (start) begin
                    state <= SHIFT;
                    busy <= 1'b1;
                    sclk_en <= 1'b1;
                    mosi_shift <= tx_data;
                    bit_count <= 3'd0;
                end
            end
            
            SHIFT: begin
                if (bit_count == 3'd7) begin
                    state <= DONE;
                    sclk_en <= 1'b0;
                end else begin
                    bit_count <= bit_count + 1'b1;
                end
            end
            
            DONE: begin
                state <= IDLE;
                busy <= 1'b0;
                rx_data <= miso_shift;
            end
            
            default: state <= IDLE;
        endcase
    end
end

// MOSI Shift Register
always @(posedge clk or posedge rst) begin
    if (rst) begin
        mosi_out <= 1'b0;
    end else if (state == SHIFT && sclk_reg == 1'b0) begin
        mosi_out <= mosi_shift[7];
        mosi_shift <= {mosi_shift[6:0], 1'b0};
    end
end

// MISO Shift Register
always @(posedge clk or posedge rst) begin
    if (rst) begin
        miso_shift <= 8'h00;
    end else if (state == SHIFT && sclk_reg == 1'b1) begin
        miso_shift <= {miso_shift[6:0], miso_in};
    end
end

assign sclk_out = (state == SHIFT) ? sclk_reg : 1'b0;

endmodule

module testbench;
    reg clk, rst, start, miso_in;
    reg [7:0] tx_data;
    wire [7:0] rx_data;
    wire mosi_out, sclk_out, busy;
    
    spi_core dut (
        .clk(clk),
        .rst(rst),
        .start(start),
        .tx_data(tx_data),
        .miso_in(miso_in),
        .rx_data(rx_data),
        .mosi_out(mosi_out),
        .sclk_out(sclk_out),
        .busy(busy)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst = 1'b1;
        start = 1'b0;
        miso_in = 1'b0;
        tx_data = 8'h55;
        
        #20 rst = 1'b0;
        #10 start = 1'b1;
        #10 start = 1'b0;
        
        #200 tx_data = 8'hAA;
        start = 1'b1;
        #10 start = 1'b0;
        
        #200 $finish;
    end
    
    always #5 clk = ~clk;
    
    always @(posedge clk) begin
        miso_in <= $random;
    end
    
    initial begin
        $monitor(""Time=%0t rst=%b start=%b busy=%b tx_data=%h rx_data=%h"",
                 $time, rst, start, busy, tx_data, rx_data);
    end
endmodule",True,145,True,False,False,,0.0,,19.89123010635376,0.010822296142578125,"Design SPI master supporting mode 0 (CPOL=0, CPHA=0). Include SCLK generation, MOSI/MISO handling. Include testbench.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph TD
    CLK[Clock Input] --> SCLK_GEN(SCLK Generator)
    RST[Reset] --> SCLK_GEN
    CLK --> FSM(SPI Control FSM)
    RST --> FSM
    
    TX_DATA[[TX Data Register]] --> MOSI_SHIFT(MOSI Shift Register)
    FSM --> MOSI_SHIFT
    SCLK_GEN --> MOSI_SHIFT
    
    MISO_IN[MISO Input] --> MISO_SHIFT(MISO Shift Register)
    FSM --> MISO_SHIFT
    SCLK_GEN --> MISO_SHIFT
    
    MOSI_SHIFT --> MOSI_OUT[MOSI Output]
    MISO_SHIFT --> RX_DATA[[RX Data Register]]
    
    START[Start Transaction] --> FSM
    FSM --> BUSY[Busy Flag]
    
    SCLK_GEN --> SCLK_OUT[SCLK Output]
    
    TB_CLK[TB Clock] -.-> CLK
    TB_RST[TB Reset] -.-> RST
    TB_DATA[TB Test Data] -.-> TX_DATA
    TB_START[TB Start] -.-> START
    MOSI_OUT -.-> TB_MOSI[TB MOSI Monitor]
    SCLK_OUT -.-> TB_SCLK[TB SCLK Monitor]
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module spi_master (
    input wire clk,
    input wire rst,
    input wire start,
    input wire [7:0] tx_data,
    input wire miso_in,
    output reg sclk_out,
    output reg mosi_out,
    output reg busy,
    output reg [7:0] rx_data
);

reg [3:0] clk_div;
reg [2:0] bit_count;
reg [7:0] mosi_shift;
reg [7:0] miso_shift;

localparam IDLE = 2'b00;
localparam TRANSFER = 2'b01;
localparam DONE = 2'b10;

reg [1:0] state;

always @(posedge clk or posedge rst) begin
    if (rst) begin
        clk_div <= 4'b0;
        sclk_out <= 1'b0;
    end else begin
        clk_div <= clk_div + 1'b1;
        if (clk_div == 4'd7) begin
            sclk_out <= ~sclk_out;
            clk_div <= 4'b0;
        end
    end
end

always @(posedge clk or posedge rst) begin
    if (rst) begin
        state <= IDLE;
        busy <= 1'b0;
        bit_count <= 3'b0;
        mosi_shift <= 8'b0;
        miso_shift <= 8'b0;
        mosi_out <= 1'b0;
        rx_data <= 8'b0;
    end else begin
        case (state)
            IDLE: begin
                if (start) begin
                    state <= TRANSFER;
                    busy <= 1'b1;
                    bit_count <= 3'b0;
                    mosi_shift <= tx_data;
                end
            end
            
            TRANSFER: begin
                if (clk_div == 4'b0 && !sclk_out) begin
                    mosi_out <= mosi_shift[7];
                    mosi_shift <= {mosi_shift[6:0], 1'b0};
                end
                
                if (clk_div == 4'b0 && sclk_out) begin
                    miso_shift <= {miso_shift[6:0], miso_in};
                    bit_count <= bit_count + 1'b1;
                    
                    if (bit_count == 3'b111) begin
                        state <= DONE;
                    end
                end
            end
            
            DONE: begin
                rx_data <= miso_shift;
                busy <= 1'b0;
                state <= IDLE;
            end
            
            default: state <= IDLE;
        endcase
    end
end

endmodule

module testbench;
    reg clk, rst, start;
    reg [7:0] tx_data;
    reg miso_in;
    wire sclk_out, mosi_out, busy;
    wire [7:0] rx_data;
    
    spi_master dut (
        .clk(clk),
        .rst(rst),
        .start(start),
        .tx_data(tx_data),
        .miso_in(miso_in),
        .sclk_out(sclk_out),
        .mosi_out(mosi_out),
        .busy(busy),
        .rx_data(rx_data)
    );
    
    initial begin
        $dumpfile(""spi_master.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst = 1'b1;
        start = 1'b0;
        tx_data = 8'h00;
        miso_in = 1'b0;
        
        #20 rst = 1'b0;
        #10 tx_data = 8'hA5;
        #10 start = 1'b1;
        #10 start = 1'b0;
        
        #500 tx_data = 8'h5A;
        start = 1'b1;
        #10 start = 1'b0;
        
        #500 $finish;
    end
    
    always #5 clk = ~clk;
    
    always @(posedge sclk_out) begin
        miso_in <= $random;
    end
    
    initial begin
        $monitor(""Time=%0t busy=%b tx_data=%h rx_data=%h"",
                 $time, busy, tx_data, rx_data);
    end
endmodule",True,139,True,True,True,,0.0,,13.624836206436157,0.020188093185424805,prompt_only,prompt_only > mermaid_only > combined,prompt_only > combined > mermaid_only
combined,Protocol,complex,"Design SPI master supporting mode 0 (CPOL=0, CPHA=0). Include SCLK generation, MOSI/MISO handling. Include testbench.",gpt-4o,"`timescale 1ns/1ps

module spi_master(
    input wire clk,
    input wire rst_n,
    input wire enable,
    input wire [7:0] data_in,
    output reg sclk,
    output reg mosi,
    input wire miso,
    output reg [7:0] data_out,
    output reg done
);

    reg [2:0] bit_counter;
    reg [7:0] shift_reg;

    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            sclk <= 1'b0;
            bit_counter <= 3'b000;
            shift_reg <= 8'b00000000;
            data_out <= 8'b00000000;
            mosi <= 1'b0;
            done <= 1'b0;
        end else if (enable) begin
            sclk <= ~sclk;
            if (!sclk) begin
                mosi <= shift_reg[7];
                shift_reg <= {shift_reg[6:0], miso};
                if (bit_counter == 3'b111) begin
                    done <= 1'b1;
                    data_out <= shift_reg;
                end else begin
                    done <= 1'b0;
                    bit_counter <= bit_counter + 1'b1;
                end
            end
        end else begin
            done <= 1'b0;
        end
    end

endmodule

module testbench;
    reg clk, rst_n, enable;
    reg [7:0] data_in;
    wire sclk, mosi, done;
    reg miso;
    wire [7:0] data_out;

    spi_master dut (
        .clk(clk),
        .rst_n(rst_n),
        .enable(enable),
        .data_in(data_in),
        .sclk(sclk),
        .mosi(mosi),
        .miso(miso),
        .data_out(data_out),
        .done(done)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 1'b0;
        rst_n = 1'b0;
        enable = 1'b0;
        miso = 1'b0;
        data_in = 8'b10101010;
        
        #20 rst_n = 1'b1;
        #10 enable = 1'b1;
        #160 enable = 1'b0;
        #20 rst_n = 1'b0;
        #20 rst_n = 1'b1;
        #50 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b enable=%b sclk=%b mosi=%b miso=%b done=%b data_out=%b"", 
                 $time, clk, rst_n, enable, sclk, mosi, miso, done, data_out);
    end
endmodule",True,89,True,True,True,True,0.9,True,9.146768808364868,10.436185836791992,"graph LR
    CLK[Clock] --> SCLK_GEN(SCLK Generation)
    RST[Reset] --> SCLK_GEN
    SCLK_GEN --> SCLK[SCLK]
    
    CTRL{CPOL=0, CPHA=0} --> SCLK_GEN
    CTRL --> MOSI_CTRL(MOSI Control)
    CTRL --> MISO_CTRL(MISO Control)
    
    MOSI_CTRL --> MOSI[MOSI]
    MISO_CTRL --> MISO[MISO]
    
    DATA_IN[Data In] --> MOSI_CTRL
    MISO_CTRL --> DATA_OUT[Data Out]
    
    TESTBENCH --> CLK
    TESTBENCH --> RST
    TESTBENCH --> DATA_IN
    TESTBENCH --> MOSI
    TESTBENCH --> MISO
    TESTBENCH --> CTRL","`timescale 1ns/1ps

module sclk_gen(
    input wire clk,
    input wire rst,
    input wire cpol,
    input wire cpha,
    output reg sclk
);
    
    always @(posedge clk or posedge rst) begin
        if (rst)
            sclk <= 1'b0;
        else
            sclk <= cpol ^ cpha;
    end
    
endmodule

module mosi_ctrl(
    input wire clk,
    input wire rst,
    input wire data_in,
    output reg mosi
);
    
    always @(posedge clk or posedge rst) begin
        if (rst)
            mosi <= 1'b0;
        else
            mosi <= data_in;
    end
    
endmodule

module miso_ctrl(
    input wire clk,
    input wire rst,
    input wire mosi,
    output reg data_out
);
    
    always @(posedge clk or posedge rst) begin
        if (rst)
            data_out <= 1'b0;
        else
            data_out <= mosi;
    end
    
endmodule

module testbench;
    reg clk, rst, data_in, cpol, cpha;
    wire sclk, mosi, data_out;
    
    sclk_gen sclk_gen_inst (
        .clk(clk),
        .rst(rst),
        .cpol(cpol),
        .cpha(cpha),
        .sclk(sclk)
    );
    
    mosi_ctrl mosi_ctrl_inst (
        .clk(clk),
        .rst(rst),
        .data_in(data_in),
        .mosi(mosi)
    );
    
    miso_ctrl miso_ctrl_inst (
        .clk(clk),
        .rst(rst),
        .mosi(mosi),
        .data_out(data_out)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst = 1'b0;
        data_in = 1'b0;
        cpol = 1'b0;
        cpha = 1'b0;
        
        #20 rst = 1'b1;
        #10 rst = 1'b0;
        #10 data_in = 1'b1;
        #50 data_in = 1'b0;
        #20 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t clk=%b rst=%b data_in=%b mosi=%b data_out=%b"", 
                 $time, clk, rst, data_in, mosi, data_out);
    end
endmodule",True,101,True,True,True,True,0.7,True,9.352266311645508,13.292941570281982,"Design SPI master supporting mode 0 (CPOL=0, CPHA=0). Include SCLK generation, MOSI/MISO handling. Include testbench.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph LR
    CLK[Clock] --> SCLK_GEN(SCLK Generation)
    RST[Reset] --> SCLK_GEN
    SCLK_GEN --> SCLK[SCLK]
    
    CTRL{CPOL=0, CPHA=0} --> SCLK_GEN
    CTRL --> MOSI_CTRL(MOSI Control)
    CTRL --> MISO_CTRL(MISO Control)
    
    MOSI_CTRL --> MOSI[MOSI]
    MISO_CTRL --> MISO[MISO]
    
    DATA_IN[Data In] --> MOSI_CTRL
    MISO_CTRL --> DATA_OUT[Data Out]
    
    TESTBENCH --> CLK
    TESTBENCH --> RST
    TESTBENCH --> DATA_IN
    TESTBENCH --> MOSI
    TESTBENCH --> MISO
    TESTBENCH --> CTRL
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module sclk_generation(
    input wire clk,
    input wire rst,
    input wire cpol,
    output reg sclk
);
    always @(posedge clk or posedge rst) begin
        if (rst)
            sclk <= cpol;
        else
            sclk <= ~sclk;
    end
endmodule

module mosi_control(
    input wire clk,
    input wire rst,
    input wire data_in,
    output reg mosi
);
    always @(posedge clk or posedge rst) begin
        if (rst)
            mosi <= 1'b0;
        else
            mosi <= data_in;
    end
endmodule

module miso_control(
    input wire clk,
    input wire rst,
    input wire miso,
    output reg data_out
);
    always @(posedge clk or posedge rst) begin
        if (rst)
            data_out <= 1'b0;
        else
            data_out <= miso;
    end
endmodule

module spi_master(
    input wire clk,
    input wire rst,
    input wire cpol,
    input wire cpha,
    input wire data_in,
    input wire miso,
    output wire sclk,
    output wire mosi,
    output wire data_out
);
    sclk_generation sclk_gen (
        .clk(clk),
        .rst(rst),
        .cpol(cpol),
        .sclk(sclk)
    );

    mosi_control mosi_ctrl (
        .clk(sclk),
        .rst(rst),
        .data_in(data_in),
        .mosi(mosi)
    );

    miso_control miso_ctrl (
        .clk(sclk),
        .rst(rst),
        .miso(miso),
        .data_out(data_out)
    );
endmodule

module testbench;
    reg clk, rst, cpol, cpha, data_in, miso;
    wire sclk, mosi, data_out;

    spi_master dut (
        .clk(clk),
        .rst(rst),
        .cpol(cpol),
        .cpha(cpha),
        .data_in(data_in),
        .miso(miso),
        .sclk(sclk),
        .mosi(mosi),
        .data_out(data_out)
    );

    initial begin
        $dumpfile(""spi_master.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst = 1'b1;
        cpol = 1'b0; // CPOL = 0
        cpha = 1'b0; // CPHA = 0
        data_in = 1'b0;
        miso = 1'b0;
        
        #20 rst = 1'b0;
        #10 data_in = 1'b1;
        #50 data_in = 1'b0;
        #100 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t clk=%b rst=%b cpol=%b cpha=%b data_in=%b miso=%b sclk=%b mosi=%b data_out=%b"", 
                 $time, clk, rst, cpol, cpha, data_in, miso, sclk, mosi, data_out);
    end
endmodule",True,117,True,True,True,,0.0,,9.209436416625977,0.017197608947753906,prompt_only,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
