circuit_name,category,complexity,original_prompt,model,prompt_only_verilog,prompt_only_generation_success,prompt_only_lines_of_code,prompt_only_has_testbench,prompt_only_compilation_success,prompt_only_simulation_success,prompt_only_vae_verdict,prompt_only_vae_confidence,prompt_only_consensus_anomalous,prompt_only_generation_time,prompt_only_simulation_time,mermaid_only_mermaid,mermaid_only_verilog,mermaid_only_generation_success,mermaid_only_lines_of_code,mermaid_only_has_testbench,mermaid_only_compilation_success,mermaid_only_simulation_success,mermaid_only_vae_verdict,mermaid_only_vae_confidence,mermaid_only_consensus_anomalous,mermaid_only_generation_time,mermaid_only_simulation_time,combined_prompt,combined_verilog,combined_generation_success,combined_lines_of_code,combined_has_testbench,combined_compilation_success,combined_simulation_success,combined_vae_verdict,combined_vae_confidence,combined_consensus_anomalous,combined_generation_time,combined_simulation_time,best_approach,correctness_ranking,simulation_ranking
combined,Combinational,simple,"Design a 2-to-1 multiplexer with inputs a, b, select sel, and output out. Include testbench testing all combinations.",claude,"`timescale 1ns/1ps

module mux_2to1 (
    input wire a,
    input wire b,
    input wire sel,
    output reg out
);

always @(*) begin
    out = sel ? b : a;
end

endmodule

module testbench;
    reg a, b, sel;
    wire out;
    
    mux_2to1 dut (
        .a(a),
        .b(b),
        .sel(sel),
        .out(out)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        // Test all combinations
        a = 0; b = 0; sel = 0; #10;
        a = 0; b = 0; sel = 1; #10;
        a = 0; b = 1; sel = 0; #10;
        a = 0; b = 1; sel = 1; #10;
        a = 1; b = 0; sel = 0; #10;
        a = 1; b = 0; sel = 1; #10;
        a = 1; b = 1; sel = 0; #10;
        a = 1; b = 1; sel = 1; #10;
        
        $finish;
    end
    
    initial begin
        $monitor(""Time=%0t a=%b b=%b sel=%b out=%b"",
                 $time, a, b, sel, out);
    end
endmodule",True,48,True,True,True,False,0.4,False,4.7366437911987305,6.558054208755493,"graph LR
    A[Input A] --> MUX{2:1 MUX}
    B[Input B] --> MUX
    SEL[Select] --> MUX
    MUX --> OUT[Output]
    
    TB[[Testbench]]
    TB --> |Test 1: sel=0,a=0,b=0| MUX
    TB --> |Test 2: sel=0,a=0,b=1| MUX
    TB --> |Test 3: sel=0,a=1,b=0| MUX
    TB --> |Test 4: sel=0,a=1,b=1| MUX
    TB --> |Test 5: sel=1,a=0,b=0| MUX
    TB --> |Test 6: sel=1,a=0,b=1| MUX
    TB --> |Test 7: sel=1,a=1,b=0| MUX
    TB --> |Test 8: sel=1,a=1,b=1| MUX","`timescale 1ns/1ps

module mux_2to1(
    input wire clk,
    input wire rst_n,
    input wire a,
    input wire b,
    input wire sel,
    output reg out
);

always @(posedge clk or negedge rst_n) begin
    if (!rst_n)
        out <= 1'b0;
    else
        out <= sel ? b : a;
end

endmodule

module testbench;
    reg clk, rst_n;
    reg a, b, sel;
    wire out;
    
    mux_2to1 dut (
        .clk(clk),
        .rst_n(rst_n),
        .a(a),
        .b(b),
        .sel(sel),
        .out(out)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 0;
        rst_n = 0;
        a = 0;
        b = 0;
        sel = 0;
        
        #10 rst_n = 1;
        
        // Test 1: sel=0,a=0,b=0
        #10 sel = 0; a = 0; b = 0;
        
        // Test 2: sel=0,a=0,b=1
        #10 sel = 0; a = 0; b = 1;
        
        // Test 3: sel=0,a=1,b=0
        #10 sel = 0; a = 1; b = 0;
        
        // Test 4: sel=0,a=1,b=1
        #10 sel = 0; a = 1; b = 1;
        
        // Test 5: sel=1,a=0,b=0
        #10 sel = 1; a = 0; b = 0;
        
        // Test 6: sel=1,a=0,b=1
        #10 sel = 1; a = 0; b = 1;
        
        // Test 7: sel=1,a=1,b=0
        #10 sel = 1; a = 1; b = 0;
        
        // Test 8: sel=1,a=1,b=1
        #10 sel = 1; a = 1; b = 1;
        
        #10 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t sel=%b a=%b b=%b out=%b"",
                 $time, sel, a, b, out);
    end
endmodule",True,80,True,True,True,False,0.3,False,11.466203689575195,7.257313013076782,"Design a 2-to-1 multiplexer with inputs a, b, select sel, and output out. Include testbench testing all combinations.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph LR
    A[Input A] --> MUX{2:1 MUX}
    B[Input B] --> MUX
    SEL[Select] --> MUX
    MUX --> OUT[Output]
    
    TB[[Testbench]]
    TB --> |Test 1: sel=0,a=0,b=0| MUX
    TB --> |Test 2: sel=0,a=0,b=1| MUX
    TB --> |Test 3: sel=0,a=1,b=0| MUX
    TB --> |Test 4: sel=0,a=1,b=1| MUX
    TB --> |Test 5: sel=1,a=0,b=0| MUX
    TB --> |Test 6: sel=1,a=0,b=1| MUX
    TB --> |Test 7: sel=1,a=1,b=0| MUX
    TB --> |Test 8: sel=1,a=1,b=1| MUX
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module mux_2to1 (
    input wire a,
    input wire b,
    input wire sel,
    output reg out
);

always @(*) begin
    case (sel)
        1'b0: out = a;
        1'b1: out = b;
    endcase
end

endmodule

module testbench;
    reg a, b, sel;
    wire out;

    mux_2to1 dut (
        .a(a),
        .b(b),
        .sel(sel),
        .out(out)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        // Test 1: sel=0,a=0,b=0
        sel = 0; a = 0; b = 0; #10;
        // Test 2: sel=0,a=0,b=1
        sel = 0; a = 0; b = 1; #10;
        // Test 3: sel=0,a=1,b=0
        sel = 0; a = 1; b = 0; #10;
        // Test 4: sel=0,a=1,b=1
        sel = 0; a = 1; b = 1; #10;
        // Test 5: sel=1,a=0,b=0
        sel = 1; a = 0; b = 0; #10;
        // Test 6: sel=1,a=0,b=1
        sel = 1; a = 0; b = 1; #10;
        // Test 7: sel=1,a=1,b=0
        sel = 1; a = 1; b = 0; #10;
        // Test 8: sel=1,a=1,b=1
        sel = 1; a = 1; b = 1; #10;

        $finish;
    end

    initial begin
        $monitor(""Time=%0t sel=%b a=%b b=%b out=%b"", 
                 $time, sel, a, b, out);
    end
endmodule",True,58,True,True,True,False,0.4,False,6.2378339767456055,7.8016626834869385,tie,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,Combinational,simple,"Design a 2-to-1 multiplexer with inputs a, b, select sel, and output out. Include testbench testing all combinations.",gpt-4o,"`timescale 1ns/1ps

module mux2to1(
    input wire a,
    input wire b,
    input wire sel,
    output wire out
);

assign out = sel ? b : a;

endmodule

module testbench;
    reg a, b, sel;
    wire out;
    
    mux2to1 dut (
        .a(a),
        .b(b),
        .sel(sel),
        .out(out)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        // Test all combinations of inputs
        a = 1'b0; b = 1'b0; sel = 1'b0;
        #10;
        a = 1'b0; b = 1'b1; sel = 1'b0;
        #10;
        a = 1'b1; b = 1'b0; sel = 1'b0;
        #10;
        a = 1'b1; b = 1'b1; sel = 1'b0;
        #10;
        a = 1'b0; b = 1'b0; sel = 1'b1;
        #10;
        a = 1'b0; b = 1'b1; sel = 1'b1;
        #10;
        a = 1'b1; b = 1'b0; sel = 1'b1;
        #10;
        a = 1'b1; b = 1'b1; sel = 1'b1;
        #10;
        
        $finish;
    end
    
    initial begin
        $monitor(""Time=%0t a=%b b=%b sel=%b out=%b"", 
                 $time, a, b, sel, out);
    end
endmodule",True,54,True,True,True,False,0.4,False,5.277013778686523,7.167185306549072,"graph LR
    SEL[Select] --> MUX{2-to-1 MUX}
    A[Input a] --> MUX
    B[Input b] --> MUX
    MUX --> OUT[Output out]

    %% Testbench
    TB[Testbench]
    TB --> SEL
    TB --> A
    TB --> B
    OUT --> TB","`timescale 1ns/1ps

module mux_2to1(
    input wire sel,
    input wire a,
    input wire b,
    output reg out
);

always @(*) begin
    if (sel)
        out = b;
    else
        out = a;
end

endmodule

module testbench;
    reg sel;
    reg a;
    reg b;
    wire out;

    mux_2to1 dut (
        .sel(sel),
        .a(a),
        .b(b),
        .out(out)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        a = 1'b0;
        b = 1'b1;
        sel = 1'b0;

        #10 sel = 1'b1;
        #10 sel = 1'b0;
        #10 a = 1'b1;
        #10 b = 1'b0;
        #10 sel = 1'b1;
        #10 sel = 1'b0;
        #50 $finish;
    end

    initial begin
        $monitor(""Time=%0t sel=%b a=%b b=%b out=%b"", 
                 $time, sel, a, b, out);
    end
endmodule",True,53,True,True,True,False,0.4,False,4.358262062072754,11.691034317016602,"Design a 2-to-1 multiplexer with inputs a, b, select sel, and output out. Include testbench testing all combinations.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph LR
    SEL[Select] --> MUX{2-to-1 MUX}
    A[Input a] --> MUX
    B[Input b] --> MUX
    MUX --> OUT[Output out]

    %% Testbench
    TB[Testbench]
    TB --> SEL
    TB --> A
    TB --> B
    OUT --> TB
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module mux_2to1(
    input wire a,
    input wire b,
    input wire sel,
    output wire out
);
    assign out = sel ? b : a;
endmodule

module testbench;
    reg a, b, sel;
    wire out;
    
    mux_2to1 dut (
        .a(a),
        .b(b),
        .sel(sel),
        .out(out)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        a = 1'b0; b = 1'b0; sel = 1'b0;
        #10 sel = 1'b1;
        #10 a = 1'b1;
        #10 b = 1'b1;
        #10 sel = 1'b0;
        #10 a = 1'b0; b = 1'b0;
        #10 $finish;
    end
    
    initial begin
        $monitor(""Time=%0t a=%b b=%b sel=%b out=%b"", 
                 $time, a, b, sel, out);
    end
endmodule",True,40,True,True,True,False,0.4,False,2.243569850921631,9.38780951499939,tie,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,Sequential,simple,"Create a D flip-flop with clock, reset, input d, and output q. Include testbench with timing verification.",claude,"`timescale 1ns/1ps

module dff(
    input wire clk,
    input wire rst_n,
    input wire d,
    output reg q
);

always @(posedge clk or negedge rst_n) begin
    if (!rst_n)
        q <= 1'b0;
    else
        q <= d;
end

endmodule

module testbench;
    reg clk, rst_n, d;
    wire q;
    
    dff dut (
        .clk(clk),
        .rst_n(rst_n),
        .d(d),
        .q(q)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 0;
        rst_n = 0;
        d = 0;
        
        #20 rst_n = 1;
        #10 d = 1;
        #10 d = 0;
        #10 d = 1;
        #10 rst_n = 0;
        #10 d = 0;
        #10 rst_n = 1;
        #20 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b d=%b q=%b"",
                 $time, clk, rst_n, d, q);
    end
endmodule",True,54,True,True,True,True,0.7,True,4.472113132476807,7.165227890014648,"graph LR
    CLK[Clock] --> DFF[[D Flip-Flop]]
    RST[Reset] --> DFF
    D[Data Input] --> DFF
    DFF --> Q[Output Q]
    TB[Testbench] --> TIMING{Timing Check}
    CLK --> TIMING
    D --> TIMING
    Q --> TIMING
    TIMING --> SETUP[Setup Time]
    TIMING --> HOLD[Hold Time]
    TIMING --> CLK2Q[Clock-to-Q]
    RST --> TIMING","`timescale 1ns/1ps

module dff(
    input wire clk,
    input wire rst,
    input wire d,
    output reg q
);

always @(posedge clk or posedge rst) begin
    if (rst)
        q <= 1'b0;
    else
        q <= d;
end

endmodule

module testbench;
    reg clk, rst, d;
    wire q;
    
    dff dut (
        .clk(clk),
        .rst(rst),
        .d(d),
        .q(q)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        // Initialize signals
        clk = 0;
        rst = 1;
        d = 0;
        
        // Reset sequence
        #20 rst = 0;
        
        // Test data transitions
        #10 d = 1;
        #10 d = 0;
        #10 d = 1;
        
        // Test reset during operation
        #10 rst = 1;
        #10 rst = 0;
        
        // Additional data transitions
        #10 d = 0;
        #10 d = 1;
        
        #20 $finish;
    end
    
    always #5 clk = ~clk;
    
    // Setup and hold time parameters
    specify
        specparam tsetup = 2;
        specparam thold = 1;
        specparam tclk2q = 3;
        
        $setup(d, posedge clk, tsetup);
        $hold(posedge clk, d, thold);
    endspecify
    
    initial begin
        $monitor(""Time=%0t rst=%b d=%b q=%b"", $time, rst, d, q);
    end
endmodule",True,73,True,True,True,False,0.3,False,8.964640140533447,7.269238471984863,"Create a D flip-flop with clock, reset, input d, and output q. Include testbench with timing verification.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph LR
    CLK[Clock] --> DFF[[D Flip-Flop]]
    RST[Reset] --> DFF
    D[Data Input] --> DFF
    DFF --> Q[Output Q]
    TB[Testbench] --> TIMING{Timing Check}
    CLK --> TIMING
    D --> TIMING
    Q --> TIMING
    TIMING --> SETUP[Setup Time]
    TIMING --> HOLD[Hold Time]
    TIMING --> CLK2Q[Clock-to-Q]
    RST --> TIMING
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module dff (
    input wire clk,
    input wire rst,
    input wire d,
    output reg q
);

always @(posedge clk or posedge rst) begin
    if (rst)
        q <= 1'b0;
    else
        q <= d;
end

endmodule

module testbench;
    reg clk, rst, d;
    wire q;
    
    // Timing parameters
    parameter SETUP_TIME = 2;
    parameter HOLD_TIME = 1;
    parameter CLK2Q_TIME = 3;
    
    dff dut (
        .clk(clk),
        .rst(rst),
        .d(d),
        .q(q)
    );
    
    initial begin
        $dumpfile(""dff.vcd"");
        $dumpvars(0, testbench);
        
        // Initialize signals
        clk = 0;
        rst = 1;
        d = 0;
        
        // Test sequence
        #10 rst = 0;
        
        // Test timing requirements
        #10;
        @(negedge clk);
        #(SETUP_TIME) d = 1;
        @(posedge clk);
        #(HOLD_TIME);
        
        // Check CLK2Q delay
        #(CLK2Q_TIME);
        if (q !== 1)
            $display(""CLK2Q violation at time %0t"", $time);
            
        #20;
        rst = 1;
        #10;
        rst = 0;
        d = 0;
        
        #50 $finish;
    end
    
    always #5 clk = ~clk;
    
    // Timing checks
    initial begin
        $monitor(""Time=%0t rst=%b d=%b q=%b"", $time, rst, d, q);
    end
    
    // Setup time check
    always @(posedge clk) begin
        if ($time > 0 && !rst && $time - $past(d) < SETUP_TIME)
            $display(""Setup violation at time %0t"", $time);
    end
    
    // Hold time check
    always @(d) begin
        if ($time > 0 && !rst && $time - $past(posedge clk) < HOLD_TIME)
            $display(""Hold violation at time %0t"", $time);
    end

endmodule",True,87,True,False,False,,0.0,,9.253686666488647,0.009728670120239258,mermaid_only,mermaid_only > prompt_only > combined,prompt_only > mermaid_only > combined
combined,Sequential,simple,"Create a D flip-flop with clock, reset, input d, and output q. Include testbench with timing verification.",gpt-4o,"`timescale 1ns/1ps

module d_flip_flop(
    input wire clk,
    input wire rst_n,
    input wire d,
    output reg q
);

always @(posedge clk or negedge rst_n) begin
    if (!rst_n)
        q <= 1'b0;
    else
        q <= d;
end

endmodule

module testbench;
    reg clk, rst_n, d;
    wire q;
    
    d_flip_flop dut (
        .clk(clk),
        .rst_n(rst_n),
        .d(d),
        .q(q)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst_n = 1'b0;
        d = 1'b0;
        
        #20 rst_n = 1'b1;
        #10 d = 1'b1;
        #15 d = 1'b0;
        #10 d = 1'b1;
        #20 rst_n = 1'b0;
        #20 rst_n = 1'b1;
        #50 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b d=%b q=%b"", 
                 $time, clk, rst_n, d, q);
    end
endmodule",True,53,True,True,True,True,0.7,True,2.4063777923583984,8.084498405456543,"graph LR
    CLK[Clock] --> DFF((D Flip-Flop))
    RST[Reset] --> DFF
    DIN[D Input] --> DFF
    DFF --> QOUT[Q Output]
    TB[Testbench] --> CLK
    TB --> RST
    TB --> DIN
    TB --> TCK[Timing Check]
    QOUT --> TCK","`timescale 1ns/1ps

module dff(
    input wire clk,
    input wire rst,
    input wire din,
    output reg qout
);

always @(posedge clk or posedge rst) begin
    if (rst)
        qout <= 1'b0;
    else
        qout <= din;
end

endmodule

module testbench;
    reg clk, rst, din;
    wire qout;

    dff dut (
        .clk(clk),
        .rst(rst),
        .din(din),
        .qout(qout)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 1'b0;
        rst = 1'b1;
        din = 1'b0;

        #20 rst = 1'b0;
        #10 din = 1'b1;
        #10 din = 1'b0;
        #50 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t clk=%b rst=%b din=%b qout=%b"", 
                 $time, clk, rst, din, qout);
    end
endmodule",True,50,True,True,True,False,0.3,False,4.938812494277954,7.37143087387085,"Create a D flip-flop with clock, reset, input d, and output q. Include testbench with timing verification.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph LR
    CLK[Clock] --> DFF((D Flip-Flop))
    RST[Reset] --> DFF
    DIN[D Input] --> DFF
    DFF --> QOUT[Q Output]
    TB[Testbench] --> CLK
    TB --> RST
    TB --> DIN
    TB --> TCK[Timing Check]
    QOUT --> TCK
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module dff(
    input wire clk,
    input wire rst,
    input wire d,
    output reg q
);

always @(posedge clk or posedge rst) begin
    if (rst)
        q <= 1'b0;
    else
        q <= d;
end

endmodule

module testbench;
    reg clk, rst, d;
    wire q;

    dff dut (
        .clk(clk),
        .rst(rst),
        .d(d),
        .q(q)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst = 1'b0;
        d = 1'b0;
        
        #10 rst = 1'b1;
        #10 rst = 1'b0;
        #10 d = 1'b1;
        #20 d = 1'b0;
        #10 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t clk=%b rst=%b d=%b q=%b"", 
                 $time, clk, rst, d, q);
    end
endmodule",True,51,True,True,True,False,0.3,False,2.1378166675567627,9.94633674621582,tie,mermaid_only > combined > prompt_only,prompt_only > mermaid_only > combined
combined,Sequential,simple,"Design a 4-bit synchronous counter with clock, reset, enable, and count[3:0]. Include testbench.",claude,"`timescale 1ns/1ps

module counter(
    input wire clk,
    input wire rst_n,
    input wire enable,
    output reg [3:0] count
);

always @(posedge clk or negedge rst_n) begin
    if (!rst_n)
        count <= 4'b0000;
    else if (enable)
        count <= count + 1'b1;
end

endmodule

module testbench;
    reg clk, rst_n, enable;
    wire [3:0] count;
    
    counter dut (
        .clk(clk),
        .rst_n(rst_n),
        .enable(enable),
        .count(count)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst_n = 1'b0;
        enable = 1'b0;
        
        #20 rst_n = 1'b1;
        #10 enable = 1'b1;
        #100 enable = 1'b0;
        #20 rst_n = 1'b0;
        #20 rst_n = 1'b1;
        #50 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b enable=%b count=%d"", 
                 $time, clk, rst_n, enable, count);
    end
endmodule",True,52,True,True,True,False,0.3,False,4.54512882232666,7.645972013473511,"graph LR
    CLK[Clock] --> COUNTER[[4-bit Counter]]
    RST[Reset] --> COUNTER
    EN[Enable] --> COUNTER
    COUNTER --> CNT[Count[3:0]]
    CLK --> TB[[Testbench]]
    RST --> TB
    EN --> TB
    CNT --> TB
    TB --> STIM[Test Stimulus]
    TB --> MON[Monitor]
    MON --> CHK(Compare Results)
    STIM --> EXP[Expected Values]
    EXP --> CHK
    CHK --> RES[Test Results]","`timescale 1ns/1ps

module counter(
    input wire clk,
    input wire rst_n,
    input wire enable,
    output reg [3:0] count
);

always @(posedge clk or negedge rst_n) begin
    if (!rst_n)
        count <= 4'b0000;
    else if (enable)
        count <= count + 1'b1;
end

endmodule

module testbench;
    reg clk, rst_n, enable;
    wire [3:0] count;
    reg [3:0] expected;
    
    counter dut (
        .clk(clk),
        .rst_n(rst_n),
        .enable(enable),
        .count(count)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst_n = 1'b0;
        enable = 1'b0;
        expected = 4'b0000;
        
        #20 rst_n = 1'b1;
        #10 enable = 1'b1;
        
        repeat(10) begin
            @(posedge clk);
            expected = expected + enable;
            #1;
            if (count !== expected)
                $display(""Error at time %0t: count=%h expected=%h"", $time, count, expected);
        end
        
        #20 enable = 1'b0;
        #20 rst_n = 1'b0;
        expected = 4'b0000;
        #20 rst_n = 1'b1;
        #50 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t rst_n=%b enable=%b count=%d expected=%d"", 
                 $time, rst_n, enable, count, expected);
    end
endmodule",True,64,True,True,True,False,0.4,False,8.705434799194336,7.0667054653167725,"Design a 4-bit synchronous counter with clock, reset, enable, and count[3:0]. Include testbench.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph LR
    CLK[Clock] --> COUNTER[[4-bit Counter]]
    RST[Reset] --> COUNTER
    EN[Enable] --> COUNTER
    COUNTER --> CNT[Count[3:0]]
    CLK --> TB[[Testbench]]
    RST --> TB
    EN --> TB
    CNT --> TB
    TB --> STIM[Test Stimulus]
    TB --> MON[Monitor]
    MON --> CHK(Compare Results)
    STIM --> EXP[Expected Values]
    EXP --> CHK
    CHK --> RES[Test Results]
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module counter(
    input wire clk,
    input wire rst_n,
    input wire enable,
    output reg [3:0] count
);

always @(posedge clk or negedge rst_n) begin
    if (!rst_n)
        count <= 4'b0000;
    else if (enable)
        count <= count + 1'b1;
end

endmodule

module testbench;
    reg clk, rst_n, enable;
    wire [3:0] count;
    reg [3:0] expected;
    reg [31:0] test_errors;
    
    counter dut (
        .clk(clk),
        .rst_n(rst_n),
        .enable(enable),
        .count(count)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst_n = 1'b0;
        enable = 1'b0;
        expected = 4'b0000;
        test_errors = 0;
        
        #20 rst_n = 1'b1;
        #10 enable = 1'b1;
        
        repeat(16) begin
            @(posedge clk);
            expected = (expected + enable) & 4'hF;
            if (count !== expected) begin
                test_errors = test_errors + 1;
                $display(""Error: count=%h expected=%h at time %t"", 
                         count, expected, $time);
            end
        end
        
        enable = 1'b0;
        #20 rst_n = 1'b0;
        #20 rst_n = 1'b1;
        
        if (test_errors == 0)
            $display(""All tests passed!"");
        else
            $display(""Tests completed with %d errors"", test_errors);
            
        #50 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b enable=%b count=%h expected=%h"", 
                 $time, clk, rst_n, enable, count, expected);
    end
endmodule",True,73,True,True,True,True,0.7,True,7.102346420288086,7.07840633392334,tie,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,Sequential,simple,"Design a 4-bit synchronous counter with clock, reset, enable, and count[3:0]. Include testbench.",gpt-4o,"`timescale 1ns/1ps

module counter(
    input wire clk,
    input wire rst_n,
    input wire enable,
    output reg [3:0] count
);

always @(posedge clk or negedge rst_n) begin
    if (!rst_n)
        count <= 4'b0000;
    else if (enable)
        count <= count + 1'b1;
end

endmodule

module testbench;
    reg clk, rst_n, enable;
    wire [3:0] count;
    
    counter dut (
        .clk(clk),
        .rst_n(rst_n),
        .enable(enable),
        .count(count)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst_n = 1'b0;
        enable = 1'b0;
        
        #20 rst_n = 1'b1;
        #10 enable = 1'b1;
        #100 enable = 1'b0;
        #20 rst_n = 1'b0;
        #20 rst_n = 1'b1;
        #50 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b enable=%b count=%d"", 
                 $time, clk, rst_n, enable, count);
    end
endmodule",True,52,True,True,True,False,0.3,False,2.4061403274536133,8.91954517364502,"graph TD
    CLK[Clock] --> CNT[Counter]
    RST[Reset] --> CNT
    EN[Enable] --> CNT
    CNT --> CntOut[[Count[3:0]]]
    subgraph Testbench
        TB_CLK[Clock] --> TB_CNT[Counter]
        TB_RST[Reset] --> TB_CNT
        TB_EN[Enable] --> TB_CNT
        TB_CNT --> TB_CntOut[[Count[3:0]]]
    end","`timescale 1ns/1ps

module counter(
    input wire clk,
    input wire rst_n,
    input wire enable,
    output reg [3:0] count
);

always @(posedge clk or negedge rst_n) begin
    if (!rst_n)
        count <= 4'b0000;
    else if (enable)
        count <= count + 1'b1;
end

endmodule

module testbench;
    reg clk, rst_n, enable;
    wire [3:0] count;
    
    counter dut (
        .clk(clk),
        .rst_n(rst_n),
        .enable(enable),
        .count(count)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst_n = 1'b0;
        enable = 1'b0;
        
        #20 rst_n = 1'b1;
        #10 enable = 1'b1;
        #100 enable = 1'b0;
        #20 rst_n = 1'b0;
        #20 rst_n = 1'b1;
        #50 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b enable=%b count=%d"", 
                 $time, clk, rst_n, enable, count);
    end
endmodule",True,52,True,True,True,False,0.3,False,5.157153606414795,11.2239351272583,"Design a 4-bit synchronous counter with clock, reset, enable, and count[3:0]. Include testbench.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph TD
    CLK[Clock] --> CNT[Counter]
    RST[Reset] --> CNT
    EN[Enable] --> CNT
    CNT --> CntOut[[Count[3:0]]]
    subgraph Testbench
        TB_CLK[Clock] --> TB_CNT[Counter]
        TB_RST[Reset] --> TB_CNT
        TB_EN[Enable] --> TB_CNT
        TB_CNT --> TB_CntOut[[Count[3:0]]]
    end
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module counter(
    input wire clk,
    input wire rst,
    input wire enable,
    output reg [3:0] count
);

always @(posedge clk or posedge rst) begin
    if (rst)
        count <= 4'b0000;
    else if (enable)
        count <= count + 1'b1;
end

endmodule

module testbench;
    reg clk, rst, enable;
    wire [3:0] count;

    counter dut (
        .clk(clk),
        .rst(rst),
        .enable(enable),
        .count(count)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst = 1'b0;
        enable = 1'b0;
        
        #20 rst = 1'b1;
        #10 rst = 1'b0;
        #10 enable = 1'b1;
        #100 enable = 1'b0;
        #20 rst = 1'b1;
        #20 rst = 1'b0;
        #50 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t clk=%b rst=%b enable=%b count=%d"", 
                 $time, clk, rst, enable, count);
    end
endmodule",True,53,True,True,True,False,0.3,False,3.1138498783111572,9.846529722213745,tie,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,Combinational,simple,"Create a full adder with inputs a, b, cin and outputs sum, cout. Include testbench with all 8 cases.",claude,"`timescale 1ns/1ps

module fulladder(
    input wire a,
    input wire b, 
    input wire cin,
    output wire sum,
    output wire cout
);

assign sum = a ^ b ^ cin;
assign cout = (a & b) | (b & cin) | (a & cin);

endmodule

module testbench;
    reg a, b, cin;
    wire sum, cout;
    
    fulladder dut(
        .a(a),
        .b(b),
        .cin(cin),
        .sum(sum),
        .cout(cout)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        // Test all 8 cases
        {a, b, cin} = 3'b000; #10;
        {a, b, cin} = 3'b001; #10;
        {a, b, cin} = 3'b010; #10;
        {a, b, cin} = 3'b011; #10;
        {a, b, cin} = 3'b100; #10;
        {a, b, cin} = 3'b101; #10;
        {a, b, cin} = 3'b110; #10;
        {a, b, cin} = 3'b111; #10;
        
        $finish;
    end
    
    initial begin
        $monitor(""Time=%0t a=%b b=%b cin=%b sum=%b cout=%b"",
                 $time, a, b, cin, sum, cout);
    end
endmodule",True,49,True,True,True,False,0.4,False,4.886253356933594,7.732071876525879,"graph LR
    A[Input A] --> FA((Full Adder))
    B[Input B] --> FA
    CIN[Carry In] --> FA
    FA --> SUM[Sum]
    FA --> COUT[Carry Out]
    
    TB1[[Test 0,0,0=0,0]] --> FA
    TB2[[Test 0,0,1=1,0]] --> FA
    TB3[[Test 0,1,0=1,0]] --> FA
    TB4[[Test 0,1,1=0,1]] --> FA
    TB5[[Test 1,0,0=1,0]] --> FA
    TB6[[Test 1,0,1=0,1]] --> FA
    TB7[[Test 1,1,0=0,1]] --> FA
    TB8[[Test 1,1,1=1,1]] --> FA
    
    subgraph Logic
    FA --- EQ1((A⊕B⊕CIN))
    FA --- EQ2((AB + BCIN + ACIN))
    end","`timescale 1ns/1ps

module full_adder(
    input wire A,
    input wire B,
    input wire CIN,
    output wire SUM,
    output wire COUT
);

assign SUM = A ^ B ^ CIN;
assign COUT = (A & B) | (B & CIN) | (A & CIN);

endmodule

module testbench;
    reg A, B, CIN;
    wire SUM, COUT;

    full_adder dut(
        .A(A),
        .B(B),
        .CIN(CIN),
        .SUM(SUM),
        .COUT(COUT)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        // Test case 1: 0,0,0
        A = 0; B = 0; CIN = 0; #10;
        // Test case 2: 0,0,1
        A = 0; B = 0; CIN = 1; #10;
        // Test case 3: 0,1,0
        A = 0; B = 1; CIN = 0; #10;
        // Test case 4: 0,1,1
        A = 0; B = 1; CIN = 1; #10;
        // Test case 5: 1,0,0
        A = 1; B = 0; CIN = 0; #10;
        // Test case 6: 1,0,1
        A = 1; B = 0; CIN = 1; #10;
        // Test case 7: 1,1,0
        A = 1; B = 1; CIN = 0; #10;
        // Test case 8: 1,1,1
        A = 1; B = 1; CIN = 1; #10;

        $finish;
    end

    initial begin
        $monitor(""Time=%0t A=%b B=%b CIN=%b SUM=%b COUT=%b"",
                 $time, A, B, CIN, SUM, COUT);
    end
endmodule",True,56,True,True,True,False,0.4,False,10.274075508117676,7.33109188079834,"Create a full adder with inputs a, b, cin and outputs sum, cout. Include testbench with all 8 cases.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph LR
    A[Input A] --> FA((Full Adder))
    B[Input B] --> FA
    CIN[Carry In] --> FA
    FA --> SUM[Sum]
    FA --> COUT[Carry Out]
    
    TB1[[Test 0,0,0=0,0]] --> FA
    TB2[[Test 0,0,1=1,0]] --> FA
    TB3[[Test 0,1,0=1,0]] --> FA
    TB4[[Test 0,1,1=0,1]] --> FA
    TB5[[Test 1,0,0=1,0]] --> FA
    TB6[[Test 1,0,1=0,1]] --> FA
    TB7[[Test 1,1,0=0,1]] --> FA
    TB8[[Test 1,1,1=1,1]] --> FA
    
    subgraph Logic
    FA --- EQ1((A⊕B⊕CIN))
    FA --- EQ2((AB + BCIN + ACIN))
    end
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module full_adder(
    input wire a,
    input wire b, 
    input wire cin,
    output wire sum,
    output wire cout
);

assign sum = a ^ b ^ cin;
assign cout = (a & b) | (b & cin) | (a & cin);

endmodule

module testbench;
    reg a, b, cin;
    wire sum, cout;
    
    full_adder dut(
        .a(a),
        .b(b),
        .cin(cin),
        .sum(sum),
        .cout(cout)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        // Test case 1: 0,0,0
        a = 0; b = 0; cin = 0;
        #10;
        
        // Test case 2: 0,0,1
        a = 0; b = 0; cin = 1;
        #10;
        
        // Test case 3: 0,1,0
        a = 0; b = 1; cin = 0;
        #10;
        
        // Test case 4: 0,1,1
        a = 0; b = 1; cin = 1;
        #10;
        
        // Test case 5: 1,0,0
        a = 1; b = 0; cin = 0;
        #10;
        
        // Test case 6: 1,0,1
        a = 1; b = 0; cin = 1;
        #10;
        
        // Test case 7: 1,1,0
        a = 1; b = 1; cin = 0;
        #10;
        
        // Test case 8: 1,1,1
        a = 1; b = 1; cin = 1;
        #10;
        
        $finish;
    end
    
    initial begin
        $monitor(""Time=%0t a=%b b=%b cin=%b sum=%b cout=%b"",
                 $time, a, b, cin, sum, cout);
    end
endmodule",True,71,True,True,True,False,0.4,False,6.3757851123809814,6.415044546127319,tie,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,Combinational,simple,"Create a full adder with inputs a, b, cin and outputs sum, cout. Include testbench with all 8 cases.",gpt-4o,"`timescale 1ns/1ps

module full_adder(
    input wire a,
    input wire b,
    input wire cin,
    output wire sum,
    output wire cout
);

assign {cout, sum} = a + b + cin;

endmodule

module testbench;
    reg a, b, cin;
    wire sum, cout;

    full_adder dut (
        .a(a),
        .b(b),
        .cin(cin),
        .sum(sum),
        .cout(cout)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        a = 0; b = 0; cin = 0; #10;
        a = 0; b = 0; cin = 1; #10;
        a = 0; b = 1; cin = 0; #10;
        a = 0; b = 1; cin = 1; #10;
        a = 1; b = 0; cin = 0; #10;
        a = 1; b = 0; cin = 1; #10;
        a = 1; b = 1; cin = 0; #10;
        a = 1; b = 1; cin = 1; #10;
        
        $finish;
    end

    initial begin
        $monitor(""Time=%0t a=%b b=%b cin=%b sum=%b cout=%b"", 
                 $time, a, b, cin, sum, cout);
    end
endmodule",True,47,True,True,True,False,0.4,False,2.242422103881836,11.759081363677979,"graph TD
    A[a] --> FA(Full Adder)
    B[b] --> FA
    CIN[cin] --> FA
    FA --> SUM[sum]
    FA --> COUT[cout]

    subgraph Testbench
        T1[Test Case 1: a=0, b=0, cin=0] --> FA
        T2[Test Case 2: a=0, b=0, cin=1] --> FA
        T3[Test Case 3: a=0, b=1, cin=0] --> FA
        T4[Test Case 4: a=0, b=1, cin=1] --> FA
        T5[Test Case 5: a=1, b=0, cin=0] --> FA
        T6[Test Case 6: a=1, b=0, cin=1] --> FA
        T7[Test Case 7: a=1, b=1, cin=0] --> FA
        T8[Test Case 8: a=1, b=1, cin=1] --> FA
    end","`timescale 1ns/1ps

module full_adder(
    input wire a,
    input wire b,
    input wire cin,
    output wire sum,
    output wire cout
);
    assign {cout, sum} = a + b + cin;
endmodule

module testbench;
    reg a, b, cin;
    wire sum, cout;

    full_adder dut (
        .a(a),
        .b(b),
        .cin(cin),
        .sum(sum),
        .cout(cout)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        // Test Case 1: a=0, b=0, cin=0
        a = 0; b = 0; cin = 0;
        #10;
        
        // Test Case 2: a=0, b=0, cin=1
        a = 0; b = 0; cin = 1;
        #10;

        // Test Case 3: a=0, b=1, cin=0
        a = 0; b = 1; cin = 0;
        #10;

        // Test Case 4: a=0, b=1, cin=1
        a = 0; b = 1; cin = 1;
        #10;

        // Test Case 5: a=1, b=0, cin=0
        a = 1; b = 0; cin = 0;
        #10;

        // Test Case 6: a=1, b=0, cin=1
        a = 1; b = 0; cin = 1;
        #10;

        // Test Case 7: a=1, b=1, cin=0
        a = 1; b = 1; cin = 0;
        #10;

        // Test Case 8: a=1, b=1, cin=1
        a = 1; b = 1; cin = 1;
        #10;

        $finish;
    end

    initial begin
        $monitor(""Time=%0t a=%b b=%b cin=%b sum=%b cout=%b"", 
                 $time, a, b, cin, sum, cout);
    end
endmodule",True,68,True,True,True,False,0.4,False,7.344783544540405,9.503284692764282,"Create a full adder with inputs a, b, cin and outputs sum, cout. Include testbench with all 8 cases.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph TD
    A[a] --> FA(Full Adder)
    B[b] --> FA
    CIN[cin] --> FA
    FA --> SUM[sum]
    FA --> COUT[cout]

    subgraph Testbench
        T1[Test Case 1: a=0, b=0, cin=0] --> FA
        T2[Test Case 2: a=0, b=0, cin=1] --> FA
        T3[Test Case 3: a=0, b=1, cin=0] --> FA
        T4[Test Case 4: a=0, b=1, cin=1] --> FA
        T5[Test Case 5: a=1, b=0, cin=0] --> FA
        T6[Test Case 6: a=1, b=0, cin=1] --> FA
        T7[Test Case 7: a=1, b=1, cin=0] --> FA
        T8[Test Case 8: a=1, b=1, cin=1] --> FA
    end
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module full_adder(
    input wire a,
    input wire b,
    input wire cin,
    output wire sum,
    output wire cout
);

assign sum = a ^ b ^ cin;
assign cout = (a & b) | (b & cin) | (a & cin);

endmodule

module testbench;
    reg a, b, cin;
    wire sum, cout;

    full_adder dut (
        .a(a),
        .b(b),
        .cin(cin),
        .sum(sum),
        .cout(cout)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        // Test Case 1: a=0, b=0, cin=0
        a = 0; b = 0; cin = 0;
        #10;
        
        // Test Case 2: a=0, b=0, cin=1
        a = 0; b = 0; cin = 1;
        #10;
        
        // Test Case 3: a=0, b=1, cin=0
        a = 0; b = 1; cin = 0;
        #10;
        
        // Test Case 4: a=0, b=1, cin=1
        a = 0; b = 1; cin = 1;
        #10;
        
        // Test Case 5: a=1, b=0, cin=0
        a = 1; b = 0; cin = 0;
        #10;
        
        // Test Case 6: a=1, b=0, cin=1
        a = 1; b = 0; cin = 1;
        #10;
        
        // Test Case 7: a=1, b=1, cin=0
        a = 1; b = 1; cin = 0;
        #10;
        
        // Test Case 8: a=1, b=1, cin=1
        a = 1; b = 1; cin = 1;
        #10;
        
        $finish;
    end

    initial begin
        $monitor(""a=%b b=%b cin=%b | sum=%b cout=%b"", a, b, cin, sum, cout);
    end
endmodule",True,70,True,True,True,True,1.0,True,3.897132396697998,8.309594869613647,tie,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,Combinational,simple,"Design a 2-bit comparator with inputs a[1:0], b[1:0] and outputs eq, gt, lt. Include testbench.",claude,"`timescale 1ns/1ps

module comparator (
    input wire [1:0] a,
    input wire [1:0] b,
    output reg eq,
    output reg gt,
    output reg lt
);

always @(*) begin
    eq = (a == b);
    gt = (a > b);
    lt = (a < b);
end

endmodule

module testbench;
    reg [1:0] a, b;
    wire eq, gt, lt;
    
    comparator dut (
        .a(a),
        .b(b),
        .eq(eq),
        .gt(gt),
        .lt(lt)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        a = 2'b00; b = 2'b00; #10;
        a = 2'b01; b = 2'b00; #10;
        a = 2'b10; b = 2'b11; #10;
        a = 2'b11; b = 2'b01; #10;
        a = 2'b01; b = 2'b01; #10;
        a = 2'b10; b = 2'b00; #10;
        
        #10 $finish;
    end
    
    initial begin
        $monitor(""Time=%0t a=%b b=%b eq=%b gt=%b lt=%b"",
                 $time, a, b, eq, gt, lt);
    end
endmodule",True,49,True,True,True,False,0.4,False,4.94603967666626,7.578563213348389,"graph LR
    A0[a[0]] --> COMP((2-bit Comparator))
    A1[a[1]] --> COMP
    B0[b[0]] --> COMP
    B1[b[1]] --> COMP
    COMP --> EQ[eq]
    COMP --> GT[gt]
    COMP --> LT[lt]
    TB[Testbench] -.-> A0
    TB -.-> A1
    TB -.-> B0
    TB -.-> B1
    TB -.-> EQ
    TB -.-> GT
    TB -.-> LT
    CLK[Clock] -.-> TB
    RST[Reset] -.-> TB","`timescale 1ns/1ps

module comparator(
    input wire [1:0] a,
    input wire [1:0] b,
    output reg eq,
    output reg gt,
    output reg lt
);

always @(*) begin
    eq = (a == b);
    gt = (a > b);
    lt = (a < b);
end

endmodule

module testbench;
    reg [1:0] a, b;
    reg clk, rst_n;
    wire eq, gt, lt;

    comparator dut (
        .a(a),
        .b(b),
        .eq(eq),
        .gt(gt),
        .lt(lt)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 0;
        rst_n = 0;
        a = 2'b00;
        b = 2'b00;
        
        #10 rst_n = 1;
        
        #10 a = 2'b01; b = 2'b00;
        #10 a = 2'b10; b = 2'b11;
        #10 a = 2'b11; b = 2'b11;
        #10 a = 2'b00; b = 2'b01;
        
        #10 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t a=%b b=%b eq=%b gt=%b lt=%b"",
                 $time, a, b, eq, gt, lt);
    end
endmodule",True,57,True,True,True,False,0.4,False,7.720073938369751,6.373287677764893,"Design a 2-bit comparator with inputs a[1:0], b[1:0] and outputs eq, gt, lt. Include testbench.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph LR
    A0[a[0]] --> COMP((2-bit Comparator))
    A1[a[1]] --> COMP
    B0[b[0]] --> COMP
    B1[b[1]] --> COMP
    COMP --> EQ[eq]
    COMP --> GT[gt]
    COMP --> LT[lt]
    TB[Testbench] -.-> A0
    TB -.-> A1
    TB -.-> B0
    TB -.-> B1
    TB -.-> EQ
    TB -.-> GT
    TB -.-> LT
    CLK[Clock] -.-> TB
    RST[Reset] -.-> TB
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module comparator (
    input wire [1:0] a,
    input wire [1:0] b,
    output reg eq,
    output reg gt,
    output reg lt
);

always @(*) begin
    eq = (a == b);
    gt = (a > b);
    lt = (a < b);
end

endmodule

module testbench;
    reg [1:0] a, b;
    wire eq, gt, lt;
    reg clk, rst;

    comparator dut (
        .a(a),
        .b(b),
        .eq(eq),
        .gt(gt),
        .lt(lt)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 0;
        rst = 0;
        a = 2'b00;
        b = 2'b00;

        #10 rst = 1;
        
        // Test all combinations
        #10 a = 2'b00; b = 2'b00;
        #10 a = 2'b00; b = 2'b01;
        #10 a = 2'b00; b = 2'b10;
        #10 a = 2'b00; b = 2'b11;
        #10 a = 2'b01; b = 2'b00;
        #10 a = 2'b01; b = 2'b01;
        #10 a = 2'b01; b = 2'b10;
        #10 a = 2'b01; b = 2'b11;
        #10 a = 2'b10; b = 2'b00;
        #10 a = 2'b10; b = 2'b01;
        #10 a = 2'b10; b = 2'b10;
        #10 a = 2'b10; b = 2'b11;
        #10 a = 2'b11; b = 2'b00;
        #10 a = 2'b11; b = 2'b01;
        #10 a = 2'b11; b = 2'b10;
        #10 a = 2'b11; b = 2'b11;
        
        #10 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t a=%b b=%b eq=%b gt=%b lt=%b"",
                 $time, a, b, eq, gt, lt);
    end
endmodule",True,70,True,True,True,False,0.4,False,7.518655300140381,7.567926406860352,tie,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,Combinational,simple,"Design a 2-bit comparator with inputs a[1:0], b[1:0] and outputs eq, gt, lt. Include testbench.",gpt-4o,"`timescale 1ns/1ps

module comparator_2bit(
    input wire [1:0] a,
    input wire [1:0] b,
    output reg eq,
    output reg gt,
    output reg lt
);

always @(*) begin
    if (a == b) begin
        eq = 1'b1;
        gt = 1'b0;
        lt = 1'b0;
    end else if (a > b) begin
        eq = 1'b0;
        gt = 1'b1;
        lt = 1'b0;
    end else begin
        eq = 1'b0;
        gt = 1'b0;
        lt = 1'b1;
    end
end

endmodule

module testbench;
    reg [1:0] a;
    reg [1:0] b;
    wire eq;
    wire gt;
    wire lt;
    
    comparator_2bit dut (
        .a(a),
        .b(b),
        .eq(eq),
        .gt(gt),
        .lt(lt)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        a = 2'b00; b = 2'b00;
        #10 a = 2'b01; b = 2'b00;
        #10 a = 2'b01; b = 2'b01;
        #10 a = 2'b10; b = 2'b01;
        #10 a = 2'b10; b = 2'b10;
        #10 a = 2'b11; b = 2'b00;
        #10 a = 2'b11; b = 2'b11;
        #10 $finish;
    end
    
    initial begin
        $monitor(""Time=%0t a=%b b=%b eq=%b gt=%b lt=%b"", 
                 $time, a, b, eq, gt, lt);
    end
endmodule",True,62,True,True,True,True,0.9,True,3.8073651790618896,7.2919533252716064,"graph TD
    A1[[a[1]]] --> CMP(Comparator)
    A0[[a[0]]] --> CMP
    B1[[b[1]]] --> CMP
    B0[[b[0]]] --> CMP
    CMP --> EQ[eq]
    CMP --> GT[gt]
    CMP --> LT[lt]

    subgraph Testbench
        TB_CLK[Clock] --> TB
        TB_RST[Reset] --> TB
        TB --> A1
        TB --> A0
        TB --> B1
        TB --> B0
        EQ --> TB
        GT --> TB
        LT --> TB
    end","`timescale 1ns/1ps

module comparator(
    input wire [1:0] a,
    input wire [1:0] b,
    output reg eq,
    output reg gt,
    output reg lt
);

always @(*) begin
    eq = (a == b);
    gt = (a > b);
    lt = (a < b);
end

endmodule

module testbench;
    reg clk, rst;
    reg [1:0] a, b;
    wire eq, gt, lt;

    comparator dut (
        .a(a),
        .b(b),
        .eq(eq),
        .gt(gt),
        .lt(lt)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 1'b0;
        rst = 1'b0;
        a = 2'b00;
        b = 2'b00;

        #20 rst = 1'b1;
        #10 a = 2'b10; b = 2'b01;
        #10 a = 2'b01; b = 2'b01;
        #10 a = 2'b00; b = 2'b11;
        #10 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t clk=%b rst=%b a=%b b=%b eq=%b gt=%b lt=%b"", 
                 $time, clk, rst, a, b, eq, gt, lt);
    end
endmodule",True,54,True,True,True,False,0.4,False,4.458291292190552,6.959852695465088,"Design a 2-bit comparator with inputs a[1:0], b[1:0] and outputs eq, gt, lt. Include testbench.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph TD
    A1[[a[1]]] --> CMP(Comparator)
    A0[[a[0]]] --> CMP
    B1[[b[1]]] --> CMP
    B0[[b[0]]] --> CMP
    CMP --> EQ[eq]
    CMP --> GT[gt]
    CMP --> LT[lt]

    subgraph Testbench
        TB_CLK[Clock] --> TB
        TB_RST[Reset] --> TB
        TB --> A1
        TB --> A0
        TB --> B1
        TB --> B0
        EQ --> TB
        GT --> TB
        LT --> TB
    end
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module comparator_2bit(
    input wire [1:0] a,
    input wire [1:0] b,
    output reg eq,
    output reg gt,
    output reg lt
);

always @* begin
    if (a == b) begin
        eq = 1'b1;
        gt = 1'b0;
        lt = 1'b0;
    end else if (a > b) begin
        eq = 1'b0;
        gt = 1'b1;
        lt = 1'b0;
    end else begin
        eq = 1'b0;
        gt = 1'b0;
        lt = 1'b1;
    end
end

endmodule

module testbench;
    reg [1:0] a;
    reg [1:0] b;
    reg clk;
    reg rst;
    wire eq;
    wire gt;
    wire lt;
    
    comparator_2bit dut (
        .a(a),
        .b(b),
        .eq(eq),
        .gt(gt),
        .lt(lt)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst = 1'b0;
        a = 2'b00;
        b = 2'b00;
        
        #20 rst = 1'b1;
        #10 a = 2'b01; b = 2'b01;
        #10 a = 2'b10; b = 2'b01;
        #10 a = 2'b01; b = 2'b10;
        #10 a = 2'b11; b = 2'b11;
        #10 a = 2'b00; b = 2'b11;
        #10 a = 2'b11; b = 2'b00;
        #50 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t a=%b b=%b eq=%b gt=%b lt=%b"", 
                 $time, a, b, eq, gt, lt);
    end
endmodule",True,71,True,True,True,False,0.4,False,2.6694447994232178,10.75631332397461,tie,mermaid_only > combined > prompt_only,prompt_only > mermaid_only > combined
combined,Arithmetic,medium,"Design a 4-bit ALU supporting ADD, SUB, AND, OR operations. Inputs: a[3:0], b[3:0], op[1:0]. Outputs: result[3:0], zero. Include testbench.",claude,"`timescale 1ns/1ps

module alu(
    input wire [3:0] a,
    input wire [3:0] b,
    input wire [1:0] op,
    output reg [3:0] result,
    output wire zero
);

assign zero = (result == 4'b0000);

always @(*) begin
    case(op)
        2'b00: result = a + b;    // ADD
        2'b01: result = a - b;    // SUB
        2'b10: result = a & b;    // AND
        2'b11: result = a | b;    // OR
        default: result = 4'b0000;
    endcase
end

endmodule

module testbench;
    reg [3:0] a, b;
    reg [1:0] op;
    wire [3:0] result;
    wire zero;

    alu dut (
        .a(a),
        .b(b),
        .op(op),
        .result(result),
        .zero(zero)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        // Test ADD
        a = 4'b0011; b = 4'b0001; op = 2'b00;
        #10;

        // Test SUB
        a = 4'b0011; b = 4'b0001; op = 2'b01;
        #10;

        // Test AND
        a = 4'b0011; b = 4'b0001; op = 2'b10;
        #10;

        // Test OR
        a = 4'b0011; b = 4'b0001; op = 2'b11;
        #10;

        // Test zero flag
        a = 4'b0001; b = 4'b0001; op = 2'b01;
        #10;

        $finish;
    end

    initial begin
        $monitor(""Time=%0t a=%b b=%b op=%b result=%b zero=%b"",
                 $time, a, b, op, result, zero);
    end
endmodule",True,70,True,True,True,False,0.4,False,6.558742523193359,10.064582586288452,"graph LR
    A[a3:0] --> ALU((4-bit ALU))
    B[b3:0] --> ALU
    OP[op1:0] --> ALU
    CLK[Clock] --> TB[[Testbench]]
    RST[Reset] --> TB
    
    ALU --> RES[result3:0]
    ALU --> Z[zero]
    
    subgraph Operations
    ADD((ADD))
    SUB((SUB))
    AND((AND))
    OR((OR))
    end
    
    Operations --> ALU
    
    RES --> TB
    Z --> TB
    A --> TB
    B --> TB
    OP --> TB
    
    TB --> SIM[Simulation Results]","`timescale 1ns/1ps

module alu(
    input wire clk,
    input wire [3:0] a,
    input wire [3:0] b,
    input wire [1:0] op,
    output reg [3:0] result,
    output reg zero
);

always @(posedge clk) begin
    case(op)
        2'b00: result <= a + b;    // ADD
        2'b01: result <= a - b;    // SUB
        2'b10: result <= a & b;    // AND
        2'b11: result <= a | b;    // OR
        default: result <= 4'b0;
    endcase
    zero <= (result == 4'b0);
end

endmodule

module testbench;
    reg clk;
    reg rst;
    reg [3:0] a;
    reg [3:0] b;
    reg [1:0] op;
    wire [3:0] result;
    wire zero;

    alu dut (
        .clk(clk),
        .a(a),
        .b(b),
        .op(op),
        .result(result),
        .zero(zero)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 0;
        a = 0;
        b = 0;
        op = 0;

        // Test ADD
        #10 a = 4'h3; b = 4'h2; op = 2'b00;
        
        // Test SUB
        #10 a = 4'h5; b = 4'h3; op = 2'b01;
        
        // Test AND
        #10 a = 4'h7; b = 4'h3; op = 2'b10;
        
        // Test OR
        #10 a = 4'h5; b = 4'h2; op = 2'b11;
        
        // Test zero flag
        #10 a = 4'h0; b = 4'h0; op = 2'b00;

        #10 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t a=%h b=%h op=%b result=%h zero=%b"",
                 $time, a, b, op, result, zero);
    end
endmodule",True,76,True,True,True,False,0.4,False,11.479290008544922,6.770126581192017,"Design a 4-bit ALU supporting ADD, SUB, AND, OR operations. Inputs: a[3:0], b[3:0], op[1:0]. Outputs: result[3:0], zero. Include testbench.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph LR
    A[a3:0] --> ALU((4-bit ALU))
    B[b3:0] --> ALU
    OP[op1:0] --> ALU
    CLK[Clock] --> TB[[Testbench]]
    RST[Reset] --> TB
    
    ALU --> RES[result3:0]
    ALU --> Z[zero]
    
    subgraph Operations
    ADD((ADD))
    SUB((SUB))
    AND((AND))
    OR((OR))
    end
    
    Operations --> ALU
    
    RES --> TB
    Z --> TB
    A --> TB
    B --> TB
    OP --> TB
    
    TB --> SIM[Simulation Results]
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module alu (
    input wire [3:0] a,
    input wire [3:0] b,
    input wire [1:0] op,
    output reg [3:0] result,
    output wire zero
);

assign zero = (result == 4'b0000);

always @(*) begin
    case (op)
        2'b00: result = a + b;    // ADD
        2'b01: result = a - b;    // SUB
        2'b10: result = a & b;    // AND
        2'b11: result = a | b;    // OR
        default: result = 4'b0000;
    endcase
end

endmodule

module testbench;
    reg clk;
    reg rst;
    reg [3:0] a;
    reg [3:0] b;
    reg [1:0] op;
    wire [3:0] result;
    wire zero;

    alu dut (
        .a(a),
        .b(b),
        .op(op),
        .result(result),
        .zero(zero)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 0;
        rst = 1;
        a = 0;
        b = 0;
        op = 0;

        #10 rst = 0;

        // Test ADD
        #10 a = 4'b0011; b = 4'b0010; op = 2'b00;
        
        // Test SUB
        #10 a = 4'b0111; b = 4'b0011; op = 2'b01;
        
        // Test AND
        #10 a = 4'b1100; b = 4'b1010; op = 2'b10;
        
        // Test OR
        #10 a = 4'b1100; b = 4'b0011; op = 2'b11;
        
        // Test zero flag
        #10 a = 4'b0000; b = 4'b0000; op = 2'b00;

        #10 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t rst=%b a=%b b=%b op=%b result=%b zero=%b"",
                 $time, rst, a, b, op, result, zero);
    end

endmodule",True,79,True,True,True,False,0.4,False,7.48971962928772,6.305248260498047,tie,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,Arithmetic,medium,"Design a 4-bit ALU supporting ADD, SUB, AND, OR operations. Inputs: a[3:0], b[3:0], op[1:0]. Outputs: result[3:0], zero. Include testbench.",gpt-4o,"`timescale 1ns/1ps

module alu_4bit(
    input wire [3:0] a,
    input wire [3:0] b,
    input wire [1:0] op,
    output reg [3:0] result,
    output wire zero
);

always @(*) begin
    case(op)
        2'b00: result = a + b;    // ADD
        2'b01: result = a - b;    // SUB
        2'b10: result = a & b;    // AND
        2'b11: result = a | b;    // OR
        default: result = 4'b0000;
    endcase
end

assign zero = (result == 4'b0000);

endmodule

module testbench;
    reg [3:0] a, b;
    reg [1:0] op;
    wire [3:0] result;
    wire zero;

    alu_4bit dut (
        .a(a),
        .b(b),
        .op(op),
        .result(result),
        .zero(zero)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        a = 4'b0000; b = 4'b0000; op = 2'b00;
        #10 a = 4'b0011; b = 4'b0001; op = 2'b00; // ADD
        #10 a = 4'b0100; b = 4'b0011; op = 2'b01; // SUB
        #10 a = 4'b0101; b = 4'b0011; op = 2'b10; // AND
        #10 a = 4'b0101; b = 4'b0010; op = 2'b11; // OR
        #10 $finish;
    end

    initial begin
        $monitor(""Time=%0t a=%b b=%b op=%b result=%b zero=%b"", 
                 $time, a, b, op, result, zero);
    end
endmodule",True,55,True,True,True,False,0.4,False,2.416041374206543,11.976751804351807,"graph TD
    IN1[a[3:0]] --> ALU
    IN2[b[3:0]] --> ALU
    OP[op[1:0]] --> ALU
    ALU(4-bit ALU)
    ALU --> OUT1[result[3:0]]
    ALU --> OUT2{zero}
    CLK[Clock] --> TB[Testbench]
    RST[Reset] --> TB
    TB --> ALU
    TB --> IN1
    TB --> IN2
    TB --> OP
    OUT1 --> TB
    OUT2 --> TB","`timescale 1ns/1ps

module alu(
    input wire [3:0] a,
    input wire [3:0] b,
    input wire [1:0] op,
    input wire clk,
    output reg [3:0] result,
    output reg zero
);

    always @(posedge clk) begin
        case (op)
            2'b00: result <= a + b;     // ADD
            2'b01: result <= a - b;     // SUBTRACT
            2'b10: result <= a & b;     // AND
            2'b11: result <= a | b;     // OR
            default: result <= 4'b0000;
        endcase
        zero <= (result == 4'b0000) ? 1'b1 : 1'b0;
    end

endmodule

module testbench;
    reg [3:0] a, b;
    reg [1:0] op;
    reg clk, rst;
    wire [3:0] result;
    wire zero;

    alu dut (
        .a(a),
        .b(b),
        .op(op),
        .clk(clk),
        .result(result),
        .zero(zero)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 1'b0;
        rst = 1'b0;
        a = 4'b0000;
        b = 4'b0000;
        op = 2'b00;

        #10 rst = 1'b1;
        #10 a = 4'b0101; b = 4'b0011; op = 2'b00;  // ADD
        #10 op = 2'b01;                           // SUBTRACT
        #10 op = 2'b10;                           // AND
        #10 op = 2'b11;                           // OR
        #10 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t a=%b b=%b op=%b result=%b zero=%b"", 
                 $time, a, b, op, result, zero);
    end
endmodule",True,65,True,True,True,False,0.4,False,13.347870111465454,8.218720197677612,"Design a 4-bit ALU supporting ADD, SUB, AND, OR operations. Inputs: a[3:0], b[3:0], op[1:0]. Outputs: result[3:0], zero. Include testbench.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph TD
    IN1[a[3:0]] --> ALU
    IN2[b[3:0]] --> ALU
    OP[op[1:0]] --> ALU
    ALU(4-bit ALU)
    ALU --> OUT1[result[3:0]]
    ALU --> OUT2{zero}
    CLK[Clock] --> TB[Testbench]
    RST[Reset] --> TB
    TB --> ALU
    TB --> IN1
    TB --> IN2
    TB --> OP
    OUT1 --> TB
    OUT2 --> TB
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module alu(
    input wire [3:0] a,
    input wire [3:0] b,
    input wire [1:0] op,
    output reg [3:0] result,
    output wire zero
);

always @(*) begin
    case(op)
        2'b00: result = a + b; // ADD
        2'b01: result = a - b; // SUB
        2'b10: result = a & b; // AND
        2'b11: result = a | b; // OR
        default: result = 4'b0000;
    endcase
end

assign zero = (result == 4'b0000);

endmodule

module testbench;
    reg [3:0] a, b;
    reg [1:0] op;
    wire [3:0] result;
    wire zero;
    reg clk, rst;

    alu dut (
        .a(a),
        .b(b),
        .op(op),
        .result(result),
        .zero(zero)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 0;
        rst = 0;
        a = 4'b0000;
        b = 4'b0000;
        op = 2'b00;

        #10 rst = 1;
        #10 a = 4'b0101; b = 4'b0011; op = 2'b00; // ADD
        #10 a = 4'b0101; b = 4'b0011; op = 2'b01; // SUB
        #10 a = 4'b0101; b = 4'b0011; op = 2'b10; // AND
        #10 a = 4'b0101; b = 4'b0011; op = 2'b11; // OR
        #10 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t a=%b b=%b op=%b result=%b zero=%b"", 
                 $time, a, b, op, result, zero);
    end
endmodule",True,64,True,True,True,False,0.4,False,3.6304759979248047,9.778707027435303,tie,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,Combinational,medium,"Create an 8:1 multiplexer with input data[7:0], select sel[2:0], and output out. Include testbench.",claude,"`timescale 1ns/1ps

module mux8to1(
    input wire [7:0] data,
    input wire [2:0] sel,
    output reg out
);

always @(*) begin
    case(sel)
        3'b000: out = data[0];
        3'b001: out = data[1];
        3'b010: out = data[2];
        3'b011: out = data[3];
        3'b100: out = data[4];
        3'b101: out = data[5];
        3'b110: out = data[6];
        3'b111: out = data[7];
        default: out = 1'b0;
    endcase
end

endmodule

module testbench;
    reg [7:0] data;
    reg [2:0] sel;
    wire out;

    mux8to1 dut (
        .data(data),
        .sel(sel),
        .out(out)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        data = 8'b10101010;
        sel = 3'b000;
        #10;

        sel = 3'b001;
        #10;

        sel = 3'b010;
        #10;

        sel = 3'b011;
        #10;

        data = 8'b11110000;
        sel = 3'b100;
        #10;

        sel = 3'b101;
        #10;

        sel = 3'b110;
        #10;

        sel = 3'b111;
        #10;

        $finish;
    end

    initial begin
        $monitor(""Time=%0t data=%b sel=%b out=%b"", 
                 $time, data, sel, out);
    end
endmodule",True,73,True,True,True,False,0.4,False,5.632862091064453,7.505833148956299,"graph LR
    D0[Data[0]] --> MUX{8:1 MUX}
    D1[Data[1]] --> MUX
    D2[Data[2]] --> MUX
    D3[Data[3]] --> MUX
    D4[Data[4]] --> MUX
    D5[Data[5]] --> MUX
    D6[Data[6]] --> MUX
    D7[Data[7]] --> MUX
    S0[Sel[0]] --> MUX
    S1[Sel[1]] --> MUX
    S2[Sel[2]] --> MUX
    MUX --> OUT[Output]
    TB[Testbench] -.-> D0
    TB -.-> D1
    TB -.-> D2
    TB -.-> D3
    TB -.-> D4
    TB -.-> D5
    TB -.-> D6
    TB -.-> D7
    TB -.-> S0
    TB -.-> S1
    TB -.-> S2
    OUT -.-> TB","`timescale 1ns/1ps

module mux8to1(
    input wire clk,
    input wire rst_n,
    input wire [7:0] data,
    input wire [2:0] sel,
    output reg out
);

always @(posedge clk or negedge rst_n) begin
    if (!rst_n)
        out <= 1'b0;
    else
        out <= data[sel];
end

endmodule

module testbench;
    reg clk;
    reg rst_n;
    reg [7:0] data;
    reg [2:0] sel;
    wire out;

    mux8to1 dut (
        .clk(clk),
        .rst_n(rst_n),
        .data(data),
        .sel(sel),
        .out(out)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 0;
        rst_n = 0;
        data = 8'b00000000;
        sel = 3'b000;

        #10 rst_n = 1;
        #10 data = 8'b10101010;
        
        for (sel = 0; sel < 8; sel = sel + 1) begin
            #10;
        end

        #10 data = 8'b11110000;
        
        for (sel = 0; sel < 8; sel = sel + 1) begin
            #10;
        end

        #10 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t rst_n=%b data=%b sel=%b out=%b"",
                 $time, rst_n, data, sel, out);
    end
endmodule",True,66,True,False,False,,0.0,,9.243388652801514,62.839125871658325,"Create an 8:1 multiplexer with input data[7:0], select sel[2:0], and output out. Include testbench.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph LR
    D0[Data[0]] --> MUX{8:1 MUX}
    D1[Data[1]] --> MUX
    D2[Data[2]] --> MUX
    D3[Data[3]] --> MUX
    D4[Data[4]] --> MUX
    D5[Data[5]] --> MUX
    D6[Data[6]] --> MUX
    D7[Data[7]] --> MUX
    S0[Sel[0]] --> MUX
    S1[Sel[1]] --> MUX
    S2[Sel[2]] --> MUX
    MUX --> OUT[Output]
    TB[Testbench] -.-> D0
    TB -.-> D1
    TB -.-> D2
    TB -.-> D3
    TB -.-> D4
    TB -.-> D5
    TB -.-> D6
    TB -.-> D7
    TB -.-> S0
    TB -.-> S1
    TB -.-> S2
    OUT -.-> TB
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module mux8to1(
    input wire [7:0] data,
    input wire [2:0] sel,
    output reg out
);

always @(*) begin
    case(sel)
        3'b000: out = data[0];
        3'b001: out = data[1];
        3'b010: out = data[2];
        3'b011: out = data[3];
        3'b100: out = data[4];
        3'b101: out = data[5];
        3'b110: out = data[6];
        3'b111: out = data[7];
        default: out = 1'b0;
    endcase
end

endmodule

module testbench;
    reg [7:0] data;
    reg [2:0] sel;
    wire out;

    mux8to1 dut(
        .data(data),
        .sel(sel),
        .out(out)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        data = 8'b10101010;
        sel = 3'b000;
        #10;

        sel = 3'b001;
        #10;

        data = 8'b11001100;
        sel = 3'b010;
        #10;

        sel = 3'b011;
        #10;

        data = 8'b11110000;
        sel = 3'b100;
        #10;

        sel = 3'b101;
        #10;

        sel = 3'b110;
        #10;

        sel = 3'b111;
        #10;

        $finish;
    end

    initial begin
        $monitor(""Time=%0t data=%b sel=%b out=%b"", 
                 $time, data, sel, out);
    end
endmodule",True,74,True,True,True,False,0.4,False,6.00570273399353,7.042628526687622,tie,prompt_only > combined > mermaid_only,prompt_only > combined > mermaid_only
combined,Combinational,medium,"Create an 8:1 multiplexer with input data[7:0], select sel[2:0], and output out. Include testbench.",gpt-4o,"`timescale 1ns/1ps

module mux_8to1(
    input wire [7:0] data,
    input wire [2:0] sel,
    output reg out
);

always @(*) begin
    case (sel)
        3'b000: out = data[0];
        3'b001: out = data[1];
        3'b010: out = data[2];
        3'b011: out = data[3];
        3'b100: out = data[4];
        3'b101: out = data[5];
        3'b110: out = data[6];
        3'b111: out = data[7];
        default: out = 1'b0;
    endcase
end

endmodule

module testbench;
    reg [7:0] data;
    reg [2:0] sel;
    wire out;
    
    mux_8to1 dut (
        .data(data),
        .sel(sel),
        .out(out)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        data = 8'b10101010;
        sel = 3'b000;
        
        #10 sel = 3'b001;
        #10 sel = 3'b010;
        #10 sel = 3'b011;
        #10 sel = 3'b100;
        #10 sel = 3'b101;
        #10 sel = 3'b110;
        #10 sel = 3'b111;
        
        #10 $finish;
    end
    
    initial begin
        $monitor(""Time=%0t sel=%b out=%b"", $time, sel, out);
    end
endmodule",True,57,True,True,True,False,0.4,False,3.083383798599243,6.96269154548645,"graph LR
    DATA[Input Data: data[7:0]] --> MUX{8:1 MUX}
    SEL[Select: sel[2:0]] --> MUX
    MUX --> OUT[Output: out]
    
    subgraph TESTBENCH
        CLK[Clock] --> MUX
        RST[Reset] --> MUX
        TB[Input Stimulus] --> DATA
        TB --> SEL
        OUT --> TB
    end","`timescale 1ns/1ps

module mux_8to1(
    input wire [7:0] data,
    input wire [2:0] sel,
    input wire clk,
    input wire rst,
    output reg out
);

always @(posedge clk or posedge rst) begin
    if (rst) begin
        out <= 1'b0;
    end else begin
        case (sel)
            3'b000: out <= data[0];
            3'b001: out <= data[1];
            3'b010: out <= data[2];
            3'b011: out <= data[3];
            3'b100: out <= data[4];
            3'b101: out <= data[5];
            3'b110: out <= data[6];
            3'b111: out <= data[7];
            default: out <= 1'b0;
        endcase
    end
end

endmodule

module testbench;
    reg [7:0] data;
    reg [2:0] sel;
    reg clk, rst;
    wire out;

    mux_8to1 dut (
        .data(data),
        .sel(sel),
        .clk(clk),
        .rst(rst),
        .out(out)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 1'b0;
        rst = 1'b1;
        data = 8'b00000000;
        sel = 3'b000;
        
        #20 rst = 1'b0;
        #10 data = 8'b10101010; sel = 3'b000;
        #10 sel = 3'b001;
        #10 sel = 3'b010;
        #10 sel = 3'b011;
        #10 sel = 3'b100;
        #10 sel = 3'b101;
        #10 sel = 3'b110;
        #10 sel = 3'b111;
        #50 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t clk=%b rst=%b data=%b sel=%b out=%b"",
                 $time, clk, rst, data, sel, out);
    end
endmodule",True,72,True,True,True,True,0.75,True,6.148372411727905,7.119603157043457,"Create an 8:1 multiplexer with input data[7:0], select sel[2:0], and output out. Include testbench.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph LR
    DATA[Input Data: data[7:0]] --> MUX{8:1 MUX}
    SEL[Select: sel[2:0]] --> MUX
    MUX --> OUT[Output: out]
    
    subgraph TESTBENCH
        CLK[Clock] --> MUX
        RST[Reset] --> MUX
        TB[Input Stimulus] --> DATA
        TB --> SEL
        OUT --> TB
    end
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module mux8to1(
    input wire [7:0] data,
    input wire [2:0] sel,
    output reg out
);
    always @(*) begin
        case (sel)
            3'b000: out = data[0];
            3'b001: out = data[1];
            3'b010: out = data[2];
            3'b011: out = data[3];
            3'b100: out = data[4];
            3'b101: out = data[5];
            3'b110: out = data[6];
            3'b111: out = data[7];
            default: out = 1'b0;
        endcase
    end
endmodule

module testbench;
    reg clk, rst;
    reg [7:0] data;
    reg [2:0] sel;
    wire out;
    
    mux8to1 uut (
        .data(data),
        .sel(sel),
        .out(out)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst = 1'b0;
        data = 8'b00000000;
        sel = 3'b000;
        
        #10 rst = 1'b1;
        #10 data = 8'b10101010;
        #10 sel = 3'b011;
        #10 sel = 3'b100;
        #10 sel = 3'b111;
        #10 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t clk=%b rst=%b sel=%b out=%b"", 
                 $time, clk, rst, sel, out);
    end
endmodule",True,58,True,True,True,False,0.4,False,4.071294784545898,7.050271034240723,tie,prompt_only > combined > mermaid_only,prompt_only > mermaid_only > combined
combined,State Machine,medium,Design an FSM detecting pattern 1011 in serial input with overlapping detection. Include testbench with sequence: 10110111011.,claude,"`timescale 1ns/1ps

module pattern_detect(
    input wire clk,
    input wire rst_n,
    input wire data_in,
    output reg detect
);

reg [2:0] state, next_state;
parameter S0 = 3'b000,
          S1 = 3'b001,
          S2 = 3'b010,
          S3 = 3'b011;

always @(posedge clk or negedge rst_n) begin
    if (!rst_n)
        state <= S0;
    else
        state <= next_state;
end

always @(*) begin
    detect = 1'b0;
    case (state)
        S0: next_state = (data_in) ? S1 : S0;
        S1: next_state = (data_in) ? S1 : S2;
        S2: next_state = (data_in) ? S3 : S0;
        S3: begin
            next_state = (data_in) ? S1 : S2;
            detect = 1'b1;
        end
        default: next_state = S0;
    endcase
end

endmodule

module testbench;
    reg clk, rst_n, data_in;
    wire detect;
    reg [10:0] test_seq = 11'b10110111011;
    integer i;

    pattern_detect dut (
        .clk(clk),
        .rst_n(rst_n),
        .data_in(data_in),
        .detect(detect)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 0;
        rst_n = 0;
        data_in = 0;
        
        #10 rst_n = 1;
        
        for(i = 10; i >= 0; i = i - 1) begin
            @(posedge clk);
            data_in = test_seq[i];
        end
        
        #10 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t rst_n=%b data_in=%b detect=%b"", 
                 $time, rst_n, data_in, detect);
    end
endmodule",True,76,True,True,True,False,0.3,False,7.041714191436768,8.008131504058838,"graph TD
    CLK[Clock] --> FSM((State Machine))
    RST[Reset] --> FSM
    SI[Serial Input] --> FSM
    FSM --> DET[Pattern Detected]
    
    TB[[Test Bench]] --> SI
    CLK --> TB
    RST --> TB
    
    S0((State 0)) --> |1| S1((State 1))
    S0 --> |0| S0
    S1 --> |0| S2((State 2))
    S1 --> |1| S1
    S2 --> |1| S3((State 3))
    S2 --> |0| S0
    S3 --> |1| S1
    S3 --> |0| S0
    
    SEQIN[10110111011] --> TB
    
    FSM --> |State| STATUS[Current State]
    FSM --> |Match| OUT[Pattern Match]","`timescale 1ns/1ps

module pattern_detector(
    input wire clk,
    input wire rst,
    input wire si,
    output reg pattern_detected,
    output reg [1:0] current_state
);

parameter S0 = 2'b00;
parameter S1 = 2'b01;
parameter S2 = 2'b10;
parameter S3 = 2'b11;

reg [1:0] state;

always @(posedge clk or posedge rst) begin
    if (rst) begin
        state <= S0;
        pattern_detected <= 1'b0;
    end
    else begin
        case (state)
            S0: state <= (si) ? S1 : S0;
            S1: state <= (si) ? S1 : S2;
            S2: state <= (si) ? S3 : S0;
            S3: state <= (si) ? S1 : S0;
            default: state <= S0;
        endcase
        pattern_detected <= (state == S3 && si == 1'b1);
    end
end

always @(*) begin
    current_state = state;
end

endmodule

module testbench;
    reg clk, rst, si;
    wire pattern_detected;
    wire [1:0] current_state;
    
    reg [10:0] test_pattern = 11'b10110111011;
    integer i;

    pattern_detector dut (
        .clk(clk),
        .rst(rst),
        .si(si),
        .pattern_detected(pattern_detected),
        .current_state(current_state)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 0;
        rst = 1;
        si = 0;
        
        #10 rst = 0;
        
        for(i = 10; i >= 0; i = i - 1) begin
            @(posedge clk) si = test_pattern[i];
        end
        
        #20 rst = 1;
        #10 rst = 0;
        #50 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t rst=%b si=%b state=%b detected=%b"", 
                 $time, rst, si, current_state, pattern_detected);
    end
endmodule",True,82,True,True,True,False,0.3,False,12.698974609375,7.760657548904419,"Design an FSM detecting pattern 1011 in serial input with overlapping detection. Include testbench with sequence: 10110111011.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph TD
    CLK[Clock] --> FSM((State Machine))
    RST[Reset] --> FSM
    SI[Serial Input] --> FSM
    FSM --> DET[Pattern Detected]
    
    TB[[Test Bench]] --> SI
    CLK --> TB
    RST --> TB
    
    S0((State 0)) --> |1| S1((State 1))
    S0 --> |0| S0
    S1 --> |0| S2((State 2))
    S1 --> |1| S1
    S2 --> |1| S3((State 3))
    S2 --> |0| S0
    S3 --> |1| S1
    S3 --> |0| S0
    
    SEQIN[10110111011] --> TB
    
    FSM --> |State| STATUS[Current State]
    FSM --> |Match| OUT[Pattern Match]
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module pattern_detector(
    input wire clk,
    input wire rst,
    input wire si,
    output reg detected,
    output reg [1:0] state
);

parameter [1:0] S0 = 2'b00,
                S1 = 2'b01,
                S2 = 2'b10,
                S3 = 2'b11;

always @(posedge clk or posedge rst) begin
    if (rst) begin
        state <= S0;
        detected <= 0;
    end
    else begin
        case (state)
            S0: state <= si ? S1 : S0;
            S1: state <= si ? S1 : S2;
            S2: state <= si ? S3 : S0;
            S3: state <= si ? S1 : S0;
            default: state <= S0;
        endcase
        
        detected <= (state == S3 && si == 1'b1);
    end
end

endmodule

module testbench;
    reg clk;
    reg rst;
    reg si;
    wire detected;
    wire [1:0] state;
    
    pattern_detector dut(
        .clk(clk),
        .rst(rst),
        .si(si),
        .detected(detected),
        .state(state)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 0;
        rst = 1;
        si = 0;
        
        #10 rst = 0;
        
        // Test sequence: 10110111011
        #10 si = 1;
        #10 si = 0;
        #10 si = 1;
        #10 si = 1;
        #10 si = 0;
        #10 si = 1;
        #10 si = 1;
        #10 si = 1;
        #10 si = 0;
        #10 si = 1;
        #10 si = 1;
        
        #20 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t rst=%b si=%b state=%b detected=%b"",
                 $time, rst, si, state, detected);
    end
endmodule",True,83,True,True,True,False,0.4,False,7.467720031738281,7.27064847946167,tie,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,State Machine,medium,Design an FSM detecting pattern 1011 in serial input with overlapping detection. Include testbench with sequence: 10110111011.,gpt-4o,"`timescale 1ns/1ps

module fsm_1011_detector(
    input wire clk,
    input wire rst_n,
    input wire serial_in,
    output reg pattern_detected
);

    typedef enum reg [2:0] {
        IDLE = 3'b000,
        S1   = 3'b001,
        S10  = 3'b010,
        S101 = 3'b011,
        S1011= 3'b100
    } state_t;

    reg [2:0] current_state, next_state;

    always @(posedge clk or negedge rst_n) begin
        if (!rst_n)
            current_state <= IDLE;
        else
            current_state <= next_state;
    end

    always @(*) begin
        next_state = current_state;
        pattern_detected = 1'b0;
        case (current_state)
            IDLE: 
                if (serial_in)
                    next_state = S1;
            S1: 
                if (!serial_in)
                    next_state = S10;
            S10: 
                if (serial_in)
                    next_state = S101;
                else
                    next_state = IDLE;
            S101: 
                if (serial_in)
                    next_state = S1011;
                else
                    next_state = S10;
            S1011: begin
                pattern_detected = 1'b1;
                if (serial_in)
                    next_state = S1;
                else
                    next_state = S10;
            end
        endcase
    end

endmodule

module testbench;
    reg clk, rst_n, serial_in;
    wire pattern_detected;

    fsm_1011_detector dut (
        .clk(clk),
        .rst_n(rst_n),
        .serial_in(serial_in),
        .pattern_detected(pattern_detected)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 1'b0;
        rst_n = 1'b0;
        serial_in = 1'b0;

        #20 rst_n = 1'b1;
        #10 serial_in = 1'b1;
        #10 serial_in = 1'b0;
        #10 serial_in = 1'b1;
        #10 serial_in = 1'b1;
        #10 serial_in = 1'b0;
        #10 serial_in = 1'b1;
        #10 serial_in = 1'b1;
        #10 serial_in = 1'b1;
        #10 serial_in = 1'b0;
        #10 serial_in = 1'b1;
        #10 serial_in = 1'b1;
        #50 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b serial_in=%b pattern_detected=%b"", 
                 $time, clk, rst_n, serial_in, pattern_detected);
    end
endmodule",True,99,True,True,True,True,0.7,True,7.608076572418213,6.848127365112305,"graph LR
    CLK[Clock] --> S0
    RST[Reset] --> S0
    IN[Serial Input] --> S0
    S0((State 0)) -->|1| S1((State 1))
    S0 -->|0| S0
    S1 -->|0| S2((State 2))
    S1 -->|1| S1
    S2 -->|1| S3((State 3))
    S2 -->|0| S0
    S3 -->|1| S4((State 4))
    S3 -->|0| S2
    S4 -->|1| S1
    S4 -->|0| S2
    S4 --> DETECTED[Pattern Detected]
    TB[Testbench Sequence: 10110111011] --> IN","`timescale 1ns/1ps

module fsm(
    input wire clk,
    input wire rst,
    input wire in,
    output reg detected
);

    reg [2:0] state, next_state;
    parameter S0 = 3'b000, S1 = 3'b001, S2 = 3'b010, S3 = 3'b011, S4 = 3'b100;

    always @(posedge clk or posedge rst) begin
        if (rst)
            state <= S0;
        else
            state <= next_state;
    end

    always @(*) begin
        next_state = state;
        detected = 1'b0;
        case (state)
            S0: begin
                if (in)
                    next_state = S1;
            end
            S1: begin
                if (!in)
                    next_state = S2;
            end
            S2: begin
                if (in)
                    next_state = S3;
                else
                    next_state = S0;
            end
            S3: begin
                if (in)
                    next_state = S4;
                else
                    next_state = S2;
            end
            S4: begin
                detected = 1'b1;
                if (in)
                    next_state = S1;
                else
                    next_state = S2;
            end
        endcase
    end

endmodule

module testbench;
    reg clk, rst, in;
    wire detected;

    fsm dut (
        .clk(clk),
        .rst(rst),
        .in(in),
        .detected(detected)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 1'b0;
        rst = 1'b1;
        in = 1'b0;

        #10 rst = 1'b0;
        #10 in = 1'b1;  // 1
        #10 in = 1'b0;  // 0
        #10 in = 1'b1;  // 1
        #10 in = 1'b1;  // 1
        #10 in = 1'b0;  // 0
        #10 in = 1'b1;  // 1
        #10 in = 1'b1;  // 1
        #10 in = 1'b0;  // 0
        #10 in = 1'b1;  // 1
        #10 in = 1'b1;  // 1
        #10 in = 1'b1;  // 1
        #10 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t clk=%b rst=%b in=%b detected=%b"", 
                 $time, clk, rst, in, detected);
    end
endmodule",True,96,True,True,True,True,0.7,True,7.958706855773926,4.99831748008728,"Design an FSM detecting pattern 1011 in serial input with overlapping detection. Include testbench with sequence: 10110111011.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph LR
    CLK[Clock] --> S0
    RST[Reset] --> S0
    IN[Serial Input] --> S0
    S0((State 0)) -->|1| S1((State 1))
    S0 -->|0| S0
    S1 -->|0| S2((State 2))
    S1 -->|1| S1
    S2 -->|1| S3((State 3))
    S2 -->|0| S0
    S3 -->|1| S4((State 4))
    S3 -->|0| S2
    S4 -->|1| S1
    S4 -->|0| S2
    S4 --> DETECTED[Pattern Detected]
    TB[Testbench Sequence: 10110111011] --> IN
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module fsm_1011_detector(
    input wire clk,
    input wire rst,
    input wire serial_in,
    output reg detected
);

    typedef enum reg [2:0] {
        STATE_0 = 3'b000,
        STATE_1 = 3'b001,
        STATE_2 = 3'b010,
        STATE_3 = 3'b011,
        STATE_4 = 3'b100
    } state_t;

    reg [2:0] current_state, next_state;

    always @(posedge clk or posedge rst) begin
        if (rst)
            current_state <= STATE_0;
        else
            current_state <= next_state;
    end

    always @(*) begin
        case (current_state)
            STATE_0: begin
                if (serial_in)
                    next_state = STATE_1;
                else
                    next_state = STATE_0;
            end
            STATE_1: begin
                if (serial_in)
                    next_state = STATE_1;
                else
                    next_state = STATE_2;
            end
            STATE_2: begin
                if (serial_in)
                    next_state = STATE_3;
                else
                    next_state = STATE_0;
            end
            STATE_3: begin
                if (serial_in)
                    next_state = STATE_4;
                else
                    next_state = STATE_2;
            end
            STATE_4: begin
                if (serial_in)
                    next_state = STATE_1;
                else
                    next_state = STATE_2;
            end
            default: next_state = STATE_0;
        endcase
    end

    always @(posedge clk or posedge rst) begin
        if (rst)
            detected <= 1'b0;
        else if (current_state == STATE_4)
            detected <= 1'b1;
        else
            detected <= 1'b0;
    end

endmodule

module testbench;
    reg clk, rst, serial_in;
    wire detected;

    fsm_1011_detector dut (
        .clk(clk),
        .rst(rst),
        .serial_in(serial_in),
        .detected(detected)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 1'b0;
        rst = 1'b1;
        serial_in = 1'b0;

        #10 rst = 1'b0;
        #10 serial_in = 1'b1;  // 1
        #10 serial_in = 1'b0;  // 0
        #10 serial_in = 1'b1;  // 1
        #10 serial_in = 1'b1;  // 1
        #10 serial_in = 1'b0;  // 0
        #10 serial_in = 1'b1;  // 1
        #10 serial_in = 1'b1;  // 1
        #10 serial_in = 1'b1;  // 1
        #10 serial_in = 1'b0;  // 0
        #10 serial_in = 1'b1;  // 1
        #10 serial_in = 1'b1;  // 1
        #10 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t clk=%b rst=%b serial_in=%b detected=%b"", 
                 $time, clk, rst, serial_in, detected);
    end
endmodule",True,114,True,True,True,True,0.7,True,5.247312784194946,9.302243947982788,prompt_only,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,Sequential,medium,"Create a 4-bit PISO shift register with clock, reset, load, parallel input[3:0], and serial output. Include testbench.",claude,"`timescale 1ns/1ps

module piso_shift_reg (
    input wire clk,
    input wire rst_n,
    input wire load,
    input wire [3:0] parallel_in,
    output reg serial_out
);

reg [3:0] shift_reg;

always @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
        shift_reg <= 4'b0000;
        serial_out <= 1'b0;
    end
    else begin
        if (load)
            shift_reg <= parallel_in;
        else begin
            serial_out <= shift_reg[3];
            shift_reg <= {shift_reg[2:0], 1'b0};
        end
    end
end

endmodule

module testbench;
    reg clk, rst_n, load;
    reg [3:0] parallel_in;
    wire serial_out;

    piso_shift_reg dut (
        .clk(clk),
        .rst_n(rst_n),
        .load(load),
        .parallel_in(parallel_in),
        .serial_out(serial_out)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 0;
        rst_n = 0;
        load = 0;
        parallel_in = 4'b0000;

        #10 rst_n = 1;
        #10 parallel_in = 4'b1101;
        #10 load = 1;
        #10 load = 0;
        
        #80 parallel_in = 4'b1010;
        #10 load = 1;
        #10 load = 0;
        
        #80 rst_n = 0;
        #20 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t rst_n=%b load=%b parallel_in=%b serial_out=%b"",
                 $time, rst_n, load, parallel_in, serial_out);
    end
endmodule",True,71,True,True,True,True,0.7,True,6.354241609573364,8.442069292068481,"graph LR
    CLK[Clock] --> REG[[4-bit Register]]
    RST[Reset] --> REG
    LD[Load] --> MUX
    PIN0[ParIn0] --> MUX0{MUX0}
    PIN1[ParIn1] --> MUX1{MUX1}
    PIN2[ParIn2] --> MUX2{MUX2}
    PIN3[ParIn3] --> MUX3{MUX3}
    MUX0 --> REG
    MUX1 --> REG
    MUX2 --> REG
    MUX3 --> REG
    REG --> FF0[[FF0]]
    REG --> FF1[[FF1]]
    REG --> FF2[[FF2]]
    REG --> FF3[[FF3]]
    FF0 --> MUX1
    FF1 --> MUX2
    FF2 --> MUX3
    FF3 --> SOUT[Serial Out]
    CLK --> FF0
    CLK --> FF1
    CLK --> FF2
    CLK --> FF3
    RST --> FF0
    RST --> FF1
    RST --> FF2
    RST --> FF3
    LD --> FF0
    LD --> FF1
    LD --> FF2
    LD --> FF3","`timescale 1ns/1ps

module shift_reg_with_mux(
    input wire clk,
    input wire rst,
    input wire ld,
    input wire [3:0] par_in,
    output wire ser_out
);

reg [3:0] shift_reg;
wire [3:0] mux_out;

assign mux_out[0] = ld ? par_in[0] : 1'b0;
assign mux_out[1] = ld ? par_in[1] : shift_reg[0];
assign mux_out[2] = ld ? par_in[2] : shift_reg[1];
assign mux_out[3] = ld ? par_in[3] : shift_reg[2];
assign ser_out = shift_reg[3];

always @(posedge clk or posedge rst) begin
    if (rst)
        shift_reg <= 4'b0000;
    else
        shift_reg <= mux_out;
end

endmodule

module testbench;
    reg clk, rst, ld;
    reg [3:0] par_in;
    wire ser_out;
    
    shift_reg_with_mux dut (
        .clk(clk),
        .rst(rst),
        .ld(ld),
        .par_in(par_in),
        .ser_out(ser_out)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 0;
        rst = 1;
        ld = 0;
        par_in = 4'b0000;
        
        #10 rst = 0;
        #10 ld = 1;
        par_in = 4'b1010;
        #10 ld = 0;
        #40 ld = 1;
        par_in = 4'b0101;
        #10 ld = 0;
        #40 rst = 1;
        #10 rst = 0;
        #20 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t rst=%b ld=%b par_in=%b ser_out=%b shift_reg=%b"",
                 $time, rst, ld, par_in, ser_out, dut.shift_reg);
    end
endmodule",True,69,True,True,True,False,0.4,False,12.11063003540039,8.0445396900177,"Create a 4-bit PISO shift register with clock, reset, load, parallel input[3:0], and serial output. Include testbench.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph LR
    CLK[Clock] --> REG[[4-bit Register]]
    RST[Reset] --> REG
    LD[Load] --> MUX
    PIN0[ParIn0] --> MUX0{MUX0}
    PIN1[ParIn1] --> MUX1{MUX1}
    PIN2[ParIn2] --> MUX2{MUX2}
    PIN3[ParIn3] --> MUX3{MUX3}
    MUX0 --> REG
    MUX1 --> REG
    MUX2 --> REG
    MUX3 --> REG
    REG --> FF0[[FF0]]
    REG --> FF1[[FF1]]
    REG --> FF2[[FF2]]
    REG --> FF3[[FF3]]
    FF0 --> MUX1
    FF1 --> MUX2
    FF2 --> MUX3
    FF3 --> SOUT[Serial Out]
    CLK --> FF0
    CLK --> FF1
    CLK --> FF2
    CLK --> FF3
    RST --> FF0
    RST --> FF1
    RST --> FF2
    RST --> FF3
    LD --> FF0
    LD --> FF1
    LD --> FF2
    LD --> FF3
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module piso_register (
    input wire clk,
    input wire rst,
    input wire ld,
    input wire [3:0] par_in,
    output wire ser_out
);

reg [3:0] shift_reg;

always @(posedge clk or posedge rst) begin
    if (rst)
        shift_reg <= 4'b0000;
    else if (ld)
        shift_reg <= par_in;
    else
        shift_reg <= {shift_reg[2:0], 1'b0};
end

assign ser_out = shift_reg[3];

endmodule

module testbench;
    reg clk, rst, ld;
    reg [3:0] par_in;
    wire ser_out;
    
    piso_register dut (
        .clk(clk),
        .rst(rst),
        .ld(ld),
        .par_in(par_in),
        .ser_out(ser_out)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 0;
        rst = 1;
        ld = 0;
        par_in = 4'b0000;
        
        #10 rst = 0;
        
        #10 par_in = 4'b1010;
        ld = 1;
        #10 ld = 0;
        
        #40 par_in = 4'b1111;
        ld = 1;
        #10 ld = 0;
        
        #40 rst = 1;
        #10 rst = 0;
        
        #40 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t rst=%b ld=%b par_in=%b ser_out=%b shift_reg=%b"", 
                 $time, rst, ld, par_in, ser_out, dut.shift_reg);
    end
endmodule",True,70,True,True,True,False,0.4,False,6.610615253448486,8.424191951751709,tie,mermaid_only > combined > prompt_only,prompt_only > mermaid_only > combined
combined,Sequential,medium,"Create a 4-bit PISO shift register with clock, reset, load, parallel input[3:0], and serial output. Include testbench.",gpt-4o,"`timescale 1ns/1ps

module piso_shift_register(
    input wire clk,
    input wire rst_n,
    input wire load,
    input wire [3:0] parallel_in,
    output reg serial_out
);

    reg [3:0] shift_reg;

    always @(posedge clk or negedge rst_n) begin
        if (!rst_n)
            shift_reg <= 4'b0000;
        else if (load)
            shift_reg <= parallel_in;
        else
            shift_reg <= {shift_reg[2:0], 1'b0};
    end

    always @(*) begin
        serial_out = shift_reg[3];
    end

endmodule

module testbench;
    reg clk, rst_n, load;
    reg [3:0] parallel_in;
    wire serial_out;
    
    piso_shift_register dut (
        .clk(clk),
        .rst_n(rst_n),
        .load(load),
        .parallel_in(parallel_in),
        .serial_out(serial_out)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 1'b0;
        rst_n = 1'b0;
        load = 1'b0;
        parallel_in = 4'b0000;

        #20 rst_n = 1'b1;
        #10 load = 1'b1; parallel_in = 4'b1010;
        #10 load = 1'b0;
        #100 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b load=%b parallel_in=%b serial_out=%b"", 
                 $time, clk, rst_n, load, parallel_in, serial_out);
    end
endmodule",True,62,True,True,True,True,0.7,True,2.6396474838256836,7.952713489532471,"graph LR
    CLK[Clock] --> SR[[4-bit PISO Shift Register]]
    RST[Reset] --> SR
    LOAD[Load] --> SR
    PI[Parallel Input[3:0]] --> SR
    SR --> SO[Serial Output]
    
    subgraph Testbench
        TBCLK[Clock] --> TB
        TBRST[Reset] --> TB
        TBLOAD[Load] --> TB
        TBPI[Parallel Input[3:0]] --> TB
        TB --> SR
        SR --> TBSO[Serial Output]
    end","`timescale 1ns/1ps

module piso_shift_register(
    input wire clk,
    input wire rst,
    input wire load,
    input wire [3:0] parallel_in,
    output reg serial_out
);

reg [3:0] shift_reg;

always @(posedge clk or posedge rst) begin
    if (rst)
        shift_reg <= 4'b0000;
    else if (load)
        shift_reg <= parallel_in;
    else
        shift_reg <= {shift_reg[2:0], 1'b0};
end

always @(posedge clk or posedge rst) begin
    if (rst)
        serial_out <= 1'b0;
    else
        serial_out <= shift_reg[3];
end

endmodule

module testbench;
    reg tb_clk, tb_rst, tb_load;
    reg [3:0] tb_parallel_in;
    wire tb_serial_out;

    piso_shift_register dut (
        .clk(tb_clk),
        .rst(tb_rst),
        .load(tb_load),
        .parallel_in(tb_parallel_in),
        .serial_out(tb_serial_out)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        tb_clk = 1'b0;
        tb_rst = 1'b1;
        tb_load = 1'b0;
        tb_parallel_in = 4'b0000;

        #10 tb_rst = 1'b0;
        #10 tb_load = 1'b1; tb_parallel_in = 4'b1010;
        #10 tb_load = 1'b0;
        #40 $finish;
    end

    always #5 tb_clk = ~tb_clk;

    initial begin
        $monitor(""Time=%0t tb_clk=%b tb_rst=%b tb_load=%b tb_parallel_in=%b tb_serial_out=%b"", 
                 $time, tb_clk, tb_rst, tb_load, tb_parallel_in, tb_serial_out);
    end
endmodule",True,65,True,True,True,False,0.3,False,5.334481477737427,8.665626049041748,"Create a 4-bit PISO shift register with clock, reset, load, parallel input[3:0], and serial output. Include testbench.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph LR
    CLK[Clock] --> SR[[4-bit PISO Shift Register]]
    RST[Reset] --> SR
    LOAD[Load] --> SR
    PI[Parallel Input[3:0]] --> SR
    SR --> SO[Serial Output]
    
    subgraph Testbench
        TBCLK[Clock] --> TB
        TBRST[Reset] --> TB
        TBLOAD[Load] --> TB
        TBPI[Parallel Input[3:0]] --> TB
        TB --> SR
        SR --> TBSO[Serial Output]
    end
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module piso_shift_register(
    input wire clk,
    input wire rst,
    input wire load,
    input wire [3:0] parallel_in,
    output reg serial_out
);

reg [3:0] shift_reg;

always @(posedge clk or posedge rst) begin
    if (rst)
        shift_reg <= 4'b0000;
    else if (load)
        shift_reg <= parallel_in;
    else
        shift_reg <= {shift_reg[2:0], 1'b0};
end

always @(posedge clk or posedge rst) begin
    if (rst)
        serial_out <= 1'b0;
    else
        serial_out <= shift_reg[3];
end

endmodule

module testbench;
    reg clk, rst, load;
    reg [3:0] parallel_in;
    wire serial_out;

    piso_shift_register dut (
        .clk(clk),
        .rst(rst),
        .load(load),
        .parallel_in(parallel_in),
        .serial_out(serial_out)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 1'b0;
        rst = 1'b1;
        load = 1'b0;
        parallel_in = 4'b0000;

        #10 rst = 1'b0;
        #10 load = 1'b1; parallel_in = 4'b1010;
        #10 load = 1'b0;
        #100 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t clk=%b rst=%b load=%b parallel_in=%b serial_out=%b"", 
                 $time, clk, rst, load, parallel_in, serial_out);
    end
endmodule",True,65,True,True,True,True,0.7,True,3.629122734069824,13.076668977737427,mermaid_only,mermaid_only > prompt_only > combined,prompt_only > mermaid_only > combined
combined,Combinational,medium,"Design a 4-to-2 priority encoder with input in[3:0], output out[1:0], and valid bit. Highest bit has priority. Include testbench.",claude,"`timescale 1ns/1ps

module priority_encoder(
    input wire [3:0] in,
    output reg [1:0] out,
    output reg valid
);

always @(*) begin
    if (in[3]) begin
        out = 2'b11;
        valid = 1'b1;
    end
    else if (in[2]) begin
        out = 2'b10;
        valid = 1'b1;
    end
    else if (in[1]) begin
        out = 2'b01;
        valid = 1'b1;
    end
    else if (in[0]) begin
        out = 2'b00;
        valid = 1'b1;
    end
    else begin
        out = 2'b00;
        valid = 1'b0;
    end
end

endmodule

module testbench;
    reg [3:0] in;
    wire [1:0] out;
    wire valid;

    priority_encoder dut (
        .in(in),
        .out(out),
        .valid(valid)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        in = 4'b0000;
        #10 in = 4'b0001;
        #10 in = 4'b0010;
        #10 in = 4'b0100;
        #10 in = 4'b1000;
        #10 in = 4'b1100;
        #10 in = 4'b0110;
        #10 in = 4'b0011;
        #10 in = 4'b0000;
        #10 $finish;
    end

    initial begin
        $monitor(""Time=%0t in=%b out=%b valid=%b"", 
                 $time, in, out, valid);
    end
endmodule",True,65,True,True,True,False,0.4,False,5.607434988021851,6.893653392791748,"graph LR
    IN[in[3:0]] --> PE((Priority_Encoder))
    subgraph Priority_Encoder_Block
        PE --> LOGIC{Priority Logic}
        LOGIC -->|if in[3]=1| OUT3[out=3]
        LOGIC -->|if in[2]=1| OUT2[out=2]
        LOGIC -->|if in[1]=1| OUT1[out=1]
        LOGIC -->|if in[0]=1| OUT0[out=0]
        OUT3 --> ENC((Encoder))
        OUT2 --> ENC
        OUT1 --> ENC
        OUT0 --> ENC
    end
    PE --> VALID[valid]
    ENC --> OUTPUT[out[1:0]]
    subgraph Testbench
        TB[[Test Vectors]] --> IN
        TB --> VERIFY{Verification}
        OUTPUT --> VERIFY
        VALID --> VERIFY
    end","`timescale 1ns/1ps

module priority_encoder(
    input wire clk,
    input wire rst_n,
    input wire [3:0] in,
    output reg [1:0] out,
    output reg valid
);

always @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
        out <= 2'b00;
        valid <= 1'b0;
    end
    else begin
        valid <= |in;
        if (in[3])
            out <= 2'b11;
        else if (in[2])
            out <= 2'b10;
        else if (in[1])
            out <= 2'b01;
        else if (in[0])
            out <= 2'b00;
        else
            out <= 2'b00;
    end
end

endmodule

module testbench;
    reg clk;
    reg rst_n;
    reg [3:0] in;
    wire [1:0] out;
    wire valid;

    priority_encoder dut (
        .clk(clk),
        .rst_n(rst_n),
        .in(in),
        .out(out),
        .valid(valid)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 0;
        rst_n = 0;
        in = 4'b0000;

        #10 rst_n = 1;
        
        #10 in = 4'b0001;
        #10 in = 4'b0010;
        #10 in = 4'b0100;
        #10 in = 4'b1000;
        #10 in = 4'b1100;
        #10 in = 4'b0011;
        #10 in = 4'b1111;
        #10 in = 4'b0000;

        #10 rst_n = 0;
        #10 rst_n = 1;
        
        #10 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t rst_n=%b in=%b out=%b valid=%b"",
                 $time, rst_n, in, out, valid);
    end
endmodule",True,79,True,True,True,True,0.8,True,11.275482654571533,8.106388807296753,"Design a 4-to-2 priority encoder with input in[3:0], output out[1:0], and valid bit. Highest bit has priority. Include testbench.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph LR
    IN[in[3:0]] --> PE((Priority_Encoder))
    subgraph Priority_Encoder_Block
        PE --> LOGIC{Priority Logic}
        LOGIC -->|if in[3]=1| OUT3[out=3]
        LOGIC -->|if in[2]=1| OUT2[out=2]
        LOGIC -->|if in[1]=1| OUT1[out=1]
        LOGIC -->|if in[0]=1| OUT0[out=0]
        OUT3 --> ENC((Encoder))
        OUT2 --> ENC
        OUT1 --> ENC
        OUT0 --> ENC
    end
    PE --> VALID[valid]
    ENC --> OUTPUT[out[1:0]]
    subgraph Testbench
        TB[[Test Vectors]] --> IN
        TB --> VERIFY{Verification}
        OUTPUT --> VERIFY
        VALID --> VERIFY
    end
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module priority_encoder(
    input wire [3:0] in,
    output reg [1:0] out,
    output reg valid
);

always @(*) begin
    valid = |in;
    if (in[3])
        out = 2'd3;
    else if (in[2])
        out = 2'd2;
    else if (in[1])
        out = 2'd1;
    else if (in[0])
        out = 2'd0;
    else
        out = 2'd0;
end

endmodule

module testbench;
    reg [3:0] in;
    wire [1:0] out;
    wire valid;

    priority_encoder dut (
        .in(in),
        .out(out),
        .valid(valid)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        // Test vectors
        in = 4'b0000; #10;
        in = 4'b0001; #10;
        in = 4'b0010; #10;
        in = 4'b0011; #10;
        in = 4'b0100; #10;
        in = 4'b0101; #10;
        in = 4'b1000; #10;
        in = 4'b1100; #10;
        in = 4'b1111; #10;
        
        $finish;
    end

    initial begin
        $monitor(""Time=%0t in=%b out=%b valid=%b"", 
                 $time, in, out, valid);
    end
endmodule",True,58,True,True,True,False,0.4,False,5.118994474411011,7.884775400161743,tie,prompt_only > combined > mermaid_only,prompt_only > mermaid_only > combined
combined,Combinational,medium,"Design a 4-to-2 priority encoder with input in[3:0], output out[1:0], and valid bit. Highest bit has priority. Include testbench.",gpt-4o,"`timescale 1ns/1ps

module priority_encoder(
    input wire [3:0] in,
    output reg [1:0] out,
    output reg valid
);

always @(*) begin
    valid = 1'b0;
    out = 2'b00;
    if (in[3]) begin
        out = 2'b11;
        valid = 1'b1;
    end else if (in[2]) begin
        out = 2'b10;
        valid = 1'b1;
    end else if (in[1]) begin
        out = 2'b01;
        valid = 1'b1;
    end else if (in[0]) begin
        out = 2'b00;
        valid = 1'b1;
    end 
end

endmodule

module testbench;
    reg [3:0] in;
    wire [1:0] out;
    wire valid;

    priority_encoder dut (
        .in(in),
        .out(out),
        .valid(valid)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        in = 4'b0000;
        #10 in = 4'b0001;
        #10 in = 4'b0010;
        #10 in = 4'b0100;
        #10 in = 4'b1000;
        #10 in = 4'b1100;
        #10 in = 4'b1010;
        #10 in = 4'b0110;
        #10 in = 4'b1111;
        #10 $finish;
    end

    initial begin
        $monitor(""Time=%0t in=%b out=%b valid=%b"", 
                 $time, in, out, valid);
    end
endmodule",True,60,True,True,True,False,0.4,False,6.258361101150513,10.007318019866943,"graph TD
    CLK[Clock] --> ENC(4-to-2 Priority Encoder)
    RST[Reset] --> ENC
    IN[in[3:0]] --> ENC
    ENC --> OUT[out[1:0]]
    ENC --> VALID[Valid Bit]
    
    subgraph Testbench
        TBCLK[Testbench Clock] --> TBENC
        TBRST[Testbench Reset] --> TBENC
        TBIN[Testbench in[3:0]] --> TBENC
        TBENC(Testbench Encoder) --> TBOUT[Testbench out[1:0]]
        TBENC --> TBVALID[Testbench Valid Bit]
    end","`timescale 1ns/1ps

module priority_encoder(
    input wire clk,
    input wire rst,
    input wire [3:0] in,
    output reg [1:0] out,
    output reg valid
);

always @(posedge clk or posedge rst) begin
    if (rst) begin
        out <= 2'b00;
        valid <= 1'b0;
    end else begin
        casez (in)
            4'b1???: begin out <= 2'b11; valid <= 1'b1; end
            4'b01??: begin out <= 2'b10; valid <= 1'b1; end
            4'b001?: begin out <= 2'b01; valid <= 1'b1; end
            4'b0001: begin out <= 2'b00; valid <= 1'b1; end
            default: begin out <= 2'b00; valid <= 1'b0; end
        endcase
    end
end

endmodule

module testbench;
    reg tbclk, tbrst;
    reg [3:0] tbin;
    wire [1:0] tbout;
    wire tbvalid;

    priority_encoder tbenc (
        .clk(tbclk),
        .rst(tbrst),
        .in(tbin),
        .out(tbout),
        .valid(tbvalid)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        tbclk = 1'b0;
        tbrst = 1'b1;
        tbin = 4'b0000;

        #10 tbrst = 1'b0;
        #10 tbin = 4'b0001;
        #10 tbin = 4'b0010;
        #10 tbin = 4'b1000;
        #10 tbin = 4'b0100;
        #10 tbrst = 1'b1;
        #10 tbrst = 1'b0;
        #50 $finish;
    end

    always #5 tbclk = ~tbclk;

    initial begin
        $monitor(""Time=%0t tbclk=%b tbrst=%b tbin=%b tbout=%b tbvalid=%b"",
                 $time, tbclk, tbrst, tbin, tbout, tbvalid);
    end
endmodule",True,66,True,True,True,True,0.7,True,7.386637926101685,10.191749334335327,"Design a 4-to-2 priority encoder with input in[3:0], output out[1:0], and valid bit. Highest bit has priority. Include testbench.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph TD
    CLK[Clock] --> ENC(4-to-2 Priority Encoder)
    RST[Reset] --> ENC
    IN[in[3:0]] --> ENC
    ENC --> OUT[out[1:0]]
    ENC --> VALID[Valid Bit]
    
    subgraph Testbench
        TBCLK[Testbench Clock] --> TBENC
        TBRST[Testbench Reset] --> TBENC
        TBIN[Testbench in[3:0]] --> TBENC
        TBENC(Testbench Encoder) --> TBOUT[Testbench out[1:0]]
        TBENC --> TBVALID[Testbench Valid Bit]
    end
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module priority_encoder_4to2(
    input wire clk,
    input wire rst_n,
    input wire [3:0] in,
    output reg [1:0] out,
    output reg valid
);

always @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
        out <= 2'b00;
        valid <= 1'b0;
    end else begin
        case (1'b1)
            in[3]: begin
                out <= 2'b11;
                valid <= 1'b1;
            end
            in[2]: begin
                out <= 2'b10;
                valid <= 1'b1;
            end
            in[1]: begin
                out <= 2'b01;
                valid <= 1'b1;
            end
            in[0]: begin
                out <= 2'b00;
                valid <= 1'b1;
            end
            default: begin
                out <= 2'b00;
                valid <= 1'b0;
            end
        endcase
    end
end

endmodule

module testbench;
    reg tb_clk, tb_rst_n;
    reg [3:0] tb_in;
    wire [1:0] tb_out;
    wire tb_valid;

    priority_encoder_4to2 dut (
        .clk(tb_clk),
        .rst_n(tb_rst_n),
        .in(tb_in),
        .out(tb_out),
        .valid(tb_valid)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        tb_clk = 1'b0;
        tb_rst_n = 1'b0;
        tb_in = 4'b0000;

        #20 tb_rst_n = 1'b1;
        #10 tb_in = 4'b1000;
        #10 tb_in = 4'b0100;
        #10 tb_in = 4'b0010;
        #10 tb_in = 4'b0001;
        #10 tb_in = 4'b0000;
        #10 $finish;
    end

    always #5 tb_clk = ~tb_clk;

    initial begin
        $monitor(""Time=%0t tb_clk=%b tb_rst_n=%b tb_in=%b tb_out=%b tb_valid=%b"",
                 $time, tb_clk, tb_rst_n, tb_in, tb_out, tb_valid);
    end
endmodule",True,80,True,True,True,True,0.7,True,3.2939860820770264,11.273618221282959,prompt_only,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,State Machine,complex,"Design a traffic light FSM with 4 states: NS_GREEN, NS_YELLOW, EW_GREEN, EW_YELLOW. Inputs: clk, rst, emergency. Outputs: ns_light[1:0], ew_light[1:0]. Timing: GREEN=8 cycles, YELLOW=2 cycles. Emergency makes both RED. Include testbench.",claude,"`timescale 1ns/1ps

module traffic_light(
    input wire clk,
    input wire rst,
    input wire emergency,
    output reg [1:0] ns_light,
    output reg [1:0] ew_light
);

parameter [1:0] RED = 2'b00;
parameter [1:0] YELLOW = 2'b01;
parameter [1:0] GREEN = 2'b10;

parameter [1:0] NS_GREEN = 2'b00;
parameter [1:0] NS_YELLOW = 2'b01;
parameter [1:0] EW_GREEN = 2'b10;
parameter [1:0] EW_YELLOW = 2'b11;

reg [1:0] state;
reg [3:0] timer;

always @(posedge clk or posedge rst) begin
    if (rst) begin
        state <= NS_GREEN;
        timer <= 4'd0;
        ns_light <= GREEN;
        ew_light <= RED;
    end
    else if (emergency) begin
        ns_light <= RED;
        ew_light <= RED;
    end
    else begin
        case (state)
            NS_GREEN: begin
                if (timer >= 4'd7) begin
                    state <= NS_YELLOW;
                    timer <= 4'd0;
                    ns_light <= YELLOW;
                end
                else begin
                    timer <= timer + 1'b1;
                    ns_light <= GREEN;
                    ew_light <= RED;
                end
            end
            
            NS_YELLOW: begin
                if (timer >= 4'd1) begin
                    state <= EW_GREEN;
                    timer <= 4'd0;
                    ns_light <= RED;
                    ew_light <= GREEN;
                end
                else begin
                    timer <= timer + 1'b1;
                end
            end
            
            EW_GREEN: begin
                if (timer >= 4'd7) begin
                    state <= EW_YELLOW;
                    timer <= 4'd0;
                    ew_light <= YELLOW;
                end
                else begin
                    timer <= timer + 1'b1;
                    ns_light <= RED;
                    ew_light <= GREEN;
                end
            end
            
            EW_YELLOW: begin
                if (timer >= 4'd1) begin
                    state <= NS_GREEN;
                    timer <= 4'd0;
                    ns_light <= GREEN;
                    ew_light <= RED;
                end
                else begin
                    timer <= timer + 1'b1;
                end
            end
        endcase
    end
end

endmodule

module testbench;
    reg clk;
    reg rst;
    reg emergency;
    wire [1:0] ns_light;
    wire [1:0] ew_light;
    
    traffic_light dut(
        .clk(clk),
        .rst(rst),
        .emergency(emergency),
        .ns_light(ns_light),
        .ew_light(ew_light)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 0;
        rst = 1;
        emergency = 0;
        
        #10 rst = 0;
        
        // Normal operation
        #100;
        
        // Test emergency
        emergency = 1;
        #20;
        emergency = 0;
        
        // Continue normal operation
        #100;
        
        $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t rst=%b emergency=%b ns_light=%b ew_light=%b"", 
                 $time, rst, emergency, ns_light, ew_light);
    end
endmodule",True,136,True,True,True,True,0.8,True,11.367968082427979,7.3926215171813965,"graph TD
    CLK[Clock] --> FSM[[FSM State Register]]
    RST[Reset] --> FSM
    EMG[Emergency] --> FSM
    
    FSM --> CTR[[Counter]]
    CLK --> CTR
    RST --> CTR
    
    FSM --> DEC(State Decoder)
    CTR --> DEC
    
    DEC --> NS_OUT[ns_light[1:0]]
    DEC --> EW_OUT[ew_light[1:0]]
    
    subgraph States
        S1[NS_GREEN: 8 cycles]
        S2[NS_YELLOW: 2 cycles]
        S3[EW_GREEN: 8 cycles]
        S4[EW_YELLOW: 2 cycles]
    end
    
    subgraph Testbench
        TB_CLK[Test Clock]
        TB_RST[Test Reset]
        TB_EMG[Test Emergency]
        TB_MON[Monitor Outputs]
    end
    
    TB_CLK --> FSM
    TB_RST --> FSM
    TB_EMG --> FSM
    FSM --> TB_MON","`timescale 1ns/1ps

module traffic_light (
    input wire clk,
    input wire rst,
    input wire emg,
    output reg [1:0] ns_light,
    output reg [1:0] ew_light
);

// State definitions
localparam NS_GREEN = 2'b00;
localparam NS_YELLOW = 2'b01;
localparam EW_GREEN = 2'b10;
localparam EW_YELLOW = 2'b11;

// Light color definitions
localparam GREEN = 2'b01;
localparam YELLOW = 2'b10;
localparam RED = 2'b11;

reg [1:0] state, next_state;
reg [3:0] counter;

// State register
always @(posedge clk or posedge rst) begin
    if (rst)
        state <= NS_GREEN;
    else
        state <= next_state;
end

// Counter
always @(posedge clk or posedge rst) begin
    if (rst)
        counter <= 4'd0;
    else if (state != next_state)
        counter <= 4'd0;
    else
        counter <= counter + 1'b1;
end

// Next state logic
always @(*) begin
    case (state)
        NS_GREEN: next_state = (counter >= 4'd7 || emg) ? NS_YELLOW : NS_GREEN;
        NS_YELLOW: next_state = (counter >= 4'd1) ? EW_GREEN : NS_YELLOW;
        EW_GREEN: next_state = (counter >= 4'd7 || emg) ? EW_YELLOW : EW_GREEN;
        EW_YELLOW: next_state = (counter >= 4'd1) ? NS_GREEN : EW_YELLOW;
        default: next_state = NS_GREEN;
    endcase
end

// Output logic
always @(*) begin
    case (state)
        NS_GREEN: begin
            ns_light = GREEN;
            ew_light = RED;
        end
        NS_YELLOW: begin
            ns_light = YELLOW;
            ew_light = RED;
        end
        EW_GREEN: begin
            ns_light = RED;
            ew_light = GREEN;
        end
        EW_YELLOW: begin
            ns_light = RED;
            ew_light = YELLOW;
        end
        default: begin
            ns_light = RED;
            ew_light = RED;
        end
    endcase
end

endmodule

module testbench;
    reg clk, rst, emg;
    wire [1:0] ns_light, ew_light;
    
    traffic_light dut (
        .clk(clk),
        .rst(rst),
        .emg(emg),
        .ns_light(ns_light),
        .ew_light(ew_light)
    );
    
    initial begin
        $dumpfile(""traffic.vcd"");
        $dumpvars(0, testbench);
        
        clk = 0;
        rst = 1;
        emg = 0;
        
        #20 rst = 0;
        #200 emg = 1;
        #20 emg = 0;
        #100 rst = 1;
        #20 rst = 0;
        #100 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t rst=%b emg=%b ns_light=%b ew_light=%b"", 
                 $time, rst, emg, ns_light, ew_light);
    end
endmodule",True,116,True,True,True,True,0.8,True,15.081360340118408,6.64475679397583,"Design a traffic light FSM with 4 states: NS_GREEN, NS_YELLOW, EW_GREEN, EW_YELLOW. Inputs: clk, rst, emergency. Outputs: ns_light[1:0], ew_light[1:0]. Timing: GREEN=8 cycles, YELLOW=2 cycles. Emergency makes both RED. Include testbench.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph TD
    CLK[Clock] --> FSM[[FSM State Register]]
    RST[Reset] --> FSM
    EMG[Emergency] --> FSM
    
    FSM --> CTR[[Counter]]
    CLK --> CTR
    RST --> CTR
    
    FSM --> DEC(State Decoder)
    CTR --> DEC
    
    DEC --> NS_OUT[ns_light[1:0]]
    DEC --> EW_OUT[ew_light[1:0]]
    
    subgraph States
        S1[NS_GREEN: 8 cycles]
        S2[NS_YELLOW: 2 cycles]
        S3[EW_GREEN: 8 cycles]
        S4[EW_YELLOW: 2 cycles]
    end
    
    subgraph Testbench
        TB_CLK[Test Clock]
        TB_RST[Test Reset]
        TB_EMG[Test Emergency]
        TB_MON[Monitor Outputs]
    end
    
    TB_CLK --> FSM
    TB_RST --> FSM
    TB_EMG --> FSM
    FSM --> TB_MON
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module traffic_fsm (
    input wire clk,
    input wire rst,
    input wire emergency,
    output reg [1:0] ns_light,
    output reg [1:0] ew_light
);

reg [1:0] state;
reg [3:0] counter;

localparam [1:0]
    NS_GREEN = 2'b00,
    NS_YELLOW = 2'b01,
    EW_GREEN = 2'b10,
    EW_YELLOW = 2'b11;

localparam [1:0]
    RED = 2'b00,
    YELLOW = 2'b01,
    GREEN = 2'b10;

always @(posedge clk or posedge rst) begin
    if (rst) begin
        state <= NS_GREEN;
        counter <= 4'd0;
    end
    else if (emergency) begin
        state <= NS_GREEN;
        counter <= 4'd0;
    end
    else begin
        case (state)
            NS_GREEN: begin
                if (counter >= 4'd7) begin
                    state <= NS_YELLOW;
                    counter <= 4'd0;
                end
                else counter <= counter + 1'b1;
            end
            NS_YELLOW: begin
                if (counter >= 4'd1) begin
                    state <= EW_GREEN;
                    counter <= 4'd0;
                end
                else counter <= counter + 1'b1;
            end
            EW_GREEN: begin
                if (counter >= 4'd7) begin
                    state <= EW_YELLOW;
                    counter <= 4'd0;
                end
                else counter <= counter + 1'b1;
            end
            EW_YELLOW: begin
                if (counter >= 4'd1) begin
                    state <= NS_GREEN;
                    counter <= 4'd0;
                end
                else counter <= counter + 1'b1;
            end
        endcase
    end
end

always @(*) begin
    if (emergency) begin
        ns_light = RED;
        ew_light = RED;
    end
    else begin
        case (state)
            NS_GREEN: begin
                ns_light = GREEN;
                ew_light = RED;
            end
            NS_YELLOW: begin
                ns_light = YELLOW;
                ew_light = RED;
            end
            EW_GREEN: begin
                ns_light = RED;
                ew_light = GREEN;
            end
            EW_YELLOW: begin
                ns_light = RED;
                ew_light = YELLOW;
            end
        endcase
    end
end

endmodule

module testbench;
    reg clk, rst, emergency;
    wire [1:0] ns_light, ew_light;
    
    traffic_fsm dut (
        .clk(clk),
        .rst(rst),
        .emergency(emergency),
        .ns_light(ns_light),
        .ew_light(ew_light)
    );
    
    initial begin
        $dumpfile(""traffic.vcd"");
        $dumpvars(0, testbench);
        
        clk = 0;
        rst = 1;
        emergency = 0;
        
        #10 rst = 0;
        
        #160 emergency = 1;
        #20 emergency = 0;
        
        #100 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t rst=%b emergency=%b ns_light=%b ew_light=%b"", 
                 $time, rst, emergency, ns_light, ew_light);
    end
endmodule",True,131,True,True,True,False,0.3,False,10.803525447845459,7.299670457839966,combined,combined > prompt_only > mermaid_only,prompt_only > mermaid_only > combined
combined,State Machine,complex,"Design a traffic light FSM with 4 states: NS_GREEN, NS_YELLOW, EW_GREEN, EW_YELLOW. Inputs: clk, rst, emergency. Outputs: ns_light[1:0], ew_light[1:0]. Timing: GREEN=8 cycles, YELLOW=2 cycles. Emergency makes both RED. Include testbench.",gpt-4o,"`timescale 1ns/1ps

module traffic_light_fsm (
    input wire clk,
    input wire rst,
    input wire emergency,
    output reg [1:0] ns_light,
    output reg [1:0] ew_light
);

    typedef enum reg [1:0] {
        NS_GREEN = 2'b00,
        NS_YELLOW = 2'b01,
        EW_GREEN = 2'b10,
        EW_YELLOW = 2'b11
    } state_t;

    reg [3:0] counter;
    reg [1:0] state, next_state;

    always @(posedge clk or posedge rst) begin
        if (rst) begin
            state <= NS_GREEN;
            counter <= 4'b0000;
        end else begin
            state <= next_state;
            if (state == next_state)
                counter <= counter + 1'b1;
            else
                counter <= 4'b0000;
        end
    end

    always @(*) begin
        if (emergency) begin
            ns_light = 2'b11;  // RED
            ew_light = 2'b11;  // RED
            next_state = state;
        end else begin
            case (state)
                NS_GREEN: begin
                    ns_light = 2'b00;  // GREEN
                    ew_light = 2'b11;  // RED
                    if (counter == 4'd7)
                        next_state = NS_YELLOW;
                    else
                        next_state = NS_GREEN;
                end
                NS_YELLOW: begin
                    ns_light = 2'b01;  // YELLOW
                    ew_light = 2'b11;  // RED
                    if (counter == 4'd1)
                        next_state = EW_GREEN;
                    else
                        next_state = NS_YELLOW;
                end
                EW_GREEN: begin
                    ns_light = 2'b11;  // RED
                    ew_light = 2'b00;  // GREEN
                    if (counter == 4'd7)
                        next_state = EW_YELLOW;
                    else
                        next_state = EW_GREEN;
                end
                EW_YELLOW: begin
                    ns_light = 2'b11;  // RED
                    ew_light = 2'b01;  // YELLOW
                    if (counter == 4'd1)
                        next_state = NS_GREEN;
                    else
                        next_state = EW_YELLOW;
                end
                default: begin
                    ns_light = 2'b11;  // RED
                    ew_light = 2'b11;  // RED
                    next_state = NS_GREEN;
                end
            endcase
        end
    end

endmodule

module testbench;
    reg clk, rst, emergency;
    wire [1:0] ns_light, ew_light;

    traffic_light_fsm dut (
        .clk(clk),
        .rst(rst),
        .emergency(emergency),
        .ns_light(ns_light),
        .ew_light(ew_light)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 1'b0;
        rst = 1'b1;
        emergency = 1'b0;

        #20 rst = 1'b0;
        #100 emergency = 1'b1;
        #20 emergency = 1'b0;
        #100 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t clk=%b rst=%b emergency=%b ns_light=%b ew_light=%b"", 
                 $time, clk, rst, emergency, ns_light, ew_light);
    end
endmodule",True,116,True,True,True,True,0.7,True,8.462130069732666,7.057024002075195,"graph LR
    CLK[clk] --> FSM
    RST[rst] --> FSM
    EMERGENCY[emergency] --> FSM
    FSM(NS_GREEN, NS_YELLOW, EW_GREEN, EW_YELLOW)
    FSM --> NS_LIGHT[ns_light[1:0]]
    FSM --> EW_LIGHT[ew_light[1:0]]
    subgraph TIMING
        GREEN[GREEN=8 cycles]
        YELLOW[YELLOW=2 cycles]
    end
    FSM --> GREEN
    FSM --> YELLOW
    EMERGENCY --> |Emergency makes both RED| FSM
    
    subgraph TESTBENCH
        TB_CLK[clk] --> TB_FSM
        TB_RST[rst] --> TB_FSM
        TB_EMERGENCY[emergency] --> TB_FSM
        TB_FSM(NS_GREEN, NS_YELLOW, EW_GREEN, EW_YELLOW)
        TB_FSM --> TB_NS_LIGHT[ns_light[1:0]]
        TB_FSM --> TB_EW_LIGHT[ew_light[1:0]]
        TB_FSM --> TB_GREEN
        TB_FSM --> TB_YELLOW
        TB_EMERGENCY --> |Emergency makes both RED| TB_FSM
    end","`timescale 1ns/1ps

module fsm(
    input wire clk,
    input wire rst,
    input wire emergency,
    output reg [1:0] ns_light,
    output reg [1:0] ew_light
);

    reg [3:0] state, next_state;
    reg [3:0] timer;

    localparam NS_GREEN = 2'b00,
               NS_YELLOW = 2'b01,
               EW_GREEN = 2'b10,
               EW_YELLOW = 2'b11,
               GREEN_TIME = 4'd8,
               YELLOW_TIME = 4'd2,
               RED = 2'b11;

    always @(posedge clk or posedge rst) begin
        if (rst) begin
            state <= NS_GREEN;
            timer <= 4'd0;
        end else begin
            state <= next_state;
            if (state == next_state)
                timer <= timer + 1'b1;
            else
                timer <= 4'd0;
        end
    end

    always @(*) begin
        ns_light = 2'b00;
        ew_light = 2'b00;
        next_state = state;

        case (state)
            NS_GREEN: begin
                ns_light = NS_GREEN;
                ew_light = RED;
                if (emergency)
                    next_state = RED;
                else if (timer >= GREEN_TIME)
                    next_state = NS_YELLOW;
            end

            NS_YELLOW: begin
                ns_light = NS_YELLOW;
                ew_light = RED;
                if (emergency)
                    next_state = RED;
                else if (timer >= YELLOW_TIME)
                    next_state = EW_GREEN;
            end

            EW_GREEN: begin
                ns_light = RED;
                ew_light = EW_GREEN;
                if (emergency)
                    next_state = RED;
                else if (timer >= GREEN_TIME)
                    next_state = EW_YELLOW;
            end

            EW_YELLOW: begin
                ns_light = RED;
                ew_light = EW_YELLOW;
                if (emergency)
                    next_state = RED;
                else if (timer >= YELLOW_TIME)
                    next_state = NS_GREEN;
            end

            RED: begin
                ns_light = RED;
                ew_light = RED;
                if (!emergency) 
                    next_state = NS_GREEN;
            end
        endcase
    end

endmodule

module testbench;
    reg clk, rst, emergency;
    wire [1:0] ns_light, ew_light;

    fsm dut (
        .clk(clk),
        .rst(rst),
        .emergency(emergency),
        .ns_light(ns_light),
        .ew_light(ew_light)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 1'b0;
        rst = 1'b1;
        emergency = 1'b0;

        #20 rst = 1'b0;
        #200 emergency = 1'b1;
        #20 emergency = 1'b0;
        #200 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t clk=%b rst=%b emergency=%b ns_light=%b ew_light=%b"",
                 $time, clk, rst, emergency, ns_light, ew_light);
    end
endmodule",True,120,True,True,True,True,0.7,True,13.425391674041748,13.771462202072144,"Design a traffic light FSM with 4 states: NS_GREEN, NS_YELLOW, EW_GREEN, EW_YELLOW. Inputs: clk, rst, emergency. Outputs: ns_light[1:0], ew_light[1:0]. Timing: GREEN=8 cycles, YELLOW=2 cycles. Emergency makes both RED. Include testbench.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph LR
    CLK[clk] --> FSM
    RST[rst] --> FSM
    EMERGENCY[emergency] --> FSM
    FSM(NS_GREEN, NS_YELLOW, EW_GREEN, EW_YELLOW)
    FSM --> NS_LIGHT[ns_light[1:0]]
    FSM --> EW_LIGHT[ew_light[1:0]]
    subgraph TIMING
        GREEN[GREEN=8 cycles]
        YELLOW[YELLOW=2 cycles]
    end
    FSM --> GREEN
    FSM --> YELLOW
    EMERGENCY --> |Emergency makes both RED| FSM
    
    subgraph TESTBENCH
        TB_CLK[clk] --> TB_FSM
        TB_RST[rst] --> TB_FSM
        TB_EMERGENCY[emergency] --> TB_FSM
        TB_FSM(NS_GREEN, NS_YELLOW, EW_GREEN, EW_YELLOW)
        TB_FSM --> TB_NS_LIGHT[ns_light[1:0]]
        TB_FSM --> TB_EW_LIGHT[ew_light[1:0]]
        TB_FSM --> TB_GREEN
        TB_FSM --> TB_YELLOW
        TB_EMERGENCY --> |Emergency makes both RED| TB_FSM
    end
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module traffic_light_fsm(
    input wire clk,
    input wire rst,
    input wire emergency,
    output reg [1:0] ns_light,
    output reg [1:0] ew_light
);

    typedef enum reg [1:0] {
        NS_GREEN = 2'b00,
        NS_YELLOW = 2'b01,
        EW_GREEN = 2'b10,
        EW_YELLOW = 2'b11
    } state_t;

    reg [3:0] timer;
    reg state_t state, next_state;

    always @(posedge clk or posedge rst) begin
        if (rst) begin
            state <= NS_GREEN;
            timer <= 4'd0;
        end else if (emergency) begin
            state <= NS_GREEN;
            timer <= 4'd0;
        end else begin
            state <= next_state;
            timer <= (timer == 4'd9) ? 4'd0 : timer + 1'b1;
        end
    end

    always @(*) begin
        case (state)
            NS_GREEN: begin
                ns_light = 2'b01;
                ew_light = 2'b00;
                if (emergency)
                    next_state = NS_GREEN;
                else if (timer == 4'd8)
                    next_state = NS_YELLOW;
                else
                    next_state = NS_GREEN;
            end
            NS_YELLOW: begin
                ns_light = 2'b10;
                ew_light = 2'b00;
                if (emergency)
                    next_state = NS_GREEN;
                else if (timer == 4'd2)
                    next_state = EW_GREEN;
                else
                    next_state = NS_YELLOW;
            end
            EW_GREEN: begin
                ns_light = 2'b00;
                ew_light = 2'b01;
                if (emergency)
                    next_state = NS_GREEN;
                else if (timer == 4'd8)
                    next_state = EW_YELLOW;
                else
                    next_state = EW_GREEN;
            end
            EW_YELLOW: begin
                ns_light = 2'b00;
                ew_light = 2'b10;
                if (emergency)
                    next_state = NS_GREEN;
                else if (timer == 4'd2)
                    next_state = NS_GREEN;
                else
                    next_state = EW_YELLOW;
            end
            default: begin
                ns_light = 2'b00;
                ew_light = 2'b00;
                next_state = NS_GREEN;
            end
        endcase
    end

endmodule

module testbench;
    reg clk, rst, emergency;
    wire [1:0] ns_light, ew_light;
    
    traffic_light_fsm dut (
        .clk(clk),
        .rst(rst),
        .emergency(emergency),
        .ns_light(ns_light),
        .ew_light(ew_light)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst = 1'b1;
        emergency = 1'b0;
        
        #20 rst = 1'b0;
        #100 emergency = 1'b1;
        #20 emergency = 1'b0;
        #200 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t clk=%b rst=%b emergency=%b ns_light=%b ew_light=%b"", 
                 $time, clk, rst, emergency, ns_light, ew_light);
    end
endmodule",True,118,True,True,True,False,0.3,False,8.266637325286865,8.350205421447754,combined,combined > prompt_only > mermaid_only,prompt_only > mermaid_only > combined
combined,State Machine,complex,"Design UART transmitter with states: IDLE, START, DATA, STOP. Protocol: START(0), 8 data bits LSB-first, STOP(1). Baud rate divider. Include testbench.",claude,"`timescale 1ns/1ps

module uart_tx(
    input wire clk,
    input wire rst_n,
    input wire tx_start,
    input wire [7:0] tx_data,
    output reg tx_done,
    output reg tx_line
);

parameter IDLE = 2'b00;
parameter START = 2'b01;
parameter DATA = 2'b10;
parameter STOP = 2'b11;

reg [1:0] state;
reg [2:0] bit_count;
reg [7:0] shift_reg;

always @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
        state <= IDLE;
        bit_count <= 3'b000;
        tx_done <= 1'b0;
        tx_line <= 1'b1;
        shift_reg <= 8'b0;
    end
    else begin
        case (state)
            IDLE: begin
                tx_line <= 1'b1;
                tx_done <= 1'b0;
                if (tx_start) begin
                    state <= START;
                    shift_reg <= tx_data;
                end
            end
            
            START: begin
                tx_line <= 1'b0;
                state <= DATA;
                bit_count <= 3'b000;
            end
            
            DATA: begin
                tx_line <= shift_reg[0];
                shift_reg <= {1'b0, shift_reg[7:1]};
                if (bit_count == 3'b111) begin
                    state <= STOP;
                end
                else begin
                    bit_count <= bit_count + 1'b1;
                end
            end
            
            STOP: begin
                tx_line <= 1'b1;
                tx_done <= 1'b1;
                state <= IDLE;
            end
            
            default: state <= IDLE;
        endcase
    end
end

endmodule

module testbench;
    reg clk;
    reg rst_n;
    reg tx_start;
    reg [7:0] tx_data;
    wire tx_done;
    wire tx_line;
    
    uart_tx dut (
        .clk(clk),
        .rst_n(rst_n),
        .tx_start(tx_start),
        .tx_data(tx_data),
        .tx_done(tx_done),
        .tx_line(tx_line)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 0;
        rst_n = 0;
        tx_start = 0;
        tx_data = 0;
        
        #20 rst_n = 1;
        #20 tx_data = 8'b10110101;
        #10 tx_start = 1;
        #10 tx_start = 0;
        
        #200 tx_data = 8'b11001100;
        #10 tx_start = 1;
        #10 tx_start = 0;
        
        #200 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t tx_line=%b tx_done=%b"", $time, tx_line, tx_done);
    end
endmodule",True,113,True,True,True,False,0.3,False,10.128362655639648,6.903784513473511,"graph LR
    CLK[Clock] --> UART_TX[UART TX Core]
    RST[Reset] --> UART_TX
    TX_START[TX Start] --> UART_TX
    TX_DATA[8-bit Data In] --> UART_TX
    BAUD_DIV[Baud Rate Divider] --> UART_TX

    UART_TX --> FSM((FSM Controller))
    FSM --> |State|STATES{IDLE START DATA STOP}
    STATES --> |Next State|FSM
    
    UART_TX --> SHIFT[[8-bit Shift Register]]
    FSM --> |Control|SHIFT
    TX_DATA --> SHIFT
    
    UART_TX --> CNT((Bit Counter))
    FSM --> |Control|CNT
    
    SHIFT --> MUX{Output MUX}
    FSM --> |Select|MUX
    MUX --> TX_OUT[TX Output]
    
    TB[Testbench] --> |Stimulus|TX_START
    TB --> |Test Data|TX_DATA
    TX_OUT --> |Monitor|TB","`timescale 1ns/1ps

module uart_tx (
    input wire clk,
    input wire rst,
    input wire tx_start,
    input wire [7:0] tx_data,
    input wire [15:0] baud_div,
    output reg tx_out
);

// FSM states
localparam IDLE = 2'b00;
localparam START = 2'b01;
localparam DATA = 2'b10;
localparam STOP = 2'b11;

reg [1:0] state, next_state;
reg [7:0] shift_reg;
reg [2:0] bit_count;
reg [15:0] baud_count;

// FSM state register
always @(posedge clk or posedge rst) begin
    if (rst)
        state <= IDLE;
    else
        state <= next_state;
end

// Next state logic
always @(*) begin
    case (state)
        IDLE: next_state = tx_start ? START : IDLE;
        START: next_state = (baud_count == baud_div) ? DATA : START;
        DATA: next_state = (baud_count == baud_div && bit_count == 3'b111) ? STOP : DATA;
        STOP: next_state = (baud_count == baud_div) ? IDLE : STOP;
        default: next_state = IDLE;
    endcase
end

// Shift register
always @(posedge clk or posedge rst) begin
    if (rst) begin
        shift_reg <= 8'h00;
        bit_count <= 3'b000;
        baud_count <= 16'h0000;
    end
    else begin
        case (state)
            IDLE: begin
                if (tx_start)
                    shift_reg <= tx_data;
                baud_count <= 16'h0000;
                bit_count <= 3'b000;
            end
            
            START: begin
                if (baud_count == baud_div)
                    baud_count <= 16'h0000;
                else
                    baud_count <= baud_count + 1'b1;
            end
            
            DATA: begin
                if (baud_count == baud_div) begin
                    shift_reg <= {1'b0, shift_reg[7:1]};
                    bit_count <= bit_count + 1'b1;
                    baud_count <= 16'h0000;
                end
                else
                    baud_count <= baud_count + 1'b1;
            end
            
            STOP: begin
                if (baud_count == baud_div)
                    baud_count <= 16'h0000;
                else
                    baud_count <= baud_count + 1'b1;
            end
        endcase
    end
end

// Output MUX
always @(*) begin
    case (state)
        IDLE: tx_out = 1'b1;
        START: tx_out = 1'b0;
        DATA: tx_out = shift_reg[0];
        STOP: tx_out = 1'b1;
        default: tx_out = 1'b1;
    endcase
end

endmodule

module testbench;
    reg clk, rst, tx_start;
    reg [7:0] tx_data;
    reg [15:0] baud_div;
    wire tx_out;
    
    uart_tx dut (
        .clk(clk),
        .rst(rst),
        .tx_start(tx_start),
        .tx_data(tx_data),
        .baud_div(baud_div),
        .tx_out(tx_out)
    );
    
    initial begin
        $dumpfile(""uart_tx.vcd"");
        $dumpvars(0, testbench);
        
        clk = 0;
        rst = 1;
        tx_start = 0;
        tx_data = 8'h00;
        baud_div = 16'd4; // Fast baud rate for simulation
        
        #20 rst = 0;
        
        // Send first byte
        #20 tx_data = 8'h55;
        #10 tx_start = 1;
        #10 tx_start = 0;
        
        // Wait for transmission
        #200;
        
        // Send second byte
        tx_data = 8'hAA;
        tx_start = 1;
        #10 tx_start = 0;
        
        #200 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t rst=%b tx_start=%b tx_data=%h tx_out=%b"",
                 $time, rst, tx_start, tx_data, tx_out);
    end
endmodule",True,147,True,True,True,False,0.3,False,19.35869550704956,8.095539093017578,"Design UART transmitter with states: IDLE, START, DATA, STOP. Protocol: START(0), 8 data bits LSB-first, STOP(1). Baud rate divider. Include testbench.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph LR
    CLK[Clock] --> UART_TX[UART TX Core]
    RST[Reset] --> UART_TX
    TX_START[TX Start] --> UART_TX
    TX_DATA[8-bit Data In] --> UART_TX
    BAUD_DIV[Baud Rate Divider] --> UART_TX

    UART_TX --> FSM((FSM Controller))
    FSM --> |State|STATES{IDLE START DATA STOP}
    STATES --> |Next State|FSM
    
    UART_TX --> SHIFT[[8-bit Shift Register]]
    FSM --> |Control|SHIFT
    TX_DATA --> SHIFT
    
    UART_TX --> CNT((Bit Counter))
    FSM --> |Control|CNT
    
    SHIFT --> MUX{Output MUX}
    FSM --> |Select|MUX
    MUX --> TX_OUT[TX Output]
    
    TB[Testbench] --> |Stimulus|TX_START
    TB --> |Test Data|TX_DATA
    TX_OUT --> |Monitor|TB
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module uart_tx(
    input wire clk,
    input wire rst,
    input wire tx_start,
    input wire [7:0] tx_data,
    input wire [15:0] baud_div,
    output reg tx_out
);

reg [1:0] state;
reg [1:0] next_state;
reg [7:0] shift_reg;
reg [3:0] bit_count;
reg [15:0] baud_counter;

localparam IDLE = 2'b00;
localparam START = 2'b01;
localparam DATA = 2'b10;
localparam STOP = 2'b11;

always @(posedge clk or posedge rst) begin
    if (rst) begin
        state <= IDLE;
        shift_reg <= 8'h00;
        bit_count <= 4'h0;
        baud_counter <= 16'h0000;
        tx_out <= 1'b1;
    end
    else begin
        state <= next_state;
        
        case (state)
            IDLE: begin
                tx_out <= 1'b1;
                if (tx_start) begin
                    shift_reg <= tx_data;
                    baud_counter <= 16'h0000;
                end
            end
            
            START: begin
                tx_out <= 1'b0;
                if (baud_counter == baud_div) begin
                    baud_counter <= 16'h0000;
                end
                else begin
                    baud_counter <= baud_counter + 1'b1;
                end
            end
            
            DATA: begin
                tx_out <= shift_reg[0];
                if (baud_counter == baud_div) begin
                    baud_counter <= 16'h0000;
                    shift_reg <= {1'b0, shift_reg[7:1]};
                    bit_count <= bit_count + 1'b1;
                end
                else begin
                    baud_counter <= baud_counter + 1'b1;
                end
            end
            
            STOP: begin
                tx_out <= 1'b1;
                if (baud_counter == baud_div) begin
                    baud_counter <= 16'h0000;
                end
                else begin
                    baud_counter <= baud_counter + 1'b1;
                end
            end
        endcase
    end
end

always @(*) begin
    case (state)
        IDLE: next_state = tx_start ? START : IDLE;
        START: next_state = (baud_counter == baud_div) ? DATA : START;
        DATA: next_state = (baud_counter == baud_div && bit_count == 4'h8) ? STOP : DATA;
        STOP: next_state = (baud_counter == baud_div) ? IDLE : STOP;
        default: next_state = IDLE;
    endcase
end

endmodule

module testbench;
    reg clk;
    reg rst;
    reg tx_start;
    reg [7:0] tx_data;
    reg [15:0] baud_div;
    wire tx_out;
    
    uart_tx dut(
        .clk(clk),
        .rst(rst),
        .tx_start(tx_start),
        .tx_data(tx_data),
        .baud_div(baud_div),
        .tx_out(tx_out)
    );
    
    initial begin
        $dumpfile(""uart_tx.vcd"");
        $dumpvars(0, testbench);
        
        clk = 0;
        rst = 1;
        tx_start = 0;
        tx_data = 8'h00;
        baud_div = 16'd8; // Fast baud rate for simulation
        
        #20 rst = 0;
        
        // Test transmission
        #20;
        tx_data = 8'h55;
        tx_start = 1;
        #10;
        tx_start = 0;
        
        // Wait for transmission to complete
        #500;
        
        // Another transmission
        tx_data = 8'hAA;
        tx_start = 1;
        #10;
        tx_start = 0;
        
        #500 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t rst=%b tx_start=%b tx_data=%h tx_out=%b"",
                 $time, rst, tx_start, tx_data, tx_out);
    end
endmodule",True,144,True,True,True,False,0.3,False,13.657239198684692,8.14949655532837,tie,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,State Machine,complex,"Design UART transmitter with states: IDLE, START, DATA, STOP. Protocol: START(0), 8 data bits LSB-first, STOP(1). Baud rate divider. Include testbench.",gpt-4o,"`timescale 1ns/1ps

module uart_tx(
    input wire clk,
    input wire rst_n,
    input wire tx_start,
    input wire [7:0] tx_data,
    output reg tx,
    output reg tx_busy
);

    reg [3:0] bit_counter;
    reg [7:0] shift_reg;
    reg [2:0] state;
    reg [15:0] baud_counter;

    localparam IDLE  = 3'b000;
    localparam START = 3'b001;
    localparam DATA  = 3'b010;
    localparam STOP  = 3'b011;

    localparam BAUD_DIV = 16'd5208; // Adjustable for specific baud rate

    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            state <= IDLE;
            tx <= 1'b1;
            tx_busy <= 1'b0;
            bit_counter <= 4'b0000;
            shift_reg <= 8'b00000000;
            baud_counter <= 16'b0;
        end else begin
            case (state)
                IDLE: begin
                    tx <= 1'b1;
                    tx_busy <= 1'b0;
                    baud_counter <= 16'b0;
                    if (tx_start) begin
                        shift_reg <= tx_data;
                        state <= START;
                        tx_busy <= 1'b1;
                    end
                end
                START: begin
                    if (baud_counter >= BAUD_DIV) begin
                        baud_counter <= 16'b0;
                        tx <= 1'b0;
                        state <= DATA;
                        bit_counter <= 4'b0000;
                    end else begin
                        baud_counter <= baud_counter + 1'b1;
                    end
                end
                DATA: begin
                    if (baud_counter >= BAUD_DIV) begin
                        baud_counter <= 16'b0;
                        tx <= shift_reg[0];
                        shift_reg <= shift_reg >> 1;
                        if (bit_counter < 4'd7) begin
                            bit_counter <= bit_counter + 1'b1;
                        end else begin
                            state <= STOP;
                        end
                    end else begin
                        baud_counter <= baud_counter + 1'b1;
                    end
                end
                STOP: begin
                    if (baud_counter >= BAUD_DIV) begin
                        baud_counter <= 16'b0;
                        tx <= 1'b1;
                        state <= IDLE;
                        tx_busy <= 1'b0;
                    end else begin
                        baud_counter <= baud_counter + 1'b1;
                    end
                end
            endcase
        end
    end

endmodule

module testbench;
    reg clk, rst_n, tx_start;
    reg [7:0] tx_data;
    wire tx, tx_busy;

    uart_tx dut (
        .clk(clk),
        .rst_n(rst_n),
        .tx_start(tx_start),
        .tx_data(tx_data),
        .tx(tx),
        .tx_busy(tx_busy)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 1'b0;
        rst_n = 1'b0;
        tx_start = 1'b0;
        tx_data = 8'b0;

        #20 rst_n = 1'b1;
        #10 tx_data = 8'b10101010; tx_start = 1'b1;
        #10 tx_start = 1'b0;
        #1000 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b tx_start=%b tx_data=%b tx=%b tx_busy=%b"",
                 $time, clk, rst_n, tx_start, tx_data, tx, tx_busy);
    end
endmodule",True,119,True,True,True,True,0.9,True,11.274046659469604,14.831506729125977,"graph TD
    CLK[Clock] --> BAUD[Baud Rate Divider]
    RST[Reset] --> FSM
    RST --> SHIFTR
    
    IN[Input Data] --> SHIFTR[Shift Register]
    FSM --> SHIFTR
    
    BAUD --> FSM[Finite State Machine]
    SHIFTR --> FSM
    FSM --> OUT[Serial Output]
    
    subgraph UART_Transmitter
        IDLE_IDLE -- ""Idle State"" --> START{Check Start}
        START -- ""Start Bit"" --> DATA[Data Bits]
        DATA -- ""8 Bits LSB first"" --> STOP{Check Stop}
        STOP -- ""Stop Bit"" --> IDLE_IDLE
    end
    
    subgraph Testbench
        TB_CLK[TB Clock] --> UART_Transmitter
        TB_RST[TB Reset] --> UART_Transmitter
        TB_IN[TB Input Data] --> UART_Transmitter
    end","`timescale 1ns/1ps

module uart_transmitter(
    input wire clk,
    input wire rst,
    input wire [7:0] in_data,
    output reg serial_out
);

    reg [3:0] baud_counter;
    reg [3:0] bit_counter;
    reg [7:0] shift_reg;
    reg fsm_state;
    
    parameter IDLE = 1'b0, TRANSMIT = 1'b1;
    
    always @(posedge clk or posedge rst) begin
        if (rst) begin
            baud_counter <= 4'd0;
            bit_counter <= 4'd0;
            shift_reg <= 8'b0;
            fsm_state <= IDLE;
            serial_out <= 1'b1;
        end else begin
            case (fsm_state)
                IDLE: begin
                    if (in_data != 8'b0) begin
                        shift_reg <= in_data;
                        fsm_state <= TRANSMIT;
                        serial_out <= 1'b0;  // Start bit
                    end
                end
                TRANSMIT: begin
                    baud_counter <= baud_counter + 1'b1;
                    if (baud_counter == 4'd15) begin
                        baud_counter <= 4'd0;
                        if (bit_counter < 4'd8) begin
                            serial_out <= shift_reg[0];
                            shift_reg <= shift_reg >> 1;
                            bit_counter <= bit_counter + 1'b1;
                        end else begin
                            serial_out <= 1'b1;  // Stop bit
                            fsm_state <= IDLE;
                            bit_counter <= 4'd0;
                        end
                    end
                end
            endcase
        end
    end

endmodule

module testbench;
    reg tb_clk;
    reg tb_rst;
    reg [7:0] tb_in_data;
    wire tb_serial_out;

    uart_transmitter dut (
        .clk(tb_clk),
        .rst(tb_rst),
        .in_data(tb_in_data),
        .serial_out(tb_serial_out)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        tb_clk = 1'b0;
        tb_rst = 1'b1;
        tb_in_data = 8'b0;

        #20 tb_rst = 1'b0;
        #10 tb_in_data = 8'hA5;
        #200 tb_in_data = 8'h0;
        #50 $finish;
    end

    always #5 tb_clk = ~tb_clk;

    initial begin
        $monitor(""Time=%0t tb_clk=%b tb_rst=%b tb_in_data=%b tb_serial_out=%b"", 
                 $time, tb_clk, tb_rst, tb_in_data, tb_serial_out);
    end
endmodule",True,87,True,True,True,True,0.7,True,13.925791263580322,13.39273715019226,"Design UART transmitter with states: IDLE, START, DATA, STOP. Protocol: START(0), 8 data bits LSB-first, STOP(1). Baud rate divider. Include testbench.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph TD
    CLK[Clock] --> BAUD[Baud Rate Divider]
    RST[Reset] --> FSM
    RST --> SHIFTR
    
    IN[Input Data] --> SHIFTR[Shift Register]
    FSM --> SHIFTR
    
    BAUD --> FSM[Finite State Machine]
    SHIFTR --> FSM
    FSM --> OUT[Serial Output]
    
    subgraph UART_Transmitter
        IDLE_IDLE -- ""Idle State"" --> START{Check Start}
        START -- ""Start Bit"" --> DATA[Data Bits]
        DATA -- ""8 Bits LSB first"" --> STOP{Check Stop}
        STOP -- ""Stop Bit"" --> IDLE_IDLE
    end
    
    subgraph Testbench
        TB_CLK[TB Clock] --> UART_Transmitter
        TB_RST[TB Reset] --> UART_Transmitter
        TB_IN[TB Input Data] --> UART_Transmitter
    end
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module uart_transmitter(
    input wire clk,
    input wire rst,
    input wire [7:0] data_in,
    output reg serial_out
);

    reg [3:0] baud_counter;
    reg [3:0] state;
    reg [7:0] shift_reg;
    reg [3:0] bit_index;
    wire baud_tick;

    parameter IDLE = 4'b0000;
    parameter START = 4'b0001;
    parameter DATA = 4'b0010;
    parameter STOP = 4'b0011;

    // Baud rate divider
    always @(posedge clk or posedge rst) begin
        if (rst)
            baud_counter <= 4'b0000;
        else
            baud_counter <= baud_counter + 1'b1;
    end

    assign baud_tick = (baud_counter == 4'b1111);

    // FSM for UART Transmitter
    always @(posedge clk or posedge rst) begin
        if (rst) begin
            state <= IDLE;
            shift_reg <= 8'b0;
            bit_index <= 4'b0000;
            serial_out <= 1'b1;
        end else if (baud_tick) begin
            case (state)
                IDLE: begin
                    serial_out <= 1'b1;
                    if (data_in[0] == 1'b0) begin // Detect start bit
                        state <= START;
                        shift_reg <= data_in;
                        bit_index <= 4'b0000;
                    end
                end
                START: begin
                    serial_out <= 1'b0;
                    state <= DATA;
                end
                DATA: begin
                    serial_out <= shift_reg[bit_index];
                    bit_index <= bit_index + 1'b1;
                    if (bit_index == 4'b1000)
                        state <= STOP;
                end
                STOP: begin
                    serial_out <= 1'b1;
                    state <= IDLE;
                end
                default: state <= IDLE;
            endcase
        end
    end

endmodule

module testbench;
    reg tb_clk, tb_rst;
    reg [7:0] tb_data_in;
    wire tb_serial_out;

    uart_transmitter uut (
        .clk(tb_clk),
        .rst(tb_rst),
        .data_in(tb_data_in),
        .serial_out(tb_serial_out)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        tb_clk = 1'b0;
        tb_rst = 1'b1;
        tb_data_in = 8'hAA;

        #10 tb_rst = 1'b0;
        #500 $finish;
    end

    always #5 tb_clk = ~tb_clk;

    initial begin
        $monitor(""Time=%0t tb_clk=%b tb_rst=%b tb_data_in=%h tb_serial_out=%b"", 
                 $time, tb_clk, tb_rst, tb_data_in, tb_serial_out);
    end
endmodule",True,99,True,True,True,True,0.7,True,21.40615677833557,7.0212085247039795,prompt_only,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,CPU Component,complex,Create 8-register × 8-bit register file with dual read ports and single write port. Include testbench with simultaneous operations.,claude,"`timescale 1ns/1ps

module register_file (
    input wire clk,
    input wire rst_n,
    input wire write_enable,
    input wire [2:0] write_addr,
    input wire [2:0] read_addr1,
    input wire [2:0] read_addr2,
    input wire [7:0] write_data,
    output wire [7:0] read_data1,
    output wire [7:0] read_data2
);

reg [7:0] registers [0:7];
integer i;

always @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
        for (i = 0; i < 8; i = i + 1)
            registers[i] <= 8'h00;
    end
    else if (write_enable)
        registers[write_addr] <= write_data;
end

assign read_data1 = registers[read_addr1];
assign read_data2 = registers[read_addr2];

endmodule

module testbench;
    reg clk;
    reg rst_n;
    reg write_enable;
    reg [2:0] write_addr;
    reg [2:0] read_addr1;
    reg [2:0] read_addr2;
    reg [7:0] write_data;
    wire [7:0] read_data1;
    wire [7:0] read_data2;

    register_file dut (
        .clk(clk),
        .rst_n(rst_n),
        .write_enable(write_enable),
        .write_addr(write_addr),
        .read_addr1(read_addr1),
        .read_addr2(read_addr2),
        .write_data(write_data),
        .read_data1(read_data1),
        .read_data2(read_data2)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 0;
        rst_n = 0;
        write_enable = 0;
        write_addr = 0;
        read_addr1 = 0;
        read_addr2 = 0;
        write_data = 0;

        #10 rst_n = 1;

        // Write some data
        #10;
        write_enable = 1;
        write_addr = 3'd0;
        write_data = 8'hA5;
        #10;
        write_addr = 3'd1;
        write_data = 8'hB4;
        #10;
        write_addr = 3'd2;
        write_data = 8'hC3;

        // Read while writing
        #10;
        read_addr1 = 3'd0;
        read_addr2 = 3'd1;
        write_addr = 3'd3;
        write_data = 8'hD2;

        // Multiple reads
        #10;
        write_enable = 0;
        read_addr1 = 3'd2;
        read_addr2 = 3'd3;

        #20;
        $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t rd1=%h rd2=%h"", $time, read_data1, read_data2);
    end
endmodule",True,103,True,True,True,False,0.4,False,9.955008506774902,8.164864301681519,"graph TD
    CLK[Clock] --> RF[[8x8 Register File]]
    RST[Reset] --> RF
    WEN[Write Enable] --> RF
    WADDR[Write Address 3:0] --> RF
    WDATA[Write Data 7:0] --> RF
    RADDR1[Read Address1 3:0] --> RF
    RADDR2[Read Address2 3:0] --> RF
    RF --> RDATA1[Read Data1 7:0]
    RF --> RDATA2[Read Data2 7:0]
    
    TB_CLK[TB Clock] --> TB([Testbench])
    TB_RST[TB Reset] --> TB
    TB --> TB_WEN[TB Write Enable]
    TB --> TB_WADDR[TB Write Address]
    TB --> TB_WDATA[TB Write Data]
    TB --> TB_RADDR1[TB Read Address1]
    TB --> TB_RADDR2[TB Read Address2]
    TB_RDATA1[TB Read Data1] --> TB
    TB_RDATA2[TB Read Data2] --> TB
    TB --> VERIFY{Verification}
    VERIFY --> PASS[Test Pass]
    VERIFY --> FAIL[Test Fail]","`timescale 1ns/1ps

module register_file (
    input wire clk,
    input wire rst,
    input wire wen,
    input wire [2:0] waddr,
    input wire [7:0] wdata,
    input wire [2:0] raddr1,
    input wire [2:0] raddr2,
    output reg [7:0] rdata1,
    output reg [7:0] rdata2
);

reg [7:0] registers [0:7];
integer i;

always @(posedge clk or posedge rst) begin
    if (rst) begin
        for (i = 1'b0; i < 8; i = i + 1) begin
            registers[i] <= 8'h00;
        end
    end else begin
        if (wen) begin
            registers[waddr] <= wdata;
        end
        rdata1 <= registers[raddr1];
        rdata2 <= registers[raddr2];
    end
end

endmodule

module testbench;
    reg clk;
    reg rst;
    reg wen;
    reg [2:0] waddr;
    reg [7:0] wdata;
    reg [2:0] raddr1;
    reg [2:0] raddr2;
    wire [7:0] rdata1;
    wire [7:0] rdata2;

    register_file dut (
        .clk(clk),
        .rst(rst),
        .wen(wen),
        .waddr(waddr),
        .wdata(wdata),
        .raddr1(raddr1),
        .raddr2(raddr2),
        .rdata1(rdata1),
        .rdata2(rdata2)
    );

    initial begin
        $dumpfile(""register_file.vcd"");
        $dumpvars(0, testbench);

        clk = 1'b0;
        rst = 1'b1;
        wen = 1'b0;
        waddr = 1'b0;
        wdata = 1'b0;
        raddr1 = 1'b0;
        raddr2 = 1'b0;

        #10 rst = 1'b0;

        // Write test
        #10 wen = 1'b1;
        waddr = 3'd2;
        wdata = 8'hAA;
        
        #10 waddr = 3'd5;
        wdata = 8'h55;

        // Read test
        #10 wen = 1'b0;
        raddr1 = 3'd2;
        raddr2 = 3'd5;

        #20;
        if (rdata1 === 8'hAA && rdata2 === 8'h55)
            $display(""Test PASSED"");
        else
            $display(""Test FAILED"");

        #10 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t rst=%b wen=%b waddr=%h wdata=%h raddr1=%h raddr2=%h rdata1=%h rdata2=%h"",
                 $time, rst, wen, waddr, wdata, raddr1, raddr2, rdata1, rdata2);
    end

endmodule",True,100,True,True,True,True,0.75,True,13.51632022857666,8.885701179504395,"Create 8-register × 8-bit register file with dual read ports and single write port. Include testbench with simultaneous operations.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph TD
    CLK[Clock] --> RF[[8x8 Register File]]
    RST[Reset] --> RF
    WEN[Write Enable] --> RF
    WADDR[Write Address 3:0] --> RF
    WDATA[Write Data 7:0] --> RF
    RADDR1[Read Address1 3:0] --> RF
    RADDR2[Read Address2 3:0] --> RF
    RF --> RDATA1[Read Data1 7:0]
    RF --> RDATA2[Read Data2 7:0]
    
    TB_CLK[TB Clock] --> TB([Testbench])
    TB_RST[TB Reset] --> TB
    TB --> TB_WEN[TB Write Enable]
    TB --> TB_WADDR[TB Write Address]
    TB --> TB_WDATA[TB Write Data]
    TB --> TB_RADDR1[TB Read Address1]
    TB --> TB_RADDR2[TB Read Address2]
    TB_RDATA1[TB Read Data1] --> TB
    TB_RDATA2[TB Read Data2] --> TB
    TB --> VERIFY{Verification}
    VERIFY --> PASS[Test Pass]
    VERIFY --> FAIL[Test Fail]
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module reg_file (
    input wire clk,
    input wire rst,
    input wire wen,
    input wire [2:0] waddr,
    input wire [7:0] wdata,
    input wire [2:0] raddr1,
    input wire [2:0] raddr2,
    output wire [7:0] rdata1,
    output wire [7:0] rdata2
);

reg [7:0] registers [0:7];
integer i;

assign rdata1 = registers[raddr1];
assign rdata2 = registers[raddr2];

always @(posedge clk or posedge rst) begin
    if (rst) begin
        for (i = 0; i < 8; i = i + 1)
            registers[i] <= 8'h00;
    end
    else if (wen) begin
        registers[waddr] <= wdata;
    end
end

endmodule

module testbench;
    reg clk, rst, wen;
    reg [2:0] waddr, raddr1, raddr2;
    reg [7:0] wdata;
    wire [7:0] rdata1, rdata2;
    
    reg_file dut (
        .clk(clk),
        .rst(rst),
        .wen(wen),
        .waddr(waddr),
        .wdata(wdata),
        .raddr1(raddr1),
        .raddr2(raddr2),
        .rdata1(rdata1),
        .rdata2(rdata2)
    );
    
    initial begin
        $dumpfile(""reg_file.vcd"");
        $dumpvars(0, testbench);
        
        clk = 0;
        rst = 1;
        wen = 0;
        waddr = 0;
        raddr1 = 0;
        raddr2 = 0;
        wdata = 0;
        
        #10 rst = 0;
        
        // Write test pattern
        #10 wen = 1;
        #10 waddr = 3'h0; wdata = 8'hA5;
        #10 waddr = 3'h1; wdata = 8'h5A;
        #10 waddr = 3'h2; wdata = 8'hF0;
        
        // Read test
        #10 wen = 0;
        #10 raddr1 = 3'h0; raddr2 = 3'h1;
        #10 raddr1 = 3'h1; raddr2 = 3'h2;
        
        // Verify
        if (rdata1 === 8'h5A && rdata2 === 8'hF0)
            $display(""TEST PASSED"");
        else
            $display(""TEST FAILED"");
            
        #10 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t rst=%b wen=%b waddr=%h wdata=%h raddr1=%h rdata1=%h raddr2=%h rdata2=%h"",
                 $time, rst, wen, waddr, wdata, raddr1, rdata1, raddr2, rdata2);
    end
endmodule",True,91,True,True,True,False,0.4,False,10.25463604927063,9.298839092254639,tie,prompt_only > combined > mermaid_only,prompt_only > mermaid_only > combined
combined,CPU Component,complex,Create 8-register × 8-bit register file with dual read ports and single write port. Include testbench with simultaneous operations.,gpt-4o,"`timescale 1ns/1ps

module reg_file(
    input wire clk,
    input wire rst_n,
    input wire [2:0] read_addr1,
    input wire [2:0] read_addr2,
    input wire [2:0] write_addr,
    input wire [7:0] write_data,
    input wire write_enable,
    output reg [7:0] read_data1,
    output reg [7:0] read_data2
);

    reg [7:0] registers [7:0];
    integer i;

    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            for (i = 1'b0; i < 8; i = i + 1) begin
                registers[i] <= 8'b0;
            end
        end else if (write_enable) begin
            registers[write_addr] <= write_data;
        end
    end

    always @(*) begin
        read_data1 = registers[read_addr1];
        read_data2 = registers[read_addr2];
    end

endmodule

module testbench;
    reg clk, rst_n, write_enable;
    reg [2:0] read_addr1, read_addr2, write_addr;
    reg [7:0] write_data;
    wire [7:0] read_data1, read_data2;
    
    reg_file dut (
        .clk(clk),
        .rst_n(rst_n),
        .read_addr1(read_addr1),
        .read_addr2(read_addr2),
        .write_addr(write_addr),
        .write_data(write_data),
        .write_enable(write_enable),
        .read_data1(read_data1),
        .read_data2(read_data2)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst_n = 1'b0;
        write_enable = 1'b0;
        read_addr1 = 3'b000;
        read_addr2 = 3'b001;
        write_addr = 3'b000;
        write_data = 8'b00000000;
        
        #20 rst_n = 1'b1;
        
        // Write to register 0
        #10 write_enable = 1'b1; write_addr = 3'b000; write_data = 8'b10101010;
        #10 write_enable = 1'b0;
        
        // Write to register 1
        #10 write_enable = 1'b1; write_addr = 3'b001; write_data = 8'b11001100;
        #10 write_enable = 1'b0;
        
        // Read from register 0 and 1 simultaneously
        #10 read_addr1 = 3'b000; read_addr2 = 3'b001;
        
        #50 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b write_enable=%b write_addr=%b write_data=%b read_addr1=%b read_data1=%b read_addr2=%b read_data2=%b"", 
                 $time, clk, rst_n, write_enable, write_addr, write_data, read_addr1, read_data1, read_addr2, read_data2);
    end
endmodule",True,87,True,True,True,True,0.75,True,8.76484489440918,10.944539308547974,"graph TD
    CLK[Clock] --> WRITE[Write Control]
    RST[Reset] --> RF[[8x8 Register File]]
    WEN[Write Enable] --> WRITE
    DIN[8-bit Write Data] --> WRITE
    WADDR[3-bit Write Address] --> WRITE
    WRITE --> RF
    RF --> DOUT1[8-bit Read Data 1]
    RADDR1[3-bit Read Address 1] --> RF
    RF --> DOUT2[8-bit Read Data 2]
    RADDR2[3-bit Read Address 2] --> RF
    TSTBENCH(Testbench) --> CLK
    TSTBENCH --> RST
    TSTBENCH --> WEN
    TSTBENCH --> DIN
    TSTBENCH --> WADDR
    TSTBENCH --> RADDR1
    TSTBENCH --> RADDR2","`timescale 1ns/1ps

module register_file_8x8(
    input wire clk,
    input wire rst_n,
    input wire write_enable,
    input wire [7:0] write_data,
    input wire [2:0] write_address,
    input wire [2:0] read_address1,
    input wire [2:0] read_address2,
    output reg [7:0] read_data1,
    output reg [7:0] read_data2
);

    reg [7:0] register_file [0:7];

    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            register_file[0] <= 8'b0;
            register_file[1] <= 8'b0;
            register_file[2] <= 8'b0;
            register_file[3] <= 8'b0;
            register_file[4] <= 8'b0;
            register_file[5] <= 8'b0;
            register_file[6] <= 8'b0;
            register_file[7] <= 8'b0;
        end else if (write_enable) begin
            register_file[write_address] <= write_data;
        end
    end

    always @(posedge clk) begin
        read_data1 <= register_file[read_address1];
        read_data2 <= register_file[read_address2];
    end

endmodule

module testbench;
    reg clk, rst_n, write_enable;
    reg [7:0] write_data;
    reg [2:0] write_address, read_address1, read_address2;
    wire [7:0] read_data1, read_data2;

    register_file_8x8 rf (
        .clk(clk),
        .rst_n(rst_n),
        .write_enable(write_enable),
        .write_data(write_data),
        .write_address(write_address),
        .read_address1(read_address1),
        .read_address2(read_address2),
        .read_data1(read_data1),
        .read_data2(read_data2)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 1'b0;
        rst_n = 1'b0;
        write_enable = 1'b0;
        write_data = 8'b0;
        write_address = 3'b0;
        read_address1 = 3'b0;
        read_address2 = 3'b0;

        #20 rst_n = 1'b1;
        #10 write_enable = 1'b1; write_data = 8'hAA; write_address = 3'b001;
        #10 write_enable = 1'b0; read_address1 = 3'b001; read_address2 = 3'b001;
        #50 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b write_enable=%b write_address=%b write_data=%h read_address1=%b read_data1=%h read_address2=%b read_data2=%h"", 
                 $time, clk, rst_n, write_enable, write_address, write_data, read_address1, read_data1, read_address2, read_data2);
    end
endmodule",True,81,True,True,True,True,0.7,True,10.600568294525146,8.555060386657715,"Create 8-register × 8-bit register file with dual read ports and single write port. Include testbench with simultaneous operations.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph TD
    CLK[Clock] --> WRITE[Write Control]
    RST[Reset] --> RF[[8x8 Register File]]
    WEN[Write Enable] --> WRITE
    DIN[8-bit Write Data] --> WRITE
    WADDR[3-bit Write Address] --> WRITE
    WRITE --> RF
    RF --> DOUT1[8-bit Read Data 1]
    RADDR1[3-bit Read Address 1] --> RF
    RF --> DOUT2[8-bit Read Data 2]
    RADDR2[3-bit Read Address 2] --> RF
    TSTBENCH(Testbench) --> CLK
    TSTBENCH --> RST
    TSTBENCH --> WEN
    TSTBENCH --> DIN
    TSTBENCH --> WADDR
    TSTBENCH --> RADDR1
    TSTBENCH --> RADDR2
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module register_file (
    input wire clk,
    input wire rst,
    input wire wen,
    input wire [7:0] din,
    input wire [2:0] waddr,
    input wire [2:0] raddr1,
    input wire [2:0] raddr2,
    output reg [7:0] dout1,
    output reg [7:0] dout2
);

    reg [7:0] regfile [7:0];
    
    always @(posedge clk or posedge rst) begin
        if (rst) begin
            integer i;
            for (i = 1'b0; i < 8; i = i + 1) begin
                regfile[i] <= 8'b0;
            end
        end else if (wen) begin
            regfile[waddr] <= din;
        end
    end
    
    always @(*) begin
        dout1 = regfile[raddr1];
        dout2 = regfile[raddr2];
    end

endmodule

module testbench;
    reg clk;
    reg rst;
    reg wen;
    reg [7:0] din;
    reg [2:0] waddr;
    reg [2:0] raddr1;
    reg [2:0] raddr2;
    wire [7:0] dout1;
    wire [7:0] dout2;
    
    register_file uut (
        .clk(clk),
        .rst(rst),
        .wen(wen),
        .din(din),
        .waddr(waddr),
        .raddr1(raddr1),
        .raddr2(raddr2),
        .dout1(dout1),
        .dout2(dout2)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst = 1'b0;
        wen = 1'b0;
        din = 8'b0;
        waddr = 3'b0;
        raddr1 = 3'b0;
        raddr2 = 3'b0;
        
        #5 rst = 1'b1;
        #10 rst = 1'b0;
        
        // Write some data into register 3
        #10 wen = 1'b1; din = 8'hAA; waddr = 3'b011;
        #10 wen = 1'b0;
        
        // Read data from register 3
        #10 raddr1 = 3'b011;
        
        // Write different data into register 5
        #10 wen = 1'b1; din = 8'h55; waddr = 3'b101;
        #10 wen = 1'b0;
        
        // Read data from register 5
        #10 raddr2 = 3'b101;
        
        #50 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t clk=%b rst=%b wen=%b din=%h waddr=%d raddr1=%d raddr2=%d dout1=%h dout2=%h"", 
                 $time, clk, rst, wen, din, waddr, raddr1, raddr2, dout1, dout2);
    end
endmodule",True,96,True,False,False,,0.0,,5.185755491256714,0.012355804443359375,prompt_only,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,Advanced Sequential,complex,"Design 8-bit resolution PWM generator with configurable duty cycle. Include testbench with duty cycles: 0%, 25%, 50%, 75%, 100%.",claude,"`timescale 1ns/1ps

module pwm_gen (
    input wire clk,
    input wire rst_n,
    input wire [7:0] duty_cycle,
    output reg pwm_out
);

reg [7:0] counter;

always @(posedge clk or negedge rst_n) begin
    if (!rst_n)
        counter <= 8'd0;
    else
        counter <= counter + 1'b1;
end

always @(posedge clk or negedge rst_n) begin
    if (!rst_n)
        pwm_out <= 1'b0;
    else
        pwm_out <= (counter < duty_cycle);
end

endmodule

module testbench;
    reg clk;
    reg rst_n;
    reg [7:0] duty_cycle;
    wire pwm_out;
    
    pwm_gen dut (
        .clk(clk),
        .rst_n(rst_n),
        .duty_cycle(duty_cycle),
        .pwm_out(pwm_out)
    );
    
    initial begin
        $dumpfile(""pwm.vcd"");
        $dumpvars(0, testbench);
        
        clk = 0;
        rst_n = 0;
        duty_cycle = 8'd0;
        
        #20 rst_n = 1;
        
        // Test 0% duty cycle
        duty_cycle = 8'd0;
        #512;
        
        // Test 25% duty cycle
        duty_cycle = 8'd64;
        #512;
        
        // Test 50% duty cycle
        duty_cycle = 8'd128;
        #512;
        
        // Test 75% duty cycle
        duty_cycle = 8'd192;
        #512;
        
        // Test 100% duty cycle
        duty_cycle = 8'd255;
        #512;
        
        $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t rst_n=%b duty_cycle=%d pwm_out=%b"", 
                 $time, rst_n, duty_cycle, pwm_out);
    end
endmodule",True,80,True,True,True,False,0.4,False,7.009838342666626,8.35983419418335,"graph TD
    CLK[Clock Input] --> COUNTER[[8-bit Counter]]
    RST[Reset] --> COUNTER
    DC[Duty Cycle Input] --> COMP
    COUNTER --> COMP(8-bit Comparator)
    COMP --> PWM_OUT[PWM Output]
    TB_DC[[Test Values:<br/>0%: 0x00<br/>25%: 0x40<br/>50%: 0x80<br/>75%: 0xC0<br/>100%: 0xFF]] --> DC
    CLK --> PWM_OUT
    RST --> PWM_OUT
    subgraph TB[Testbench]
    TB_DC
    end
    subgraph PWM_GEN[PWM Generator]
    COUNTER
    COMP
    end","`timescale 1ns/1ps

module pwm_gen (
    input wire clk,
    input wire rst,
    input wire [7:0] duty_cycle,
    output wire pwm_out
);

reg [7:0] counter;
reg pwm_out_reg;

always @(posedge clk or posedge rst) begin
    if (rst)
        counter <= 8'h00;
    else
        counter <= counter + 1'b1;
end

always @(posedge clk or posedge rst) begin
    if (rst)
        pwm_out_reg <= 1'b0;
    else
        pwm_out_reg <= (counter < duty_cycle);
end

assign pwm_out = pwm_out_reg;

endmodule

module testbench;
    reg clk;
    reg rst;
    reg [7:0] duty_cycle;
    wire pwm_out;

    pwm_gen dut (
        .clk(clk),
        .rst(rst),
        .duty_cycle(duty_cycle),
        .pwm_out(pwm_out)
    );

    initial begin
        $dumpfile(""pwm.vcd"");
        $dumpvars(0, testbench);

        clk = 0;
        rst = 1;
        duty_cycle = 8'h00;

        #20 rst = 0;

        // Test 0% duty cycle
        #100 duty_cycle = 8'h00;
        
        // Test 25% duty cycle
        #256 duty_cycle = 8'h40;
        
        // Test 50% duty cycle
        #256 duty_cycle = 8'h80;
        
        // Test 75% duty cycle
        #256 duty_cycle = 8'hC0;
        
        // Test 100% duty cycle
        #256 duty_cycle = 8'hFF;
        
        #256 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t rst=%b duty_cycle=0x%h pwm_out=%b"", 
                 $time, rst, duty_cycle, pwm_out);
    end
endmodule",True,78,True,True,True,False,0.4,False,12.406872272491455,8.193161010742188,"Design 8-bit resolution PWM generator with configurable duty cycle. Include testbench with duty cycles: 0%, 25%, 50%, 75%, 100%.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph TD
    CLK[Clock Input] --> COUNTER[[8-bit Counter]]
    RST[Reset] --> COUNTER
    DC[Duty Cycle Input] --> COMP
    COUNTER --> COMP(8-bit Comparator)
    COMP --> PWM_OUT[PWM Output]
    TB_DC[[Test Values:<br/>0%: 0x00<br/>25%: 0x40<br/>50%: 0x80<br/>75%: 0xC0<br/>100%: 0xFF]] --> DC
    CLK --> PWM_OUT
    RST --> PWM_OUT
    subgraph TB[Testbench]
    TB_DC
    end
    subgraph PWM_GEN[PWM Generator]
    COUNTER
    COMP
    end
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module pwm_gen (
    input wire clk,
    input wire rst,
    input wire [7:0] duty_cycle,
    output reg pwm_out
);

reg [7:0] counter;

always @(posedge clk or posedge rst) begin
    if (rst)
        counter <= 8'h00;
    else
        counter <= counter + 1'b1;
end

always @(posedge clk or posedge rst) begin
    if (rst)
        pwm_out <= 1'b0;
    else
        pwm_out <= (counter < duty_cycle);
end

endmodule

module testbench;
    reg clk;
    reg rst;
    reg [7:0] duty_cycle;
    wire pwm_out;

    pwm_gen dut (
        .clk(clk),
        .rst(rst),
        .duty_cycle(duty_cycle),
        .pwm_out(pwm_out)
    );

    initial begin
        $dumpfile(""pwm.vcd"");
        $dumpvars(0, testbench);

        clk = 0;
        rst = 1;
        duty_cycle = 8'h00;

        #20 rst = 0;

        // Test 0% duty cycle
        duty_cycle = 8'h00;
        #512;

        // Test 25% duty cycle
        duty_cycle = 8'h40;
        #512;

        // Test 50% duty cycle
        duty_cycle = 8'h80;
        #512;

        // Test 75% duty cycle
        duty_cycle = 8'hC0;
        #512;

        // Test 100% duty cycle
        duty_cycle = 8'hFF;
        #512;

        $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t rst=%b duty_cycle=0x%h pwm_out=%b"", 
                 $time, rst, duty_cycle, pwm_out);
    end
endmodule",True,80,True,True,True,False,0.3,False,6.348843574523926,7.437453269958496,tie,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,Advanced Sequential,complex,"Design 8-bit resolution PWM generator with configurable duty cycle. Include testbench with duty cycles: 0%, 25%, 50%, 75%, 100%.",gpt-4o,"`timescale 1ns/1ps

module pwm_generator(
    input wire clk,
    input wire rst_n,
    input wire [7:0] duty_cycle,
    output reg pwm_out
);

reg [7:0] counter;

always @(posedge clk or negedge rst_n) begin
    if (!rst_n)
        counter <= 8'b0;
    else
        counter <= counter + 1'b1;
end

always @(posedge clk or negedge rst_n) begin
    if (!rst_n)
        pwm_out <= 1'b0;
    else
        pwm_out <= (counter < duty_cycle) ? 1'b1 : 1'b0;
end

endmodule

module testbench;
    reg clk, rst_n;
    reg [7:0] duty_cycle;
    wire pwm_out;
    
    pwm_generator dut (
        .clk(clk),
        .rst_n(rst_n),
        .duty_cycle(duty_cycle),
        .pwm_out(pwm_out)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst_n = 1'b0;
        duty_cycle = 8'd0;
        
        #20 rst_n = 1'b1;
        #10 duty_cycle = 8'd0;   // 0%
        #100 duty_cycle = 8'd64; // 25%
        #100 duty_cycle = 8'd128;// 50%
        #100 duty_cycle = 8'd192;// 75%
        #100 duty_cycle = 8'd255;// 100%
        #100 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b duty_cycle=%d pwm_out=%b"", 
                 $time, clk, rst_n, duty_cycle, pwm_out);
    end
endmodule",True,63,True,True,True,False,0.3,False,3.1239848136901855,9.361344814300537,"graph LR
    CLK[Clock] --> COUNTER(Counter)
    RST[Reset] --> COUNTER
    COUNTER --> COMP(Comparator)
    DUTY[Duty Cycle Input] --> COMP
    COMP --> PWM[8-bit PWM Output]
    
    subgraph Testbench
        TB_CLK[Test Clock] --> TB_COUNTER(Test Counter)
        TB_RST[Test Reset] --> TB_COUNTER
        TB_COUNTER --> TB_COMP(Test Comparator)
        TB_DUTY[Test Duty Cycle Input] --> TB_COMP
        TB_COMP --> TB_PWM[Test PWM Output]
        
        TB_DUTY0[Test Duty 0%] --> TB_DUTY
        TB_DUTY25[Test Duty 25%] --> TB_DUTY
        TB_DUTY50[Test Duty 50%] --> TB_DUTY
        TB_DUTY75[Test Duty 75%] --> TB_DUTY
        TB_DUTY100[Test Duty 100%] --> TB_DUTY
    end","`timescale 1ns/1ps

module pwm_generator(
    input wire clk,
    input wire rst_n,
    input wire [7:0] duty_cycle,
    output reg pwm_out
);

    reg [7:0] counter;

    always @(posedge clk or negedge rst_n) begin
        if (!rst_n)
            counter <= 8'b0;
        else
            counter <= counter + 1'b1;
    end

    always @(posedge clk or negedge rst_n) begin
        if (!rst_n)
            pwm_out <= 1'b0;
        else
            pwm_out <= (counter < duty_cycle) ? 1'b1 : 1'b0;
    end

endmodule

module testbench;
    reg clk, rst_n;
    reg [7:0] duty_cycle;
    wire pwm_out;

    pwm_generator dut (
        .clk(clk),
        .rst_n(rst_n),
        .duty_cycle(duty_cycle),
        .pwm_out(pwm_out)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 1'b0;
        rst_n = 1'b0;
        duty_cycle = 8'd0;
        
        #20 rst_n = 1'b1;
        #10 duty_cycle = 8'd0;
        #100 duty_cycle = 8'd64;
        #100 duty_cycle = 8'd128;
        #100 duty_cycle = 8'd192;
        #100 duty_cycle = 8'd255;
        #50 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b duty_cycle=%d pwm_out=%b"", 
                 $time, clk, rst_n, duty_cycle, pwm_out);
    end
endmodule",True,63,True,True,True,False,0.3,False,10.360413312911987,9.0547513961792,"Design 8-bit resolution PWM generator with configurable duty cycle. Include testbench with duty cycles: 0%, 25%, 50%, 75%, 100%.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph LR
    CLK[Clock] --> COUNTER(Counter)
    RST[Reset] --> COUNTER
    COUNTER --> COMP(Comparator)
    DUTY[Duty Cycle Input] --> COMP
    COMP --> PWM[8-bit PWM Output]
    
    subgraph Testbench
        TB_CLK[Test Clock] --> TB_COUNTER(Test Counter)
        TB_RST[Test Reset] --> TB_COUNTER
        TB_COUNTER --> TB_COMP(Test Comparator)
        TB_DUTY[Test Duty Cycle Input] --> TB_COMP
        TB_COMP --> TB_PWM[Test PWM Output]
        
        TB_DUTY0[Test Duty 0%] --> TB_DUTY
        TB_DUTY25[Test Duty 25%] --> TB_DUTY
        TB_DUTY50[Test Duty 50%] --> TB_DUTY
        TB_DUTY75[Test Duty 75%] --> TB_DUTY
        TB_DUTY100[Test Duty 100%] --> TB_DUTY
    end
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module counter(
    input wire clk,
    input wire rst_n,
    output reg [7:0] count
);

always @(posedge clk or negedge rst_n) begin
    if (!rst_n)
        count <= 8'b00000000;
    else
        count <= count + 1'b1;
end

endmodule

module comparator(
    input wire [7:0] count,
    input wire [7:0] duty_cycle,
    output reg pwm_out
);

always @(*) begin
    if (count < duty_cycle)
        pwm_out = 1'b1;
    else
        pwm_out = 1'b0;
end

endmodule

module pwm_generator(
    input wire clk,
    input wire rst_n,
    input wire [7:0] duty_cycle,
    output wire pwm_out
);

wire [7:0] count;

counter u_counter (
    .clk(clk),
    .rst_n(rst_n),
    .count(count)
);

comparator u_comparator (
    .count(count),
    .duty_cycle(duty_cycle),
    .pwm_out(pwm_out)
);

endmodule

module testbench;
    reg clk, rst_n;
    reg [7:0] duty_cycle;
    wire pwm_out;
    
    pwm_generator dut (
        .clk(clk),
        .rst_n(rst_n),
        .duty_cycle(duty_cycle),
        .pwm_out(pwm_out)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst_n = 1'b0;
        duty_cycle = 8'd0;
        
        #20 rst_n = 1'b1;
        #10 duty_cycle = 8'd64;  // 25%
        #100 duty_cycle = 8'd128; // 50%
        #100 duty_cycle = 8'd192; // 75%
        #100 duty_cycle = 8'd255; // 100%
        #100 duty_cycle = 8'd0;   // 0%
        #50 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b duty_cycle=%d pwm_out=%b"", 
                 $time, clk, rst_n, duty_cycle, pwm_out);
    end
endmodule",True,91,True,True,True,False,0.3,False,8.250875473022461,9.07468056678772,tie,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,Protocol,complex,"Design SPI master supporting mode 0 (CPOL=0, CPHA=0). Include SCLK generation, MOSI/MISO handling. Include testbench.",claude,"`timescale 1ns/1ps

module spi_master(
    input wire clk,
    input wire rst_n,
    input wire start,
    input wire [7:0] tx_data,
    input wire miso,
    output reg sclk,
    output reg mosi,
    output reg busy,
    output reg [7:0] rx_data
);

reg [7:0] tx_shift;
reg [7:0] rx_shift;
reg [3:0] bit_count;
reg spi_clk_en;

always @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
        sclk <= 1'b0;
        mosi <= 1'b0;
        busy <= 1'b0;
        rx_data <= 8'h00;
        tx_shift <= 8'h00;
        rx_shift <= 8'h00;
        bit_count <= 4'h0;
        spi_clk_en <= 1'b0;
    end else begin
        if (start && !busy) begin
            busy <= 1'b1;
            tx_shift <= tx_data;
            bit_count <= 4'h0;
            spi_clk_en <= 1'b1;
        end else if (busy) begin
            sclk <= spi_clk_en;
            spi_clk_en <= ~spi_clk_en;
            
            if (!spi_clk_en) begin  // Sample on rising edge
                rx_shift <= {rx_shift[6:0], miso};
                bit_count <= bit_count + 1'b1;
                
                if (bit_count == 4'h7) begin
                    busy <= 1'b0;
                    rx_data <= {rx_shift[6:0], miso};
                end
            end else begin  // Setup on falling edge
                mosi <= tx_shift[7];
                tx_shift <= {tx_shift[6:0], 1'b0};
            end
        end
    end
end

endmodule

module testbench;
    reg clk;
    reg rst_n;
    reg start;
    reg [7:0] tx_data;
    reg miso;
    wire sclk;
    wire mosi;
    wire busy;
    wire [7:0] rx_data;

    spi_master dut (
        .clk(clk),
        .rst_n(rst_n),
        .start(start),
        .tx_data(tx_data),
        .miso(miso),
        .sclk(sclk),
        .mosi(mosi),
        .busy(busy),
        .rx_data(rx_data)
    );

    initial begin
        $dumpfile(""spi_master.vcd"");
        $dumpvars(0, testbench);

        clk = 1'b0;
        rst_n = 1'b0;
        start = 1'b0;
        tx_data = 8'h00;
        miso = 1'b0;

        #20 rst_n = 1'b1;
        #20 tx_data = 8'hA5;
        #10 start = 1'b1;
        #10 start = 1'b0;
        miso = 1'b1;

        #200 tx_data = 8'h5A;
        #10 start = 1'b1;
        #10 start = 1'b0;
        miso = 1'b0;

        #200 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t rst_n=%b start=%b tx_data=%h rx_data=%h busy=%b"",
                 $time, rst_n, start, tx_data, rx_data, busy);
    end
endmodule",True,111,True,True,True,False,0.4,False,11.361348628997803,9.315285205841064,"graph TD
    CLK[Clock Input] --> CLKGEN(SCLK Generator)
    RST[Reset] --> CLKGEN
    RST --> CTRL(SPI Control FSM)
    CLK --> CTRL
    
    TXDATA[[TX Data Register]] --> TXSHIFT(TX Shift Register)
    RXSHIFT(RX Shift Register) --> RXDATA[[RX Data Register]]
    
    CLKGEN --> SCLK[SCLK Output]
    CTRL --> TXSHIFT
    CTRL --> RXSHIFT
    
    TXSHIFT --> MOSI[MOSI Output]
    MISO[MISO Input] --> RXSHIFT
    
    START[Start Transaction] --> CTRL
    BUSY[Busy Signal] --> CTRL
    
    subgraph Testbench
        TB_CLK[Test Clock] --> TB_CTRL(Test Controller)
        TB_CTRL --> TB_DATA[[Test Data]]
        TB_CTRL --> TB_EXPECT[[Expected Results]]
        TB_DATA --> TXDATA
        RXDATA --> TB_VERIFY{Compare Results}
        TB_EXPECT --> TB_VERIFY
    end","`timescale 1ns/1ps

module spi_core #(
    parameter DATA_WIDTH = 8
)(
    input wire clk,
    input wire rst_n,
    input wire start,
    input wire miso,
    input wire [DATA_WIDTH-1:0] tx_data,
    output reg mosi,
    output reg sclk,
    output reg busy,
    output reg [DATA_WIDTH-1:0] rx_data
);

reg [2:0] state;
reg [3:0] bit_count;
reg [DATA_WIDTH-1:0] tx_shift;
reg [DATA_WIDTH-1:0] rx_shift;

localparam IDLE = 3'd0;
localparam TRANSFER = 3'd1;
localparam COMPLETE = 3'd2;

always @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
        state <= IDLE;
        bit_count <= 4'b0000;
        tx_shift <= 4'b0000;
        rx_shift <= 4'b0000;
        mosi <= 1'b0;
        sclk <= 1'b0;
        busy <= 1'b0;
        rx_data <= 4'b0000;
    end else begin
        case (state)
            IDLE: begin
                if (start) begin
                    state <= TRANSFER;
                    tx_shift <= tx_data;
                    bit_count <= DATA_WIDTH-1;
                    busy <= 1'b1;
                end
            end
            
            TRANSFER: begin
                sclk <= ~sclk;
                if (sclk) begin
                    rx_shift <= {rx_shift[DATA_WIDTH-2:0], miso};
                    if (bit_count == 0) begin
                        state <= COMPLETE;
                    end else begin
                        bit_count <= bit_count - 1'b1;
                    end
                end else begin
                    mosi <= tx_shift[bit_count];
                end
            end
            
            COMPLETE: begin
                rx_data <= rx_shift;
                busy <= 1'b0;
                state <= IDLE;
                sclk <= 1'b0;
                mosi <= 1'b0;
            end
            
            default: state <= IDLE;
        endcase
    end
end

endmodule

module testbench;
    reg clk;
    reg rst_n;
    reg start;
    reg [7:0] tx_data;
    reg miso;
    wire mosi;
    wire sclk;
    wire busy;
    wire [7:0] rx_data;
    
    spi_core #(8) dut (
        .clk(clk),
        .rst_n(rst_n),
        .start(start),
        .miso(miso),
        .tx_data(tx_data),
        .mosi(mosi),
        .sclk(sclk),
        .busy(busy),
        .rx_data(rx_data)
    );
    
    initial begin
        $dumpfile(""spi.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst_n = 1'b0;
        start = 1'b0;
        tx_data = 1'b0;
        miso = 1'b0;
        
        #20 rst_n = 1'b1;
        #10 tx_data = 8'hA5;
        #10 start = 1'b1;
        #10 start = 1'b0;
        miso = 1'b1;
        
        #200;
        
        tx_data = 8'h5A;
        start = 1'b1;
        #10 start = 1'b0;
        miso = 1'b0;
        
        #200 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t rx_data=%h busy=%b"", $time, rx_data, busy);
    end
endmodule",True,130,True,True,True,False,0.3,False,16.575196743011475,8.974974870681763,"Design SPI master supporting mode 0 (CPOL=0, CPHA=0). Include SCLK generation, MOSI/MISO handling. Include testbench.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph TD
    CLK[Clock Input] --> CLKGEN(SCLK Generator)
    RST[Reset] --> CLKGEN
    RST --> CTRL(SPI Control FSM)
    CLK --> CTRL
    
    TXDATA[[TX Data Register]] --> TXSHIFT(TX Shift Register)
    RXSHIFT(RX Shift Register) --> RXDATA[[RX Data Register]]
    
    CLKGEN --> SCLK[SCLK Output]
    CTRL --> TXSHIFT
    CTRL --> RXSHIFT
    
    TXSHIFT --> MOSI[MOSI Output]
    MISO[MISO Input] --> RXSHIFT
    
    START[Start Transaction] --> CTRL
    BUSY[Busy Signal] --> CTRL
    
    subgraph Testbench
        TB_CLK[Test Clock] --> TB_CTRL(Test Controller)
        TB_CTRL --> TB_DATA[[Test Data]]
        TB_CTRL --> TB_EXPECT[[Expected Results]]
        TB_DATA --> TXDATA
        RXDATA --> TB_VERIFY{Compare Results}
        TB_EXPECT --> TB_VERIFY
    end
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module spi_master (
    input wire clk,
    input wire rst,
    input wire start,
    input wire miso,
    input wire [7:0] tx_data,
    output reg mosi,
    output reg sclk,
    output reg busy,
    output reg [7:0] rx_data
);

reg [3:0] bit_count;
reg [7:0] tx_shift;
reg [7:0] rx_shift;
reg [2:0] state;
reg sclk_en;

localparam IDLE = 3'b000;
localparam SETUP = 3'b001;
localparam SHIFT = 3'b010;
localparam DONE = 3'b011;

always @(posedge clk or posedge rst) begin
    if (rst) begin
        state <= IDLE;
        bit_count <= 4'b0;
        tx_shift <= 8'b0;
        rx_shift <= 8'b0;
        mosi <= 1'b0;
        sclk <= 1'b0;
        busy <= 1'b0;
        rx_data <= 8'b0;
        sclk_en <= 1'b0;
    end else begin
        case (state)
            IDLE: begin
                if (start) begin
                    state <= SETUP;
                    tx_shift <= tx_data;
                    bit_count <= 4'b0;
                    busy <= 1'b1;
                end
            end
            
            SETUP: begin
                mosi <= tx_shift[7];
                state <= SHIFT;
                sclk_en <= 1'b1;
            end
            
            SHIFT: begin
                if (bit_count == 4'h8) begin
                    state <= DONE;
                    sclk_en <= 1'b0;
                end else begin
                    if (!sclk) begin
                        rx_shift <= {rx_shift[6:0], miso};
                        bit_count <= bit_count + 1'b1;
                    end else begin
                        tx_shift <= {tx_shift[6:0], 1'b0};
                        mosi <= tx_shift[6];
                    end
                end
            end
            
            DONE: begin
                rx_data <= rx_shift;
                busy <= 1'b0;
                state <= IDLE;
            end
            
            default: state <= IDLE;
        endcase
    end
end

always @(posedge clk or posedge rst) begin
    if (rst)
        sclk <= 1'b0;
    else if (sclk_en)
        sclk <= ~sclk;
end

endmodule

module spi_master_tb;
    reg clk;
    reg rst;
    reg start;
    reg [7:0] tx_data;
    reg miso;
    wire mosi;
    wire sclk;
    wire busy;
    wire [7:0] rx_data;
    
    reg [7:0] expected_rx;
    
    spi_master dut (
        .clk(clk),
        .rst(rst),
        .start(start),
        .miso(miso),
        .tx_data(tx_data),
        .mosi(mosi),
        .sclk(sclk),
        .busy(busy),
        .rx_data(rx_data)
    );
    
    initial begin
        clk = 1'b0;
        forever #5 clk = ~clk;
    end
    
    initial begin
        $dumpfile(""spi_master.vcd"");
        $dumpvars(0, spi_master_tb);
        
        rst = 1'b1;
        start = 1'b0;
        tx_data = 1'b0;
        miso = 1'b0;
        expected_rx = 8'hA5;
        
        #20;
        rst = 1'b0;
        #10;
        
        tx_data = 8'h55;
        start = 1'b1;
        #10;
        start = 1'b0;
        
        repeat(8) begin
            @(posedge sclk);
            miso = expected_rx[7];
            expected_rx = {expected_rx[6:0], expected_rx[7]};
        end
        
        @(negedge busy);
        
        if (rx_data == 8'hA5)
            $display(""Test passed: RX data matches expected"");
        else
            $display(""Test failed: RX data mismatch"");
            
        #100;
        $finish;
    end
    
endmodule",True,155,False,True,True,True,1.0,True,14.123164892196655,8.447161436080933,tie,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,Protocol,complex,"Design SPI master supporting mode 0 (CPOL=0, CPHA=0). Include SCLK generation, MOSI/MISO handling. Include testbench.",gpt-4o,"`timescale 1ns/1ps

module spi_master(
    input wire clk,
    input wire rst_n,
    input wire mosi,
    input wire [7:0] data_in,
    input wire start,
    output reg sclk,
    output reg miso,
    output reg [7:0] data_out,
    output reg done
);

    reg [2:0] bit_cnt;
    reg [7:0] shift_reg;
    reg state;
    
    localparam IDLE = 1'b0;
    localparam TRANSFER = 1'b1;

    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            sclk <= 1'b0;
            miso <= 1'b0;
            data_out <= 8'b0;
            bit_cnt <= 3'b0;
            shift_reg <= 8'b0;
            state <= IDLE;
            done <= 1'b0;
        end else begin
            case (state)
                IDLE: begin
                    done <= 1'b0;
                    if (start) begin
                        state <= TRANSFER;
                        shift_reg <= data_in;
                        bit_cnt <= 3'b0;
                    end
                end
                TRANSFER: begin
                    sclk <= ~sclk;
                    if (sclk) begin
                        miso <= shift_reg[7];
                        shift_reg <= {shift_reg[6:0], mosi};
                        bit_cnt <= bit_cnt + 1'b1;
                        if (bit_cnt == 3'b111) begin
                            state <= IDLE;
                            data_out <= shift_reg;
                            done <= 1'b1;
                        end
                    end
                end
            endcase
        end
    end
    
endmodule

module testbench;
    reg clk, rst_n, mosi, start;
    reg [7:0] data_in;
    wire sclk, miso, done;
    wire [7:0] data_out;

    spi_master dut (
        .clk(clk),
        .rst_n(rst_n),
        .mosi(mosi),
        .data_in(data_in),
        .start(start),
        .sclk(sclk),
        .miso(miso),
        .data_out(data_out),
        .done(done)
    );

    initial begin
        $dumpfile(""spi_master_tb.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst_n = 1'b0;
        mosi = 1'b0;
        data_in = 8'hAA;
        start = 1'b0;
        
        #20 rst_n = 1'b1;
        #10 start = 1'b1;
        #10 start = 1'b0;
        #160 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b mosi=%b data_in=%h start=%b sclk=%b miso=%b data_out=%h done=%b"", 
                 $time, clk, rst_n, mosi, data_in, start, sclk, miso, data_out, done);
    end
endmodule",True,100,True,True,True,True,0.9,True,7.831451177597046,8.145363807678223,"graph TD
    CLK[Clock (SCLK)] --> SCLK_GEN((SCLK Generator))
    RST[Reset] --> CTRL((Control Logic))
    CTRL --> SCLK_GEN

    MOSI_IN[Master Out Slave In (MOSI)] --> MISO_MOSI_HANDLER((MISO/MOSI Handler))
    MISO_MOSI_HANDLER --> MOSI_OUT[MOSI Output]
    
    MISO_IN[Master In Slave Out (MISO)] --> MISO_MOSI_HANDLER
    MISO_MOSI_HANDLER --> MISO_OUT[MISO Output]

    SCLK_GEN --> MISO_MOSI_HANDLER
    CTRL --> MISO_MOSI_HANDLER

    TB[[Testbench]] --> CLK
    TB --> RST
    TB --> MOSI_IN
    TB --> MISO_IN
    TB --> CTRL

    TB --> SCLK_GEN
    TB --> MISO_MOSI_HANDLER","`timescale 1ns/1ps

module sclk_generator(
    input wire clk,
    input wire rst,
    input wire ctrl,
    output reg sclk
);

always @(posedge clk or posedge rst) begin
    if (rst)
        sclk <= 1'b0;
    else if (ctrl)
        sclk <= ~sclk;
end

endmodule

module miso_mosi_handler(
    input wire clk,
    input wire rst,
    input wire sclk,
    input wire ctrl,
    input wire mosi_in,
    input wire miso_in,
    output reg mosi_out,
    output reg miso_out
);

always @(posedge clk or posedge rst) begin
    if (rst) begin
        mosi_out <= 1'b0;
        miso_out <= 1'b0;
    end else if (sclk && ctrl) begin
        mosi_out <= mosi_in;
        miso_out <= miso_in;
    end
end

endmodule

module testbench;
    reg clk, rst, ctrl, mosi_in, miso_in;
    wire sclk, mosi_out, miso_out;
    
    sclk_generator sclk_gen (
        .clk(clk),
        .rst(rst),
        .ctrl(ctrl),
        .sclk(sclk)
    );
    
    miso_mosi_handler miso_mosi_hdl (
        .clk(clk),
        .rst(rst),
        .sclk(sclk),
        .ctrl(ctrl),
        .mosi_in(mosi_in),
        .miso_in(miso_in),
        .mosi_out(mosi_out),
        .miso_out(miso_out)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst = 1'b1;
        ctrl = 1'b0;
        mosi_in = 1'b0;
        miso_in = 1'b0;
        
        #20 rst = 1'b0;
        #10 ctrl = 1'b1;
        
        #100 mosi_in = 1'b1;
        #100 miso_in = 1'b1;
        
        #50 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t clk=%b rst=%b ctrl=%b sclk=%b mosi_in=%b miso_in=%b mosi_out=%b miso_out=%b"", 
                 $time, clk, rst, ctrl, sclk, mosi_in, miso_in, mosi_out, miso_out);
    end
endmodule",True,89,True,True,True,False,0.3,False,9.077420949935913,6.4986326694488525,"Design SPI master supporting mode 0 (CPOL=0, CPHA=0). Include SCLK generation, MOSI/MISO handling. Include testbench.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph TD
    CLK[Clock (SCLK)] --> SCLK_GEN((SCLK Generator))
    RST[Reset] --> CTRL((Control Logic))
    CTRL --> SCLK_GEN

    MOSI_IN[Master Out Slave In (MOSI)] --> MISO_MOSI_HANDLER((MISO/MOSI Handler))
    MISO_MOSI_HANDLER --> MOSI_OUT[MOSI Output]
    
    MISO_IN[Master In Slave Out (MISO)] --> MISO_MOSI_HANDLER
    MISO_MOSI_HANDLER --> MISO_OUT[MISO Output]

    SCLK_GEN --> MISO_MOSI_HANDLER
    CTRL --> MISO_MOSI_HANDLER

    TB[[Testbench]] --> CLK
    TB --> RST
    TB --> MOSI_IN
    TB --> MISO_IN
    TB --> CTRL

    TB --> SCLK_GEN
    TB --> MISO_MOSI_HANDLER
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module sclk_generator(
    input wire clk,
    input wire rst_n,
    input wire ctrl,
    output reg sclk
);

always @(posedge clk or negedge rst_n) begin
    if (!rst_n)
        sclk <= 1'b0;
    else if (ctrl)
        sclk <= ~sclk;
end

endmodule

module miso_mosi_handler(
    input wire mosi_in,
    input wire miso_in,
    input wire sclk,
    input wire ctrl,
    output reg mosi_out,
    output reg miso_out
);

always @(posedge sclk or negedge ctrl) begin
    if (!ctrl) begin
        miso_out <= 1'b0;
        mosi_out <= 1'b0;
    end else begin
        miso_out <= mosi_in;
        mosi_out <= miso_in;
    end
end

endmodule

module spi_master(
    input wire clk,
    input wire rst_n,
    input wire ctrl,
    input wire mosi_in,
    input wire miso_in,
    output wire mosi_out,
    output wire miso_out
);

wire sclk;

sclk_generator sclk_gen_inst (
    .clk(clk),
    .rst_n(rst_n),
    .ctrl(ctrl),
    .sclk(sclk)
);

miso_mosi_handler miso_mosi_handler_inst (
    .mosi_in(mosi_in),
    .miso_in(miso_in),
    .sclk(sclk),
    .ctrl(ctrl),
    .mosi_out(mosi_out),
    .miso_out(miso_out)
);

endmodule

module testbench;
    reg clk, rst_n, ctrl, mosi_in, miso_in;
    wire mosi_out, miso_out;
    
    spi_master dut (
        .clk(clk),
        .rst_n(rst_n),
        .ctrl(ctrl),
        .mosi_in(mosi_in),
        .miso_in(miso_in),
        .mosi_out(mosi_out),
        .miso_out(miso_out)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst_n = 1'b0;
        ctrl = 1'b0;
        mosi_in = 1'b0;
        miso_in = 1'b0;
        
        #20 rst_n = 1'b1;
        #10 ctrl = 1'b1;
        #10 mosi_in = 1'b1;
        #10 miso_in = 1'b1;
        #100 ctrl = 1'b0;
        #20 rst_n = 1'b0;
        #20 rst_n = 1'b1;
        #50 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b ctrl=%b mosi_in=%b miso_in=%b mosi_out=%b miso_out=%b"", 
                 $time, clk, rst_n, ctrl, mosi_in, miso_in, mosi_out, miso_out);
    end
endmodule",True,110,True,True,True,True,0.7,True,4.758407115936279,7.343653678894043,mermaid_only,mermaid_only > prompt_only > combined,prompt_only > mermaid_only > combined
