circuit_name,category,complexity,original_prompt,model,prompt_only_verilog,prompt_only_generation_success,prompt_only_lines_of_code,prompt_only_has_testbench,prompt_only_compilation_success,prompt_only_simulation_success,prompt_only_vae_verdict,prompt_only_vae_confidence,prompt_only_consensus_anomalous,prompt_only_generation_time,prompt_only_simulation_time,mermaid_only_mermaid,mermaid_only_verilog,mermaid_only_generation_success,mermaid_only_lines_of_code,mermaid_only_has_testbench,mermaid_only_compilation_success,mermaid_only_simulation_success,mermaid_only_vae_verdict,mermaid_only_vae_confidence,mermaid_only_consensus_anomalous,mermaid_only_generation_time,mermaid_only_simulation_time,combined_prompt,combined_verilog,combined_generation_success,combined_lines_of_code,combined_has_testbench,combined_compilation_success,combined_simulation_success,combined_vae_verdict,combined_vae_confidence,combined_consensus_anomalous,combined_generation_time,combined_simulation_time,best_approach,correctness_ranking,simulation_ranking
combined,Combinational,simple,"Design a 2-to-1 multiplexer with inputs a, b, select sel, and output out. Include testbench testing all combinations.",claude,"`timescale 1ns/1ps

module mux2to1(
    input wire a,
    input wire b,
    input wire sel,
    output reg out
);

always @(*) begin
    case(sel)
        1'b0: out = a;
        1'b1: out = b;
    endcase
end

endmodule

module testbench;
    reg a, b, sel;
    wire out;
    
    mux2to1 dut(
        .a(a),
        .b(b),
        .sel(sel),
        .out(out)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        // Test all combinations
        a = 0; b = 0; sel = 0; #10;
        a = 0; b = 0; sel = 1; #10;
        a = 0; b = 1; sel = 0; #10;
        a = 0; b = 1; sel = 1; #10;
        a = 1; b = 0; sel = 0; #10;
        a = 1; b = 0; sel = 1; #10;
        a = 1; b = 1; sel = 0; #10;
        a = 1; b = 1; sel = 1; #10;
        
        $finish;
    end
    
    initial begin
        $monitor(""Time=%0t a=%b b=%b sel=%b out=%b"", 
                 $time, a, b, sel, out);
    end
endmodule",True,51,True,True,True,False,0.4,False,5.64285945892334,7.070704936981201,"graph LR
    A[Input A] --> MUX{2:1 MUX}
    B[Input B] --> MUX
    SEL[Select] --> MUX
    MUX --> OUT[Output]
    TB[[Testbench]]
    TB -->|Test 1: sel=0, a=0, b=0| MUX
    TB -->|Test 2: sel=0, a=0, b=1| MUX
    TB -->|Test 3: sel=0, a=1, b=0| MUX
    TB -->|Test 4: sel=0, a=1, b=1| MUX
    TB -->|Test 5: sel=1, a=0, b=0| MUX
    TB -->|Test 6: sel=1, a=0, b=1| MUX
    TB -->|Test 7: sel=1, a=1, b=0| MUX
    TB -->|Test 8: sel=1, a=1, b=1| MUX
    MUX -->|Verify Output| TB","`timescale 1ns/1ps

module mux2to1(
    input wire a,
    input wire b,
    input wire sel,
    output reg out
);

always @(a or b or sel) begin
    out <= (sel) ? b : a;
end

endmodule

module testbench;
    reg a, b, sel;
    wire out;
    
    mux2to1 dut (
        .a(a),
        .b(b),
        .sel(sel),
        .out(out)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        // Test 1: sel=0, a=0, b=0
        sel = 0; a = 0; b = 0; #10;
        
        // Test 2: sel=0, a=0, b=1
        sel = 0; a = 0; b = 1; #10;
        
        // Test 3: sel=0, a=1, b=0
        sel = 0; a = 1; b = 0; #10;
        
        // Test 4: sel=0, a=1, b=1
        sel = 0; a = 1; b = 1; #10;
        
        // Test 5: sel=1, a=0, b=0
        sel = 1; a = 0; b = 0; #10;
        
        // Test 6: sel=1, a=0, b=1
        sel = 1; a = 0; b = 1; #10;
        
        // Test 7: sel=1, a=1, b=0
        sel = 1; a = 1; b = 0; #10;
        
        // Test 8: sel=1, a=1, b=1
        sel = 1; a = 1; b = 1; #10;
        
        $finish;
    end
    
    initial begin
        $monitor(""Time=%0t sel=%b a=%b b=%b out=%b"", 
                 $time, sel, a, b, out);
    end
endmodule",True,62,True,True,True,False,0.4,False,10.389607667922974,11.161691665649414,"Design a 2-to-1 multiplexer with inputs a, b, select sel, and output out. Include testbench testing all combinations.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph LR
    A[Input A] --> MUX{2:1 MUX}
    B[Input B] --> MUX
    SEL[Select] --> MUX
    MUX --> OUT[Output]
    TB[[Testbench]]
    TB -->|Test 1: sel=0, a=0, b=0| MUX
    TB -->|Test 2: sel=0, a=0, b=1| MUX
    TB -->|Test 3: sel=0, a=1, b=0| MUX
    TB -->|Test 4: sel=0, a=1, b=1| MUX
    TB -->|Test 5: sel=1, a=0, b=0| MUX
    TB -->|Test 6: sel=1, a=0, b=1| MUX
    TB -->|Test 7: sel=1, a=1, b=0| MUX
    TB -->|Test 8: sel=1, a=1, b=1| MUX
    MUX -->|Verify Output| TB
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module mux2to1(
    input wire a,
    input wire b,
    input wire sel,
    output reg out
);

always @(*) begin
    case (sel)
        1'b0: out = a;
        1'b1: out = b;
        default: out = 1'b0;
    endcase
end

endmodule

module testbench;
    reg a, b, sel;
    wire out;
    
    mux2to1 dut (
        .a(a),
        .b(b),
        .sel(sel),
        .out(out)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        // Test 1: sel=0, a=0, b=0
        sel = 0; a = 0; b = 0; #10;
        
        // Test 2: sel=0, a=0, b=1
        sel = 0; a = 0; b = 1; #10;
        
        // Test 3: sel=0, a=1, b=0
        sel = 0; a = 1; b = 0; #10;
        
        // Test 4: sel=0, a=1, b=1
        sel = 0; a = 1; b = 1; #10;
        
        // Test 5: sel=1, a=0, b=0
        sel = 1; a = 0; b = 0; #10;
        
        // Test 6: sel=1, a=0, b=1
        sel = 1; a = 0; b = 1; #10;
        
        // Test 7: sel=1, a=1, b=0
        sel = 1; a = 1; b = 0; #10;
        
        // Test 8: sel=1, a=1, b=1
        sel = 1; a = 1; b = 1; #10;
        
        $finish;
    end
    
    initial begin
        $monitor(""Time=%0t sel=%b a=%b b=%b out=%b"", 
                 $time, sel, a, b, out);
    end
endmodule",True,66,True,True,True,False,0.4,False,6.690354108810425,7.148262977600098,tie,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,Combinational,simple,"Design a 2-to-1 multiplexer with inputs a, b, select sel, and output out. Include testbench testing all combinations.",gpt-4o,"`timescale 1ns/1ps

module mux2to1(
    input wire a,
    input wire b,
    input wire sel,
    output wire out
);

assign out = sel ? b : a;

endmodule

module testbench;
    reg a, b, sel;
    wire out;

    mux2to1 dut (
        .a(a),
        .b(b),
        .sel(sel),
        .out(out)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        a = 1'b0; b = 1'b0; sel = 1'b0;
        #10 a = 1'b0; b = 1'b1; sel = 1'b0;
        #10 a = 1'b1; b = 1'b0; sel = 1'b0;
        #10 a = 1'b1; b = 1'b1; sel = 1'b0;
        #10 a = 1'b0; b = 1'b0; sel = 1'b1;
        #10 a = 1'b0; b = 1'b1; sel = 1'b1;
        #10 a = 1'b1; b = 1'b0; sel = 1'b1;
        #10 a = 1'b1; b = 1'b1; sel = 1'b1;
        #10 $finish;
    end

    initial begin
        $monitor(""Time=%0t a=%b b=%b sel=%b out=%b"", 
                 $time, a, b, sel, out);
    end
endmodule",True,44,True,True,True,False,0.4,False,4.6596784591674805,11.148839235305786,"graph LR
    A[a] --> MUX{2-to-1 MUX}
    B[b] --> MUX
    SEL[sel] --> MUX
    MUX --> OUT[out]

    subgraph Testbench
        IN1[Test a = 0, b = 0, sel = 0] --> MUX
        IN2[Test a = 0, b = 1, sel = 0] --> MUX
        IN3[Test a = 1, b = 0, sel = 0] --> MUX
        IN4[Test a = 1, b = 1, sel = 0] --> MUX
        IN5[Test a = 0, b = 0, sel = 1] --> MUX
        IN6[Test a = 0, b = 1, sel = 1] --> MUX
        IN7[Test a = 1, b = 0, sel = 1] --> MUX
        IN8[Test a = 1, b = 1, sel = 1] --> MUX
    end","`timescale 1ns/1ps

module mux_2to1 (
    input wire a,
    input wire b,
    input wire sel,
    output reg out
);

always @(*) begin
    if (sel)
        out = b;
    else
        out = a;
end

endmodule

module testbench;
    reg a, b, sel;
    wire out;
    
    mux_2to1 dut (
        .a(a),
        .b(b),
        .sel(sel),
        .out(out)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        // Test a = 0, b = 0, sel = 0
        a = 0; b = 0; sel = 0;
        #10;
        
        // Test a = 0, b = 1, sel = 0
        a = 0; b = 1; sel = 0;
        #10;
        
        // Test a = 1, b = 0, sel = 0
        a = 1; b = 0; sel = 0;
        #10;
        
        // Test a = 1, b = 1, sel = 0
        a = 1; b = 1; sel = 0;
        #10;
        
        // Test a = 0, b = 0, sel = 1
        a = 0; b = 0; sel = 1;
        #10;
        
        // Test a = 0, b = 1, sel = 1
        a = 0; b = 1; sel = 1;
        #10;
        
        // Test a = 1, b = 0, sel = 1
        a = 1; b = 0; sel = 1;
        #10;
        
        // Test a = 1, b = 1, sel = 1
        a = 1; b = 1; sel = 1;
        #10;
        
        $finish;
    end
    
    initial begin
        $monitor(""Time=%0t a=%b b=%b sel=%b out=%b"", 
                 $time, a, b, sel, out);
    end
endmodule",True,73,True,True,True,False,0.4,False,11.000362873077393,6.850062847137451,"Design a 2-to-1 multiplexer with inputs a, b, select sel, and output out. Include testbench testing all combinations.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph LR
    A[a] --> MUX{2-to-1 MUX}
    B[b] --> MUX
    SEL[sel] --> MUX
    MUX --> OUT[out]

    subgraph Testbench
        IN1[Test a = 0, b = 0, sel = 0] --> MUX
        IN2[Test a = 0, b = 1, sel = 0] --> MUX
        IN3[Test a = 1, b = 0, sel = 0] --> MUX
        IN4[Test a = 1, b = 1, sel = 0] --> MUX
        IN5[Test a = 0, b = 0, sel = 1] --> MUX
        IN6[Test a = 0, b = 1, sel = 1] --> MUX
        IN7[Test a = 1, b = 0, sel = 1] --> MUX
        IN8[Test a = 1, b = 1, sel = 1] --> MUX
    end
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module mux_2to1(
    input wire a,
    input wire b,
    input wire sel,
    output wire out
);

assign out = sel ? b : a;

endmodule

module testbench;
    reg a, b, sel;
    wire out;

    mux_2to1 dut (
        .a(a),
        .b(b),
        .sel(sel),
        .out(out)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        $monitor(""Time=%0t a=%b b=%b sel=%b out=%b"", $time, a, b, sel, out);

        // Test a = 0, b = 0, sel = 0
        a = 0; b = 0; sel = 0;
        #10;

        // Test a = 0, b = 1, sel = 0
        a = 0; b = 1; sel = 0;
        #10;

        // Test a = 1, b = 0, sel = 0
        a = 1; b = 0; sel = 0;
        #10;

        // Test a = 1, b = 1, sel = 0
        a = 1; b = 1; sel = 0;
        #10;

        // Test a = 0, b = 0, sel = 1
        a = 0; b = 0; sel = 1;
        #10;

        // Test a = 0, b = 1, sel = 1
        a = 0; b = 1; sel = 1;
        #10;

        // Test a = 1, b = 0, sel = 1
        a = 1; b = 0; sel = 1;
        #10;

        // Test a = 1, b = 1, sel = 1
        a = 1; b = 1; sel = 1;
        #10;

        $finish;
    end
endmodule",True,65,True,True,True,False,0.4,False,6.007907390594482,8.555989027023315,tie,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,Sequential,simple,"Create a D flip-flop with clock, reset, input d, and output q. Include testbench with timing verification.",claude,"`timescale 1ns/1ps

module dff(
    input wire clk,
    input wire rst_n,
    input wire d,
    output reg q
);

always @(posedge clk or negedge rst_n) begin
    if (!rst_n)
        q <= 1'b0;
    else
        q <= d;
end

endmodule

module testbench;
    reg clk, rst_n, d;
    wire q;
    
    dff dut (
        .clk(clk),
        .rst_n(rst_n),
        .d(d),
        .q(q)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst_n = 1'b0;
        d = 1'b0;
        
        #20 rst_n = 1'b1;
        #10 d = 1'b1;
        #10 d = 1'b0;
        #10 d = 1'b1;
        #20 rst_n = 1'b0;
        #20 rst_n = 1'b1;
        #50 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b d=%b q=%b"", 
                 $time, clk, rst_n, d, q);
    end
endmodule",True,53,True,True,True,True,0.7,True,4.640871524810791,6.568542718887329,"graph LR
    CLK[Clock] --> DFF[[D Flip-Flop]]
    RST[Reset] --> DFF
    D[Data Input] --> DFF
    DFF --> Q[Output Q]
    TB1[Testbench Setup] --> STIM([Stimulus Generator])
    STIM --> D
    STIM --> CLK
    STIM --> RST
    DFF --> VER([Timing Verification])
    CLK --> VER
    Q --> VER
    VER --> RES[Test Results]","`timescale 1ns/1ps

module dff(
    input wire clk,
    input wire rst,
    input wire d,
    output reg q
);

always @(posedge clk or posedge rst) begin
    if (rst)
        q <= 1'b0;
    else
        q <= d;
end

endmodule

module testbench;
    reg clk, rst, d;
    wire q;
    
    dff dut (
        .clk(clk),
        .rst(rst),
        .d(d),
        .q(q)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 0;
        rst = 1;
        d = 0;
        
        #10 rst = 0;
        
        #10 d = 1;
        #10 d = 0;
        #10 d = 1;
        
        #10 rst = 1;
        #10 rst = 0;
        
        #10 d = 0;
        #10 d = 1;
        
        #20 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t rst=%b d=%b q=%b"", 
                 $time, rst, d, q);
    end
endmodule",True,59,True,True,True,False,0.3,False,7.402623414993286,7.571316719055176,"Create a D flip-flop with clock, reset, input d, and output q. Include testbench with timing verification.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph LR
    CLK[Clock] --> DFF[[D Flip-Flop]]
    RST[Reset] --> DFF
    D[Data Input] --> DFF
    DFF --> Q[Output Q]
    TB1[Testbench Setup] --> STIM([Stimulus Generator])
    STIM --> D
    STIM --> CLK
    STIM --> RST
    DFF --> VER([Timing Verification])
    CLK --> VER
    Q --> VER
    VER --> RES[Test Results]
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module dff (
    input wire clk,
    input wire rst,
    input wire d,
    output reg q
);

always @(posedge clk or posedge rst) begin
    if (rst)
        q <= 1'b0;
    else
        q <= d;
end

endmodule

module testbench;
    reg clk, rst, d;
    wire q;
    
    dff dut (
        .clk(clk),
        .rst(rst),
        .d(d),
        .q(q)
    );

    initial begin
        $dumpfile(""dff.vcd"");
        $dumpvars(0, testbench);
        
        // Initialize signals
        clk = 0;
        rst = 1;
        d = 0;
        
        // Test sequence
        #20 rst = 0;
        #10 d = 1;
        #10 d = 0;
        #10 d = 1;
        #10 rst = 1;
        #10 rst = 0;
        #10 d = 0;
        #20 $finish;
    end

    always #5 clk = ~clk;

    // Timing verification
    reg [63:0] setup_time, hold_time;
    time last_d_change, last_clk_edge;
    
    always @(d) last_d_change = $time;
    always @(posedge clk) begin
        last_clk_edge = $time;
        setup_time = last_clk_edge - last_d_change;
    end
    
    initial begin
        $monitor(""Time=%0t rst=%b d=%b q=%b setup_time=%0t"",
                 $time, rst, d, q, setup_time);
    end

endmodule",True,67,True,True,True,,0.0,,6.159275770187378,0.01629161834716797,mermaid_only,mermaid_only > prompt_only > combined,prompt_only > mermaid_only > combined
combined,Sequential,simple,"Create a D flip-flop with clock, reset, input d, and output q. Include testbench with timing verification.",gpt-4o,"`timescale 1ns/1ps

module d_flip_flop(
    input wire clk,
    input wire rst_n,
    input wire d,
    output reg q
);

always @(posedge clk or negedge rst_n) begin
    if (!rst_n)
        q <= 1'b0;
    else
        q <= d;
end

endmodule

module testbench;
    reg clk, rst_n, d;
    wire q;
    
    d_flip_flop dut (
        .clk(clk),
        .rst_n(rst_n),
        .d(d),
        .q(q)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst_n = 1'b0;
        d = 1'b0;
        
        #20 rst_n = 1'b1;
        #10 d = 1'b1;
        #20 d = 1'b0;
        #20 d = 1'b1;
        #50 rst_n = 1'b0;
        #20 rst_n = 1'b1;
        #50 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b d=%b q=%b"", 
                 $time, clk, rst_n, d, q);
    end
endmodule",True,53,True,True,True,True,0.7,True,9.054438352584839,8.91908884048462,"graph LR
    CLK[Clock] --> DFF((D Flip-Flop))
    RST[Reset] --> DFF
    D[Input D] --> DFF
    DFF --> Q[Output Q]
    subgraph Testbench
        TB_CLK[Clock] --> DFF
        TB_RST[Reset] --> DFF
        TB_D[Input D] --> DFF
        TB_Q[Expected Q] --> DFF
    end","`timescale 1ns/1ps

module d_flip_flop(
    input wire clk,
    input wire rst,
    input wire d,
    output reg q
);

always @(posedge clk or posedge rst) begin
    if (rst)
        q <= 1'b0;
    else
        q <= d;
end

endmodule

module testbench;
    reg clk, rst, d;
    wire q;

    d_flip_flop dut (
        .clk(clk),
        .rst(rst),
        .d(d),
        .q(q)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 1'b0;
        rst = 1'b1;
        d = 1'b0;

        #20 rst = 1'b0;
        #10 d = 1'b1;
        #10 d = 1'b0;
        #10 d = 1'b1;
        #30 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t clk=%b rst=%b d=%b q=%b"", 
                 $time, clk, rst, d, q);
    end
endmodule",True,51,True,True,True,False,0.3,False,5.728381872177124,12.676453113555908,"Create a D flip-flop with clock, reset, input d, and output q. Include testbench with timing verification.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph LR
    CLK[Clock] --> DFF((D Flip-Flop))
    RST[Reset] --> DFF
    D[Input D] --> DFF
    DFF --> Q[Output Q]
    subgraph Testbench
        TB_CLK[Clock] --> DFF
        TB_RST[Reset] --> DFF
        TB_D[Input D] --> DFF
        TB_Q[Expected Q] --> DFF
    end
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module d_flip_flop(
    input wire clk,
    input wire rst,
    input wire d,
    output reg q
);

always @(posedge clk or posedge rst) begin
    if (rst)
        q <= 1'b0;
    else
        q <= d;
end

endmodule

module testbench;
    reg tb_clk;
    reg tb_rst;
    reg tb_d;
    wire tb_q;
    
    d_flip_flop dut (
        .clk(tb_clk),
        .rst(tb_rst),
        .d(tb_d),
        .q(tb_q)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        tb_clk = 1'b0;
        tb_rst = 1'b0;
        tb_d = 1'b0;
        
        #10 tb_rst = 1'b1;
        #10 tb_rst = 1'b0;
        #20 tb_d = 1'b1;
        #20 tb_d = 1'b0;
        #20 tb_d = 1'b1;
        #40 $finish;
    end
    
    always #5 tb_clk = ~tb_clk;
    
    initial begin
        $monitor(""Time=%0t tb_clk=%b tb_rst=%b tb_d=%b tb_q=%b"", 
                 $time, tb_clk, tb_rst, tb_d, tb_q);
    end
endmodule",True,54,True,True,True,True,0.7,True,3.4681215286254883,13.703815221786499,mermaid_only,mermaid_only > prompt_only > combined,prompt_only > mermaid_only > combined
combined,Sequential,simple,"Design a 4-bit synchronous counter with clock, reset, enable, and count[3:0]. Include testbench.",claude,"`timescale 1ns/1ps

module counter(
    input wire clk,
    input wire rst_n,
    input wire enable,
    output reg [3:0] count
);

always @(posedge clk or negedge rst_n) begin
    if (!rst_n)
        count <= 4'b0000;
    else if (enable)
        count <= count + 1'b1;
end

endmodule

module testbench;
    reg clk, rst_n, enable;
    wire [3:0] count;
    
    counter dut (
        .clk(clk),
        .rst_n(rst_n),
        .enable(enable),
        .count(count)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst_n = 1'b0;
        enable = 1'b0;
        
        #20 rst_n = 1'b1;
        #10 enable = 1'b1;
        #100 enable = 1'b0;
        #20 rst_n = 1'b0;
        #20 rst_n = 1'b1;
        #50 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b enable=%b count=%d"", 
                 $time, clk, rst_n, enable, count);
    end
endmodule",True,52,True,True,True,False,0.3,False,4.5577781200408936,7.82759428024292,"graph LR
    CLK[Clock] --> COUNTER((4-bit Counter))
    RST[Reset] --> COUNTER
    EN[Enable] --> COUNTER
    COUNTER --> COUNT[Count[3:0]]
    COUNTER --> TB[[Testbench]]
    CLK --> TB
    RST --> TB
    EN --> TB
    COUNT --> TB
    TB --> MONITOR[Monitor Count Value]
    TB --> ASSERT{Verify Count Sequence}
    ASSERT --> |Pass| RESULT[Test Pass]
    ASSERT --> |Fail| ERROR[Test Fail]","`timescale 1ns/1ps

module counter(
    input wire clk,
    input wire rst_n,
    input wire enable,
    output reg [3:0] count
);

always @(posedge clk or negedge rst_n) begin
    if (!rst_n)
        count <= 4'b0000;
    else if (enable)
        count <= count + 1'b1;
end

endmodule

module testbench;
    reg clk, rst_n, enable;
    wire [3:0] count;
    reg [3:0] expected_count;
    reg test_failed;
    
    counter dut (
        .clk(clk),
        .rst_n(rst_n),
        .enable(enable),
        .count(count)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst_n = 1'b0;
        enable = 1'b0;
        test_failed = 1'b0;
        expected_count = 4'b0000;
        
        #20 rst_n = 1'b1;
        #10 enable = 1'b1;
        
        repeat(16) begin
            @(posedge clk);
            if (count !== expected_count) begin
                $display(""Error: Count mismatch at time %0t"", $time);
                $display(""Expected: %d, Got: %d"", expected_count, count);
                test_failed = 1'b1;
            end
            expected_count = expected_count + 1'b1;
        end
        
        if (!test_failed)
            $display(""Test Passed: Counter sequence verified successfully"");
        else
            $display(""Test Failed: Counter sequence verification failed"");
            
        #20 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t rst_n=%b enable=%b count=%d"", 
                 $time, rst_n, enable, count);
    end
endmodule",True,69,True,True,True,False,0.4,False,9.692313432693481,8.8236825466156,"Design a 4-bit synchronous counter with clock, reset, enable, and count[3:0]. Include testbench.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph LR
    CLK[Clock] --> COUNTER((4-bit Counter))
    RST[Reset] --> COUNTER
    EN[Enable] --> COUNTER
    COUNTER --> COUNT[Count[3:0]]
    COUNTER --> TB[[Testbench]]
    CLK --> TB
    RST --> TB
    EN --> TB
    COUNT --> TB
    TB --> MONITOR[Monitor Count Value]
    TB --> ASSERT{Verify Count Sequence}
    ASSERT --> |Pass| RESULT[Test Pass]
    ASSERT --> |Fail| ERROR[Test Fail]
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module counter(
    input wire clk,
    input wire rst_n,
    input wire enable,
    output reg [3:0] count
);

always @(posedge clk or negedge rst_n) begin
    if (!rst_n)
        count <= 4'b0000;
    else if (enable)
        count <= count + 1'b1;
end

endmodule

module testbench;
    reg clk, rst_n, enable;
    wire [3:0] count;
    reg [3:0] expected_count;
    reg test_failed;
    
    counter dut (
        .clk(clk),
        .rst_n(rst_n),
        .enable(enable),
        .count(count)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 0;
        rst_n = 0;
        enable = 0;
        test_failed = 0;
        expected_count = 0;
        
        #10 rst_n = 1;
        #10 enable = 1;
        
        // Test sequence verification
        repeat(16) begin
            @(posedge clk);
            if (count !== expected_count) begin
                $display(""ERROR: Count mismatch at time %0t. Expected %d, Got %d"",
                         $time, expected_count, count);
                test_failed = 1;
            end
            expected_count = expected_count + 1;
        end
        
        if (!test_failed)
            $display(""TEST PASSED: Counter sequence verified correctly"");
        else
            $display(""TEST FAILED: Counter sequence verification failed"");
            
        #10 enable = 0;
        #10 rst_n = 0;
        #10 $finish;
    end
    
    always #5 clk = ~clk;
    
    always @(posedge clk) begin
        $display(""Time=%0t rst_n=%b enable=%b count=%d"",
                 $time, rst_n, enable, count);
    end
    
endmodule",True,73,True,True,True,False,0.4,False,6.746453523635864,7.818451881408691,tie,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,Sequential,simple,"Design a 4-bit synchronous counter with clock, reset, enable, and count[3:0]. Include testbench.",gpt-4o,"`timescale 1ns/1ps

module counter(
    input wire clk,
    input wire rst_n,
    input wire enable,
    output reg [3:0] count
);

always @(posedge clk or negedge rst_n) begin
    if (!rst_n)
        count <= 4'b0000;
    else if (enable)
        count <= count + 1'b1;
end

endmodule

module testbench;
    reg clk, rst_n, enable;
    wire [3:0] count;
    
    counter dut (
        .clk(clk),
        .rst_n(rst_n),
        .enable(enable),
        .count(count)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst_n = 1'b0;
        enable = 1'b0;
        
        #20 rst_n = 1'b1;
        #10 enable = 1'b1;
        #100 enable = 1'b0;
        #20 rst_n = 1'b0;
        #20 rst_n = 1'b1;
        #50 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b enable=%b count=%d"", 
                 $time, clk, rst_n, enable, count);
    end
endmodule",True,52,True,True,True,False,0.3,False,3.4963462352752686,12.840839385986328,"graph TD
    CLK[Clock] --> COUNTER(Counter Logic)
    RST[Reset] --> COUNTER
    EN[Enable] --> COUNTER
    COUNTER --> COUNT[[Count[3:0]]]
    subgraph Testbench
        CLK_TB[Clock] --> COUNTER_TB(Counter Logic)
        RST_TB[Reset] --> COUNTER_TB
        EN_TB[Enable] --> COUNTER_TB
        COUNTER_TB --> COUNT_TB[[Count[3:0]]]
    end","`timescale 1ns/1ps

module counter(
    input wire clk,
    input wire rst,
    input wire enable,
    output reg [3:0] count
);

always @(posedge clk or posedge rst) begin
    if (rst)
        count <= 4'b0000;
    else if (enable)
        count <= count + 1'b1;
end

endmodule

module testbench;
    reg clk, rst, enable;
    wire [3:0] count;
    
    counter dut (
        .clk(clk),
        .rst(rst),
        .enable(enable),
        .count(count)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst = 1'b1;
        enable = 1'b0;
        
        #20 rst = 1'b0;
        #10 enable = 1'b1;
        #100 enable = 1'b0;
        #20 rst = 1'b1;
        #20 rst = 1'b0;
        #50 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t clk=%b rst=%b enable=%b count=%d"", 
                 $time, clk, rst, enable, count);
    end
endmodule",True,52,True,True,True,False,0.3,False,9.07345724105835,9.639254808425903,"Design a 4-bit synchronous counter with clock, reset, enable, and count[3:0]. Include testbench.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph TD
    CLK[Clock] --> COUNTER(Counter Logic)
    RST[Reset] --> COUNTER
    EN[Enable] --> COUNTER
    COUNTER --> COUNT[[Count[3:0]]]
    subgraph Testbench
        CLK_TB[Clock] --> COUNTER_TB(Counter Logic)
        RST_TB[Reset] --> COUNTER_TB
        EN_TB[Enable] --> COUNTER_TB
        COUNTER_TB --> COUNT_TB[[Count[3:0]]]
    end
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module counter(
    input wire clk,
    input wire rst,
    input wire en,
    output reg [3:0] count
);

always @(posedge clk or posedge rst) begin
    if (rst)
        count <= 4'b0000;
    else if (en)
        count <= count + 1'b1;
end

endmodule

module testbench;
    reg clk, rst, en;
    wire [3:0] count;
    
    counter dut (
        .clk(clk),
        .rst(rst),
        .en(en),
        .count(count)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst = 1'b1;
        en = 1'b0;
        
        #20 rst = 1'b0;
        #10 en = 1'b1;
        #100 en = 1'b0;
        #20 rst = 1'b1;
        #20 rst = 1'b0;
        #50 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t clk=%b rst=%b en=%b count=%d"", 
                 $time, clk, rst, en, count);
    end
endmodule",True,52,True,True,True,False,0.3,False,2.8614070415496826,9.94931411743164,tie,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,Combinational,simple,"Create a full adder with inputs a, b, cin and outputs sum, cout. Include testbench with all 8 cases.",claude,"`timescale 1ns/1ps

module full_adder(
    input wire a,
    input wire b,
    input wire cin,
    output wire sum,
    output wire cout
);

assign sum = a ^ b ^ cin;
assign cout = (a & b) | (b & cin) | (a & cin);

endmodule

module testbench;
    reg a, b, cin;
    wire sum, cout;

    full_adder dut(
        .a(a),
        .b(b),
        .cin(cin),
        .sum(sum),
        .cout(cout)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        // Test all 8 input combinations
        {a, b, cin} = 3'b000; #10;
        {a, b, cin} = 3'b001; #10;
        {a, b, cin} = 3'b010; #10;
        {a, b, cin} = 3'b011; #10;
        {a, b, cin} = 3'b100; #10;
        {a, b, cin} = 3'b101; #10;
        {a, b, cin} = 3'b110; #10;
        {a, b, cin} = 3'b111; #10;

        $finish;
    end

    initial begin
        $monitor(""Time=%0t a=%b b=%b cin=%b sum=%b cout=%b"",
                 $time, a, b, cin, sum, cout);
    end

endmodule",True,50,True,True,True,False,0.4,False,4.709482908248901,6.112629175186157,"graph TD
    A[Input A] --> FA((Full Adder))
    B[Input B] --> FA
    CIN[Carry In] --> FA
    FA --> SUM[Sum Out]
    FA --> COUT[Carry Out]
    TB[[TestBench Cases]]
    TB --> T0((0,0,0=0,0))
    TB --> T1((0,0,1=1,0))
    TB --> T2((0,1,0=1,0))
    TB --> T3((0,1,1=0,1))
    TB --> T4((1,0,0=1,0))
    TB --> T5((1,0,1=0,1))
    TB --> T6((1,1,0=0,1))
    TB --> T7((1,1,1=1,1))
    T0 --> V{Verify}
    T1 --> V
    T2 --> V
    T3 --> V
    T4 --> V
    T5 --> V
    T6 --> V
    T7 --> V","`timescale 1ns/1ps

module full_adder(
    input wire a,
    input wire b,
    input wire cin,
    output wire sum,
    output wire cout
);

assign sum = a ^ b ^ cin;
assign cout = (a & b) | (b & cin) | (a & cin);

endmodule

module testbench;
    reg a, b, cin;
    wire sum, cout;

    full_adder dut(
        .a(a),
        .b(b),
        .cin(cin),
        .sum(sum),
        .cout(cout)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        // Test case 0: 0,0,0
        a = 0; b = 0; cin = 0; #10;
        if (sum !== 0 || cout !== 0) $display(""Test 0 failed"");

        // Test case 1: 0,0,1
        a = 0; b = 0; cin = 1; #10;
        if (sum !== 1 || cout !== 0) $display(""Test 1 failed"");

        // Test case 2: 0,1,0
        a = 0; b = 1; cin = 0; #10;
        if (sum !== 1 || cout !== 0) $display(""Test 2 failed"");

        // Test case 3: 0,1,1
        a = 0; b = 1; cin = 1; #10;
        if (sum !== 0 || cout !== 1) $display(""Test 3 failed"");

        // Test case 4: 1,0,0
        a = 1; b = 0; cin = 0; #10;
        if (sum !== 1 || cout !== 0) $display(""Test 4 failed"");

        // Test case 5: 1,0,1
        a = 1; b = 0; cin = 1; #10;
        if (sum !== 0 || cout !== 1) $display(""Test 5 failed"");

        // Test case 6: 1,1,0
        a = 1; b = 1; cin = 0; #10;
        if (sum !== 0 || cout !== 1) $display(""Test 6 failed"");

        // Test case 7: 1,1,1
        a = 1; b = 1; cin = 1; #10;
        if (sum !== 1 || cout !== 1) $display(""Test 7 failed"");

        #10 $finish;
    end

    initial begin
        $monitor(""Time=%0t a=%b b=%b cin=%b sum=%b cout=%b"", 
                 $time, a, b, cin, sum, cout);
    end
endmodule",True,71,True,True,True,False,0.4,False,11.968690156936646,7.0111353397369385,"Create a full adder with inputs a, b, cin and outputs sum, cout. Include testbench with all 8 cases.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph TD
    A[Input A] --> FA((Full Adder))
    B[Input B] --> FA
    CIN[Carry In] --> FA
    FA --> SUM[Sum Out]
    FA --> COUT[Carry Out]
    TB[[TestBench Cases]]
    TB --> T0((0,0,0=0,0))
    TB --> T1((0,0,1=1,0))
    TB --> T2((0,1,0=1,0))
    TB --> T3((0,1,1=0,1))
    TB --> T4((1,0,0=1,0))
    TB --> T5((1,0,1=0,1))
    TB --> T6((1,1,0=0,1))
    TB --> T7((1,1,1=1,1))
    T0 --> V{Verify}
    T1 --> V
    T2 --> V
    T3 --> V
    T4 --> V
    T5 --> V
    T6 --> V
    T7 --> V
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module full_adder (
    input wire a,
    input wire b,
    input wire cin,
    output wire sum,
    output wire cout
);

assign sum = a ^ b ^ cin;
assign cout = (a & b) | (b & cin) | (a & cin);

endmodule

module testbench;
    reg a, b, cin;
    wire sum, cout;
    
    full_adder dut (
        .a(a),
        .b(b),
        .cin(cin),
        .sum(sum),
        .cout(cout)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        // Test case 0: 0,0,0 = 0,0
        a = 0; b = 0; cin = 0;
        #10;
        
        // Test case 1: 0,0,1 = 1,0
        a = 0; b = 0; cin = 1;
        #10;
        
        // Test case 2: 0,1,0 = 1,0
        a = 0; b = 1; cin = 0;
        #10;
        
        // Test case 3: 0,1,1 = 0,1
        a = 0; b = 1; cin = 1;
        #10;
        
        // Test case 4: 1,0,0 = 1,0
        a = 1; b = 0; cin = 0;
        #10;
        
        // Test case 5: 1,0,1 = 0,1
        a = 1; b = 0; cin = 1;
        #10;
        
        // Test case 6: 1,1,0 = 0,1
        a = 1; b = 1; cin = 0;
        #10;
        
        // Test case 7: 1,1,1 = 1,1
        a = 1; b = 1; cin = 1;
        #10;
        
        $finish;
    end
    
    initial begin
        $monitor(""Time=%0t a=%b b=%b cin=%b sum=%b cout=%b"",
                 $time, a, b, cin, sum, cout);
    end
endmodule",True,71,True,True,True,False,0.4,False,6.892034530639648,6.732221364974976,tie,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,Combinational,simple,"Create a full adder with inputs a, b, cin and outputs sum, cout. Include testbench with all 8 cases.",gpt-4o,"`timescale 1ns/1ps

module full_adder(
    input wire a,
    input wire b,
    input wire cin,
    output wire sum,
    output wire cout
);

assign sum = a ^ b ^ cin;
assign cout = (a & b) | (b & cin) | (cin & a);

endmodule

module testbench;
    reg a, b, cin;
    wire sum, cout;
    
    full_adder dut (
        .a(a),
        .b(b),
        .cin(cin),
        .sum(sum),
        .cout(cout)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        a = 0; b = 0; cin = 0;
        #10 a = 0; b = 0; cin = 1;
        #10 a = 0; b = 1; cin = 0;
        #10 a = 0; b = 1; cin = 1;
        #10 a = 1; b = 0; cin = 0;
        #10 a = 1; b = 0; cin = 1;
        #10 a = 1; b = 1; cin = 0;
        #10 a = 1; b = 1; cin = 1;
        #10 $finish;
    end
    
    initial begin
        $monitor(""Time=%0t a=%b b=%b cin=%b sum=%b cout=%b"", 
                 $time, a, b, cin, sum, cout);
    end
endmodule",True,47,True,True,True,False,0.4,False,4.312452793121338,10.103047132492065,"graph LR
    A[a] --> XOR1
    B[b] --> XOR1
    CIN[cin] --> AND1
    CIN --> AND2
    XOR1((XOR)) --> XOR2
    XOR1 --> AND1
    XOR1 --> AND3
    AND1((AND)) --> OR1
    OR1((OR)) --> COUT[cout]
    AND2((AND)) --> OR1
    AND3((AND)) --> OR1
    XOR2((XOR)) --> SUM[sum]
    TB[Testbench] --> A
    TB --> B
    TB --> CIN","`timescale 1ns/1ps

module full_adder(
    input wire a,
    input wire b,
    input wire cin,
    output wire sum,
    output wire cout
);
    wire xor1_out, and1_out, and2_out, and3_out;

    assign xor1_out = a ^ b;
    assign and1_out = xor1_out & cin;
    assign and2_out = a & b;
    assign and3_out = cin & xor1_out;
    assign sum = xor1_out ^ cin;
    assign cout = and1_out | and2_out | and3_out;

endmodule

module testbench;
    reg a, b, cin;
    wire sum, cout;

    full_adder dut (
        .a(a),
        .b(b),
        .cin(cin),
        .sum(sum),
        .cout(cout)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        a = 0; b = 0; cin = 0;
        #10 a = 0; b = 0; cin = 1;
        #10 a = 0; b = 1; cin = 0;
        #10 a = 0; b = 1; cin = 1;
        #10 a = 1; b = 0; cin = 0;
        #10 a = 1; b = 0; cin = 1;
        #10 a = 1; b = 1; cin = 0;
        #10 a = 1; b = 1; cin = 1;
        #10 $finish;
    end

    initial begin
        $monitor(""Time=%0t a=%b b=%b cin=%b sum=%b cout=%b"", 
                 $time, a, b, cin, sum, cout);
    end
endmodule",True,52,True,True,True,False,0.4,False,9.651330947875977,10.60391116142273,"Create a full adder with inputs a, b, cin and outputs sum, cout. Include testbench with all 8 cases.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph LR
    A[a] --> XOR1
    B[b] --> XOR1
    CIN[cin] --> AND1
    CIN --> AND2
    XOR1((XOR)) --> XOR2
    XOR1 --> AND1
    XOR1 --> AND3
    AND1((AND)) --> OR1
    OR1((OR)) --> COUT[cout]
    AND2((AND)) --> OR1
    AND3((AND)) --> OR1
    XOR2((XOR)) --> SUM[sum]
    TB[Testbench] --> A
    TB --> B
    TB --> CIN
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module full_adder(
    input wire a,
    input wire b,
    input wire cin,
    output wire sum,
    output wire cout
);

wire xor1_out, and1_out, and2_out, and3_out;

assign xor1_out = a ^ b;
assign and1_out = xor1_out & cin;
assign and2_out = cin & b;
assign and3_out = xor1_out & b;
assign sum = xor1_out ^ cin;
assign cout = and1_out | and2_out | and3_out;

endmodule

module testbench;
    reg a, b, cin;
    wire sum, cout;

    full_adder dut (
        .a(a),
        .b(b),
        .cin(cin),
        .sum(sum),
        .cout(cout)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        a = 0; b = 0; cin = 0;
        #10 a = 0; b = 0; cin = 1;
        #10 a = 0; b = 1; cin = 0;
        #10 a = 0; b = 1; cin = 1;
        #10 a = 1; b = 0; cin = 0;
        #10 a = 1; b = 0; cin = 1;
        #10 a = 1; b = 1; cin = 0;
        #10 a = 1; b = 1; cin = 1;
        #10 $finish;
    end

    initial begin
        $monitor(""Time=%0t a=%b b=%b cin=%b sum=%b cout=%b"", 
                 $time, a, b, cin, sum, cout);
    end
endmodule",True,53,True,True,True,False,0.4,False,4.603017330169678,8.513117551803589,tie,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,Combinational,simple,"Design a 2-bit comparator with inputs a[1:0], b[1:0] and outputs eq, gt, lt. Include testbench.",claude,"`timescale 1ns/1ps

module comparator(
    input wire [1:0] a,
    input wire [1:0] b,
    output reg eq,
    output reg gt,
    output reg lt
);

always @(*) begin
    eq = (a == b);
    gt = (a > b);
    lt = (a < b);
end

endmodule

module testbench;
    reg [1:0] a, b;
    wire eq, gt, lt;
    
    comparator dut (
        .a(a),
        .b(b),
        .eq(eq),
        .gt(gt),
        .lt(lt)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        // Test all possible combinations
        a = 2'b00; b = 2'b00; #10;
        a = 2'b00; b = 2'b01; #10;
        a = 2'b00; b = 2'b10; #10;
        a = 2'b00; b = 2'b11; #10;
        a = 2'b01; b = 2'b00; #10;
        a = 2'b01; b = 2'b01; #10;
        a = 2'b01; b = 2'b10; #10;
        a = 2'b01; b = 2'b11; #10;
        a = 2'b10; b = 2'b00; #10;
        a = 2'b10; b = 2'b01; #10;
        a = 2'b10; b = 2'b10; #10;
        a = 2'b10; b = 2'b11; #10;
        a = 2'b11; b = 2'b00; #10;
        a = 2'b11; b = 2'b01; #10;
        a = 2'b11; b = 2'b10; #10;
        a = 2'b11; b = 2'b11; #10;
        
        $finish;
    end
    
    initial begin
        $monitor(""Time=%0t a=%b b=%b eq=%b gt=%b lt=%b"", 
                 $time, a, b, eq, gt, lt);
    end
endmodule",True,60,True,True,True,False,0.4,False,6.805031776428223,7.7604124546051025,"graph LR
    A[a1:0] --> COMP((2-bit Comparator))
    B[b1:0] --> COMP
    COMP --> EQ[eq]
    COMP --> GT[gt]
    COMP --> LT[lt]
    TB[Testbench] -.-> A
    TB -.-> B
    EQ -.-> TV{Test Verify}
    GT -.-> TV
    LT -.-> TV
    TV -.-> TB
    CLK[Clock] --> TB
    RST[Reset] --> TB","`timescale 1ns/1ps

module comparator(
    input wire [1:0] a,
    input wire [1:0] b,
    output reg eq,
    output reg gt,
    output reg lt
);

always @(*) begin
    eq = (a == b);
    gt = (a > b);
    lt = (a < b);
end

endmodule

module testbench;
    reg [1:0] a, b;
    reg clk, rst_n;
    wire eq, gt, lt;

    comparator dut (
        .a(a),
        .b(b),
        .eq(eq),
        .gt(gt),
        .lt(lt)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 0;
        rst_n = 0;
        a = 2'b00;
        b = 2'b00;

        #10 rst_n = 1;

        // Test all combinations
        #10 a = 2'b00; b = 2'b00;
        #10 a = 2'b00; b = 2'b01;
        #10 a = 2'b01; b = 2'b00;
        #10 a = 2'b01; b = 2'b01;
        #10 a = 2'b10; b = 2'b01;
        #10 a = 2'b11; b = 2'b10;
        
        #10 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t a=%b b=%b eq=%b gt=%b lt=%b"",
                 $time, a, b, eq, gt, lt);
    end
endmodule",True,60,True,True,True,False,0.4,False,8.456080436706543,7.3550848960876465,"Design a 2-bit comparator with inputs a[1:0], b[1:0] and outputs eq, gt, lt. Include testbench.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph LR
    A[a1:0] --> COMP((2-bit Comparator))
    B[b1:0] --> COMP
    COMP --> EQ[eq]
    COMP --> GT[gt]
    COMP --> LT[lt]
    TB[Testbench] -.-> A
    TB -.-> B
    EQ -.-> TV{Test Verify}
    GT -.-> TV
    LT -.-> TV
    TV -.-> TB
    CLK[Clock] --> TB
    RST[Reset] --> TB
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module comparator(
    input wire [1:0] a,
    input wire [1:0] b,
    output reg eq,
    output reg gt,
    output reg lt
);

always @(*) begin
    eq = (a == b);
    gt = (a > b);
    lt = (a < b);
end

endmodule

module testbench;
    reg [1:0] a, b;
    wire eq, gt, lt;
    reg clk, rst;
    
    comparator dut (
        .a(a),
        .b(b),
        .eq(eq),
        .gt(gt),
        .lt(lt)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 0;
        rst = 1;
        a = 2'b00;
        b = 2'b00;
        
        #10 rst = 0;
        
        // Test case 1: a = b
        #10 a = 2'b00; b = 2'b00;
        
        // Test case 2: a > b
        #10 a = 2'b10; b = 2'b01;
        
        // Test case 3: a < b
        #10 a = 2'b01; b = 2'b11;
        
        // Test case 4: Different combination
        #10 a = 2'b11; b = 2'b10;
        
        #10 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t rst=%b a=%b b=%b eq=%b gt=%b lt=%b"",
                 $time, rst, a, b, eq, gt, lt);
    end
    
    // Verification
    always @(posedge clk) begin
        if (!rst) begin
            if (eq && (a != b)) $display(""Error: eq wrong at time %0t"", $time);
            if (gt && (a <= b)) $display(""Error: gt wrong at time %0t"", $time);
            if (lt && (a >= b)) $display(""Error: lt wrong at time %0t"", $time);
        end
    end
    
endmodule",True,74,True,True,True,False,0.4,False,7.619990348815918,6.575414657592773,tie,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,Combinational,simple,"Design a 2-bit comparator with inputs a[1:0], b[1:0] and outputs eq, gt, lt. Include testbench.",gpt-4o,"`timescale 1ns/1ps

module comparator_2bit(
    input wire [1:0] a,
    input wire [1:0] b,
    output reg eq,
    output reg gt,
    output reg lt
);

always @(*) begin
    if (a == b) begin
        eq = 1'b1;
        gt = 1'b0;
        lt = 1'b0;
    end else if (a > b) begin
        eq = 1'b0;
        gt = 1'b1;
        lt = 1'b0;
    end else begin
        eq = 1'b0;
        gt = 1'b0;
        lt = 1'b1;
    end
end

endmodule

module testbench;
    reg [1:0] a, b;
    wire eq, gt, lt;

    comparator_2bit dut (
        .a(a),
        .b(b),
        .eq(eq),
        .gt(gt),
        .lt(lt)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        a = 2'b00; b = 2'b00;
        #10 a = 2'b01; b = 2'b00;
        #10 a = 2'b01; b = 2'b01;
        #10 a = 2'b10; b = 2'b01;
        #10 a = 2'b10; b = 2'b10;
        #10 a = 2'b11; b = 2'b10;
        #10 a = 2'b11; b = 2'b11;
        #10 a = 2'b00; b = 2'b01;
        #10 a = 2'b01; b = 2'b10;
        #10 a = 2'b10; b = 2'b11;
        #10 $finish;
    end

    initial begin
        $monitor(""Time=%0t a=%b b=%b eq=%b gt=%b lt=%b"", 
                 $time, a, b, eq, gt, lt);
    end
endmodule",True,62,True,True,True,False,0.4,False,6.195302486419678,6.830478191375732,"graph LR
    A[a[1:0]] --> CMP(Comparator)
    B[b[1:0]] --> CMP
    CMP --> EQ[eq]
    CMP --> GT[gt]
    CMP --> LT[lt]
    
    subgraph Testbench
        TB_A[Test Input a[1:0]] --> TB_CMP
        TB_B[Test Input b[1:0]] --> TB_CMP
        TB_CMP(Comparator)
        TB_CMP --> TB_EQ[Test eq]
        TB_CMP --> TB_GT[Test gt]
        TB_CMP --> TB_LT[Test lt]
    end","`timescale 1ns/1ps

module comparator(
    input wire [1:0] a,
    input wire [1:0] b,
    output reg eq,
    output reg gt,
    output reg lt
);

always @* begin
    eq = (a == b);
    gt = (a > b);
    lt = (a < b);
end

endmodule

module testbench;
    reg [1:0] a;
    reg [1:0] b;
    wire eq;
    wire gt;
    wire lt;
    
    comparator dut (
        .a(a),
        .b(b),
        .eq(eq),
        .gt(gt),
        .lt(lt)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        a = 2'b00; b = 2'b00;
        #10 a = 2'b01; b = 2'b00;
        #10 a = 2'b10; b = 2'b01;
        #10 a = 2'b11; b = 2'b10;
        #10 a = 2'b01; b = 2'b01;
        #10 a = 2'b10; b = 2'b11;
        #10 a = 2'b00; b = 2'b01;
        #10 $finish;
    end
    
    initial begin
        $monitor(""Time=%0t a=%b b=%b eq=%b gt=%b lt=%b"", 
                 $time, a, b, eq, gt, lt);
    end
endmodule",True,52,True,True,True,False,0.4,False,8.450205326080322,11.77858304977417,"Design a 2-bit comparator with inputs a[1:0], b[1:0] and outputs eq, gt, lt. Include testbench.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph LR
    A[a[1:0]] --> CMP(Comparator)
    B[b[1:0]] --> CMP
    CMP --> EQ[eq]
    CMP --> GT[gt]
    CMP --> LT[lt]
    
    subgraph Testbench
        TB_A[Test Input a[1:0]] --> TB_CMP
        TB_B[Test Input b[1:0]] --> TB_CMP
        TB_CMP(Comparator)
        TB_CMP --> TB_EQ[Test eq]
        TB_CMP --> TB_GT[Test gt]
        TB_CMP --> TB_LT[Test lt]
    end
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module comparator(
    input wire [1:0] a,
    input wire [1:0] b,
    output reg eq,
    output reg gt,
    output reg lt
);

always @(*) begin
    if (a == b) begin
        eq = 1'b1;
        gt = 1'b0;
        lt = 1'b0;
    end else if (a > b) begin
        eq = 1'b0;
        gt = 1'b1;
        lt = 1'b0;
    end else begin
        eq = 1'b0;
        gt = 1'b0;
        lt = 1'b1;
    end
end

endmodule

module testbench;
    reg [1:0] a;
    reg [1:0] b;
    wire eq;
    wire gt;
    wire lt;
    
    comparator dut (
        .a(a),
        .b(b),
        .eq(eq),
        .gt(gt),
        .lt(lt)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        a = 2'b00; b = 2'b00;
        #10 a = 2'b01; b = 2'b00;
        #10 a = 2'b01; b = 2'b01;
        #10 a = 2'b10; b = 2'b11;
        #10 a = 2'b11; b = 2'b10;
        #10 a = 2'b11; b = 2'b11;
        #10 $finish;
    end
    
    initial begin
        $monitor(""Time=%0t a=%b b=%b eq=%b gt=%b lt=%b"", 
                 $time, a, b, eq, gt, lt);
    end
endmodule",True,61,True,True,True,False,0.4,False,4.1855628490448,6.198824644088745,tie,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,Arithmetic,medium,"Design a 4-bit ALU supporting ADD, SUB, AND, OR operations. Inputs: a[3:0], b[3:0], op[1:0]. Outputs: result[3:0], zero. Include testbench.",claude,"`timescale 1ns/1ps

module alu(
    input wire [3:0] a,
    input wire [3:0] b,
    input wire [1:0] op,
    output reg [3:0] result,
    output wire zero
);

assign zero = (result == 4'b0000);

always @(*) begin
    case(op)
        2'b00: result = a + b;    // ADD
        2'b01: result = a - b;    // SUB
        2'b10: result = a & b;    // AND
        2'b11: result = a | b;    // OR
        default: result = 4'b0000;
    endcase
end

endmodule

module testbench;
    reg [3:0] a, b;
    reg [1:0] op;
    wire [3:0] result;
    wire zero;

    alu dut(
        .a(a),
        .b(b),
        .op(op),
        .result(result),
        .zero(zero)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        // Test ADD
        a = 4'b0011; b = 4'b0010; op = 2'b00;
        #10;

        // Test SUB
        a = 4'b0111; b = 4'b0011; op = 2'b01;
        #10;

        // Test AND
        a = 4'b1100; b = 4'b1010; op = 2'b10;
        #10;

        // Test OR
        a = 4'b1100; b = 4'b0011; op = 2'b11;
        #10;

        // Test zero flag
        a = 4'b0000; b = 4'b0000; op = 2'b00;
        #10;

        $finish;
    end

    initial begin
        $monitor(""Time=%0t a=%b b=%b op=%b result=%b zero=%b"",
                 $time, a, b, op, result, zero);
    end

endmodule",True,71,True,True,True,False,0.4,False,6.5345940589904785,6.889162540435791,"graph LR
    A[a[3:0]] --> ALU((ALU Core))
    B[b[3:0]] --> ALU
    OP[op[1:0]] --> ALU
    CLK[Clock] --> TB[[Testbench]]
    RST[Reset] --> TB
    ALU --> RES[result[3:0]]
    ALU --> ZERO[zero]
    
    subgraph ALU_OPS
        ADD{ADD op=00}
        SUB{SUB op=01}
        AND{AND op=10}
        OR{OR op=11}
    end
    
    ALU_OPS -.-> ALU
    
    TB --> A
    TB --> B
    TB --> OP
    RES --> TB
    ZERO --> TB","`timescale 1ns/1ps

module alu(
    input wire clk,
    input wire rst_n,
    input wire [3:0] a,
    input wire [3:0] b,
    input wire [1:0] op,
    output reg [3:0] result,
    output reg zero
);

always @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
        result <= 4'b0000;
        zero <= 1'b0;
    end
    else begin
        case (op)
            2'b00: result <= a + b;
            2'b01: result <= a - b;
            2'b10: result <= a & b;
            2'b11: result <= a | b;
        endcase
        zero <= (result == 4'b0000);
    end
end

endmodule

module testbench;
    reg clk, rst_n;
    reg [3:0] a, b;
    reg [1:0] op;
    wire [3:0] result;
    wire zero;

    alu dut (
        .clk(clk),
        .rst_n(rst_n),
        .a(a),
        .b(b),
        .op(op),
        .result(result),
        .zero(zero)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 0;
        rst_n = 0;
        a = 0;
        b = 0;
        op = 0;

        #10 rst_n = 1;

        // Test ADD
        #10 a = 4'h3; b = 4'h2; op = 2'b00;
        
        // Test SUB
        #10 a = 4'h5; b = 4'h3; op = 2'b01;
        
        // Test AND
        #10 a = 4'h7; b = 4'h3; op = 2'b10;
        
        // Test OR
        #10 a = 4'h5; b = 4'h2; op = 2'b11;

        #10 rst_n = 0;
        #10 rst_n = 1;
        
        #20 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t rst_n=%b a=%h b=%h op=%b result=%h zero=%b"",
                 $time, rst_n, a, b, op, result, zero);
    end
endmodule",True,84,True,True,True,False,0.4,False,11.11778736114502,8.664893627166748,"Design a 4-bit ALU supporting ADD, SUB, AND, OR operations. Inputs: a[3:0], b[3:0], op[1:0]. Outputs: result[3:0], zero. Include testbench.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph LR
    A[a[3:0]] --> ALU((ALU Core))
    B[b[3:0]] --> ALU
    OP[op[1:0]] --> ALU
    CLK[Clock] --> TB[[Testbench]]
    RST[Reset] --> TB
    ALU --> RES[result[3:0]]
    ALU --> ZERO[zero]
    
    subgraph ALU_OPS
        ADD{ADD op=00}
        SUB{SUB op=01}
        AND{AND op=10}
        OR{OR op=11}
    end
    
    ALU_OPS -.-> ALU
    
    TB --> A
    TB --> B
    TB --> OP
    RES --> TB
    ZERO --> TB
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module alu(
    input wire [3:0] a,
    input wire [3:0] b,
    input wire [1:0] op,
    output reg [3:0] result,
    output wire zero
);

always @(*) begin
    case(op)
        2'b00: result = a + b;    // ADD
        2'b01: result = a - b;    // SUB
        2'b10: result = a & b;    // AND
        2'b11: result = a | b;    // OR
        default: result = 4'b0000;
    endcase
end

assign zero = (result == 4'b0000);

endmodule

module testbench;
    reg clk;
    reg rst_n;
    reg [3:0] a;
    reg [3:0] b;
    reg [1:0] op;
    wire [3:0] result;
    wire zero;

    alu dut (
        .a(a),
        .b(b),
        .op(op),
        .result(result),
        .zero(zero)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 0;
        rst_n = 0;
        a = 0;
        b = 0;
        op = 0;

        #10 rst_n = 1;

        // Test ADD
        #10;
        a = 4'b0011;
        b = 4'b0010;
        op = 2'b00;

        // Test SUB
        #10;
        a = 4'b0111;
        b = 4'b0011;
        op = 2'b01;

        // Test AND
        #10;
        a = 4'b1111;
        b = 4'b0011;
        op = 2'b10;

        // Test OR
        #10;
        a = 4'b1100;
        b = 4'b0011;
        op = 2'b11;

        // Test zero flag
        #10;
        a = 4'b0000;
        b = 4'b0000;
        op = 2'b00;

        #10 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t rst_n=%b a=%b b=%b op=%b result=%b zero=%b"",
                 $time, rst_n, a, b, op, result, zero);
    end

endmodule",True,94,True,True,True,False,0.4,False,7.698284149169922,6.371880292892456,tie,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,Arithmetic,medium,"Design a 4-bit ALU supporting ADD, SUB, AND, OR operations. Inputs: a[3:0], b[3:0], op[1:0]. Outputs: result[3:0], zero. Include testbench.",gpt-4o,"`timescale 1ns/1ps

module alu(
    input wire [3:0] a,
    input wire [3:0] b,
    input wire [1:0] op,
    output reg [3:0] result,
    output wire zero
);

always @(*) begin
    case (op)
        2'b00: result = a + b; // ADD
        2'b01: result = a - b; // SUB
        2'b10: result = a & b; // AND
        2'b11: result = a | b; // OR
        default: result = 4'b0000;
    endcase
end

assign zero = (result == 4'b0000);

endmodule

module testbench;
    reg [3:0] a, b;
    reg [1:0] op;
    wire [3:0] result;
    wire zero;

    alu dut (
        .a(a),
        .b(b),
        .op(op),
        .result(result),
        .zero(zero)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        a = 4'b0000; b = 4'b0000; op = 2'b00; // Test ADD
        #10 a = 4'b0010; b = 4'b0011; op = 2'b00; // Test ADD
        #10 a = 4'b0100; b = 4'b0010; op = 2'b01; // Test SUB
        #10 a = 4'b0101; b = 4'b0011; op = 2'b10; // Test AND
        #10 a = 4'b0110; b = 4'b0010; op = 2'b11; // Test OR
        #10 $finish;
    end

    initial begin
        $monitor(""Time=%0t a=%b b=%b op=%b result=%b zero=%b"",
                 $time, a, b, op, result, zero);
    end
endmodule",True,55,True,True,True,False,0.4,False,4.812446594238281,10.284636974334717,"graph LR
    a[a[3:0]] --> ALU
    b[b[3:0]] --> ALU
    op[op[1:0]] --> ALU
    ALU(4-bit ALU)
    ALU --> result[result[3:0]]
    ALU --> zero[zero]

    subgraph Testbench
        a_test[a[3:0] Test Input] --> ALU
        b_test[b[3:0] Test Input] --> ALU
        op_test[op[1:0] Test Input] --> ALU
        result_test[result[3:0] Expected Output]
        zero_test[zero Expected Output]
    end","`timescale 1ns/1ps

module alu(
    input wire [3:0] a,
    input wire [3:0] b,
    input wire [1:0] op,
    output reg [3:0] result,
    output reg zero
);
    
    always @(*) begin
        case (op)
            2'b00: result = a + b;
            2'b01: result = a - b;
            2'b10: result = a & b;
            2'b11: result = a | b;
            default: result = 4'b0000;
        endcase
        zero = (result == 4'b0000) ? 1'b1 : 1'b0;
    end

endmodule

module testbench;
    reg [3:0] a_test;
    reg [3:0] b_test;
    reg [1:0] op_test;
    wire [3:0] result_test;
    wire zero_test;
    
    alu dut (
        .a(a_test),
        .b(b_test),
        .op(op_test),
        .result(result_test),
        .zero(zero_test)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        a_test = 4'd0;
        b_test = 4'd0;
        op_test = 2'b00;
        
        #10 a_test = 4'd3; b_test = 4'd2; op_test = 2'b00; // Add
        #10 a_test = 4'd5; b_test = 4'd5; op_test = 2'b01; // Sub
        #10 a_test = 4'd8; b_test = 4'd7; op_test = 2'b10; // And
        #10 a_test = 4'd1; b_test = 4'd14; op_test = 2'b11; // Or
        #10 $finish;
    end
    
    initial begin
        $monitor(""Time=%0t a=%b b=%b op=%b result=%b zero=%b"", 
                 $time, a_test, b_test, op_test, result_test, zero_test);
    end
endmodule",True,58,True,True,True,False,0.4,False,8.475539445877075,6.4680540561676025,"Design a 4-bit ALU supporting ADD, SUB, AND, OR operations. Inputs: a[3:0], b[3:0], op[1:0]. Outputs: result[3:0], zero. Include testbench.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph LR
    a[a[3:0]] --> ALU
    b[b[3:0]] --> ALU
    op[op[1:0]] --> ALU
    ALU(4-bit ALU)
    ALU --> result[result[3:0]]
    ALU --> zero[zero]

    subgraph Testbench
        a_test[a[3:0] Test Input] --> ALU
        b_test[b[3:0] Test Input] --> ALU
        op_test[op[1:0] Test Input] --> ALU
        result_test[result[3:0] Expected Output]
        zero_test[zero Expected Output]
    end
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module alu (
    input wire [3:0] a,
    input wire [3:0] b,
    input wire [1:0] op,
    output reg [3:0] result,
    output reg zero
);

always @(*) begin
    case (op)
        2'b00: result = a + b;    // ADD
        2'b01: result = a - b;    // SUB
        2'b10: result = a & b;    // AND
        2'b11: result = a | b;    // OR
        default: result = 4'b0000;
    endcase
    zero = (result == 4'b0000);
end

endmodule

module testbench;
    reg [3:0] a_test;
    reg [3:0] b_test;
    reg [1:0] op_test;
    wire [3:0] result_test;
    wire zero_test;
    
    alu dut (
        .a(a_test),
        .b(b_test),
        .op(op_test),
        .result(result_test),
        .zero(zero_test)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        // Test ADD
        a_test = 4'b0011; b_test = 4'b0001; op_test = 2'b00;
        #10;
        // Test SUB
        a_test = 4'b0100; b_test = 4'b0010; op_test = 2'b01;
        #10;
        // Test AND
        a_test = 4'b1100; b_test = 4'b1010; op_test = 2'b10;
        #10;
        // Test OR
        a_test = 4'b1100; b_test = 4'b1010; op_test = 2'b11;
        #10;
        // Test zero result
        a_test = 4'b0001; b_test = 4'b0001; op_test = 2'b01;
        #10;
        
        $finish;
    end
    
    initial begin
        $monitor(""Time=%0t a=%b b=%b op=%b result=%b zero=%b"", 
                 $time, a_test, b_test, op_test, result_test, zero_test);
    end
endmodule",True,66,True,True,True,False,0.4,False,5.744948148727417,11.05720043182373,tie,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,Combinational,medium,"Create an 8:1 multiplexer with input data[7:0], select sel[2:0], and output out. Include testbench.",claude,"`timescale 1ns/1ps

module mux8to1(
    input wire [7:0] data,
    input wire [2:0] sel,
    output reg out
);

always @(*) begin
    case(sel)
        3'b000: out = data[0];
        3'b001: out = data[1]; 
        3'b010: out = data[2];
        3'b011: out = data[3];
        3'b100: out = data[4];
        3'b101: out = data[5];
        3'b110: out = data[6];
        3'b111: out = data[7];
        default: out = 1'b0;
    endcase
end

endmodule

module testbench;
    reg [7:0] data;
    reg [2:0] sel;
    wire out;
    
    mux8to1 dut (
        .data(data),
        .sel(sel),
        .out(out)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        data = 8'b10101010;
        
        sel = 3'b000; #10;
        sel = 3'b001; #10;
        sel = 3'b010; #10;
        sel = 3'b011; #10;
        sel = 3'b100; #10;
        sel = 3'b101; #10;
        sel = 3'b110; #10;
        sel = 3'b111; #10;
        
        data = 8'b11110000;
        
        sel = 3'b000; #10;
        sel = 3'b111; #10;
        
        $finish;
    end
    
    initial begin
        $monitor(""Time=%0t data=%b sel=%b out=%b"", 
                 $time, data, sel, out);
    end
endmodule",True,63,True,True,True,False,0.4,False,5.896484613418579,8.022953271865845,"graph LR
    D0[Data0] --> MUX{8:1 MUX}
    D1[Data1] --> MUX
    D2[Data2] --> MUX
    D3[Data3] --> MUX
    D4[Data4] --> MUX
    D5[Data5] --> MUX
    D6[Data6] --> MUX
    D7[Data7] --> MUX
    SEL0[Select0] --> MUX
    SEL1[Select1] --> MUX
    SEL2[Select2] --> MUX
    MUX --> OUT[Output]
    TB[[Testbench]]
    TB --> D0
    TB --> D1
    TB --> D2
    TB --> D3
    TB --> D4
    TB --> D5
    TB --> D6
    TB --> D7
    TB --> SEL0
    TB --> SEL1
    TB --> SEL2
    OUT --> TB","`timescale 1ns/1ps

module mux8to1 (
    input wire clk,
    input wire rst_n,
    input wire [7:0] data_in_0,
    input wire [7:0] data_in_1,
    input wire [7:0] data_in_2,
    input wire [7:0] data_in_3,
    input wire [7:0] data_in_4,
    input wire [7:0] data_in_5,
    input wire [7:0] data_in_6,
    input wire [7:0] data_in_7,
    input wire [2:0] sel,
    output reg [7:0] data_out
);

always @(posedge clk or negedge rst_n) begin
    if (!rst_n)
        data_out <= 8'b0;
    else
        case (sel)
            3'b000: data_out <= data_in_0;
            3'b001: data_out <= data_in_1;
            3'b010: data_out <= data_in_2;
            3'b011: data_out <= data_in_3;
            3'b100: data_out <= data_in_4;
            3'b101: data_out <= data_in_5;
            3'b110: data_out <= data_in_6;
            3'b111: data_out <= data_in_7;
            default: data_out <= 8'b0;
        endcase
end

endmodule

module testbench;
    reg clk, rst_n;
    reg [7:0] data_in_0, data_in_1, data_in_2, data_in_3;
    reg [7:0] data_in_4, data_in_5, data_in_6, data_in_7;
    reg [2:0] sel;
    wire [7:0] data_out;

    mux8to1 dut (
        .clk(clk),
        .rst_n(rst_n),
        .data_in_0(data_in_0),
        .data_in_1(data_in_1),
        .data_in_2(data_in_2),
        .data_in_3(data_in_3),
        .data_in_4(data_in_4),
        .data_in_5(data_in_5),
        .data_in_6(data_in_6),
        .data_in_7(data_in_7),
        .sel(sel),
        .data_out(data_out)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 0;
        rst_n = 0;
        data_in_0 = 8'h11;
        data_in_1 = 8'h22;
        data_in_2 = 8'h33;
        data_in_3 = 8'h44;
        data_in_4 = 8'h55;
        data_in_5 = 8'h66;
        data_in_6 = 8'h77;
        data_in_7 = 8'h88;
        sel = 3'b000;

        #10 rst_n = 1;

        #10 sel = 3'b000;
        #10 sel = 3'b001;
        #10 sel = 3'b010;
        #10 sel = 3'b011;
        #10 sel = 3'b100;
        #10 sel = 3'b101;
        #10 sel = 3'b110;
        #10 sel = 3'b111;

        #10 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t sel=%b data_out=%h"", $time, sel, data_out);
    end

endmodule",True,95,True,True,True,False,0.4,False,14.639628410339355,6.602310419082642,"Create an 8:1 multiplexer with input data[7:0], select sel[2:0], and output out. Include testbench.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph LR
    D0[Data0] --> MUX{8:1 MUX}
    D1[Data1] --> MUX
    D2[Data2] --> MUX
    D3[Data3] --> MUX
    D4[Data4] --> MUX
    D5[Data5] --> MUX
    D6[Data6] --> MUX
    D7[Data7] --> MUX
    SEL0[Select0] --> MUX
    SEL1[Select1] --> MUX
    SEL2[Select2] --> MUX
    MUX --> OUT[Output]
    TB[[Testbench]]
    TB --> D0
    TB --> D1
    TB --> D2
    TB --> D3
    TB --> D4
    TB --> D5
    TB --> D6
    TB --> D7
    TB --> SEL0
    TB --> SEL1
    TB --> SEL2
    OUT --> TB
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module mux8to1(
    input wire [7:0] data,
    input wire [2:0] sel,
    output reg out
);

always @(*) begin
    case(sel)
        3'b000: out = data[0];
        3'b001: out = data[1];
        3'b010: out = data[2];
        3'b011: out = data[3];
        3'b100: out = data[4];
        3'b101: out = data[5];
        3'b110: out = data[6];
        3'b111: out = data[7];
        default: out = 1'b0;
    endcase
end

endmodule

module testbench;
    reg [7:0] data;
    reg [2:0] sel;
    wire out;

    mux8to1 dut (
        .data(data),
        .sel(sel),
        .out(out)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        data = 8'b10101010;
        sel = 3'b000;
        #10;

        sel = 3'b001;
        #10;

        data = 8'b11001100;
        sel = 3'b010;
        #10;

        sel = 3'b011;
        #10;

        data = 8'b11110000;
        sel = 3'b100;
        #10;

        sel = 3'b101;
        #10;

        data = 8'b00001111;
        sel = 3'b110;
        #10;

        sel = 3'b111;
        #10;

        $finish;
    end

    initial begin
        $monitor(""Time=%0t data=%b sel=%b out=%b"", 
                 $time, data, sel, out);
    end
endmodule",True,75,True,True,True,False,0.4,False,5.982212543487549,6.903308391571045,tie,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,Combinational,medium,"Create an 8:1 multiplexer with input data[7:0], select sel[2:0], and output out. Include testbench.",gpt-4o,"`timescale 1ns/1ps

module mux_8to1(
    input wire [7:0] data,
    input wire [2:0] sel,
    output reg out
);

always @(*) begin
    case (sel)
        3'b000: out = data[0];
        3'b001: out = data[1];
        3'b010: out = data[2];
        3'b011: out = data[3];
        3'b100: out = data[4];
        3'b101: out = data[5];
        3'b110: out = data[6];
        3'b111: out = data[7];
        default: out = 1'b0;
    endcase
end

endmodule

module testbench;
    reg [7:0] data;
    reg [2:0] sel;
    wire out;
    
    mux_8to1 dut (
        .data(data),
        .sel(sel),
        .out(out)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        data = 8'b10101010;
        sel = 3'b000;
        
        #10 sel = 3'b001;
        #10 sel = 3'b010;
        #10 sel = 3'b011;
        #10 sel = 3'b100;
        #10 sel = 3'b101;
        #10 sel = 3'b110;
        #10 sel = 3'b111;
        #10 $finish;
    end
    
    initial begin
        $monitor(""Time=%0t data=%b sel=%b out=%b"", $time, data, sel, out);
    end
endmodule",True,56,True,True,True,False,0.4,False,4.287983655929565,8.815486192703247,"graph TD
    CLK[Clock] --> MUX{8:1 MUX}
    RST[Reset] --> TB[Testbench]
    data[7:0] --> MUX
    sel[2:0] --> MUX
    MUX --> out[Output]
    TB --> data
    TB --> sel
    TB --> CLK
    TB --> RST
    out --> TB","`timescale 1ns/1ps

module mux_8to1(
    input wire clk,
    input wire [7:0] data,
    input wire [2:0] sel,
    output reg out
);

    always @(posedge clk) begin
        case (sel)
            3'b000: out <= data[0];
            3'b001: out <= data[1];
            3'b010: out <= data[2];
            3'b011: out <= data[3];
            3'b100: out <= data[4];
            3'b101: out <= data[5];
            3'b110: out <= data[6];
            3'b111: out <= data[7];
            default: out <= 1'b0;
        endcase
    end

endmodule

module testbench;
    reg clk;
    reg rst;
    reg [7:0] data;
    reg [2:0] sel;
    wire out;

    mux_8to1 dut (
        .clk(clk),
        .data(data),
        .sel(sel),
        .out(out)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 1'b0;
        rst = 1'b0;
        data = 8'b00000000;
        sel = 3'b000;

        #10 rst = 1'b1;
        #20 data = 8'b10101010; sel = 3'b000;
        #20 sel = 3'b001;
        #20 sel = 3'b010;
        #20 sel = 3'b011;
        #20 sel = 3'b100;
        #20 sel = 3'b101;
        #20 sel = 3'b110;
        #20 sel = 3'b111;
        #20 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t clk=%b rst=%b data=%b sel=%b out=%b"", 
                 $time, clk, rst, data, sel, out);
    end
endmodule",True,67,True,True,True,True,0.7,True,7.610339164733887,16.077322721481323,"Create an 8:1 multiplexer with input data[7:0], select sel[2:0], and output out. Include testbench.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph TD
    CLK[Clock] --> MUX{8:1 MUX}
    RST[Reset] --> TB[Testbench]
    data[7:0] --> MUX
    sel[2:0] --> MUX
    MUX --> out[Output]
    TB --> data
    TB --> sel
    TB --> CLK
    TB --> RST
    out --> TB
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module mux_8to1(
    input wire [7:0] data,
    input wire [2:0] sel,
    output wire out
);
    assign out = data[sel];
endmodule

module testbench;
    reg clk;
    reg rst;
    reg [7:0] data;
    reg [2:0] sel;
    wire out;
    
    mux_8to1 dut (
        .data(data),
        .sel(sel),
        .out(out)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst = 1'b0;
        data = 8'b00000000;
        sel = 3'b000;
        
        #10 rst = 1'b1;
        #10 data = 8'b11110000; sel = 3'b000;
        #10 sel = 3'b001;
        #10 sel = 3'b010;
        #10 sel = 3'b011;
        #10 sel = 3'b100;
        #10 sel = 3'b101;
        #10 sel = 3'b110;
        #10 sel = 3'b111;
        #20 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t clk=%b rst=%b data=%b sel=%b out=%b"", 
                 $time, clk, rst, data, sel, out);
    end
endmodule",True,51,True,True,True,False,0.4,False,4.380061149597168,12.992269515991211,tie,prompt_only > combined > mermaid_only,prompt_only > mermaid_only > combined
combined,State Machine,medium,Design an FSM detecting pattern 1011 in serial input with overlapping detection. Include testbench with sequence: 10110111011.,claude,"`timescale 1ns/1ps

module sequence_detector(
    input wire clk,
    input wire rst_n,
    input wire data_in,
    output reg detected
);

reg [2:0] state;
reg [2:0] next_state;

parameter S0 = 3'b000;
parameter S1 = 3'b001;
parameter S2 = 3'b010;
parameter S3 = 3'b011;

always @(posedge clk or negedge rst_n) begin
    if (!rst_n)
        state <= S0;
    else
        state <= next_state;
end

always @(*) begin
    case (state)
        S0: next_state = (data_in) ? S1 : S0;
        S1: next_state = (data_in) ? S1 : S2;
        S2: next_state = (data_in) ? S3 : S0;
        S3: next_state = (data_in) ? S1 : S2;
        default: next_state = S0;
    endcase
end

always @(posedge clk or negedge rst_n) begin
    if (!rst_n)
        detected <= 1'b0;
    else
        detected <= (state == S3 && data_in == 1'b1);
end

endmodule

module testbench;
    reg clk;
    reg rst_n;
    reg data_in;
    wire detected;
    
    sequence_detector dut (
        .clk(clk),
        .rst_n(rst_n),
        .data_in(data_in),
        .detected(detected)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 0;
        rst_n = 0;
        data_in = 0;
        
        #10 rst_n = 1;
        
        // Test sequence: 10110111011
        #10 data_in = 1;
        #10 data_in = 0;
        #10 data_in = 1;
        #10 data_in = 1;
        #10 data_in = 0;
        #10 data_in = 1;
        #10 data_in = 1;
        #10 data_in = 1;
        #10 data_in = 0;
        #10 data_in = 1;
        #10 data_in = 1;
        
        #20 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t rst_n=%b data_in=%b detected=%b"", 
                 $time, rst_n, data_in, detected);
    end
endmodule",True,89,True,True,True,False,0.3,False,8.84805417060852,7.79748272895813,"graph LR
    CLK[Clock] --> FSM((FSM Logic))
    RST[Reset] --> FSM
    DIN[Serial Input] --> FSM
    FSM --> VALID[Pattern Detected]

    TB[Testbench] --> |10110111011| DIN
    CLK --> TB
    RST --> TB

    FSM --> |S0| ST[[IDLE]]
    FSM --> |S1| ST1[[Got1]]
    FSM --> |S2| ST2[[Got10]]
    FSM --> |S3| ST3[[Got101]]
    FSM --> |S4| ST4[[Got1011]]

    ST --> |1| ST1
    ST --> |0| ST
    ST1 --> |0| ST2
    ST1 --> |1| ST1
    ST2 --> |1| ST3
    ST2 --> |0| ST
    ST3 --> |1| ST4
    ST3 --> |0| ST
    ST4 --> |1| ST1
    ST4 --> |0| ST2","`timescale 1ns/1ps

module pattern_detector(
    input wire clk,
    input wire rst,
    input wire din,
    output reg valid
);

// State encoding
parameter S0_IDLE  = 3'd0;
parameter S1_GOT1  = 3'd1;
parameter S2_GOT10 = 3'd2;
parameter S3_GOT101 = 3'd3;
parameter S4_GOT1011 = 3'd4;

reg [2:0] state, next_state;

// State register
always @(posedge clk or posedge rst) begin
    if (rst)
        state <= S0_IDLE;
    else
        state <= next_state;
end

// Next state logic
always @(*) begin
    case (state)
        S0_IDLE: next_state = (din) ? S1_GOT1 : S0_IDLE;
        S1_GOT1: next_state = (din) ? S1_GOT1 : S2_GOT10;
        S2_GOT10: next_state = (din) ? S3_GOT101 : S0_IDLE;
        S3_GOT101: next_state = (din) ? S4_GOT1011 : S0_IDLE;
        S4_GOT1011: next_state = (din) ? S1_GOT1 : S2_GOT10;
        default: next_state = S0_IDLE;
    endcase
end

// Output logic
always @(posedge clk or posedge rst) begin
    if (rst)
        valid <= 1'b0;
    else
        valid <= (state == S4_GOT1011 && din);
end

endmodule

module testbench;
    reg clk, rst, din;
    wire valid;
    
    pattern_detector dut (
        .clk(clk),
        .rst(rst),
        .din(din),
        .valid(valid)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 0;
        rst = 1;
        din = 0;
        
        #10 rst = 0;
        
        // Test pattern ""10110111011""
        #10 din = 1;
        #10 din = 0;
        #10 din = 1;
        #10 din = 1;
        #10 din = 0;
        #10 din = 1;
        #10 din = 1;
        #10 din = 1;
        #10 din = 0;
        #10 din = 1;
        #10 din = 1;
        
        #50 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t rst=%b din=%b valid=%b state=%d"", 
                 $time, rst, din, valid, dut.state);
    end
endmodule",True,92,True,True,True,False,0.4,False,13.213716745376587,7.751620531082153,"Design an FSM detecting pattern 1011 in serial input with overlapping detection. Include testbench with sequence: 10110111011.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph LR
    CLK[Clock] --> FSM((FSM Logic))
    RST[Reset] --> FSM
    DIN[Serial Input] --> FSM
    FSM --> VALID[Pattern Detected]

    TB[Testbench] --> |10110111011| DIN
    CLK --> TB
    RST --> TB

    FSM --> |S0| ST[[IDLE]]
    FSM --> |S1| ST1[[Got1]]
    FSM --> |S2| ST2[[Got10]]
    FSM --> |S3| ST3[[Got101]]
    FSM --> |S4| ST4[[Got1011]]

    ST --> |1| ST1
    ST --> |0| ST
    ST1 --> |0| ST2
    ST1 --> |1| ST1
    ST2 --> |1| ST3
    ST2 --> |0| ST
    ST3 --> |1| ST4
    ST3 --> |0| ST
    ST4 --> |1| ST1
    ST4 --> |0| ST2
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module fsm_pattern_detector(
    input wire clk,
    input wire rst,
    input wire din,
    output reg valid
);

reg [2:0] state, next_state;
parameter IDLE = 3'd0;
parameter GOT1 = 3'd1;
parameter GOT10 = 3'd2;
parameter GOT101 = 3'd3;
parameter GOT1011 = 3'd4;

always @(posedge clk or posedge rst) begin
    if (rst)
        state <= IDLE;
    else
        state <= next_state;
end

always @(*) begin
    case (state)
        IDLE: next_state = (din) ? GOT1 : IDLE;
        GOT1: next_state = (din) ? GOT1 : GOT10;
        GOT10: next_state = (din) ? GOT101 : IDLE;
        GOT101: next_state = (din) ? GOT1011 : IDLE;
        GOT1011: next_state = (din) ? GOT1 : GOT10;
        default: next_state = IDLE;
    endcase
end

always @(posedge clk or posedge rst) begin
    if (rst)
        valid <= 1'b0;
    else
        valid <= (state == GOT1011);
end

endmodule

module testbench;
    reg clk;
    reg rst;
    reg din;
    wire valid;

    fsm_pattern_detector dut (
        .clk(clk),
        .rst(rst),
        .din(din),
        .valid(valid)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 0;
        rst = 1;
        din = 0;
        
        #10 rst = 0;
        
        // Test sequence: 10110111011
        #10 din = 1;
        #10 din = 0;
        #10 din = 1;
        #10 din = 1;
        #10 din = 0;
        #10 din = 1;
        #10 din = 1;
        #10 din = 1;
        #10 din = 0;
        #10 din = 1;
        #10 din = 1;
        
        #20 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t rst=%b din=%b valid=%b state=%d"", 
                 $time, rst, din, valid, dut.state);
    end
endmodule",True,89,True,True,True,False,0.4,False,7.989764451980591,8.64666223526001,tie,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,State Machine,medium,Design an FSM detecting pattern 1011 in serial input with overlapping detection. Include testbench with sequence: 10110111011.,gpt-4o,"`timescale 1ns/1ps

module fsm_1011_detector(
    input wire clk,
    input wire rst_n,
    input wire serial_in,
    output reg pattern_detected
);

    typedef enum reg [2:0] {
        S0 = 3'b000,
        S1 = 3'b001,
        S2 = 3'b010,
        S3 = 3'b011,
        S4 = 3'b100
    } state_t;

    state_t current_state, next_state;

    always @(posedge clk or negedge rst_n) begin
        if (!rst_n)
            current_state <= S0;
        else
            current_state <= next_state;
    end

    always @(*) begin
        next_state = current_state; // default state
        pattern_detected = 1'b0; // default output
        case (current_state)
            S0: begin
                if (serial_in)
                    next_state = S1;
            end
            S1: begin
                if (!serial_in)
                    next_state = S2;
                else
                    next_state = S1;
            end
            S2: begin
                if (serial_in)
                    next_state = S3;
                else
                    next_state = S0;
            end
            S3: begin
                if (serial_in)
                    next_state = S4;
                else
                    next_state = S2;
            end
            S4: begin
                pattern_detected = 1'b1;
                if (!serial_in)
                    next_state = S2;
            end
            default: next_state = S0;
        endcase
    end

endmodule

module testbench;
    reg clk, rst_n, serial_in;
    wire pattern_detected;
    
    fsm_1011_detector dut (
        .clk(clk),
        .rst_n(rst_n),
        .serial_in(serial_in),
        .pattern_detected(pattern_detected)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst_n = 1'b0;
        serial_in = 1'b0;
        
        #20 rst_n = 1'b1;
        #10 serial_in = 1'b1; // 1
        #10 serial_in = 1'b0; // 0
        #10 serial_in = 1'b1; // 1
        #10 serial_in = 1'b1; // 1
        #10 serial_in = 1'b0; // 0
        #10 serial_in = 1'b1; // 1
        #10 serial_in = 1'b1; // 1
        #10 serial_in = 1'b1; // 1
        #10 serial_in = 1'b0; // 0
        #10 serial_in = 1'b1; // 1
        #10 serial_in = 1'b1; // 1
        #50 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b serial_in=%b pattern_detected=%b"", 
                 $time, clk, rst_n, serial_in, pattern_detected);
    end
endmodule",True,104,True,True,True,True,0.7,True,10.761871337890625,12.164898872375488,"graph LR
    CLK[Clock] --> FSM
    RST[Reset] --> FSM
    IN[Serial Input] --> FSM
    
    subgraph FSM [Finite State Machine]
        S0((S0))
        S1((S1))
        S2((S2))
        S3((S3))
        S4((S4))
        
        S0 -->|1| S1
        S0 -->|0| S0
        S1 -->|0| S2
        S1 -->|1| S1
        S2 -->|1| S3
        S2 -->|0| S0
        S3 -->|1| S4
        S3 -->|0| S2
        S4 -->|1| S1
        S4 -->|0| S2
    end
    
    FSM --> DETECTED[Pattern Detected]

    subgraph Testbench [Testbench with sequence]
        TEST_INPUT[[10110111011]]
        CLK --> TEST_INPUT
        TEST_INPUT --> IN
    end","`timescale 1ns/1ps

module fsm(
    input wire clk,
    input wire rst_n,
    input wire serial_in,
    output reg pattern_detected
);

    // State encoding
    parameter S0 = 3'b000;
    parameter S1 = 3'b001;
    parameter S2 = 3'b010;
    parameter S3 = 3'b011;
    parameter S4 = 3'b100;

    // State registers
    reg [2:0] current_state, next_state;

    // State transition logic
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n)
            current_state <= S0;
        else
            current_state <= next_state;
    end

    // Next state logic
    always @(*) begin
        case (current_state)
            S0: next_state = (serial_in) ? S1 : S0;
            S1: next_state = (serial_in) ? S1 : S2;
            S2: next_state = (serial_in) ? S3 : S0;
            S3: next_state = (serial_in) ? S4 : S2;
            S4: next_state = (serial_in) ? S1 : S2;
            default: next_state = S0;
        endcase
    end

    // Output logic
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n)
            pattern_detected <= 1'b0;
        else
            pattern_detected <= (current_state == S4) ? 1'b1 : 1'b0;
    end

endmodule

module testbench;
    reg clk, rst_n, serial_in;
    wire pattern_detected;
    
    fsm dut (
        .clk(clk),
        .rst_n(rst_n),
        .serial_in(serial_in),
        .pattern_detected(pattern_detected)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst_n = 1'b0;
        serial_in = 1'b0;
        
        #15 rst_n = 1'b1;
        
        // Test sequence 10110111011
        #10 serial_in = 1'b1;
        #10 serial_in = 1'b0;
        #10 serial_in = 1'b1;
        #10 serial_in = 1'b1;
        #10 serial_in = 1'b0;
        #10 serial_in = 1'b1;
        #10 serial_in = 1'b1;
        #10 serial_in = 1'b1;
        #10 serial_in = 1'b0;
        #10 serial_in = 1'b1;
        #10 serial_in = 1'b1;
        
        #50 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b serial_in=%b pattern_detected=%b"", 
                 $time, clk, rst_n, serial_in, pattern_detected);
    end
endmodule",True,93,True,True,True,True,0.7,True,10.125369548797607,12.85077977180481,"Design an FSM detecting pattern 1011 in serial input with overlapping detection. Include testbench with sequence: 10110111011.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph LR
    CLK[Clock] --> FSM
    RST[Reset] --> FSM
    IN[Serial Input] --> FSM
    
    subgraph FSM [Finite State Machine]
        S0((S0))
        S1((S1))
        S2((S2))
        S3((S3))
        S4((S4))
        
        S0 -->|1| S1
        S0 -->|0| S0
        S1 -->|0| S2
        S1 -->|1| S1
        S2 -->|1| S3
        S2 -->|0| S0
        S3 -->|1| S4
        S3 -->|0| S2
        S4 -->|1| S1
        S4 -->|0| S2
    end
    
    FSM --> DETECTED[Pattern Detected]

    subgraph Testbench [Testbench with sequence]
        TEST_INPUT[[10110111011]]
        CLK --> TEST_INPUT
        TEST_INPUT --> IN
    end
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module fsm_1011_detector (
    input wire clk,
    input wire rst_n,
    input wire serial_in,
    output reg detected
);

    typedef enum reg [2:0] {
        S0 = 3'b000,
        S1 = 3'b001,
        S2 = 3'b010,
        S3 = 3'b011,
        S4 = 3'b100
    } state_t;

    state_t current_state, next_state;

    always @(posedge clk or negedge rst_n) begin
        if (!rst_n)
            current_state <= S0;
        else
            current_state <= next_state;
    end

    always @(*) begin
        case (current_state)
            S0: begin
                if (serial_in)
                    next_state = S1;
                else
                    next_state = S0;
            end
            S1: begin
                if (serial_in)
                    next_state = S1;
                else
                    next_state = S2;
            end
            S2: begin
                if (serial_in)
                    next_state = S3;
                else
                    next_state = S0;
            end
            S3: begin
                if (serial_in)
                    next_state = S4;
                else
                    next_state = S2;
            end
            S4: begin
                if (serial_in)
                    next_state = S1;
                else
                    next_state = S2;
            end
            default: next_state = S0;
        endcase
    end

    always @(posedge clk or negedge rst_n) begin
        if (!rst_n)
            detected <= 1'b0;
        else if (current_state == S4 && serial_in == 1'b0) // State S4 signals detection
            detected <= 1'b1;
        else
            detected <= 1'b0;
    end

endmodule

module testbench;
    reg clk, rst_n, serial_in;
    wire detected;

    fsm_1011_detector dut (
        .clk(clk),
        .rst_n(rst_n),
        .serial_in(serial_in),
        .detected(detected)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 1'b0;
        rst_n = 1'b0;
        serial_in = 1'b0;

        #20 rst_n = 1'b1;

        #10 serial_in = 1'b1; // 1
        #10 serial_in = 1'b0; // 0
        #10 serial_in = 1'b1; // 1
        #10 serial_in = 1'b1; // 1
        #10 serial_in = 1'b0; // 0
        #10 serial_in = 1'b1; // 1
        #10 serial_in = 1'b1; // 1
        #10 serial_in = 1'b1; // 1
        #10 serial_in = 1'b0; // 0
        #10 serial_in = 1'b1; // 1
        #10 serial_in = 1'b1; // 1

        #50 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b serial_in=%b detected=%b"", 
                 $time, clk, rst_n, serial_in, detected);
    end
endmodule",True,116,True,True,True,True,0.7,True,8.724907398223877,19.369280099868774,prompt_only,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,Sequential,medium,"Create a 4-bit PISO shift register with clock, reset, load, parallel input[3:0], and serial output. Include testbench.",claude,"`timescale 1ns/1ps

module piso_register(
    input wire clk,
    input wire rst_n,
    input wire load,
    input wire [3:0] parallel_in,
    output reg serial_out
);

reg [3:0] shift_reg;

always @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
        shift_reg <= 4'b0000;
        serial_out <= 1'b0;
    end
    else if (load)
        shift_reg <= parallel_in;
    else begin
        serial_out <= shift_reg[3];
        shift_reg <= {shift_reg[2:0], 1'b0};
    end
end

endmodule

module testbench;
    reg clk, rst_n, load;
    reg [3:0] parallel_in;
    wire serial_out;
    
    piso_register dut (
        .clk(clk),
        .rst_n(rst_n),
        .load(load),
        .parallel_in(parallel_in),
        .serial_out(serial_out)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 0;
        rst_n = 0;
        load = 0;
        parallel_in = 4'b0000;
        
        #10 rst_n = 1;
        #10 parallel_in = 4'b1101;
        #10 load = 1;
        #10 load = 0;
        
        #80 parallel_in = 4'b1010;
        #10 load = 1;
        #10 load = 0;
        
        #80 rst_n = 0;
        #20 rst_n = 1;
        #50 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t rst_n=%b load=%b parallel_in=%b serial_out=%b"", 
                 $time, rst_n, load, parallel_in, serial_out);
    end
endmodule",True,70,True,True,True,True,0.7,True,6.438212633132935,7.673946380615234,"graph LR
    CLK[Clock] --> SR[[4-bit PISO Register]]
    RST[Reset] --> SR
    LOAD[Load] --> SR
    PI0[Parallel In 0] --> SR
    PI1[Parallel In 1] --> SR
    PI2[Parallel In 2] --> SR
    PI3[Parallel In 3] --> SR
    SR --> SO[Serial Out]
    TB[Testbench] --> CLK
    TB --> RST
    TB --> LOAD
    TB --> PI0
    TB --> PI1
    TB --> PI2
    TB --> PI3
    SR --> TB_MON[Monitor]
    SO --> TB_MON
    TB_MON --> TB","`timescale 1ns/1ps

module piso_register(
    input wire clk,
    input wire rst,
    input wire load,
    input wire [3:0] parallel_in,
    output reg serial_out
);

reg [3:0] shift_reg;

always @(posedge clk or posedge rst) begin
    if (rst) begin
        shift_reg <= 4'b0000;
        serial_out <= 1'b0;
    end else begin
        if (load)
            shift_reg <= parallel_in;
        else begin
            serial_out <= shift_reg[3];
            shift_reg <= {shift_reg[2:0], 1'b0};
        end
    end
end

endmodule

module testbench;
    reg clk, rst, load;
    reg [3:0] parallel_in;
    wire serial_out;
    
    piso_register dut (
        .clk(clk),
        .rst(rst),
        .load(load),
        .parallel_in(parallel_in),
        .serial_out(serial_out)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst = 1'b1;
        load = 1'b0;
        parallel_in = 4'b0000;
        
        #10 rst = 1'b0;
        #10 parallel_in = 4'b1010;
        #10 load = 1'b1;
        #10 load = 1'b0;
        
        #40 parallel_in = 4'b1111;
        #10 load = 1'b1;
        #10 load = 1'b0;
        
        #40 rst = 1'b1;
        #10 rst = 1'b0;
        
        #50 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t rst=%b load=%b parallel_in=%b serial_out=%b"", 
                 $time, rst, load, parallel_in, serial_out);
    end
endmodule",True,72,True,True,True,False,0.3,False,9.45055079460144,7.662591457366943,"Create a 4-bit PISO shift register with clock, reset, load, parallel input[3:0], and serial output. Include testbench.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph LR
    CLK[Clock] --> SR[[4-bit PISO Register]]
    RST[Reset] --> SR
    LOAD[Load] --> SR
    PI0[Parallel In 0] --> SR
    PI1[Parallel In 1] --> SR
    PI2[Parallel In 2] --> SR
    PI3[Parallel In 3] --> SR
    SR --> SO[Serial Out]
    TB[Testbench] --> CLK
    TB --> RST
    TB --> LOAD
    TB --> PI0
    TB --> PI1
    TB --> PI2
    TB --> PI3
    SR --> TB_MON[Monitor]
    SO --> TB_MON
    TB_MON --> TB
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module piso_register (
    input wire clk,
    input wire rst,
    input wire load,
    input wire [3:0] parallel_in,
    output reg serial_out
);

reg [3:0] shift_reg;

always @(posedge clk or posedge rst) begin
    if (rst) begin
        shift_reg <= 4'b0000;
        serial_out <= 1'b0;
    end
    else begin
        if (load)
            shift_reg <= parallel_in;
        else begin
            serial_out <= shift_reg[3];
            shift_reg <= {shift_reg[2:0], 1'b0};
        end
    end
end

endmodule

module testbench;
    reg clk, rst, load;
    reg [3:0] parallel_in;
    wire serial_out;

    piso_register dut (
        .clk(clk),
        .rst(rst),
        .load(load),
        .parallel_in(parallel_in),
        .serial_out(serial_out)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 0;
        rst = 1;
        load = 0;
        parallel_in = 4'b0000;

        #10 rst = 0;
        #10 parallel_in = 4'b1010;
        load = 1;
        #10 load = 0;
        
        #40;
        parallel_in = 4'b1111;
        load = 1;
        #10 load = 0;
        
        #40;
        rst = 1;
        #10 rst = 0;
        
        #20 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t rst=%b load=%b parallel_in=%b serial_out=%b"", 
                 $time, rst, load, parallel_in, serial_out);
    end
endmodule",True,75,True,True,True,False,0.3,False,6.4594056606292725,7.3559558391571045,tie,mermaid_only > combined > prompt_only,prompt_only > mermaid_only > combined
combined,Sequential,medium,"Create a 4-bit PISO shift register with clock, reset, load, parallel input[3:0], and serial output. Include testbench.",gpt-4o,"`timescale 1ns/1ps

module piso_shift_register(
    input wire clk,
    input wire rst_n,
    input wire load,
    input wire [3:0] parallel_in,
    output reg serial_out
);
    
    reg [3:0] shift_reg;
    
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n)
            shift_reg <= 4'b0000;
        else if (load)
            shift_reg <= parallel_in;
        else
            shift_reg <= {shift_reg[2:0], 1'b0};
    end
    
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n)
            serial_out <= 1'b0;
        else
            serial_out <= shift_reg[3];
    end
    
endmodule

module testbench;
    reg clk, rst_n, load;
    reg [3:0] parallel_in;
    wire serial_out;
    
    piso_shift_register dut (
        .clk(clk),
        .rst_n(rst_n),
        .load(load),
        .parallel_in(parallel_in),
        .serial_out(serial_out)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst_n = 1'b0;
        load = 1'b0;
        parallel_in = 4'b0000;
        
        #20 rst_n = 1'b1;
        #10 load = 1'b1;
        parallel_in = 4'b1010;
        #10 load = 1'b0;
        #50 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b load=%b parallel_in=%b serial_out=%b"", 
                 $time, clk, rst_n, load, parallel_in, serial_out);
    end
endmodule",True,66,True,True,True,True,0.7,True,4.948749303817749,16.714125394821167,"graph LR
    CLK[Clock] --> LOAD(Load Control)
    RST[Reset] --> LOAD
    LOAD --> SHIFT[[4-bit PISO Shift Register]]
    PI[Parallel Input[3:0]] --> SHIFT
    SHIFT --> SO[Serial Output]
    CLK --> SHIFT
    TB[Testbench] --> CLK
    TB --> RST
    TB --> PI","`timescale 1ns/1ps

module piso_shift_register(
    input wire clk,
    input wire rst_n,
    input wire load,
    input wire [3:0] parallel_in,
    output reg serial_out
);

    reg [3:0] shift_reg;

    always @(posedge clk or negedge rst_n) begin
        if (!rst_n)
            shift_reg <= 4'b0000;
        else if (load)
            shift_reg <= parallel_in;
        else
            shift_reg <= {shift_reg[2:0], 1'b0};
    end

    always @(posedge clk or negedge rst_n) begin
        if (!rst_n)
            serial_out <= 1'b0;
        else
            serial_out <= shift_reg[3];
    end

endmodule

module testbench;
    reg clk, rst_n, load;
    reg [3:0] parallel_in;
    wire serial_out;
    
    piso_shift_register dut (
        .clk(clk),
        .rst_n(rst_n),
        .load(load),
        .parallel_in(parallel_in),
        .serial_out(serial_out)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst_n = 1'b0;
        load = 1'b0;
        parallel_in = 4'b0000;
        
        #20 rst_n = 1'b1;
        #10 load = 1'b1; parallel_in = 4'b1010;
        #10 load = 1'b0;
        #100 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b load=%b parallel_in=%b serial_out=%b"", 
                 $time, clk, rst_n, load, parallel_in, serial_out);
    end
endmodule",True,65,True,True,True,True,0.7,True,6.407594442367554,13.878192901611328,"Create a 4-bit PISO shift register with clock, reset, load, parallel input[3:0], and serial output. Include testbench.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph LR
    CLK[Clock] --> LOAD(Load Control)
    RST[Reset] --> LOAD
    LOAD --> SHIFT[[4-bit PISO Shift Register]]
    PI[Parallel Input[3:0]] --> SHIFT
    SHIFT --> SO[Serial Output]
    CLK --> SHIFT
    TB[Testbench] --> CLK
    TB --> RST
    TB --> PI
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module piso_shift_register(
    input wire clk,
    input wire rst_n,
    input wire load,
    input wire [3:0] parallel_in,
    output reg serial_out
);

reg [3:0] shift_reg;

always @(posedge clk or negedge rst_n) begin
    if (!rst_n)
        shift_reg <= 4'b0000;
    else if (load)
        shift_reg <= parallel_in;
    else
        shift_reg <= {shift_reg[2:0], 1'b0};
end

always @(posedge clk or negedge rst_n) begin
    if (!rst_n)
        serial_out <= 1'b0;
    else
        serial_out <= shift_reg[3];
end

endmodule

module testbench;
    reg clk, rst_n, load;
    reg [3:0] parallel_in;
    wire serial_out;
    
    piso_shift_register dut (
        .clk(clk),
        .rst_n(rst_n),
        .load(load),
        .parallel_in(parallel_in),
        .serial_out(serial_out)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst_n = 1'b0;
        load = 1'b0;
        parallel_in = 4'b0000;
        
        #20 rst_n = 1'b1;
        #10 load = 1'b1; parallel_in = 4'b1010;
        #10 load = 1'b0;
        #100 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b load=%b parallel_in=%b serial_out=%b"", 
                 $time, clk, rst_n, load, parallel_in, serial_out);
    end
endmodule",True,65,True,True,True,True,0.7,True,6.2354736328125,11.075496673583984,prompt_only,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,Combinational,medium,"Design a 4-to-2 priority encoder with input in[3:0], output out[1:0], and valid bit. Highest bit has priority. Include testbench.",claude,"`timescale 1ns/1ps

module priority_encoder(
    input wire [3:0] in,
    output reg [1:0] out,
    output reg valid
);

always @(*) begin
    if (in[3]) begin
        out = 2'b11;
        valid = 1'b1;
    end
    else if (in[2]) begin
        out = 2'b10;
        valid = 1'b1;
    end
    else if (in[1]) begin
        out = 2'b01;
        valid = 1'b1;
    end
    else if (in[0]) begin
        out = 2'b00;
        valid = 1'b1;
    end
    else begin
        out = 2'b00;
        valid = 1'b0;
    end
end

endmodule

module testbench;
    reg [3:0] in;
    wire [1:0] out;
    wire valid;

    priority_encoder dut (
        .in(in),
        .out(out),
        .valid(valid)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        // Test all possible input combinations
        in = 4'b0000; #10;
        in = 4'b0001; #10;
        in = 4'b0010; #10;
        in = 4'b0011; #10;
        in = 4'b0100; #10;
        in = 4'b0101; #10;
        in = 4'b0110; #10;
        in = 4'b0111; #10;
        in = 4'b1000; #10;
        in = 4'b1001; #10;
        in = 4'b1010; #10;
        in = 4'b1011; #10;
        in = 4'b1100; #10;
        in = 4'b1101; #10;
        in = 4'b1110; #10;
        in = 4'b1111; #10;

        $finish;
    end

    initial begin
        $monitor(""Time=%0t in=%b out=%b valid=%b"", 
                 $time, in, out, valid);
    end
endmodule",True,74,True,True,True,False,0.4,False,6.567570924758911,7.827303171157837,"graph LR
    IN0[in[0]] --> ENC((Priority Encoder))
    IN1[in[1]] --> ENC
    IN2[in[2]] --> ENC
    IN3[in[3]] --> ENC
    ENC --> OUT[out[1:0]]
    ENC --> VALID[valid]
    TB[Testbench] -.-> IN0
    TB -.-> IN1
    TB -.-> IN2
    TB -.-> IN3
    OUT -.-> VERIFY{Verification}
    VALID -.-> VERIFY
    LOGIC{Priority Logic:
    3>2>1>0} --> ENC
    CLK[Clock] -.-> TB
    RST[Reset] -.-> TB
    subgraph TestEnvironment
    TB
    VERIFY
    end","`timescale 1ns/1ps

module priority_encoder (
    input wire clk,
    input wire rst_n,
    input wire [3:0] in,
    output reg [1:0] out,
    output reg valid
);

always @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
        out <= 2'b00;
        valid <= 1'b0;
    end
    else begin
        valid <= |in;
        if (in[3])
            out <= 2'b11;
        else if (in[2])
            out <= 2'b10;
        else if (in[1])
            out <= 2'b01;
        else if (in[0])
            out <= 2'b00;
        else
            out <= 2'b00;
    end
end

endmodule

module testbench;
    reg clk;
    reg rst_n;
    reg [3:0] in;
    wire [1:0] out;
    wire valid;

    priority_encoder dut (
        .clk(clk),
        .rst_n(rst_n),
        .in(in),
        .out(out),
        .valid(valid)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 0;
        rst_n = 0;
        in = 4'b0000;

        #10 rst_n = 1;
        
        #10 in = 4'b0001;
        #10 in = 4'b0010;
        #10 in = 4'b0100;
        #10 in = 4'b1000;
        #10 in = 4'b1111;
        #10 in = 4'b0011;
        #10 in = 4'b0000;
        
        #10 rst_n = 0;
        #10 rst_n = 1;
        
        #20 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t rst_n=%b in=%b out=%b valid=%b"", 
                 $time, rst_n, in, out, valid);
    end
endmodule",True,78,True,True,True,True,0.8,True,10.75540828704834,8.836186408996582,"Design a 4-to-2 priority encoder with input in[3:0], output out[1:0], and valid bit. Highest bit has priority. Include testbench.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph LR
    IN0[in[0]] --> ENC((Priority Encoder))
    IN1[in[1]] --> ENC
    IN2[in[2]] --> ENC
    IN3[in[3]] --> ENC
    ENC --> OUT[out[1:0]]
    ENC --> VALID[valid]
    TB[Testbench] -.-> IN0
    TB -.-> IN1
    TB -.-> IN2
    TB -.-> IN3
    OUT -.-> VERIFY{Verification}
    VALID -.-> VERIFY
    LOGIC{Priority Logic:
    3>2>1>0} --> ENC
    CLK[Clock] -.-> TB
    RST[Reset] -.-> TB
    subgraph TestEnvironment
    TB
    VERIFY
    end
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module priority_encoder(
    input wire [3:0] in,
    output reg [1:0] out,
    output reg valid
);

always @(*) begin
    valid = |in;
    if (in[3])
        out = 2'd3;
    else if (in[2])
        out = 2'd2;
    else if (in[1])
        out = 2'd1;
    else if (in[0])
        out = 2'd0;
    else
        out = 2'd0;
end

endmodule

module testbench;
    reg clk;
    reg rst_n;
    reg [3:0] in;
    wire [1:0] out;
    wire valid;

    priority_encoder dut (
        .in(in),
        .out(out),
        .valid(valid)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 0;
        rst_n = 0;
        in = 4'b0000;

        #10 rst_n = 1;

        // Test all input combinations
        #10 in = 4'b0001;
        #10 in = 4'b0010;
        #10 in = 4'b0011;
        #10 in = 4'b0100;
        #10 in = 4'b0101;
        #10 in = 4'b0110;
        #10 in = 4'b0111;
        #10 in = 4'b1000;
        #10 in = 4'b1001;
        #10 in = 4'b1010;
        #10 in = 4'b1011;
        #10 in = 4'b1100;
        #10 in = 4'b1101;
        #10 in = 4'b1110;
        #10 in = 4'b1111;
        #10 in = 4'b0000;

        #10 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t rst_n=%b in=%b out=%b valid=%b"",
                 $time, rst_n, in, out, valid);
    end

    // Verification
    reg [1:0] expected_out;
    reg expected_valid;

    always @(*) begin
        expected_valid = |in;
        if (in[3])
            expected_out = 2'd3;
        else if (in[2])
            expected_out = 2'd2;
        else if (in[1])
            expected_out = 2'd1;
        else if (in[0])
            expected_out = 2'd0;
        else
            expected_out = 2'd0;

        if ((out !== expected_out) || (valid !== expected_valid))
            $display(""Error at time %0t: in=%b, expected_out=%b, got_out=%b, expected_valid=%b, got_valid=%b"",
                     $time, in, expected_out, out, expected_valid, valid);
    end

endmodule",True,98,True,True,True,False,0.4,False,9.589341163635254,8.1371488571167,tie,prompt_only > combined > mermaid_only,prompt_only > mermaid_only > combined
combined,Combinational,medium,"Design a 4-to-2 priority encoder with input in[3:0], output out[1:0], and valid bit. Highest bit has priority. Include testbench.",gpt-4o,"`timescale 1ns/1ps

module priority_encoder(
    input wire [3:0] in,
    output reg [1:0] out,
    output reg valid
);

always @(*) begin
    valid = 1'b0;
    out = 2'b00;
    if (in[3]) begin
        out = 2'b11;
        valid = 1'b1;
    end else if (in[2]) begin
        out = 2'b10;
        valid = 1'b1;
    end else if (in[1]) begin
        out = 2'b01;
        valid = 1'b1;
    end else if (in[0]) begin
        out = 2'b00;
        valid = 1'b1;
    end
end

endmodule

module testbench;
    reg [3:0] in;
    wire [1:0] out;
    wire valid;
    
    priority_encoder dut (
        .in(in),
        .out(out),
        .valid(valid)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        in = 4'b0000;
        #10 in = 4'b0001;
        #10 in = 4'b0010;
        #10 in = 4'b0100;
        #10 in = 4'b1000;
        #10 in = 4'b1100;
        #10 in = 4'b1010;
        #10 in = 4'b0110;
        #10 in = 4'b1111;
        #10 $finish;
    end
    
    initial begin
        $monitor(""Time=%0t in=%b out=%b valid=%b"", 
                 $time, in, out, valid);
    end
endmodule",True,60,True,True,True,False,0.4,False,6.065812110900879,11.969948291778564,"graph TD
    CLK[Clock] --> ENC(4-to-2 Priority Encoder)
    RST[Reset] --> ENC
    IN[Input in[3:0]] --> ENC
    ENC --> OUT[Output out[1:0]]
    ENC --> VALID[Valid Bit]
    
    subgraph Testbench
        TB_IN[Test Input in[3:0]] --> ENC
        TB_OUT[Test Output out[1:0]] <-- ENC
        TB_VALID[Test Valid Bit] <-- ENC
    end","`timescale 1ns/1ps

module priority_encoder(
    input wire clk,
    input wire rst,
    input wire [3:0] in,
    output reg [1:0] out,
    output reg valid
);

reg [3:0] in_reg;
reg [1:0] out_reg;
reg valid_reg;

always @(posedge clk or posedge rst) begin
    if (rst) begin
        in_reg <= 4'b0000;
        out_reg <= 2'b00;
        valid_reg <= 1'b0;
    end else begin
        in_reg <= in;
        casez (in_reg)
            4'b1???: begin
                out_reg <= 2'b11;
                valid_reg <= 1'b1;
            end
            4'b01??: begin
                out_reg <= 2'b10;
                valid_reg <= 1'b1;
            end
            4'b001?: begin
                out_reg <= 2'b01;
                valid_reg <= 1'b1;
            end
            4'b0001: begin
                out_reg <= 2'b00;
                valid_reg <= 1'b1;
            end
            default: begin
                out_reg <= 2'b00;
                valid_reg <= 1'b0;
            end
        endcase
    end
end

assign out = out_reg;
assign valid = valid_reg;

endmodule

module testbench;
    reg clk, rst;
    reg [3:0] test_in;
    wire [1:0] test_out;
    wire test_valid;

    priority_encoder dut (
        .clk(clk),
        .rst(rst),
        .in(test_in),
        .out(test_out),
        .valid(test_valid)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 1'b0;
        rst = 1'b1;
        test_in = 4'b0000;
        
        #10 rst = 1'b0;
        #10 test_in = 4'b1000;
        #10 test_in = 4'b0100;
        #10 test_in = 4'b0010;
        #10 test_in = 4'b0001;
        #10 test_in = 4'b0000;
        #10 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t clk=%b rst=%b test_in=%b test_out=%b test_valid=%b"", 
                 $time, clk, rst, test_in, test_out, test_valid);
    end
endmodule",True,89,True,False,False,,0.0,,10.892296314239502,0.011271953582763672,"Design a 4-to-2 priority encoder with input in[3:0], output out[1:0], and valid bit. Highest bit has priority. Include testbench.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph TD
    CLK[Clock] --> ENC(4-to-2 Priority Encoder)
    RST[Reset] --> ENC
    IN[Input in[3:0]] --> ENC
    ENC --> OUT[Output out[1:0]]
    ENC --> VALID[Valid Bit]
    
    subgraph Testbench
        TB_IN[Test Input in[3:0]] --> ENC
        TB_OUT[Test Output out[1:0]] <-- ENC
        TB_VALID[Test Valid Bit] <-- ENC
    end
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module priority_encoder_4to2(
    input wire clk,
    input wire rst,
    input wire [3:0] in,
    output reg [1:0] out,
    output reg valid
);

always @(posedge clk or posedge rst) begin
    if (rst) begin
        out <= 2'b00;
        valid <= 1'b0;
    end else begin
        casez (in)
            4'b1???: begin out <= 2'b11; valid <= 1'b1; end
            4'b01??: begin out <= 2'b10; valid <= 1'b1; end
            4'b001?: begin out <= 2'b01; valid <= 1'b1; end
            4'b0001: begin out <= 2'b00; valid <= 1'b1; end
            default: begin out <= 2'b00; valid <= 1'b0; end
        endcase
    end
end

endmodule

module testbench;
    reg clk, rst;
    reg [3:0] tb_in;
    wire [1:0] tb_out;
    wire tb_valid;
    
    priority_encoder_4to2 dut (
        .clk(clk),
        .rst(rst),
        .in(tb_in),
        .out(tb_out),
        .valid(tb_valid)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst = 1'b1;
        tb_in = 4'b0000;
        
        #10 rst = 1'b0;
        #10 tb_in = 4'b0001;
        #10 tb_in = 4'b0010;
        #10 tb_in = 4'b0100;
        #10 tb_in = 4'b1000;
        #10 tb_in = 4'b0110;
        #10 tb_in = 4'b1100;
        #10 tb_in = 4'b1010;
        #10 tb_in = 4'b1111;
        #10 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t clk=%b rst=%b in=%b out=%b valid=%b"", 
                 $time, clk, rst, tb_in, tb_out, tb_valid);
    end
endmodule",True,68,True,True,True,True,0.7,True,5.967592239379883,15.492374181747437,prompt_only,prompt_only > mermaid_only > combined,prompt_only > combined > mermaid_only
combined,State Machine,complex,"Design a traffic light FSM with 4 states: NS_GREEN, NS_YELLOW, EW_GREEN, EW_YELLOW. Inputs: clk, rst, emergency. Outputs: ns_light[1:0], ew_light[1:0]. Timing: GREEN=8 cycles, YELLOW=2 cycles. Emergency makes both RED. Include testbench.",claude,"`timescale 1ns/1ps

module traffic_light (
    input wire clk,
    input wire rst,
    input wire emergency,
    output reg [1:0] ns_light,
    output reg [1:0] ew_light
);

parameter RED = 2'b00;
parameter YELLOW = 2'b01;
parameter GREEN = 2'b10;

parameter NS_GREEN = 2'b00;
parameter NS_YELLOW = 2'b01;
parameter EW_GREEN = 2'b10;
parameter EW_YELLOW = 2'b11;

reg [1:0] state;
reg [3:0] timer;

always @(posedge clk or posedge rst) begin
    if (rst) begin
        state <= NS_GREEN;
        timer <= 4'd0;
        ns_light <= GREEN;
        ew_light <= RED;
    end
    else if (emergency) begin
        ns_light <= RED;
        ew_light <= RED;
    end
    else begin
        case (state)
            NS_GREEN: begin
                if (timer == 4'd7) begin
                    state <= NS_YELLOW;
                    timer <= 4'd0;
                    ns_light <= YELLOW;
                end
                else begin
                    timer <= timer + 1'b1;
                    ns_light <= GREEN;
                    ew_light <= RED;
                end
            end
            
            NS_YELLOW: begin
                if (timer == 4'd1) begin
                    state <= EW_GREEN;
                    timer <= 4'd0;
                    ns_light <= RED;
                    ew_light <= GREEN;
                end
                else begin
                    timer <= timer + 1'b1;
                end
            end
            
            EW_GREEN: begin
                if (timer == 4'd7) begin
                    state <= EW_YELLOW;
                    timer <= 4'd0;
                    ew_light <= YELLOW;
                end
                else begin
                    timer <= timer + 1'b1;
                    ns_light <= RED;
                    ew_light <= GREEN;
                end
            end
            
            EW_YELLOW: begin
                if (timer == 4'd1) begin
                    state <= NS_GREEN;
                    timer <= 4'd0;
                    ns_light <= GREEN;
                    ew_light <= RED;
                end
                else begin
                    timer <= timer + 1'b1;
                end
            end
        endcase
    end
end

endmodule

module testbench;
    reg clk, rst, emergency;
    wire [1:0] ns_light, ew_light;
    
    traffic_light dut (
        .clk(clk),
        .rst(rst),
        .emergency(emergency),
        .ns_light(ns_light),
        .ew_light(ew_light)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 0;
        rst = 1;
        emergency = 0;
        
        #10 rst = 0;
        
        #100 emergency = 1;
        #20 emergency = 0;
        
        #200 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t rst=%b emergency=%b ns_light=%b ew_light=%b"", 
                 $time, rst, emergency, ns_light, ew_light);
    end
endmodule",True,125,True,True,True,False,0.4,False,10.194713592529297,7.447377443313599,"graph LR
    CLK[clk] --> FSM((Traffic Light FSM))
    RST[rst] --> FSM
    EMG[emergency] --> FSM
    
    FSM --> CNT[[Counter<br>8/2 cycles]]
    CLK --> CNT
    CNT --> FSM
    
    FSM --> NS_OUT[ns_light[1:0]]
    FSM --> EW_OUT[ew_light[1:0]]
    
    FSM --> States{State Register<br>NS_GREEN<br>NS_YELLOW<br>EW_GREEN<br>EW_YELLOW}
    CLK --> States
    States --> FSM
    
    TB[Testbench] --> EMG
    TB --> RST
    TB -.-> NS_OUT
    TB -.-> EW_OUT","`timescale 1ns/1ps

module traffic_fsm (
    input wire clk,
    input wire rst,
    input wire emergency,
    output reg [1:0] ns_light,
    output reg [1:0] ew_light
);

localparam [1:0] 
    NS_GREEN  = 2'b00,
    NS_YELLOW = 2'b01,
    EW_GREEN  = 2'b10,
    EW_YELLOW = 2'b11;

reg [1:0] state, next_state;
reg [3:0] counter;

always @(posedge clk or posedge rst) begin
    if (rst) begin
        state <= NS_GREEN;
        counter <= 4'd0;
    end else begin
        state <= next_state;
        if (counter == 4'd7)
            counter <= 4'd0;
        else
            counter <= counter + 1'b1;
    end
end

always @(*) begin
    case (state)
        NS_GREEN: begin
            if (emergency || counter == 4'd7)
                next_state = NS_YELLOW;
            else
                next_state = NS_GREEN;
        end
        NS_YELLOW: begin
            if (counter == 4'd1)
                next_state = EW_GREEN;
            else
                next_state = NS_YELLOW;
        end
        EW_GREEN: begin
            if (emergency || counter == 4'd7)
                next_state = EW_YELLOW;
            else
                next_state = EW_GREEN;
        end
        EW_YELLOW: begin
            if (counter == 4'd1)
                next_state = NS_GREEN;
            else
                next_state = EW_YELLOW;
        end
        default: next_state = NS_GREEN;
    endcase
end

always @(*) begin
    case (state)
        NS_GREEN:  begin ns_light = 2'b10; ew_light = 2'b00; end
        NS_YELLOW: begin ns_light = 2'b01; ew_light = 2'b00; end
        EW_GREEN:  begin ns_light = 2'b00; ew_light = 2'b10; end
        EW_YELLOW: begin ns_light = 2'b00; ew_light = 2'b01; end
        default:   begin ns_light = 2'b00; ew_light = 2'b00; end
    endcase
end

endmodule

module testbench;
    reg clk, rst, emergency;
    wire [1:0] ns_light, ew_light;
    
    traffic_fsm dut (
        .clk(clk),
        .rst(rst),
        .emergency(emergency),
        .ns_light(ns_light),
        .ew_light(ew_light)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst = 1'b1;
        emergency = 1'b0;
        
        #10 rst = 1'b0;
        #50 emergency = 1'b1;
        #10 emergency = 1'b0;
        #100 emergency = 1'b1;
        #10 emergency = 1'b0;
        #50 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t rst=%b emergency=%b ns_light=%b ew_light=%b"", 
                 $time, rst, emergency, ns_light, ew_light);
    end
endmodule",True,109,True,True,True,False,0.3,False,15.223508834838867,7.605963230133057,"Design a traffic light FSM with 4 states: NS_GREEN, NS_YELLOW, EW_GREEN, EW_YELLOW. Inputs: clk, rst, emergency. Outputs: ns_light[1:0], ew_light[1:0]. Timing: GREEN=8 cycles, YELLOW=2 cycles. Emergency makes both RED. Include testbench.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph LR
    CLK[clk] --> FSM((Traffic Light FSM))
    RST[rst] --> FSM
    EMG[emergency] --> FSM
    
    FSM --> CNT[[Counter<br>8/2 cycles]]
    CLK --> CNT
    CNT --> FSM
    
    FSM --> NS_OUT[ns_light[1:0]]
    FSM --> EW_OUT[ew_light[1:0]]
    
    FSM --> States{State Register<br>NS_GREEN<br>NS_YELLOW<br>EW_GREEN<br>EW_YELLOW}
    CLK --> States
    States --> FSM
    
    TB[Testbench] --> EMG
    TB --> RST
    TB -.-> NS_OUT
    TB -.-> EW_OUT
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module traffic_light(
    input wire clk,
    input wire rst,
    input wire emergency,
    output reg [1:0] ns_light,
    output reg [1:0] ew_light
);

parameter [1:0] RED = 2'b00;
parameter [1:0] YELLOW = 2'b01;
parameter [1:0] GREEN = 2'b10;

parameter [1:0] NS_GREEN = 2'b00;
parameter [1:0] NS_YELLOW = 2'b01;
parameter [1:0] EW_GREEN = 2'b10;
parameter [1:0] EW_YELLOW = 2'b11;

reg [1:0] state;
reg [3:0] counter;

always @(posedge clk or posedge rst) begin
    if (rst) begin
        state <= NS_GREEN;
        counter <= 4'd0;
    end
    else if (emergency) begin
        state <= state;
        counter <= 4'd0;
    end
    else begin
        case (state)
            NS_GREEN: begin
                if (counter >= 4'd7) begin
                    state <= NS_YELLOW;
                    counter <= 4'd0;
                end
                else counter <= counter + 1'b1;
            end
            NS_YELLOW: begin
                if (counter >= 4'd1) begin
                    state <= EW_GREEN;
                    counter <= 4'd0;
                end
                else counter <= counter + 1'b1;
            end
            EW_GREEN: begin
                if (counter >= 4'd7) begin
                    state <= EW_YELLOW;
                    counter <= 4'd0;
                end
                else counter <= counter + 1'b1;
            end
            EW_YELLOW: begin
                if (counter >= 4'd1) begin
                    state <= NS_GREEN;
                    counter <= 4'd0;
                end
                else counter <= counter + 1'b1;
            end
        endcase
    end
end

always @(*) begin
    if (emergency) begin
        ns_light = RED;
        ew_light = RED;
    end
    else begin
        case (state)
            NS_GREEN: begin
                ns_light = GREEN;
                ew_light = RED;
            end
            NS_YELLOW: begin
                ns_light = YELLOW;
                ew_light = RED;
            end
            EW_GREEN: begin
                ns_light = RED;
                ew_light = GREEN;
            end
            EW_YELLOW: begin
                ns_light = RED;
                ew_light = YELLOW;
            end
        endcase
    end
end

endmodule

module testbench;
    reg clk;
    reg rst;
    reg emergency;
    wire [1:0] ns_light;
    wire [1:0] ew_light;

    traffic_light dut (
        .clk(clk),
        .rst(rst),
        .emergency(emergency),
        .ns_light(ns_light),
        .ew_light(ew_light)
    );

    initial begin
        $dumpfile(""traffic.vcd"");
        $dumpvars(0, testbench);
        
        clk = 0;
        rst = 1;
        emergency = 0;
        
        #10 rst = 0;
        
        #100 emergency = 1;
        #20 emergency = 0;
        
        #200 rst = 1;
        #10 rst = 0;
        
        #100 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t rst=%b emergency=%b ns_light=%b ew_light=%b"",
                 $time, rst, emergency, ns_light, ew_light);
    end

endmodule",True,136,True,True,True,,0.0,,11.182844400405884,0.014643192291259766,tie,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,State Machine,complex,"Design a traffic light FSM with 4 states: NS_GREEN, NS_YELLOW, EW_GREEN, EW_YELLOW. Inputs: clk, rst, emergency. Outputs: ns_light[1:0], ew_light[1:0]. Timing: GREEN=8 cycles, YELLOW=2 cycles. Emergency makes both RED. Include testbench.",gpt-4o,"`timescale 1ns/1ps

module traffic_light_fsm(
    input wire clk,
    input wire rst,
    input wire emergency,
    output reg [1:0] ns_light,
    output reg [1:0] ew_light
);

    // State encoding
    localparam NS_GREEN  = 2'b00;
    localparam NS_YELLOW = 2'b01;
    localparam EW_GREEN  = 2'b10;
    localparam EW_YELLOW = 2'b11;

    // Light encoding
    localparam RED    = 2'b00;
    localparam GREEN  = 2'b01;
    localparam YELLOW = 2'b10;

    reg [1:0] state, next_state;
    reg [3:0] timer;

    always @(posedge clk or posedge rst) begin
        if (rst) begin
            state <= NS_GREEN;
            timer <= 4'd0;
        end else if (emergency) begin
            state <= NS_GREEN;
            timer <= 4'd0;
        end else begin
            if (timer == 4'd9) begin
                state <= next_state;
                timer <= 4'd0;
            end else begin
                timer <= timer + 1'b1;
            end
        end
    end

    always @(*) begin
        case (state)
            NS_GREEN: begin
                ns_light = GREEN;
                ew_light = RED;
                if (timer == 4'd7)
                    next_state = NS_YELLOW;
                else
                    next_state = NS_GREEN;
            end
            NS_YELLOW: begin
                ns_light = YELLOW;
                ew_light = RED;
                if (timer == 4'd1)
                    next_state = EW_GREEN;
                else
                    next_state = NS_YELLOW;
            end
            EW_GREEN: begin
                ns_light = RED;
                ew_light = GREEN;
                if (timer == 4'd7)
                    next_state = EW_YELLOW;
                else
                    next_state = EW_GREEN;
            end
            EW_YELLOW: begin
                ns_light = RED;
                ew_light = YELLOW;
                if (timer == 4'd1)
                    next_state = NS_GREEN;
                else
                    next_state = EW_YELLOW;
            end
            default: begin
                ns_light = RED;
                ew_light = RED;
                next_state = NS_GREEN;
            end
        endcase
    end
endmodule

module testbench;
    reg clk, rst, emergency;
    wire [1:0] ns_light, ew_light;

    traffic_light_fsm dut (
        .clk(clk),
        .rst(rst),
        .emergency(emergency),
        .ns_light(ns_light),
        .ew_light(ew_light)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 1'b0;
        rst = 1'b1;
        emergency = 1'b0;

        #10 rst = 1'b0;
        #200 emergency = 1'b1;
        #20 emergency = 1'b0;
        #300 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t clk=%b rst=%b emergency=%b ns_light=%b ew_light=%b"", 
                 $time, clk, rst, emergency, ns_light, ew_light);
    end
endmodule",True,117,True,True,True,True,0.9,True,10.677585124969482,9.733082294464111,"graph TD
    CLK[clk] --> FSM
    RST[rst] --> FSM
    EMERGENCY[emergency] --> EMG{Emergency Check}
    
    FSM(NS_GREEN)
    FSM -->|8 cycles| YELLOW1(NS_YELLOW)
    YELLOW1 -->|2 cycles| GREEN1(EW_GREEN)
    GREEN1 -->|8 cycles| YELLOW2(EW_YELLOW)
    YELLOW2 -->|2 cycles| FSM

    EMG -->|emergency active| RED(RED State)
    RED --> FSM

    FSM --> NS_OUT[ns_light[1:0]]
    FSM --> EW_OUT[ew_light[1:0]]
    EMG --> NS_OUT
    EMG --> EW_OUT

    subgraph Testbench
        TB_CLK[clk] --> FSM
        TB_RST[rst] --> FSM
        TB_EMERGENCY[emergency] --> FSM
        FSM --> TB_NS_OUT[ns_light[1:0]]
        FSM --> TB_EW_OUT[ew_light[1:0]]
    end","`timescale 1ns/1ps

module traffic_light_fsm(
    input wire clk,
    input wire rst,
    input wire emergency,
    output reg [1:0] ns_light,
    output reg [1:0] ew_light
);

    reg [1:0] state;
    reg [3:0] cycle_count;
    parameter NS_GREEN = 2'b00, NS_YELLOW = 2'b01, EW_GREEN = 2'b10, EW_YELLOW = 2'b11, RED_STATE = 2'b00;

    always @(posedge clk or posedge rst) begin
        if (rst) begin
            state <= NS_GREEN;
            cycle_count <= 4'd0;
            ns_light <= 2'b01;
            ew_light <= 2'b00;
        end
        else if (emergency) begin
            state <= RED_STATE;
            ns_light <= 2'b00;
            ew_light <= 2'b00;
        end
        else begin
            case (state)
                NS_GREEN: begin
                    ns_light <= 2'b01;
                    ew_light <= 2'b00;
                    if (cycle_count == 4'd7) begin
                        state <= NS_YELLOW;
                        cycle_count <= 4'd0;
                    end
                    else begin
                        cycle_count <= cycle_count + 1'b1;
                    end
                end
                
                NS_YELLOW: begin
                    ns_light <= 2'b10;
                    ew_light <= 2'b00;
                    if (cycle_count == 4'd1) begin
                        state <= EW_GREEN;
                        cycle_count <= 4'd0;
                    end
                    else begin
                        cycle_count <= cycle_count + 1'b1;
                    end
                end
                
                EW_GREEN: begin
                    ns_light <= 2'b00;
                    ew_light <= 2'b01;
                    if (cycle_count == 4'd7) begin
                        state <= EW_YELLOW;
                        cycle_count <= 4'd0;
                    end
                    else begin
                        cycle_count <= cycle_count + 1'b1;
                    end
                end
                
                EW_YELLOW: begin
                    ns_light <= 2'b00;
                    ew_light <= 2'b10;
                    if (cycle_count == 4'd1) begin
                        state <= NS_GREEN;
                        cycle_count <= 4'd0;
                    end
                    else begin
                        cycle_count <= cycle_count + 1'b1;
                    end
                end
                
                RED_STATE: begin
                    ns_light <= 2'b00;
                    ew_light <= 2'b00;
                    state <= NS_GREEN;
                end
                
                default: begin
                    state <= NS_GREEN;
                    cycle_count <= 4'd0;
                end
            endcase
        end
    end
    
endmodule

module testbench;
    reg clk, rst, emergency;
    wire [1:0] ns_light;
    wire [1:0] ew_light;
    
    traffic_light_fsm dut (
        .clk(clk),
        .rst(rst),
        .emergency(emergency),
        .ns_light(ns_light),
        .ew_light(ew_light)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst = 1'b1;
        emergency = 1'b0;
        
        #10 rst = 1'b0;
        #100 emergency = 1'b1;
        #20 emergency = 1'b0;
        #200 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t clk=%b rst=%b emergency=%b ns_light=%b ew_light=%b"", 
                 $time, clk, rst, emergency, ns_light, ew_light);
    end
endmodule",True,126,True,True,True,False,0.3,False,20.649577617645264,12.851975202560425,"Design a traffic light FSM with 4 states: NS_GREEN, NS_YELLOW, EW_GREEN, EW_YELLOW. Inputs: clk, rst, emergency. Outputs: ns_light[1:0], ew_light[1:0]. Timing: GREEN=8 cycles, YELLOW=2 cycles. Emergency makes both RED. Include testbench.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph TD
    CLK[clk] --> FSM
    RST[rst] --> FSM
    EMERGENCY[emergency] --> EMG{Emergency Check}
    
    FSM(NS_GREEN)
    FSM -->|8 cycles| YELLOW1(NS_YELLOW)
    YELLOW1 -->|2 cycles| GREEN1(EW_GREEN)
    GREEN1 -->|8 cycles| YELLOW2(EW_YELLOW)
    YELLOW2 -->|2 cycles| FSM

    EMG -->|emergency active| RED(RED State)
    RED --> FSM

    FSM --> NS_OUT[ns_light[1:0]]
    FSM --> EW_OUT[ew_light[1:0]]
    EMG --> NS_OUT
    EMG --> EW_OUT

    subgraph Testbench
        TB_CLK[clk] --> FSM
        TB_RST[rst] --> FSM
        TB_EMERGENCY[emergency] --> FSM
        FSM --> TB_NS_OUT[ns_light[1:0]]
        FSM --> TB_EW_OUT[ew_light[1:0]]
    end
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module traffic_light_fsm(
    input wire clk,
    input wire rst,
    input wire emergency,
    output reg [1:0] ns_light,
    output reg [1:0] ew_light
);

    typedef enum reg [1:0] {
        NS_GREEN = 2'b00,
        NS_YELLOW = 2'b01,
        EW_GREEN = 2'b10,
        EW_YELLOW = 2'b11
    } state_t;

    state_t current_state, next_state;
    reg [3:0] cycle_count;

    always @(posedge clk or posedge rst) begin
        if (rst) begin
            current_state <= NS_GREEN;
            cycle_count <= 4'd0;
        end else if (emergency) begin
            current_state <= NS_GREEN;
            cycle_count <= 4'd0;
        end else begin
            current_state <= next_state;
            cycle_count <= (cycle_count == 4'd9) ? 4'd0 : cycle_count + 1'b1;
        end
    end

    always @(*) begin
        case (current_state)
            NS_GREEN: begin
                if (cycle_count < 4'd8) begin
                    next_state = NS_GREEN;
                end else begin
                    next_state = NS_YELLOW;
                end
            end
            NS_YELLOW: begin
                if (cycle_count < 4'd2) begin
                    next_state = NS_YELLOW;
                end else begin
                    next_state = EW_GREEN;
                end
            end
            EW_GREEN: begin
                if (cycle_count < 4'd8) begin
                    next_state = EW_GREEN;
                end else begin
                    next_state = EW_YELLOW;
                end
            end
            EW_YELLOW: begin
                if (cycle_count < 4'd2) begin
                    next_state = EW_YELLOW;
                end else begin
                    next_state = NS_GREEN;
                end
            end
            default: next_state = NS_GREEN;
        endcase
    end

    always @(*) begin
        if (emergency) begin
            ns_light = 2'b00;  // RED
            ew_light = 2'b00;  // RED
        end else begin
            case (current_state)
                NS_GREEN: begin
                    ns_light = 2'b01;  // GREEN
                    ew_light = 2'b00;  // RED
                end
                NS_YELLOW: begin
                    ns_light = 2'b10;  // YELLOW
                    ew_light = 2'b00;  // RED
                end
                EW_GREEN: begin
                    ns_light = 2'b00;  // RED
                    ew_light = 2'b01;  // GREEN
                end
                EW_YELLOW: begin
                    ns_light = 2'b00;  // RED
                    ew_light = 2'b10;  // YELLOW
                end
                default: begin
                    ns_light = 2'b00;  // RED
                    ew_light = 2'b00;  // RED
                end
            endcase
        end
    end

endmodule

module testbench;
    reg clk, rst, emergency;
    wire [1:0] ns_light, ew_light;
    
    traffic_light_fsm dut (
        .clk(clk),
        .rst(rst),
        .emergency(emergency),
        .ns_light(ns_light),
        .ew_light(ew_light)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst = 1'b1;
        emergency = 1'b0;
        
        #20 rst = 1'b0;
        #200 emergency = 1'b1;
        #20 emergency = 1'b0;
        #200 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t clk=%b rst=%b emergency=%b ns_light=%b ew_light=%b"", 
                 $time, clk, rst, emergency, ns_light, ew_light);
    end
endmodule",True,132,True,True,True,False,0.3,False,9.538957595825195,9.575531482696533,tie,mermaid_only > combined > prompt_only,prompt_only > mermaid_only > combined
combined,State Machine,complex,"Design UART transmitter with states: IDLE, START, DATA, STOP. Protocol: START(0), 8 data bits LSB-first, STOP(1). Baud rate divider. Include testbench.",claude,"`timescale 1ns/1ps

module uart_tx(
    input wire clk,
    input wire rst_n,
    input wire tx_start,
    input wire [7:0] tx_data,
    output reg tx_done,
    output reg tx_line
);

parameter IDLE = 2'b00;
parameter START = 2'b01;
parameter DATA = 2'b10;
parameter STOP = 2'b11;

reg [1:0] state;
reg [2:0] bit_count;
reg [7:0] tx_shift;

always @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
        state <= IDLE;
        bit_count <= 3'b000;
        tx_shift <= 8'b0;
        tx_done <= 1'b0;
        tx_line <= 1'b1;
    end
    else begin
        case (state)
            IDLE: begin
                tx_line <= 1'b1;
                tx_done <= 1'b0;
                if (tx_start) begin
                    state <= START;
                    tx_shift <= tx_data;
                end
            end
            
            START: begin
                tx_line <= 1'b0;
                state <= DATA;
                bit_count <= 3'b000;
            end
            
            DATA: begin
                tx_line <= tx_shift[0];
                tx_shift <= {1'b0, tx_shift[7:1]};
                if (bit_count == 3'b111) begin
                    state <= STOP;
                end
                else begin
                    bit_count <= bit_count + 1'b1;
                end
            end
            
            STOP: begin
                tx_line <= 1'b1;
                tx_done <= 1'b1;
                state <= IDLE;
            end
            
            default: state <= IDLE;
        endcase
    end
end

endmodule

module testbench;
    reg clk;
    reg rst_n;
    reg tx_start;
    reg [7:0] tx_data;
    wire tx_done;
    wire tx_line;
    
    uart_tx dut (
        .clk(clk),
        .rst_n(rst_n),
        .tx_start(tx_start),
        .tx_data(tx_data),
        .tx_done(tx_done),
        .tx_line(tx_line)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst_n = 1'b0;
        tx_start = 1'b0;
        tx_data = 8'h00;
        
        #20 rst_n = 1'b1;
        #10 tx_data = 8'hA5;
        #10 tx_start = 1'b1;
        #10 tx_start = 1'b0;
        
        #200 tx_data = 8'h3C;
        #10 tx_start = 1'b1;
        #10 tx_start = 1'b0;
        
        #200 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t rst_n=%b tx_start=%b tx_data=%h tx_done=%b tx_line=%b"", 
                 $time, rst_n, tx_start, tx_data, tx_done, tx_line);
    end
endmodule",True,114,True,True,True,True,0.7,True,11.598081350326538,9.98303747177124,"graph LR
    CLK[Clock] --> BAUD(Baud Generator)
    RST[Reset] --> CTRL
    BAUD --> CTRL(Control FSM)
    
    CTRL --> |state|FSM[[State Register]]
    FSM --> |IDLE/START/DATA/STOP|CTRL
    
    DIN[TX Data Input] --> |8 bits|SHIFT[[Shift Register]]
    CTRL --> |load/shift|SHIFT
    
    SHIFT --> |serial_out|MUX{Output MUX}
    CTRL --> |sel|MUX
    
    MUX --> |tx_out|DOUT[UART TX Output]
    
    BIT_CNT[[Bit Counter]] --> CTRL
    CTRL --> |enable|BIT_CNT
    
    TB[Testbench] --> |test_data|DIN
    TB --> |test_clk|CLK
    TB --> |test_rst|RST
    DOUT --> |verify|TB","`timescale 1ns/1ps

module uart_tx (
    input wire clk,
    input wire rst,
    input wire [7:0] din,
    output wire tx_out
);

parameter IDLE = 2'b00;
parameter START = 2'b01;
parameter DATA = 2'b10;
parameter STOP = 2'b11;

reg [1:0] state, next_state;
reg [7:0] shift_reg;
reg [2:0] bit_count;
reg baud_tick;
reg tx_mux;

// Baud generator (simplified - divide by 4)
reg [1:0] baud_counter;
always @(posedge clk) begin
    if (rst)
        baud_counter <= 2'b00;
    else
        baud_counter <= baud_counter + 1'b1;
end
assign baud_tick = (baud_counter == 2'b11);

// State register
always @(posedge clk) begin
    if (rst)
        state <= IDLE;
    else
        state <= next_state;
end

// Next state logic
always @(*) begin
    case (state)
        IDLE: next_state = START;
        START: next_state = (baud_tick) ? DATA : START;
        DATA: next_state = (baud_tick && bit_count == 3'b111) ? STOP : DATA;
        STOP: next_state = (baud_tick) ? IDLE : STOP;
        default: next_state = IDLE;
    endcase
end

// Shift register
always @(posedge clk) begin
    if (rst)
        shift_reg <= 8'h00;
    else if (state == IDLE)
        shift_reg <= din;
    else if (state == DATA && baud_tick)
        shift_reg <= {1'b0, shift_reg[7:1]};
end

// Bit counter
always @(posedge clk) begin
    if (rst || state == IDLE)
        bit_count <= 3'b000;
    else if (state == DATA && baud_tick)
        bit_count <= bit_count + 1'b1;
end

// Output MUX
always @(*) begin
    case (state)
        IDLE: tx_mux = 1'b1;
        START: tx_mux = 1'b0;
        DATA: tx_mux = shift_reg[0];
        STOP: tx_mux = 1'b1;
        default: tx_mux = 1'b1;
    endcase
end

assign tx_out = tx_mux;

endmodule

module testbench;
    reg clk, rst;
    reg [7:0] test_data;
    wire tx_out;
    
    uart_tx dut (
        .clk(clk),
        .rst(rst),
        .din(test_data),
        .tx_out(tx_out)
    );
    
    initial begin
        $dumpfile(""uart_tx.vcd"");
        $dumpvars(0, testbench);
        
        clk = 0;
        rst = 1;
        test_data = 8'h55;
        
        #20 rst = 0;
        #200 test_data = 8'hAA;
        #200 rst = 1;
        #20 rst = 0;
        #100 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t rst=%b data=%h tx=%b"", 
                 $time, rst, test_data, tx_out);
    end
endmodule",True,116,True,True,True,,0.0,,16.298060417175293,0.015392303466796875,"Design UART transmitter with states: IDLE, START, DATA, STOP. Protocol: START(0), 8 data bits LSB-first, STOP(1). Baud rate divider. Include testbench.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph LR
    CLK[Clock] --> BAUD(Baud Generator)
    RST[Reset] --> CTRL
    BAUD --> CTRL(Control FSM)
    
    CTRL --> |state|FSM[[State Register]]
    FSM --> |IDLE/START/DATA/STOP|CTRL
    
    DIN[TX Data Input] --> |8 bits|SHIFT[[Shift Register]]
    CTRL --> |load/shift|SHIFT
    
    SHIFT --> |serial_out|MUX{Output MUX}
    CTRL --> |sel|MUX
    
    MUX --> |tx_out|DOUT[UART TX Output]
    
    BIT_CNT[[Bit Counter]] --> CTRL
    CTRL --> |enable|BIT_CNT
    
    TB[Testbench] --> |test_data|DIN
    TB --> |test_clk|CLK
    TB --> |test_rst|RST
    DOUT --> |verify|TB
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module baud_gen(
    input wire clk,
    input wire rst_n,
    output reg baud_tick
);

parameter DIVISOR = 16'd868; // 115200 baud @ 100MHz

reg [15:0] counter;

always @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
        counter <= 16'd0;
        baud_tick <= 1'b0;
    end else begin
        if (counter == DIVISOR-1) begin
            counter <= 16'd0;
            baud_tick <= 1'b1;
        end else begin
            counter <= counter + 1'b1;
            baud_tick <= 1'b0;
        end
    end
end
endmodule

module uart_tx(
    input wire clk,
    input wire rst_n,
    input wire [7:0] tx_data,
    input wire tx_start,
    output reg tx_busy,
    output wire tx_out
);

localparam IDLE = 2'b00;
localparam START = 2'b01;
localparam DATA = 2'b10;
localparam STOP = 2'b11;

reg [1:0] state, next_state;
reg [2:0] bit_cnt;
reg [7:0] shift_reg;
reg shift_load, shift_en;
wire baud_tick;

baud_gen baud_gen_inst(
    .clk(clk),
    .rst_n(rst_n),
    .baud_tick(baud_tick)
);

always @(posedge clk or negedge rst_n) begin
    if (!rst_n)
        state <= IDLE;
    else
        state <= next_state;
end

always @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
        shift_reg <= 8'h00;
    end else if (shift_load) begin
        shift_reg <= tx_data;
    end else if (shift_en && baud_tick) begin
        shift_reg <= {1'b0, shift_reg[7:1]};
    end
end

always @(posedge clk or negedge rst_n) begin
    if (!rst_n)
        bit_cnt <= 3'b000;
    else if (state == IDLE)
        bit_cnt <= 3'b000;
    else if (baud_tick && state == DATA)
        bit_cnt <= bit_cnt + 1'b1;
end

always @(*) begin
    next_state = state;
    shift_load = 1'b0;
    shift_en = 1'b0;
    tx_busy = 1'b1;
    
    case (state)
        IDLE: begin
            tx_busy = 1'b0;
            if (tx_start) begin
                next_state = START;
                shift_load = 1'b1;
            end
        end
        
        START: begin
            if (baud_tick)
                next_state = DATA;
        end
        
        DATA: begin
            shift_en = 1'b1;
            if (baud_tick && bit_cnt == 3'b111)
                next_state = STOP;
        end
        
        STOP: begin
            if (baud_tick)
                next_state = IDLE;
        end
    endcase
end

assign tx_out = (state == IDLE) ? 1'b1 :
                (state == START) ? 1'b0 :
                (state == DATA) ? shift_reg[0] :
                1'b1;

endmodule

module testbench;
    reg clk, rst_n;
    reg [7:0] tx_data;
    reg tx_start;
    wire tx_busy, tx_out;
    
    uart_tx dut(
        .clk(clk),
        .rst_n(rst_n),
        .tx_data(tx_data),
        .tx_start(tx_start),
        .tx_busy(tx_busy),
        .tx_out(tx_out)
    );
    
    initial begin
        $dumpfile(""uart_tx.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst_n = 1'b0;
        tx_data = 8'h00;
        tx_start = 1'b0;
        
        #20 rst_n = 1'b1;
        #20 tx_data = 8'h55;
        #10 tx_start = 1'b1;
        #10 tx_start = 1'b0;
        
        wait(!tx_busy);
        #1000;
        
        tx_data = 8'hAA;
        tx_start = 1'b1;
        #10 tx_start = 1'b0;
        
        wait(!tx_busy);
        #1000;
        
        $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t rst_n=%b tx_data=%h tx_start=%b tx_busy=%b tx_out=%b"",
                 $time, rst_n, tx_data, tx_start, tx_busy, tx_out);
    end
endmodule",True,169,True,True,True,,0.0,,15.684786319732666,0.05286574363708496,prompt_only,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,State Machine,complex,"Design UART transmitter with states: IDLE, START, DATA, STOP. Protocol: START(0), 8 data bits LSB-first, STOP(1). Baud rate divider. Include testbench.",gpt-4o,"`timescale 1ns/1ps

module uart_tx(
    input wire clk,
    input wire rst_n,
    input wire start,
    input wire [7:0] data_in,
    output reg tx,
    output reg busy
);

    reg [3:0] state;
    reg [7:0] shift_reg;
    reg [2:0] bit_count;
    reg [15:0] baud_count;

    parameter IDLE = 4'b0000;
    parameter START = 4'b0001;
    parameter DATA = 4'b0010;
    parameter STOP = 4'b0011;

    parameter BAUD_DIV = 16'd5208; // Example baud rate divider

    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            state <= IDLE;
            tx <= 1'b1;
            busy <= 1'b0;
            shift_reg <= 8'b00000000;
            bit_count <= 3'b000;
            baud_count <= 16'b0;
        end else begin
            case (state)
                IDLE: begin
                    tx <= 1'b1;
                    busy <= 1'b0;
                    if (start) begin
                        state <= START;
                        shift_reg <= data_in;
                        bit_count <= 3'b000;
                        baud_count <= 16'b0;
                    end
                end
                START: begin
                    busy <= 1'b1;
                    if (baud_count == BAUD_DIV) begin
                        baud_count <= 16'b0;
                        tx <= 1'b0;
                        state <= DATA;
                    end else begin
                        baud_count <= baud_count + 1'b1;
                    end
                end
                DATA: begin
                    if (baud_count == BAUD_DIV) begin
                        baud_count <= 16'b0;
                        tx <= shift_reg[0];
                        shift_reg <= shift_reg >> 1;
                        bit_count <= bit_count + 1'b1;
                        if (bit_count == 3'b111) begin
                            state <= STOP;
                        end
                    end else begin
                        baud_count <= baud_count + 1'b1;
                    end
                end
                STOP: begin
                    if (baud_count == BAUD_DIV) begin
                        baud_count <= 16'b0;
                        tx <= 1'b1;
                        state <= IDLE;
                    end else begin
                        baud_count <= baud_count + 1'b1;
                    end
                end
            endcase
        end
    end

endmodule

module testbench;
    reg clk, rst_n, start;
    reg [7:0] data_in;
    wire tx, busy;

    uart_tx dut (
        .clk(clk),
        .rst_n(rst_n),
        .start(start),
        .data_in(data_in),
        .tx(tx),
        .busy(busy)
    );

    initial begin
        $dumpfile(""uart_tx.vcd"");
        $dumpvars(0, testbench);

        clk = 1'b0;
        rst_n = 1'b0;
        start = 1'b0;
        data_in = 8'b10101010;

        #20 rst_n = 1'b1;
        #10 start = 1'b1;
        #10 start = 1'b0;
        #1000 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b start=%b data_in=%b tx=%b busy=%b"", 
                 $time, clk, rst_n, start, data_in, tx, busy);
    end
endmodule",True,117,True,True,True,,0.0,,10.207045555114746,0.015212297439575195,"graph TD
    CLK[Clock] --> BD[Baud Rate Divider]
    RST[Reset] --> FSM
    BD --> FSM

    IN[Data Input] --> FSM
    FSM --> OUT[Serial Output]

    FSM(Idle State) -->|Start Bit| FSM(Start State)
    FSM(Start State) -->|Data Bits| FSM(Data State)
    FSM(Data State) -->|Stop Bit| FSM(Stop State)
    FSM(Stop State) -->|Completed| FSM(Idle State)

    TB[Testbench]
    TB --> CLK
    TB --> RST
    TB --> IN
    OUT --> TB","`timescale 1ns/1ps

module fsm_uart(
    input wire clk,
    input wire rst_n,
    input wire baud_pulse,
    input wire data_in,
    output reg serial_out
);
    reg [1:0] state, next_state;
    reg [7:0] data_reg;
    reg [3:0] bit_count;

    localparam IDLE = 2'b00;
    localparam START = 2'b01;
    localparam DATA = 2'b10;
    localparam STOP = 2'b11;

    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            state <= IDLE;
            data_reg <= 8'b0;
            bit_count <= 4'b0;
            serial_out <= 1'b1;
        end else begin
            if (baud_pulse) begin
                state <= next_state;
                if (state == DATA) begin
                    data_reg <= {data_in, data_reg[7:1]};
                    bit_count <= bit_count + 1'b1;
                end
            end
        end
    end

    always @(*) begin
        next_state = state;
        serial_out = 1'b1;
        case (state)
            IDLE: begin
                if (data_in == 1'b0) // Start bit detected
                    next_state = START;
            end
            START: begin
                next_state = DATA;
            end
            DATA: begin
                serial_out = data_reg[0];
                if (bit_count == 4'b1000) // 8 data bits
                    next_state = STOP;
            end
            STOP: begin
                next_state = IDLE;
            end
        endcase
    end

endmodule

module testbench;
    reg clk, rst_n, baud_pulse, data_in;
    wire serial_out;

    fsm_uart dut (
        .clk(clk),
        .rst_n(rst_n),
        .baud_pulse(baud_pulse),
        .data_in(data_in),
        .serial_out(serial_out)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 1'b0;
        rst_n = 1'b0;
        baud_pulse = 1'b0;
        data_in = 1'b1;

        #20 rst_n = 1'b1;
        #10 data_in = 1'b0; // Start bit
        #10 baud_pulse = 1'b1;
        #10 baud_pulse = 1'b0;
        #10 data_in = 1'b1; // Data bit 1
        #10 baud_pulse = 1'b1;
        #10 baud_pulse = 1'b0;
        #10 data_in = 1'b1; // Data bit 2
        #10 baud_pulse = 1'b1;
        #10 baud_pulse = 1'b0;
        #10 data_in = 1'b0; // Data bit 3
        #10 baud_pulse = 1'b1;
        #10 baud_pulse = 1'b0;
        #10 data_in = 1'b1; // Data bit 4
        #10 baud_pulse = 1'b1;
        #10 baud_pulse = 1'b0;
        #10 data_in = 1'b0; // Data bit 5
        #10 baud_pulse = 1'b1;
        #10 baud_pulse = 1'b0;
        #10 data_in = 1'b1; // Data bit 6
        #10 baud_pulse = 1'b1;
        #10 baud_pulse = 1'b0;
        #10 data_in = 1'b0; // Data bit 7
        #10 baud_pulse = 1'b1;
        #10 baud_pulse = 1'b0;
        #10 data_in = 1'b1; // Data bit 8
        #10 baud_pulse = 1'b1;
        #10 baud_pulse = 1'b0;
        #10 baud_pulse = 1'b1; // Stop bit
        #10 baud_pulse = 1'b0;
        #50 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b baud_pulse=%b data_in=%b serial_out=%b"", 
                 $time, clk, rst_n, baud_pulse, data_in, serial_out);
    end
endmodule",True,120,True,True,True,True,0.7,True,14.067245721817017,16.66065788269043,"Design UART transmitter with states: IDLE, START, DATA, STOP. Protocol: START(0), 8 data bits LSB-first, STOP(1). Baud rate divider. Include testbench.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph TD
    CLK[Clock] --> BD[Baud Rate Divider]
    RST[Reset] --> FSM
    BD --> FSM

    IN[Data Input] --> FSM
    FSM --> OUT[Serial Output]

    FSM(Idle State) -->|Start Bit| FSM(Start State)
    FSM(Start State) -->|Data Bits| FSM(Data State)
    FSM(Data State) -->|Stop Bit| FSM(Stop State)
    FSM(Stop State) -->|Completed| FSM(Idle State)

    TB[Testbench]
    TB --> CLK
    TB --> RST
    TB --> IN
    OUT --> TB
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module uart_tx(
    input wire clk,
    input wire rst,
    input wire [7:0] data_in,
    input wire start,
    output reg tx_out,
    output reg busy
);

    reg [3:0] state;
    reg [9:0] shift_reg;
    reg [3:0] bit_counter;
    wire baud_tick;

    localparam IDLE = 4'd0;
    localparam START = 4'd1;
    localparam DATA = 4'd2;
    localparam STOP = 4'd3;

    baud_rate_divider bd(
        .clk(clk),
        .rst(rst),
        .tick(baud_tick)
    );

    always @(posedge clk or posedge rst) begin
        if (rst) begin
            state <= IDLE;
            tx_out <= 1'b1;
            busy <= 1'b0;
            shift_reg <= 10'b1111111111;
            bit_counter <= 4'd0;
        end else if (baud_tick) begin
            case (state)
                IDLE: begin
                    tx_out <= 1'b1;
                    busy <= 1'b0;
                    if (start) begin
                        state <= START;
                        busy <= 1'b1;
                        shift_reg <= {1'b1, data_in, 1'b0}; // STOP, DATA, START
                        bit_counter <= 4'd0;
                    end
                end
                START: begin
                    tx_out <= shift_reg[0];
                    shift_reg <= shift_reg >> 1;
                    state <= DATA;
                end
                DATA: begin
                    tx_out <= shift_reg[0];
                    shift_reg <= shift_reg >> 1;
                    bit_counter <= bit_counter + 1'b1;
                    if (bit_counter == 4'd7) begin
                        state <= STOP;
                    end
                end
                STOP: begin
                    tx_out <= shift_reg[0];
                    state <= IDLE;
                end
            endcase
        end
    end

endmodule

module baud_rate_divider(
    input wire clk,
    input wire rst,
    output reg tick
);

    reg [15:0] counter;

    always @(posedge clk or posedge rst) begin
        if (rst) begin
            counter <= 16'd0;
            tick <= 1'b0;
        end else begin
            if (counter == 16'd5208) begin // Assuming 50MHz clock and 9600 baud rate
                counter <= 16'd0;
                tick <= 1'b1;
            end else begin
                counter <= counter + 1'b1;
                tick <= 1'b0;
            end
        end
    end

endmodule

module testbench;
    reg clk, rst, start;
    reg [7:0] data_in;
    wire tx_out, busy;

    uart_tx dut(
        .clk(clk),
        .rst(rst),
        .data_in(data_in),
        .start(start),
        .tx_out(tx_out),
        .busy(busy)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 1'b0;
        rst = 1'b1;
        start = 1'b0;
        data_in = 8'b10101010;

        #10 rst = 1'b0;
        #20 start = 1'b1;
        #10 start = 1'b0;
        #1000 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t clk=%b rst=%b start=%b data_in=%b tx_out=%b busy=%b"", 
                 $time, clk, rst, start, data_in, tx_out, busy);
    end
endmodule",True,130,True,True,True,True,0.9,True,21.731009244918823,14.22541880607605,prompt_only,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,CPU Component,complex,Create 8-register  8-bit register file with dual read ports and single write port. Include testbench with simultaneous operations.,claude,"`timescale 1ns/1ps

module regfile8x8 (
    input wire clk,
    input wire rst_n,
    input wire write_en,
    input wire [2:0] write_addr,
    input wire [7:0] write_data,
    input wire [2:0] read_addr1,
    input wire [2:0] read_addr2,
    output wire [7:0] read_data1,
    output wire [7:0] read_data2
);

reg [7:0] registers [0:7];
integer i;

assign read_data1 = registers[read_addr1];
assign read_data2 = registers[read_addr2];

always @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
        for (i = 0; i < 8; i = i + 1)
            registers[i] <= 8'b0;
    end
    else if (write_en) begin
        registers[write_addr] <= write_data;
    end
end

endmodule

module testbench;
    reg clk, rst_n, write_en;
    reg [2:0] write_addr, read_addr1, read_addr2;
    reg [7:0] write_data;
    wire [7:0] read_data1, read_data2;
    
    regfile8x8 dut (
        .clk(clk),
        .rst_n(rst_n),
        .write_en(write_en),
        .write_addr(write_addr),
        .write_data(write_data),
        .read_addr1(read_addr1),
        .read_addr2(read_addr2),
        .read_data1(read_data1),
        .read_data2(read_data2)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 0;
        rst_n = 0;
        write_en = 0;
        write_addr = 0;
        write_data = 0;
        read_addr1 = 0;
        read_addr2 = 0;
        
        #10 rst_n = 1;
        
        // Write test pattern
        #10 write_en = 1;
        write_addr = 3'h0; write_data = 8'h11;
        #10 write_addr = 3'h1; write_data = 8'h22;
        #10 write_addr = 3'h2; write_data = 8'h33;
        
        // Simultaneous read test
        #10 write_en = 0;
        read_addr1 = 3'h0;
        read_addr2 = 3'h1;
        
        #10 read_addr1 = 3'h1;
        read_addr2 = 3'h2;
        
        // Write while reading
        #10 write_en = 1;
        write_addr = 3'h3;
        write_data = 8'h44;
        read_addr1 = 3'h2;
        read_addr2 = 3'h0;
        
        #50 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t rd1=%h rd2=%h"", $time, read_data1, read_data2);
    end
endmodule",True,94,True,True,True,False,0.4,False,9.980693578720093,7.1141674518585205,"graph LR
    CLK[Clock] --> REGFILE
    RST[Reset] --> REGFILE
    WE[Write Enable] --> REGFILE
    WADDR[Write Address] --> REGFILE
    WDATA[Write Data] --> REGFILE
    RADDR1[Read Address 1] --> REGFILE
    RADDR2[Read Address 2] --> REGFILE
    REGFILE[[8x8 Register File]] --> RDATA1[Read Data 1]
    REGFILE --> RDATA2[Read Data 2]
    TB[Testbench] --> WE
    TB --> WADDR
    TB --> WDATA
    TB --> RADDR1
    TB --> RADDR2
    CLK --> TB
    RST --> TB
    RDATA1 --> TB
    RDATA2 --> TB
    TB --> VERIFY{Verification}
    VERIFY --> RESULT[Test Results]","`timescale 1ns/1ps

module regfile (
    input wire clk,
    input wire rst,
    input wire we,
    input wire [2:0] waddr,
    input wire [7:0] wdata,
    input wire [2:0] raddr1,
    input wire [2:0] raddr2,
    output reg [7:0] rdata1,
    output reg [7:0] rdata2
);

reg [7:0] registers [0:7];
integer i;

always @(posedge clk or posedge rst) begin
    if (rst) begin
        for (i = 0; i < 8; i = i + 1)
            registers[i] <= 8'h00;
    end
    else begin
        if (we)
            registers[waddr] <= wdata;
        rdata1 <= registers[raddr1];
        rdata2 <= registers[raddr2];
    end
end

endmodule

module testbench;
    reg clk, rst, we;
    reg [2:0] waddr, raddr1, raddr2;
    reg [7:0] wdata;
    wire [7:0] rdata1, rdata2;
    
    regfile dut (
        .clk(clk),
        .rst(rst),
        .we(we),
        .waddr(waddr),
        .wdata(wdata),
        .raddr1(raddr1),
        .raddr2(raddr2),
        .rdata1(rdata1),
        .rdata2(rdata2)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 0;
        rst = 1;
        we = 0;
        waddr = 0;
        raddr1 = 0;
        raddr2 = 0;
        wdata = 0;
        
        #20 rst = 0;
        
        // Write test pattern
        #10 we = 1;
        #10 waddr = 3'h1; wdata = 8'h55;
        #10 waddr = 3'h2; wdata = 8'hAA;
        #10 we = 0;
        
        // Read test pattern
        #10 raddr1 = 3'h1; raddr2 = 3'h2;
        #20 raddr1 = 3'h2; raddr2 = 3'h1;
        
        #50 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t rst=%b we=%b waddr=%h wdata=%h raddr1=%h rdata1=%h raddr2=%h rdata2=%h"",
                 $time, rst, we, waddr, wdata, raddr1, rdata1, raddr2, rdata2);
    end
endmodule",True,84,True,True,True,False,0.4,False,12.72896671295166,8.707679510116577,"Create 8-register  8-bit register file with dual read ports and single write port. Include testbench with simultaneous operations.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph LR
    CLK[Clock] --> REGFILE
    RST[Reset] --> REGFILE
    WE[Write Enable] --> REGFILE
    WADDR[Write Address] --> REGFILE
    WDATA[Write Data] --> REGFILE
    RADDR1[Read Address 1] --> REGFILE
    RADDR2[Read Address 2] --> REGFILE
    REGFILE[[8x8 Register File]] --> RDATA1[Read Data 1]
    REGFILE --> RDATA2[Read Data 2]
    TB[Testbench] --> WE
    TB --> WADDR
    TB --> WDATA
    TB --> RADDR1
    TB --> RADDR2
    CLK --> TB
    RST --> TB
    RDATA1 --> TB
    RDATA2 --> TB
    TB --> VERIFY{Verification}
    VERIFY --> RESULT[Test Results]
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module regfile (
    input wire clk,
    input wire rst,
    input wire we,
    input wire [2:0] waddr,
    input wire [7:0] wdata,
    input wire [2:0] raddr1,
    input wire [2:0] raddr2,
    output reg [7:0] rdata1,
    output reg [7:0] rdata2
);

reg [7:0] registers[0:7];
integer i;

always @(posedge clk or posedge rst) begin
    if (rst) begin
        for (i = 0; i < 8; i = i + 1)
            registers[i] <= 8'h00;
    end
    else if (we) begin
        registers[waddr] <= wdata;
    end
end

always @(*) begin
    rdata1 = registers[raddr1];
    rdata2 = registers[raddr2];
end

endmodule

module testbench;
    reg clk, rst, we;
    reg [2:0] waddr, raddr1, raddr2;
    reg [7:0] wdata;
    wire [7:0] rdata1, rdata2;
    
    regfile dut (
        .clk(clk),
        .rst(rst),
        .we(we),
        .waddr(waddr),
        .wdata(wdata),
        .raddr1(raddr1),
        .raddr2(raddr2),
        .rdata1(rdata1),
        .rdata2(rdata2)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 0;
        rst = 1;
        we = 0;
        waddr = 0;
        raddr1 = 0;
        raddr2 = 0;
        wdata = 0;
        
        #20 rst = 0;
        
        // Test write operations
        #10;
        we = 1;
        waddr = 3'd0;
        wdata = 8'hA5;
        #10;
        waddr = 3'd1;
        wdata = 8'h5A;
        
        // Test read operations
        #10;
        we = 0;
        raddr1 = 3'd0;
        raddr2 = 3'd1;
        
        // Verify results
        #10;
        if (rdata1 !== 8'hA5 || rdata2 !== 8'h5A)
            $display(""Test failed!"");
        else
            $display(""Test passed!"");
            
        #10 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t rst=%b we=%b waddr=%h wdata=%h raddr1=%h rdata1=%h raddr2=%h rdata2=%h"",
                 $time, rst, we, waddr, wdata, raddr1, rdata1, raddr2, rdata2);
    end

endmodule",True,99,True,True,True,False,0.4,False,9.55275559425354,7.824563980102539,tie,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,CPU Component,complex,Create 8-register  8-bit register file with dual read ports and single write port. Include testbench with simultaneous operations.,gpt-4o,"`timescale 1ns/1ps

module register_file_8x8(
    input wire clk,
    input wire rst_n,
    input wire [2:0] read_addr1,
    input wire [2:0] read_addr2,
    input wire [2:0] write_addr,
    input wire [7:0] write_data,
    input wire write_enable,
    output wire [7:0] read_data1,
    output wire [7:0] read_data2
);

    reg [7:0] registers [7:0];
    integer i;

    assign read_data1 = registers[read_addr1];
    assign read_data2 = registers[read_addr2];

    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            for (i = 1'b0; i < 8; i = i + 1) begin
                registers[i] <= 8'b00000000;
            end
        end else if (write_enable) begin
            registers[write_addr] <= write_data;
        end
    end
    
endmodule

module testbench;
    reg clk;
    reg rst_n;
    reg [2:0] read_addr1, read_addr2, write_addr;
    reg [7:0] write_data;
    reg write_enable;
    wire [7:0] read_data1, read_data2;

    register_file_8x8 dut (
        .clk(clk),
        .rst_n(rst_n),
        .read_addr1(read_addr1),
        .read_addr2(read_addr2),
        .write_addr(write_addr),
        .write_data(write_data),
        .write_enable(write_enable),
        .read_data1(read_data1),
        .read_data2(read_data2)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 1'b0;
        rst_n = 1'b0;
        write_enable = 1'b0;
        read_addr1 = 3'b000;
        read_addr2 = 3'b000;
        write_addr = 3'b000;
        write_data = 8'b00000000;

        #20 rst_n = 1'b1;
        #10 write_enable = 1'b1; write_addr = 3'b001; write_data = 8'b10101010;
        #10 write_enable = 1'b0; read_addr1 = 3'b001;
        #10 write_enable = 1'b1; write_addr = 3'b010; write_data = 8'b11001100;
        #10 write_enable = 1'b0; read_addr2 = 3'b010;
        #50 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b write_enable=%b write_addr=%b write_data=%h read_addr1=%b read_data1=%h read_addr2=%b read_data2=%h"", 
                 $time, clk, rst_n, write_enable, write_addr, write_data, read_addr1, read_data1, read_addr2, read_data2);
    end
endmodule",True,79,True,True,True,True,0.75,True,9.376673460006714,8.064392805099487,"graph TD
    CLK[Clock] --> RF[[8x8 Register File]]
    RST[Reset] --> RF
    
    WriteData[Write Data (8-bit)] --> RF
    WriteAddr[Write Address (3-bit)] --> RF
    WriteEnable[Write Enable] --> RF
    
    RF --> ReadData1[Read Data 1 (8-bit)]
    ReadAddr1[Read Address 1 (3-bit)] --> RF
    
    RF --> ReadData2[Read Data 2 (8-bit)]
    ReadAddr2[Read Address 2 (3-bit)] --> RF
    
    Testbench((Testbench)) -->|Simultaneous Operations| RF
    CLK --> Testbench
    RST --> Testbench","`timescale 1ns/1ps

module register_file(
    input wire clk,
    input wire rst,
    input wire [7:0] write_data,
    input wire [2:0] write_addr,
    input wire write_enable,
    input wire [2:0] read_addr1,
    output reg [7:0] read_data1,
    input wire [2:0] read_addr2,
    output reg [7:0] read_data2
);

    reg [7:0] registers [7:0];
    integer i;

    always @(posedge clk or posedge rst) begin
        if (rst) begin
            for (i = 1'b0; i < 8; i = i + 1) begin
                registers[i] <= 8'b0;
            end
            read_data1 <= 8'b0;
            read_data2 <= 8'b0;
        end else begin
            if (write_enable) begin
                registers[write_addr] <= write_data;
            end
            read_data1 <= registers[read_addr1];
            read_data2 <= registers[read_addr2];
        end
    end

endmodule

module testbench;
    reg clk, rst, write_enable;
    reg [7:0] write_data;
    reg [2:0] write_addr, read_addr1, read_addr2;
    wire [7:0] read_data1, read_data2;

    register_file dut (
        .clk(clk),
        .rst(rst),
        .write_data(write_data),
        .write_addr(write_addr),
        .write_enable(write_enable),
        .read_addr1(read_addr1),
        .read_data1(read_data1),
        .read_addr2(read_addr2),
        .read_data2(read_data2)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst = 1'b1;
        write_enable = 1'b0;
        write_data = 8'b0;
        write_addr = 3'b0;
        read_addr1 = 3'b0;
        read_addr2 = 3'b0;
        
        #20 rst = 1'b0;
        #10 write_enable = 1'b1; write_data = 8'hAA; write_addr = 3'b001;
        #10 write_enable = 1'b0; read_addr1 = 3'b001;
        #10 read_addr2 = 3'b001;
        #50 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t clk=%b rst=%b write_enable=%b write_addr=%b write_data=%h read_addr1=%b read_data1=%h read_addr2=%b read_data2=%h"", 
                 $time, clk, rst, write_enable, write_addr, write_data, read_addr1, read_data1, read_addr2, read_data2);
    end
endmodule",True,79,True,True,True,True,0.75,True,11.473275661468506,10.913578748703003,"Create 8-register  8-bit register file with dual read ports and single write port. Include testbench with simultaneous operations.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph TD
    CLK[Clock] --> RF[[8x8 Register File]]
    RST[Reset] --> RF
    
    WriteData[Write Data (8-bit)] --> RF
    WriteAddr[Write Address (3-bit)] --> RF
    WriteEnable[Write Enable] --> RF
    
    RF --> ReadData1[Read Data 1 (8-bit)]
    ReadAddr1[Read Address 1 (3-bit)] --> RF
    
    RF --> ReadData2[Read Data 2 (8-bit)]
    ReadAddr2[Read Address 2 (3-bit)] --> RF
    
    Testbench((Testbench)) -->|Simultaneous Operations| RF
    CLK --> Testbench
    RST --> Testbench
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module register_file(
    input wire clk,
    input wire rst,
    input wire [7:0] write_data,
    input wire [2:0] write_addr,
    input wire write_enable,
    input wire [2:0] read_addr1,
    output reg [7:0] read_data1,
    input wire [2:0] read_addr2,
    output reg [7:0] read_data2
);
    reg [7:0] regfile [7:0];

    // Write operation
    always @(posedge clk or posedge rst) begin
        if (rst) begin
            regfile[0] <= 8'b0;
            regfile[1] <= 8'b0;
            regfile[2] <= 8'b0;
            regfile[3] <= 8'b0;
            regfile[4] <= 8'b0;
            regfile[5] <= 8'b0;
            regfile[6] <= 8'b0;
            regfile[7] <= 8'b0;
        end else if (write_enable) begin
            regfile[write_addr] <= write_data;
        end
    end

    // Read operations
    always @(*) begin
        read_data1 = regfile[read_addr1];
        read_data2 = regfile[read_addr2];
    end

endmodule

module testbench;
    reg clk, rst, write_enable;
    reg [7:0] write_data;
    reg [2:0] write_addr, read_addr1, read_addr2;
    wire [7:0] read_data1, read_data2;

    register_file dut (
        .clk(clk),
        .rst(rst),
        .write_data(write_data),
        .write_addr(write_addr),
        .write_enable(write_enable),
        .read_addr1(read_addr1),
        .read_data1(read_data1),
        .read_addr2(read_addr2),
        .read_data2(read_data2)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 1'b0;
        rst = 1'b1;
        write_enable = 1'b0;
        write_data = 8'b0;
        write_addr = 3'b0;
        read_addr1 = 3'b0;
        read_addr2 = 3'b0;

        #20 rst = 1'b0;
        #10 write_enable = 1'b1; write_data = 8'b10101010; write_addr = 3'b001;
        #10 write_enable = 1'b0; read_addr1 = 3'b001; read_addr2 = 3'b010;
        #20 write_enable = 1'b1; write_data = 8'b11001100; write_addr = 3'b010;
        #10 write_enable = 1'b0;
        #50 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t clk=%b rst=%b write_enable=%b write_data=%b write_addr=%b read_addr1=%b read_data1=%b read_addr2=%b read_data2=%b"", 
                 $time, clk, rst, write_enable, write_data, write_addr, read_addr1, read_data1, read_addr2, read_data2);
    end
endmodule",True,84,True,True,True,True,0.7,True,8.941047430038452,17.20231580734253,prompt_only,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,Advanced Sequential,complex,"Design 8-bit resolution PWM generator with configurable duty cycle. Include testbench with duty cycles: 0%, 25%, 50%, 75%, 100%.",claude,"`timescale 1ns/1ps

module pwm_gen(
    input wire clk,
    input wire rst_n,
    input wire [7:0] duty_cycle,
    output reg pwm_out
);

reg [7:0] counter;

always @(posedge clk or negedge rst_n) begin
    if (!rst_n)
        counter <= 8'h00;
    else
        counter <= counter + 1'b1;
end

always @(posedge clk or negedge rst_n) begin
    if (!rst_n)
        pwm_out <= 1'b0;
    else
        pwm_out <= (counter < duty_cycle);
end

endmodule

module testbench;
    reg clk;
    reg rst_n;
    reg [7:0] duty_cycle;
    wire pwm_out;

    pwm_gen dut (
        .clk(clk),
        .rst_n(rst_n),
        .duty_cycle(duty_cycle),
        .pwm_out(pwm_out)
    );

    initial begin
        $dumpfile(""pwm.vcd"");
        $dumpvars(0, testbench);

        clk = 0;
        rst_n = 0;
        duty_cycle = 8'h00;

        #20 rst_n = 1;

        // Test 0% duty cycle
        #100 duty_cycle = 8'h00;

        // Test 25% duty cycle
        #512 duty_cycle = 8'h40;

        // Test 50% duty cycle
        #512 duty_cycle = 8'h80;

        // Test 75% duty cycle
        #512 duty_cycle = 8'hC0;

        // Test 100% duty cycle
        #512 duty_cycle = 8'hFF;

        #512 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t rst_n=%b duty_cycle=%d pwm_out=%b"",
                 $time, rst_n, duty_cycle, pwm_out);
    end
endmodule",True,75,True,True,True,,0.0,,6.304419040679932,0.01374197006225586,"graph TD
    CLK[Clock Input] --> CNT((8-bit Counter))
    RST[Reset] --> CNT
    
    DC[[Duty Cycle Register]] --> CMP((Comparator))
    CNT --> CMP
    
    T0[Test 0% - 0x00] --> MUX
    T1[Test 25% - 0x40] --> MUX
    T2[Test 50% - 0x80] --> MUX
    T3[Test 75% - 0xC0] --> MUX
    T4[Test 100% - 0xFF] --> MUX
    
    SEL[Test Select] --> MUX{Test MUX}
    MUX --> DC
    
    CMP --> PWM[PWM Output]
    
    CLK --> DC
    RST --> DC
    CLK --> CMP
    RST --> CMP","`timescale 1ns/1ps

module pwm_generator(
    input wire clk,
    input wire rst,
    input wire [2:0] sel,
    output wire pwm_out
);

reg [7:0] counter;
reg [7:0] duty_cycle;
reg pwm_reg;

// 8-bit counter
always @(posedge clk or posedge rst) begin
    if (rst)
        counter <= 8'h00;
    else
        counter <= counter + 1'b1;
end

// Duty cycle register with test values mux
always @(posedge clk or posedge rst) begin
    if (rst)
        duty_cycle <= 8'h00;
    else
        case (sel)
            3'b000: duty_cycle <= 8'h00;  // 0%
            3'b001: duty_cycle <= 8'h40;  // 25%
            3'b010: duty_cycle <= 8'h80;  // 50%
            3'b011: duty_cycle <= 8'hC0;  // 75%
            3'b100: duty_cycle <= 8'hFF;  // 100%
            default: duty_cycle <= 8'h00;
        endcase
end

// Comparator
always @(posedge clk or posedge rst) begin
    if (rst)
        pwm_reg <= 1'b0;
    else
        pwm_reg <= (counter < duty_cycle);
end

assign pwm_out = pwm_reg;

endmodule

module testbench;
    reg clk;
    reg rst;
    reg [2:0] sel;
    wire pwm_out;
    
    pwm_generator dut (
        .clk(clk),
        .rst(rst),
        .sel(sel),
        .pwm_out(pwm_out)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 0;
        rst = 1;
        sel = 0;
        
        #20 rst = 0;
        
        #100 sel = 3'b001;  // 25%
        #100 sel = 3'b010;  // 50%
        #100 sel = 3'b011;  // 75%
        #100 sel = 3'b100;  // 100%
        
        #100 rst = 1;
        #20 rst = 0;
        
        #100 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t rst=%b sel=%b pwm=%b"", 
                 $time, rst, sel, pwm_out);
    end
endmodule",True,89,True,True,True,False,0.4,False,12.197649478912354,7.63319993019104,"Design 8-bit resolution PWM generator with configurable duty cycle. Include testbench with duty cycles: 0%, 25%, 50%, 75%, 100%.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph TD
    CLK[Clock Input] --> CNT((8-bit Counter))
    RST[Reset] --> CNT
    
    DC[[Duty Cycle Register]] --> CMP((Comparator))
    CNT --> CMP
    
    T0[Test 0% - 0x00] --> MUX
    T1[Test 25% - 0x40] --> MUX
    T2[Test 50% - 0x80] --> MUX
    T3[Test 75% - 0xC0] --> MUX
    T4[Test 100% - 0xFF] --> MUX
    
    SEL[Test Select] --> MUX{Test MUX}
    MUX --> DC
    
    CMP --> PWM[PWM Output]
    
    CLK --> DC
    RST --> DC
    CLK --> CMP
    RST --> CMP
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module pwm_gen (
    input wire clk,
    input wire rst,
    input wire [2:0] sel,
    output wire pwm_out
);

reg [7:0] counter;
reg [7:0] duty_reg;
reg pwm_cmp;

// 8-bit Counter
always @(posedge clk or posedge rst) begin
    if (rst)
        counter <= 8'h00;
    else
        counter <= counter + 1'b1;
end

// Duty Cycle MUX and Register
always @(posedge clk or posedge rst) begin
    if (rst)
        duty_reg <= 8'h00;
    else
        case (sel)
            3'b000: duty_reg <= 8'h00;  // 0%
            3'b001: duty_reg <= 8'h40;  // 25%
            3'b010: duty_reg <= 8'h80;  // 50%
            3'b011: duty_reg <= 8'hC0;  // 75%
            3'b100: duty_reg <= 8'hFF;  // 100%
            default: duty_reg <= duty_reg;
        endcase
end

// Comparator
always @(posedge clk or posedge rst) begin
    if (rst)
        pwm_cmp <= 1'b0;
    else
        pwm_cmp <= (counter < duty_reg);
end

assign pwm_out = pwm_cmp;

endmodule

module testbench;
    reg clk;
    reg rst;
    reg [2:0] sel;
    wire pwm_out;
    
    pwm_gen dut (
        .clk(clk),
        .rst(rst),
        .sel(sel),
        .pwm_out(pwm_out)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 0;
        rst = 1;
        sel = 3'b000;
        
        #20 rst = 0;
        
        // Test 0%
        #512;
        
        // Test 25%
        sel = 3'b001;
        #512;
        
        // Test 50%
        sel = 3'b010;
        #512;
        
        // Test 75%
        sel = 3'b011;
        #512;
        
        // Test 100%
        sel = 3'b100;
        #512;
        
        $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t rst=%b sel=%b pwm=%b"", 
                 $time, rst, sel, pwm_out);
    end
endmodule",True,100,True,True,True,False,0.4,False,9.610039472579956,8.40839695930481,tie,mermaid_only > combined > prompt_only,prompt_only > mermaid_only > combined
combined,Advanced Sequential,complex,"Design 8-bit resolution PWM generator with configurable duty cycle. Include testbench with duty cycles: 0%, 25%, 50%, 75%, 100%.",gpt-4o,"`timescale 1ns/1ps

module pwm_generator(
    input wire clk,
    input wire rst_n,
    input wire [7:0] duty_cycle,
    output reg pwm_out
);
    reg [7:0] counter;

    always @(posedge clk or negedge rst_n) begin
        if (!rst_n)
            counter <= 8'b00000000;
        else
            counter <= counter + 1'b1;
    end

    always @(posedge clk or negedge rst_n) begin
        if (!rst_n)
            pwm_out <= 1'b0;
        else
            pwm_out <= (counter < duty_cycle) ? 1'b1 : 1'b0;
    end
endmodule

module testbench;
    reg clk, rst_n;
    reg [7:0] duty_cycle;
    wire pwm_out;

    pwm_generator dut (
        .clk(clk),
        .rst_n(rst_n),
        .duty_cycle(duty_cycle),
        .pwm_out(pwm_out)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst_n = 1'b0;
        duty_cycle = 8'b00000000; // 0% duty cycle
        
        #20 rst_n = 1'b1;
        #100 duty_cycle = 8'b01000000; // 25% duty cycle
        #100 duty_cycle = 8'b10000000; // 50% duty cycle
        #100 duty_cycle = 8'b11000000; // 75% duty cycle
        #100 duty_cycle = 8'b11111111; // 100% duty cycle
        #100 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b duty_cycle=%d pwm_out=%b"", 
                 $time, clk, rst_n, duty_cycle, pwm_out);
    end
endmodule",True,60,True,True,True,False,0.3,False,4.263332843780518,11.110600233078003,"graph TD
    CLK[Clock] --> COUNTER(Counter)
    RST[Reset] --> COUNTER
    COUNTER --> COMP(Comparator)
    DUTY[Duty Cycle (8-bit)] --> COMP
    COMP --> PWM[Output PWM Signal]

    subgraph Testbench
        TB0[Duty Cycle 0%] --> COMP
        TB25[Duty Cycle 25%] --> COMP
        TB50[Duty Cycle 50%] --> COMP
        TB75[Duty Cycle 75%] --> COMP
        TB100[Duty Cycle 100%] --> COMP
    end","`timescale 1ns/1ps

module counter(
    input wire clk,
    input wire rst,
    output reg [7:0] count
);
    
always @(posedge clk or posedge rst) begin
    if (rst)
        count <= 8'b00000000;
    else
        count <= count + 1'b1;
end

endmodule

module comparator(
    input wire [7:0] count,
    input wire [7:0] duty_cycle,
    output reg pwm
);

always @(*) begin
    if (count < duty_cycle)
        pwm = 1'b1;
    else
        pwm = 1'b0;
end

endmodule

module pwm_generator(
    input wire clk,
    input wire rst,
    input wire [7:0] duty_cycle,
    output wire pwm
);

wire [7:0] count;

counter cnt(
    .clk(clk),
    .rst(rst),
    .count(count)
);

comparator comp(
    .count(count),
    .duty_cycle(duty_cycle),
    .pwm(pwm)
);

endmodule

module testbench;
    reg clk, rst;
    reg [7:0] duty_cycle;
    wire pwm;

    pwm_generator dut (
        .clk(clk),
        .rst(rst),
        .duty_cycle(duty_cycle),
        .pwm(pwm)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 1'b0;
        rst = 1'b0;
        duty_cycle = 8'd0;

        #10 rst = 1'b1;
        #10 rst = 1'b0;
        
        #10 duty_cycle = 8'd0;    // 0%
        #100 duty_cycle = 8'd64;  // 25%
        #100 duty_cycle = 8'd128; // 50%
        #100 duty_cycle = 8'd192; // 75%
        #100 duty_cycle = 8'd255; // 100%
        
        #100 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t clk=%b rst=%b duty_cycle=%d pwm=%b"", 
                 $time, clk, rst, duty_cycle, pwm);
    end
endmodule",True,94,True,True,True,False,0.3,False,12.466766834259033,10.498701095581055,"Design 8-bit resolution PWM generator with configurable duty cycle. Include testbench with duty cycles: 0%, 25%, 50%, 75%, 100%.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph TD
    CLK[Clock] --> COUNTER(Counter)
    RST[Reset] --> COUNTER
    COUNTER --> COMP(Comparator)
    DUTY[Duty Cycle (8-bit)] --> COMP
    COMP --> PWM[Output PWM Signal]

    subgraph Testbench
        TB0[Duty Cycle 0%] --> COMP
        TB25[Duty Cycle 25%] --> COMP
        TB50[Duty Cycle 50%] --> COMP
        TB75[Duty Cycle 75%] --> COMP
        TB100[Duty Cycle 100%] --> COMP
    end
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module counter(
    input wire clk,
    input wire rst_n,
    output reg [7:0] count
);

always @(posedge clk or negedge rst_n) begin
    if (!rst_n)
        count <= 8'b00000000;
    else
        count <= count + 1'b1;
end

endmodule

module comparator(
    input wire [7:0] counter_val,
    input wire [7:0] duty_cycle,
    output wire pwm_out
);

assign pwm_out = (counter_val < duty_cycle) ? 1'b1 : 1'b0;

endmodule

module pwm_generator(
    input wire clk,
    input wire rst_n,
    input wire [7:0] duty_cycle,
    output wire pwm_out
);

wire [7:0] counter_val;

counter u_counter (
    .clk(clk),
    .rst_n(rst_n),
    .count(counter_val)
);

comparator u_comparator (
    .counter_val(counter_val),
    .duty_cycle(duty_cycle),
    .pwm_out(pwm_out)
);

endmodule

module testbench;
    reg clk, rst_n;
    reg [7:0] duty_cycle;
    wire pwm_out;

    pwm_generator dut (
        .clk(clk),
        .rst_n(rst_n),
        .duty_cycle(duty_cycle),
        .pwm_out(pwm_out)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 1'b0;
        rst_n = 1'b0;
        duty_cycle = 8'b00000000;

        #20 rst_n = 1'b1;
        #10 duty_cycle = 8'd0;  // 0%
        #100 duty_cycle = 8'd64; // 25%
        #100 duty_cycle = 8'd128; // 50%
        #100 duty_cycle = 8'd192; // 75%
        #100 duty_cycle = 8'd255; // 100%
        #50 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b duty_cycle=%d pwm_out=%b"", 
                 $time, clk, rst_n, duty_cycle, pwm_out);
    end
endmodule",True,86,True,True,True,False,0.3,False,6.815582990646362,11.032011032104492,tie,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,Protocol,complex,"Design SPI master supporting mode 0 (CPOL=0, CPHA=0). Include SCLK generation, MOSI/MISO handling. Include testbench.",claude,"`timescale 1ns/1ps

module spi_master (
    input wire clk,
    input wire rst_n,
    input wire [7:0] tx_data,
    input wire start,
    output reg sclk,
    output reg mosi,
    input wire miso,
    output reg busy,
    output reg [7:0] rx_data
);

reg [3:0] bit_count;
reg [7:0] tx_shift;
reg [7:0] rx_shift;
reg [3:0] sclk_div;

always @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
        sclk_div <= 4'd0;
        sclk <= 1'b0;
    end
    else if (busy) begin
        sclk_div <= sclk_div + 1'b1;
        if (sclk_div == 4'd7)
            sclk <= ~sclk;
    end
    else begin
        sclk <= 1'b0;
        sclk_div <= 4'd0;
    end
end

always @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
        busy <= 1'b0;
        bit_count <= 4'd0;
        mosi <= 1'b0;
        tx_shift <= 8'd0;
        rx_shift <= 8'd0;
        rx_data <= 8'd0;
    end
    else begin
        if (!busy && start) begin
            busy <= 1'b1;
            bit_count <= 4'd0;
            tx_shift <= tx_data;
            mosi <= tx_data[7];
        end
        else if (busy && sclk_div == 4'd7 && !sclk) begin
            tx_shift <= {tx_shift[6:0], 1'b0};
            mosi <= tx_shift[6];
            rx_shift <= {rx_shift[6:0], miso};
            bit_count <= bit_count + 1'b1;
            if (bit_count == 4'd7) begin
                busy <= 1'b0;
                rx_data <= {rx_shift[6:0], miso};
            end
        end
    end
end

endmodule

module testbench;
    reg clk;
    reg rst_n;
    reg [7:0] tx_data;
    reg start;
    wire sclk;
    wire mosi;
    reg miso;
    wire busy;
    wire [7:0] rx_data;

    spi_master dut (
        .clk(clk),
        .rst_n(rst_n),
        .tx_data(tx_data),
        .start(start),
        .sclk(sclk),
        .mosi(mosi),
        .miso(miso),
        .busy(busy),
        .rx_data(rx_data)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 0;
        rst_n = 0;
        tx_data = 8'h00;
        start = 0;
        miso = 0;

        #20 rst_n = 1;
        #20 tx_data = 8'hA5;
        #10 start = 1;
        #10 start = 0;
        
        #20 miso = 1;
        #500 tx_data = 8'h5A;
        #10 start = 1;
        #10 start = 0;
        
        #1000 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t rst_n=%b start=%b tx_data=%h rx_data=%h busy=%b"",
                 $time, rst_n, start, tx_data, rx_data, busy);
    end

endmodule",True,120,True,True,True,True,0.9,True,11.943614482879639,9.061119079589844,"graph LR
    CLK[Clock Input] --> CLKGEN(Clock Generator)
    RST[Reset] --> CLKGEN
    RST --> CTRL(SPI Control FSM)
    CLK --> CTRL
    
    CLKGEN --> SCLK[SCLK Output]
    CLKGEN --> CTRL
    
    TXDATA[[TX Data Register]] --> SHIFT(Shift Register)
    CTRL --> SHIFT
    SHIFT --> MOSI[MOSI Output]
    
    MISO[MISO Input] --> RXSHIFT(RX Shift Register)
    CTRL --> RXSHIFT
    RXSHIFT --> RXDATA[[RX Data Register]]
    
    START[Start Transaction] --> CTRL
    BUSY[Busy Signal] --> CTRL
    
    TB_CLK[Test Clock] -.-> |Testbench|CLK
    TB_RST[Test Reset] -.-> |Testbench|RST
    TB_DATA[Test Data] -.-> |Testbench|TXDATA
    MOSI -.-> |Testbench|TB_VERIFY[Verify MOSI]
    TB_MISO[Test MISO] -.-> |Testbench|MISO","`timescale 1ns/1ps

module spi_controller(
    input wire clk,
    input wire rst,
    input wire start,
    input wire miso,
    input wire [7:0] tx_data,
    output reg sclk,
    output reg mosi,
    output reg busy,
    output reg [7:0] rx_data
);

reg [2:0] bit_count;
reg [7:0] tx_shift;
reg [7:0] rx_shift;
reg [1:0] state;

localparam IDLE = 2'b00;
localparam SHIFT = 2'b01;
localparam DONE = 2'b10;

always @(posedge clk or posedge rst) begin
    if (rst) begin
        state <= IDLE;
        bit_count <= 3'b000;
        sclk <= 1'b0;
        mosi <= 1'b0;
        busy <= 1'b0;
        tx_shift <= 8'h00;
        rx_shift <= 8'h00;
        rx_data <= 8'h00;
    end else begin
        case (state)
            IDLE: begin
                if (start) begin
                    state <= SHIFT;
                    busy <= 1'b1;
                    tx_shift <= tx_data;
                    bit_count <= 3'b111;
                end
            end
            
            SHIFT: begin
                sclk <= ~sclk;
                if (sclk) begin
                    rx_shift <= {rx_shift[6:0], miso};
                end else begin
                    mosi <= tx_shift[7];
                    tx_shift <= {tx_shift[6:0], 1'b0};
                    if (bit_count == 0) begin
                        state <= DONE;
                    end else begin
                        bit_count <= bit_count - 1'b1;
                    end
                end
            end
            
            DONE: begin
                sclk <= 1'b0;
                busy <= 1'b0;
                rx_data <= rx_shift;
                state <= IDLE;
            end
        endcase
    end
end

endmodule

module testbench;
    reg clk, rst, start;
    reg [7:0] tx_data;
    reg miso;
    wire sclk, mosi, busy;
    wire [7:0] rx_data;

    spi_controller dut (
        .clk(clk),
        .rst(rst),
        .start(start),
        .miso(miso),
        .tx_data(tx_data),
        .sclk(sclk),
        .mosi(mosi),
        .busy(busy),
        .rx_data(rx_data)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst = 1'b1;
        start = 1'b0;
        tx_data = 8'h00;
        miso = 1'b0;
        
        #20 rst = 1'b0;
        #10 tx_data = 8'hA5;
        #10 start = 1'b1;
        #10 start = 1'b0;
        #200 tx_data = 8'h5A;
        #10 start = 1'b1;
        #10 start = 1'b0;
        #200 $finish;
    end

    always #5 clk = ~clk;

    always @(posedge sclk) begin
        miso <= $random;
    end

    initial begin
        $monitor(""Time=%0t rst=%b start=%b tx_data=%h rx_data=%h busy=%b"",
                 $time, rst, start, tx_data, rx_data, busy);
    end
endmodule",True,121,True,True,True,False,0.4,False,16.96833300590515,7.1602582931518555,"Design SPI master supporting mode 0 (CPOL=0, CPHA=0). Include SCLK generation, MOSI/MISO handling. Include testbench.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph LR
    CLK[Clock Input] --> CLKGEN(Clock Generator)
    RST[Reset] --> CLKGEN
    RST --> CTRL(SPI Control FSM)
    CLK --> CTRL
    
    CLKGEN --> SCLK[SCLK Output]
    CLKGEN --> CTRL
    
    TXDATA[[TX Data Register]] --> SHIFT(Shift Register)
    CTRL --> SHIFT
    SHIFT --> MOSI[MOSI Output]
    
    MISO[MISO Input] --> RXSHIFT(RX Shift Register)
    CTRL --> RXSHIFT
    RXSHIFT --> RXDATA[[RX Data Register]]
    
    START[Start Transaction] --> CTRL
    BUSY[Busy Signal] --> CTRL
    
    TB_CLK[Test Clock] -.-> |Testbench|CLK
    TB_RST[Test Reset] -.-> |Testbench|RST
    TB_DATA[Test Data] -.-> |Testbench|TXDATA
    MOSI -.-> |Testbench|TB_VERIFY[Verify MOSI]
    TB_MISO[Test MISO] -.-> |Testbench|MISO
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module spi_master (
    input wire clk,
    input wire rst,
    input wire start,
    input wire miso,
    input wire [7:0] tx_data,
    output reg sclk,
    output reg mosi,
    output reg busy,
    output reg [7:0] rx_data
);

reg [2:0] bit_count;
reg [7:0] shift_reg;
reg [2:0] state;
reg sclk_en;

parameter IDLE = 3'b000;
parameter SETUP = 3'b001;
parameter SHIFT = 3'b010;
parameter DONE = 3'b011;

always @(posedge clk or posedge rst) begin
    if (rst) begin
        state <= IDLE;
        sclk <= 1'b0;
        mosi <= 1'b0;
        busy <= 1'b0;
        bit_count <= 3'b000;
        shift_reg <= 8'b0;
        rx_data <= 8'b0;
        sclk_en <= 1'b0;
    end else begin
        case (state)
            IDLE: begin
                if (start) begin
                    state <= SETUP;
                    shift_reg <= tx_data;
                    busy <= 1'b1;
                    sclk_en <= 1'b1;
                end
            end
            
            SETUP: begin
                mosi <= shift_reg[7];
                state <= SHIFT;
            end
            
            SHIFT: begin
                if (bit_count == 3'b111) begin
                    state <= DONE;
                end else begin
                    bit_count <= bit_count + 1'b1;
                end
                shift_reg <= {shift_reg[6:0], miso};
            end
            
            DONE: begin
                busy <= 1'b0;
                sclk_en <= 1'b0;
                rx_data <= shift_reg;
                state <= IDLE;
                bit_count <= 3'b000;
            end
        endcase
    end
end

always @(posedge clk) begin
    if (sclk_en)
        sclk <= ~sclk;
end

endmodule

module testbench;
    reg clk, rst, start;
    reg [7:0] tx_data;
    reg miso;
    wire sclk, mosi, busy;
    wire [7:0] rx_data;

    spi_master dut (
        .clk(clk),
        .rst(rst),
        .start(start),
        .miso(miso),
        .tx_data(tx_data),
        .sclk(sclk),
        .mosi(mosi),
        .busy(busy),
        .rx_data(rx_data)
    );

    initial begin
        $dumpfile(""spi_master.vcd"");
        $dumpvars(0, testbench);

        clk = 1'b0;
        rst = 1'b1;
        start = 1'b0;
        tx_data = 1'b0;
        miso = 1'b0;

        #20 rst = 1'b0;
        #10 tx_data = 8'hA5;
        #10 start = 1'b1;
        #10 start = 1'b0;
        
        #200 tx_data = 8'h5A;
        #10 start = 1'b1;
        #10 start = 1'b0;
        
        #200 $finish;
    end

    always #5 clk = ~clk;

    always @(posedge sclk) begin
        miso <= $random;
    end

    initial begin
        $monitor(""Time=%0t rst=%b start=%b tx_data=%h rx_data=%h busy=%b"",
                 $time, rst, start, tx_data, rx_data, busy);
    end
endmodule",True,129,True,True,True,,0.0,,11.850730180740356,0.01741766929626465,mermaid_only,mermaid_only > prompt_only > combined,prompt_only > mermaid_only > combined
combined,Protocol,complex,"Design SPI master supporting mode 0 (CPOL=0, CPHA=0). Include SCLK generation, MOSI/MISO handling. Include testbench.",gpt-4o,"`timescale 1ns/1ps

module spi_master(
    input wire clk,
    input wire rst_n,
    input wire start,
    input wire [7:0] data_in,
    output reg sclk,
    output reg mosi,
    input wire miso,
    output reg [7:0] data_out,
    output reg done
);

    reg [2:0] bit_count;
    reg [7:0] shift_reg;
    reg [1:0] state;
    
    localparam IDLE = 2'b00;
    localparam TRANSFER = 2'b01;
    localparam DONE = 2'b10;

    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            sclk <= 1'b0;
            mosi <= 1'b0;
            data_out <= 8'b0;
            done <= 1'b0;
            bit_count <= 3'b0;
            shift_reg <= 8'b0;
            state <= IDLE;
        end else begin
            case(state)
                IDLE: begin
                    sclk <= 1'b0;
                    done <= 1'b0;
                    if (start) begin
                        shift_reg <= data_in;
                        bit_count <= 3'b111;
                        state <= TRANSFER;
                    end
                end
                
                TRANSFER: begin
                    sclk <= ~sclk;
                    if (sclk) begin
                        mosi <= shift_reg[7];
                        shift_reg <= {shift_reg[6:0], miso};
                        bit_count <= bit_count - 1'b1;
                        if (bit_count == 3'b000) begin
                            state <= DONE;
                        end
                    end
                end
                
                DONE: begin
                    data_out <= shift_reg;
                    done <= 1'b1;
                    state <= IDLE;
                end
            endcase
        end
    end

endmodule

module testbench;
    reg clk, rst_n, start;
    reg [7:0] data_in;
    wire sclk, mosi, done;
    reg miso;
    wire [7:0] data_out;

    spi_master dut (
        .clk(clk),
        .rst_n(rst_n),
        .start(start),
        .data_in(data_in),
        .sclk(sclk),
        .mosi(mosi),
        .miso(miso),
        .data_out(data_out),
        .done(done)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 1'b0;
        rst_n = 1'b0;
        start = 1'b0;
        data_in = 8'b10101010;
        miso = 1'b0;

        #20 rst_n = 1'b1;
        #10 start = 1'b1;
        #10 start = 1'b0;

        #200 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b start=%b data_in=%b miso=%b data_out=%b done=%b"", 
                 $time, clk, rst_n, start, data_in, miso, data_out, done);
    end
endmodule",True,109,True,True,True,True,0.9,True,10.632790803909302,17.55785059928894,"graph TD
    CLK[Clock (SCLK)] --> SCLK_GEN(SCLK Generator)
    RST[Reset] --> CTRL(Controller)
    CTRL --> SCLK_GEN
    DATA_IN[MOSI Data Input] --> SHIFT_REG(Shift Register)
    SHIFT_REG --> MOSI_OUT[MOSI Output]
    MISO_IN[MISO Input] --> SHIFT_REG
    SHIFT_REG --> DATA_OUT[Data Output]
    SCLK_GEN --> SHIFT_REG
    SCLK_GEN --> SPI_MODE{SPI Mode}
    SPI_MODE --> CTRL
    TESTBENCH[Testbench] --> CTRL
    TESTBENCH --> DATA_IN
    TESTBENCH --> MISO_IN
    TESTBENCH --> RST
    TESTBENCH --> CLK","`timescale 1ns/1ps

module spi_controller (
    input wire clk,
    input wire rst,
    input wire mosi_data_in,
    input wire miso_in,
    output wire mosi_out,
    output wire data_out
);

    wire sclk;
    wire spi_mode;
    reg shift_reg;

    // SCLK Generator
    sclk_generator sclk_gen (
        .clk(clk),
        .rst(rst),
        .sclk(sclk),
        .spi_mode(spi_mode)
    );

    // Controller
    controller ctrl (
        .rst(rst),
        .spi_mode(spi_mode)
    );

    // Shift Register
    always @(posedge sclk or posedge rst) begin
        if (rst)
            shift_reg <= 1'b0;
        else
            shift_reg <= mosi_data_in;
    end

    assign mosi_out = shift_reg;
    assign data_out = shift_reg;

endmodule

module sclk_generator (
    input wire clk,
    input wire rst,
    output wire sclk,
    output wire spi_mode
);
    reg sclk_reg;
    reg spi_mode_reg;

    always @(posedge clk or posedge rst) begin
        if (rst) begin
            sclk_reg <= 1'b0;
            spi_mode_reg <= 1'b0;
        end else begin
            sclk_reg <= ~sclk_reg;
            spi_mode_reg <= 1'b1;
        end
    end

    assign sclk = sclk_reg;
    assign spi_mode = spi_mode_reg;

endmodule

module controller (
    input wire rst,
    output wire spi_mode
);
    reg spi_mode_reg;

    always @(posedge rst) begin
        spi_mode_reg <= 1'b0;
    end

    assign spi_mode = spi_mode_reg;

endmodule

module testbench;
    reg clk, rst, mosi_data_in, miso_in;
    wire mosi_out, data_out;

    spi_controller dut (
        .clk(clk),
        .rst(rst),
        .mosi_data_in(mosi_data_in),
        .miso_in(miso_in),
        .mosi_out(mosi_out),
        .data_out(data_out)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 1'b0;
        rst = 1'b0;
        mosi_data_in = 1'b0;
        miso_in = 1'b0;

        #20 rst = 1'b1;
        #10 mosi_data_in = 1'b1;
        #100 mosi_data_in = 1'b0;
        #20 rst = 1'b0;
        #20 rst = 1'b1;
        #50 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t clk=%b rst=%b mosi_data_in=%b mosi_out=%b data_out=%b"", 
                 $time, clk, rst, mosi_data_in, mosi_out, data_out);
    end
endmodule",True,117,True,True,True,True,0.75,True,14.569755554199219,14.669477939605713,"Design SPI master supporting mode 0 (CPOL=0, CPHA=0). Include SCLK generation, MOSI/MISO handling. Include testbench.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph TD
    CLK[Clock (SCLK)] --> SCLK_GEN(SCLK Generator)
    RST[Reset] --> CTRL(Controller)
    CTRL --> SCLK_GEN
    DATA_IN[MOSI Data Input] --> SHIFT_REG(Shift Register)
    SHIFT_REG --> MOSI_OUT[MOSI Output]
    MISO_IN[MISO Input] --> SHIFT_REG
    SHIFT_REG --> DATA_OUT[Data Output]
    SCLK_GEN --> SHIFT_REG
    SCLK_GEN --> SPI_MODE{SPI Mode}
    SPI_MODE --> CTRL
    TESTBENCH[Testbench] --> CTRL
    TESTBENCH --> DATA_IN
    TESTBENCH --> MISO_IN
    TESTBENCH --> RST
    TESTBENCH --> CLK
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module spi_master(
    input wire clk,
    input wire rst_n,
    input wire mosi_data_in,
    input wire miso_in,
    output wire mosi_out,
    output wire data_out
);
    wire sclk;
    wire spi_mode;
    reg [7:0] shift_reg;
    reg [2:0] bit_count;
    
    // SCLK Generator
    reg sclk_gen;
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n)
            sclk_gen <= 1'b0;
        else
            sclk_gen <= ~sclk_gen;
    end
    assign sclk = sclk_gen;
    
    // Shift Register
    always @(posedge sclk or negedge rst_n) begin
        if (!rst_n) begin
            shift_reg <= 8'b0;
            bit_count <= 3'b0;
        end else begin
            shift_reg <= {shift_reg[6:0], mosi_data_in};
            bit_count <= bit_count + 1'b1;
        end
    end
    assign mosi_out = shift_reg[7];
    assign data_out = shift_reg[0];
    
    // SPI Mode (mode 0: CPOL=0, CPHA=0)
    assign spi_mode = 1'b0; // Static assignment for SPI Mode 0
    
    // Controller (currently no control logic)
    // Add control logic as needed

endmodule

module testbench;
    reg clk, rst_n, mosi_data_in, miso_in;
    wire mosi_out, data_out;
    
    spi_master dut (
        .clk(clk),
        .rst_n(rst_n),
        .mosi_data_in(mosi_data_in),
        .miso_in(miso_in),
        .mosi_out(mosi_out),
        .data_out(data_out)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst_n = 1'b0;
        mosi_data_in = 1'b0;
        miso_in = 1'b0;
        
        #20 rst_n = 1'b1;
        #10 mosi_data_in = 1'b1;
        #40 mosi_data_in = 1'b0;
        #40 mosi_data_in = 1'b1;
        #100 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b mosi_data_in=%b miso_in=%b mosi_out=%b data_out=%b"", 
                 $time, clk, rst_n, mosi_data_in, miso_in, mosi_out, data_out);
    end
endmodule",True,82,True,True,True,True,0.7,True,9.368724822998047,12.012949705123901,prompt_only,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
