circuit_name,category,complexity,original_prompt,model,prompt_only_verilog,prompt_only_generation_success,prompt_only_lines_of_code,prompt_only_has_testbench,prompt_only_compilation_success,prompt_only_simulation_success,prompt_only_vae_verdict,prompt_only_vae_confidence,prompt_only_consensus_anomalous,prompt_only_generation_time,prompt_only_simulation_time,mermaid_only_mermaid,mermaid_only_verilog,mermaid_only_generation_success,mermaid_only_lines_of_code,mermaid_only_has_testbench,mermaid_only_compilation_success,mermaid_only_simulation_success,mermaid_only_vae_verdict,mermaid_only_vae_confidence,mermaid_only_consensus_anomalous,mermaid_only_generation_time,mermaid_only_simulation_time,combined_prompt,combined_verilog,combined_generation_success,combined_lines_of_code,combined_has_testbench,combined_compilation_success,combined_simulation_success,combined_vae_verdict,combined_vae_confidence,combined_consensus_anomalous,combined_generation_time,combined_simulation_time,best_approach,correctness_ranking,simulation_ranking
combined,Combinational,simple,"Design a 2-to-1 multiplexer with inputs a, b, select sel, and output out. Include testbench testing all combinations.",claude,"`timescale 1ns/1ps

module mux2to1(
    input wire a,
    input wire b,
    input wire sel,
    output reg out
);

always @(*) begin
    out = sel ? b : a;
end

endmodule

module testbench;
    reg a, b, sel;
    wire out;
    
    mux2to1 dut (
        .a(a),
        .b(b),
        .sel(sel),
        .out(out)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        // Test all combinations
        a = 0; b = 0; sel = 0; #10;
        a = 0; b = 0; sel = 1; #10;
        a = 0; b = 1; sel = 0; #10;
        a = 0; b = 1; sel = 1; #10;
        a = 1; b = 0; sel = 0; #10;
        a = 1; b = 0; sel = 1; #10;
        a = 1; b = 1; sel = 0; #10;
        a = 1; b = 1; sel = 1; #10;
        
        $finish;
    end
    
    initial begin
        $monitor(""Time=%0t a=%b b=%b sel=%b out=%b"", 
                 $time, a, b, sel, out);
    end
endmodule",True,48,True,True,True,False,0.4,False,5.0594446659088135,7.423325538635254,"graph LR
    A[Input A] --> MUX{2:1 MUX}
    B[Input B] --> MUX
    SEL[Select] --> MUX
    MUX --> OUT[Output]
    
    TB_A[TB Input A] --> TB{TESTBENCH}
    TB_B[TB Input B] --> TB
    TB_SEL[TB Select] --> TB
    TB --> EXPECTED[Expected Output]
    TB --> ACTUAL[Actual Output]
    
    TEST0((Test 0: A=0,B=0)) --> TB
    TEST1((Test 1: A=0,B=1)) --> TB
    TEST2((Test 2: A=1,B=0)) --> TB
    TEST3((Test 3: A=1,B=1)) --> TB","`timescale 1ns/1ps

module mux2to1 (
    input wire a,
    input wire b,
    input wire sel,
    output reg out
);

always @(a or b or sel) begin
    case(sel)
        1'b0: out = a;
        1'b1: out = b;
        default: out = 1'b0;
    endcase
end

endmodule

module testbench;
    reg a, b, sel;
    wire out;
    reg expected;
    
    mux2to1 dut (
        .a(a),
        .b(b),
        .sel(sel),
        .out(out)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        // Test 0: A=0,B=0
        a = 0; b = 0; sel = 0; expected = 0;
        #10;
        if (out !== expected) $display(""Test 0 failed!"");
        
        // Test 1: A=0,B=1
        a = 0; b = 1; sel = 0; expected = 0;
        #10;
        if (out !== expected) $display(""Test 1 failed!"");
        
        // Test 2: A=1,B=0
        a = 1; b = 0; sel = 0; expected = 1;
        #10;
        if (out !== expected) $display(""Test 2 failed!"");
        
        // Test 3: A=1,B=1
        a = 1; b = 1; sel = 0; expected = 1;
        #10;
        
        // Additional tests with sel=1
        a = 0; b = 0; sel = 1; expected = 0;
        #10;
        a = 0; b = 1; sel = 1; expected = 1;
        #10;
        a = 1; b = 0; sel = 1; expected = 0;
        #10;
        a = 1; b = 1; sel = 1; expected = 1;
        #10;
        
        $display(""Test complete"");
        $finish;
    end
    
    initial begin
        $monitor(""Time=%0t a=%b b=%b sel=%b out=%b expected=%b"",
                 $time, a, b, sel, out, expected);
    end
endmodule",True,73,True,True,True,False,0.4,False,11.268527507781982,8.839336156845093,"Design a 2-to-1 multiplexer with inputs a, b, select sel, and output out. Include testbench testing all combinations.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph LR
    A[Input A] --> MUX{2:1 MUX}
    B[Input B] --> MUX
    SEL[Select] --> MUX
    MUX --> OUT[Output]
    
    TB_A[TB Input A] --> TB{TESTBENCH}
    TB_B[TB Input B] --> TB
    TB_SEL[TB Select] --> TB
    TB --> EXPECTED[Expected Output]
    TB --> ACTUAL[Actual Output]
    
    TEST0((Test 0: A=0,B=0)) --> TB
    TEST1((Test 1: A=0,B=1)) --> TB
    TEST2((Test 2: A=1,B=0)) --> TB
    TEST3((Test 3: A=1,B=1)) --> TB
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module mux2to1(
    input wire a,
    input wire b, 
    input wire sel,
    output reg out
);

always @(*) begin
    out = sel ? b : a;
end

endmodule

module testbench;
    reg a, b, sel;
    wire out;
    reg expected;
    
    mux2to1 dut(
        .a(a),
        .b(b),
        .sel(sel),
        .out(out)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        // Test 0: A=0,B=0
        a = 0; b = 0; sel = 0; expected = 0;
        #10;
        if (out !== expected) $display(""Error: Test 0 failed"");
        
        // Test 1: A=0,B=1
        a = 0; b = 1; sel = 0; expected = 0;
        #10;
        if (out !== expected) $display(""Error: Test 1 failed"");
        
        // Test 2: A=1,B=0
        a = 1; b = 0; sel = 0; expected = 1;
        #10;
        if (out !== expected) $display(""Error: Test 2 failed"");
        
        // Test 3: A=1,B=1
        a = 1; b = 1; sel = 0; expected = 1;
        #10;
        
        // Repeat tests with sel=1
        a = 0; b = 0; sel = 1; expected = 0;
        #10;
        a = 0; b = 1; sel = 1; expected = 1;
        #10;
        a = 1; b = 0; sel = 1; expected = 0;
        #10;
        a = 1; b = 1; sel = 1; expected = 1;
        #10;
        
        $display(""Testing completed"");
        $finish;
    end
    
    initial begin
        $monitor(""Time=%0t a=%b b=%b sel=%b out=%b expected=%b"",
                 $time, a, b, sel, out, expected);
    end
endmodule",True,69,True,True,True,False,0.4,False,7.235952854156494,8.317572832107544,tie,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,Combinational,simple,"Design a 2-to-1 multiplexer with inputs a, b, select sel, and output out. Include testbench testing all combinations.",gpt-4o,"`timescale 1ns/1ps

module mux_2_to_1(
    input wire a,
    input wire b,
    input wire sel,
    output wire out
);

assign out = sel ? b : a;

endmodule

module testbench;
    reg a, b, sel;
    wire out;

    mux_2_to_1 dut (
        .a(a),
        .b(b),
        .sel(sel),
        .out(out)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        a = 1'b0; b = 1'b0; sel = 1'b0;
        #10 a = 1'b0; b = 1'b1; sel = 1'b0;
        #10 a = 1'b1; b = 1'b0; sel = 1'b0;
        #10 a = 1'b1; b = 1'b1; sel = 1'b0;
        #10 a = 1'b0; b = 1'b0; sel = 1'b1;
        #10 a = 1'b0; b = 1'b1; sel = 1'b1;
        #10 a = 1'b1; b = 1'b0; sel = 1'b1;
        #10 a = 1'b1; b = 1'b1; sel = 1'b1;
        #10 $finish;
    end

    initial begin
        $monitor(""Time=%0t a=%b b=%b sel=%b out=%b"",
                 $time, a, b, sel, out);
    end
endmodule",True,44,True,True,True,False,0.4,False,5.893024444580078,6.793081998825073,"graph LR
    A[Input a] --> MUX{2-to-1 MUX}
    B[Input b] --> MUX
    SEL[Select sel] --> MUX
    MUX --> OUT[Output out]

    subgraph Testbench
        TB_A[Testbench Input a]
        TB_B[Testbench Input b]
        TB_SEL[Testbench Select sel]
        TB_A --> MUX
        TB_B --> MUX
        TB_SEL --> MUX
        MUX --> TB_OUT[Testbench Output out]
    end","`timescale 1ns/1ps

module mux_2to1(
    input wire a,
    input wire b,
    input wire sel,
    output reg out
);

always @(*) begin
    if (sel)
        out = b;
    else
        out = a;
end

endmodule

module testbench;
    reg tb_a, tb_b, tb_sel;
    wire tb_out;
    
    mux_2to1 dut (
        .a(tb_a),
        .b(tb_b),
        .sel(tb_sel),
        .out(tb_out)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        tb_a = 1'b0;
        tb_b = 1'b0;
        tb_sel = 1'b0;
        
        #10 tb_a = 1'b1;
        #10 tb_b = 1'b1;
        #10 tb_sel = 1'b1;
        #10 tb_sel = 1'b0;
        #10 tb_a = 1'b0;
        #10 tb_b = 1'b0;
        #10 $finish;
    end
    
    initial begin
        $monitor(""Time=%0t tb_a=%b tb_b=%b tb_sel=%b tb_out=%b"", 
                 $time, tb_a, tb_b, tb_sel, tb_out);
    end
endmodule",True,51,True,True,True,False,0.4,False,6.966429710388184,113.38284015655518,"Design a 2-to-1 multiplexer with inputs a, b, select sel, and output out. Include testbench testing all combinations.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph LR
    A[Input a] --> MUX{2-to-1 MUX}
    B[Input b] --> MUX
    SEL[Select sel] --> MUX
    MUX --> OUT[Output out]

    subgraph Testbench
        TB_A[Testbench Input a]
        TB_B[Testbench Input b]
        TB_SEL[Testbench Select sel]
        TB_A --> MUX
        TB_B --> MUX
        TB_SEL --> MUX
        MUX --> TB_OUT[Testbench Output out]
    end
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module mux_2to1(
    input wire a,
    input wire b,
    input wire sel,
    output wire out
);

    assign out = sel ? b : a;

endmodule

module testbench;
    reg tb_a, tb_b, tb_sel;
    wire tb_out;

    mux_2to1 dut (
        .a(tb_a),
        .b(tb_b),
        .sel(tb_sel),
        .out(tb_out)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        tb_a = 0; tb_b = 0; tb_sel = 0;
        #10 tb_a = 0; tb_b = 1; tb_sel = 0;
        #10 tb_a = 1; tb_b = 0; tb_sel = 0;
        #10 tb_a = 1; tb_b = 1; tb_sel = 0;
        #10 tb_a = 0; tb_b = 0; tb_sel = 1;
        #10 tb_a = 0; tb_b = 1; tb_sel = 1;
        #10 tb_a = 1; tb_b = 0; tb_sel = 1;
        #10 tb_a = 1; tb_b = 1; tb_sel = 1;
        #10 $finish;
    end

    initial begin
        $monitor(""Time=%0t tb_a=%b tb_b=%b tb_sel=%b tb_out=%b"", 
                 $time, tb_a, tb_b, tb_sel, tb_out);
    end
endmodule",True,44,True,True,True,False,0.4,False,3.896968126296997,5.46031928062439,tie,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,Sequential,simple,"Create a D flip-flop with clock, reset, input d, and output q. Include testbench with timing verification.",claude,"`timescale 1ns/1ps

module dff(
    input wire clk,
    input wire rst_n,
    input wire d,
    output reg q
);

always @(posedge clk or negedge rst_n) begin
    if (!rst_n)
        q <= 1'b0;
    else
        q <= d;
end

endmodule

module testbench;
    reg clk, rst_n, d;
    wire q;
    
    dff dut (
        .clk(clk),
        .rst_n(rst_n),
        .d(d),
        .q(q)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst_n = 1'b0;
        d = 1'b0;
        
        #20 rst_n = 1'b1;
        #10 d = 1'b1;
        #10 d = 1'b0;
        #10 d = 1'b1;
        #20 rst_n = 1'b0;
        #20 rst_n = 1'b1;
        #50 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b d=%b q=%b"", 
                 $time, clk, rst_n, d, q);
    end
endmodule",True,53,True,True,True,True,0.7,True,4.54449462890625,7.062177419662476,"graph LR
    CLK[Clock Input] --> DFF[[D Flip-Flop]]
    RST[Reset] --> DFF
    D[Data Input] --> DFF
    DFF --> Q[Output Q]
    TB[Testbench] --> CLK
    TB --> RST
    TB --> D
    TB --> TV{Timing Verification}
    Q --> TV
    CLK --> TV
    TV --> PASS[Pass/Fail Status]","`timescale 1ns/1ps

module dff(
    input wire clk,
    input wire rst,
    input wire d,
    output reg q
);

always @(posedge clk or posedge rst) begin
    if (rst)
        q <= 1'b0;
    else
        q <= d;
end

endmodule

module testbench;
    reg clk, rst, d;
    wire q;
    
    dff dut (
        .clk(clk),
        .rst(rst),
        .d(d),
        .q(q)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 0;
        rst = 1;
        d = 0;
        
        #20 rst = 0;
        
        #10 d = 1;
        #10 d = 0;
        #10 d = 1;
        #10 d = 0;
        
        #10 rst = 1;
        #10 rst = 0;
        
        #50 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t rst=%b d=%b q=%b"", $time, rst, d, q);
    end
    
    reg verify_pass;
    always @(posedge clk) begin
        verify_pass = (q === d);
        if (!rst && !verify_pass)
            $display(""Verification Failed at time %0t"", $time);
    end
endmodule",True,63,True,True,True,True,0.8,True,8.177793264389038,7.634181976318359,"Create a D flip-flop with clock, reset, input d, and output q. Include testbench with timing verification.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph LR
    CLK[Clock Input] --> DFF[[D Flip-Flop]]
    RST[Reset] --> DFF
    D[Data Input] --> DFF
    DFF --> Q[Output Q]
    TB[Testbench] --> CLK
    TB --> RST
    TB --> D
    TB --> TV{Timing Verification}
    Q --> TV
    CLK --> TV
    TV --> PASS[Pass/Fail Status]
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module dff(
    input wire clk,
    input wire rst,
    input wire d,
    output reg q
);

always @(posedge clk or posedge rst) begin
    if (rst)
        q <= 1'b0;
    else
        q <= d;
end

endmodule

module testbench;
    reg clk, rst, d;
    wire q;
    reg pass;
    reg [31:0] errors;
    
    dff dut (
        .clk(clk),
        .rst(rst),
        .d(d),
        .q(q)
    );
    
    initial begin
        $dumpfile(""dff_tb.vcd"");
        $dumpvars(0, testbench);
        
        errors = 0;
        clk = 0;
        rst = 1;
        d = 0;
        pass = 1;
        
        #10 rst = 0;
        
        // Test case 1: Basic operation
        #10 d = 1;
        #10 if (q !== 1) begin
            errors = errors + 1;
            pass = 0;
        end
        
        // Test case 2: Reset check
        #10 rst = 1;
        #10 if (q !== 0) begin
            errors = errors + 1;
            pass = 0;
        end
        
        // Test case 3: Multiple transitions
        #10 rst = 0;
        d = 1;
        #10 d = 0;
        #10 d = 1;
        #10 if (q !== 1) begin
            errors = errors + 1;
            pass = 0;
        end
        
        #10;
        if (pass)
            $display(""PASS: All tests completed successfully"");
        else
            $display(""FAIL: %d errors detected"", errors);
            
        $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t rst=%b d=%b q=%b"", $time, rst, d, q);
    end
endmodule",True,82,True,True,True,,0.0,,6.938964366912842,0.01595592498779297,prompt_only,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,Sequential,simple,"Create a D flip-flop with clock, reset, input d, and output q. Include testbench with timing verification.",gpt-4o,"`timescale 1ns/1ps

module d_flip_flop(
    input wire clk,
    input wire rst_n,
    input wire d,
    output reg q
);

always @(posedge clk or negedge rst_n) begin
    if (!rst_n)
        q <= 1'b0;
    else
        q <= d;
end

endmodule

module testbench;
    reg clk, rst_n, d;
    wire q;
    
    d_flip_flop dut (
        .clk(clk),
        .rst_n(rst_n),
        .d(d),
        .q(q)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst_n = 1'b0;
        d = 1'b0;
        
        #20 rst_n = 1'b1;
        #10 d = 1'b1;
        #10 d = 1'b0;
        #20 d = 1'b1;
        #20 rst_n = 1'b0;
        #20 rst_n = 1'b1;
        #50 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b d=%b q=%b"", 
                 $time, clk, rst_n, d, q);
    end
endmodule",True,53,True,True,True,True,0.7,True,5.0804314613342285,13.765392541885376,"graph LR
    CLK[Clock] --> DFF((D Flip-Flop))
    RST[Reset] --> DFF
    D[Input D] --> DFF
    DFF --> Q[Output Q]
    subgraph TESTBENCH[ ]
        TB_CLK[Clock] --> DFF
        TB_RST[Reset] --> DFF
        TB_D[Test Input D] --> DFF
        DFF --> TB_Q[Test Output Q]
    end","`timescale 1ns/1ps

module d_flip_flop(
    input wire clk,
    input wire rst,
    input wire d,
    output reg q
);

always @(posedge clk or posedge rst) begin
    if (rst)
        q <= 1'b0;
    else
        q <= d;
end

endmodule

module testbench;
    reg tb_clk, tb_rst, tb_d;
    wire tb_q;
    
    d_flip_flop dut (
        .clk(tb_clk),
        .rst(tb_rst),
        .d(tb_d),
        .q(tb_q)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        tb_clk = 1'b0;
        tb_rst = 1'b0;
        tb_d = 1'b0;
        
        #10 tb_rst = 1'b1;
        #10 tb_rst = 1'b0;
        #10 tb_d = 1'b1;
        #20 tb_d = 1'b0;
        #10 tb_d = 1'b1;
        #30 $finish;
    end
    
    always #5 tb_clk = ~tb_clk;
    
    initial begin
        $monitor(""Time=%0t tb_clk=%b tb_rst=%b tb_d=%b tb_q=%b"", 
                 $time, tb_clk, tb_rst, tb_d, tb_q);
    end
endmodule",True,52,True,True,True,True,0.7,True,8.092217922210693,15.42921233177185,"Create a D flip-flop with clock, reset, input d, and output q. Include testbench with timing verification.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph LR
    CLK[Clock] --> DFF((D Flip-Flop))
    RST[Reset] --> DFF
    D[Input D] --> DFF
    DFF --> Q[Output Q]
    subgraph TESTBENCH[ ]
        TB_CLK[Clock] --> DFF
        TB_RST[Reset] --> DFF
        TB_D[Test Input D] --> DFF
        DFF --> TB_Q[Test Output Q]
    end
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module d_flip_flop(
    input wire clk,
    input wire rst,
    input wire d,
    output reg q
);

always @(posedge clk or posedge rst) begin
    if (rst)
        q <= 1'b0;
    else
        q <= d;
end

endmodule

module testbench;
    reg tb_clk, tb_rst, tb_d;
    wire tb_q;
    
    d_flip_flop dut (
        .clk(tb_clk),
        .rst(tb_rst),
        .d(tb_d),
        .q(tb_q)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        tb_clk = 1'b0;
        tb_rst = 1'b0;
        tb_d = 1'b0;
        
        #15 tb_rst = 1'b1;
        #10 tb_rst = 1'b0;
        #10 tb_d = 1'b1;
        #20 tb_d = 1'b0;
        #10 tb_d = 1'b1;
        #30 $finish;
    end
    
    always #5 tb_clk = ~tb_clk;
    
    initial begin
        $monitor(""Time=%0t tb_clk=%b tb_rst=%b tb_d=%b tb_q=%b"", 
                 $time, tb_clk, tb_rst, tb_d, tb_q);
    end
endmodule",True,52,True,True,True,True,0.7,True,17.021512269973755,11.321163892745972,prompt_only,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,Sequential,simple,"Design a 4-bit synchronous counter with clock, reset, enable, and count[3:0]. Include testbench.",claude,"`timescale 1ns/1ps

module counter(
    input wire clk,
    input wire rst_n, 
    input wire enable,
    output reg [3:0] count
);

always @(posedge clk or negedge rst_n) begin
    if (!rst_n)
        count <= 4'b0000;
    else if (enable)
        count <= count + 1'b1;
end

endmodule

module testbench;
    reg clk, rst_n, enable;
    wire [3:0] count;
    
    counter dut (
        .clk(clk),
        .rst_n(rst_n),
        .enable(enable),
        .count(count)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst_n = 1'b0;
        enable = 1'b0;
        
        #20 rst_n = 1'b1;
        #10 enable = 1'b1;
        #100 enable = 1'b0;
        #20 rst_n = 1'b0;
        #20 rst_n = 1'b1;
        #50 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b enable=%b count=%d"", 
                 $time, clk, rst_n, enable, count);
    end
endmodule",True,52,True,True,True,False,0.3,False,4.9072425365448,7.7328126430511475,"graph TD
    CLK[Clock] --> CNT[[4-bit Counter]]
    RST[Reset] --> CNT
    EN[Enable] --> CNT
    CNT --> COUNT[Count[3:0]]
    CNT --> TB([Testbench])
    CLK --> TB
    RST --> TB
    EN --> TB
    COUNT --> TB
    TB --> SIG{Signal Verification}
    SIG --> RES[Test Results]
    CLK -.-> |Clock Domain| CNT
    RST -.-> |Async Reset| CNT
    EN -.-> |Control| CNT
    COUNT -.-> |4-bit Output| TB","`timescale 1ns/1ps

module counter(
    input wire clk,
    input wire rst_n,
    input wire enable,
    output reg [3:0] count
);

always @(posedge clk or negedge rst_n) begin
    if (!rst_n)
        count <= 4'b0000;
    else if (enable)
        count <= count + 1'b1;
end

endmodule

module testbench;
    reg clk, rst_n, enable;
    wire [3:0] count;
    
    counter dut (
        .clk(clk),
        .rst_n(rst_n),
        .enable(enable),
        .count(count)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst_n = 1'b0;
        enable = 1'b0;
        
        #20 rst_n = 1'b1;
        #10 enable = 1'b1;
        #100 enable = 1'b0;
        #20 rst_n = 1'b0;
        #20 rst_n = 1'b1;
        #50 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b enable=%b count=%d"", 
                 $time, clk, rst_n, enable, count);
    end
endmodule",True,52,True,True,True,False,0.3,False,7.6604108810424805,8.499868154525757,"Design a 4-bit synchronous counter with clock, reset, enable, and count[3:0]. Include testbench.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph TD
    CLK[Clock] --> CNT[[4-bit Counter]]
    RST[Reset] --> CNT
    EN[Enable] --> CNT
    CNT --> COUNT[Count[3:0]]
    CNT --> TB([Testbench])
    CLK --> TB
    RST --> TB
    EN --> TB
    COUNT --> TB
    TB --> SIG{Signal Verification}
    SIG --> RES[Test Results]
    CLK -.-> |Clock Domain| CNT
    RST -.-> |Async Reset| CNT
    EN -.-> |Control| CNT
    COUNT -.-> |4-bit Output| TB
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module counter(
    input wire clk,
    input wire rst_n,
    input wire enable,
    output reg [3:0] count
);

always @(posedge clk or negedge rst_n) begin
    if (!rst_n)
        count <= 4'b0000;
    else if (enable)
        count <= count + 1'b1;
end

endmodule

module testbench;
    reg clk, rst_n, enable;
    wire [3:0] count;
    
    counter dut (
        .clk(clk),
        .rst_n(rst_n),
        .enable(enable),
        .count(count)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst_n = 1'b0;
        enable = 1'b0;
        
        #20 rst_n = 1'b1;
        #10 enable = 1'b1;
        #100 enable = 1'b0;
        #20 rst_n = 1'b0;
        #20 rst_n = 1'b1;
        #50 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b enable=%b count=%d"", 
                 $time, clk, rst_n, enable, count);
    end
endmodule",True,52,True,True,True,False,0.3,False,4.663634300231934,8.822444915771484,tie,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,Sequential,simple,"Design a 4-bit synchronous counter with clock, reset, enable, and count[3:0]. Include testbench.",gpt-4o,"`timescale 1ns/1ps

module counter(
    input wire clk,
    input wire rst_n,
    input wire enable,
    output reg [3:0] count
);

always @(posedge clk or negedge rst_n) begin
    if (!rst_n)
        count <= 4'b0000;
    else if (enable)
        count <= count + 1'b1;
end

endmodule

module testbench;
    reg clk, rst_n, enable;
    wire [3:0] count;
    
    counter dut (
        .clk(clk),
        .rst_n(rst_n),
        .enable(enable),
        .count(count)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst_n = 1'b0;
        enable = 1'b0;
        
        #20 rst_n = 1'b1;
        #10 enable = 1'b1;
        #100 enable = 1'b0;
        #20 rst_n = 1'b0;
        #20 rst_n = 1'b1;
        #50 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b enable=%b count=%d"", 
                 $time, clk, rst_n, enable, count);
    end
endmodule",True,52,True,True,True,False,0.3,False,2.9876081943511963,14.452826261520386,"graph TD
    CLK[Clock] --> COUNTER(4-bit Counter)
    RST[Reset] --> COUNTER
    EN[Enable] --> COUNTER
    COUNTER --> COUNT[[Count[3:0]]]
    
    subgraph Testbench
        TBCLK[Clock] --> TBCOUNTER
        TBRST[Reset] --> TBCOUNTER
        TBEN[Enable] --> TBCOUNTER
        TBCOUNTER(4-bit Counter)
        TBCOUNTER --> TBCOUNT[[Count[3:0]]]
    end","`timescale 1ns/1ps

module counter(
    input wire clk,
    input wire rst_n,
    input wire enable,
    output reg [3:0] count
);

always @(posedge clk or negedge rst_n) begin
    if (!rst_n)
        count <= 4'b0000;
    else if (enable)
        count <= count + 1'b1;
end

endmodule

module testbench;
    reg clk, rst_n, enable;
    wire [3:0] count;
    
    counter dut (
        .clk(clk),
        .rst_n(rst_n),
        .enable(enable),
        .count(count)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst_n = 1'b0;
        enable = 1'b0;
        
        #20 rst_n = 1'b1;
        #10 enable = 1'b1;
        #100 enable = 1'b0;
        #20 rst_n = 1'b0;
        #20 rst_n = 1'b1;
        #50 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b enable=%b count=%d"", 
                 $time, clk, rst_n, enable, count);
    end
endmodule",True,52,True,True,True,False,0.3,False,7.50211501121521,12.261483669281006,"Design a 4-bit synchronous counter with clock, reset, enable, and count[3:0]. Include testbench.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph TD
    CLK[Clock] --> COUNTER(4-bit Counter)
    RST[Reset] --> COUNTER
    EN[Enable] --> COUNTER
    COUNTER --> COUNT[[Count[3:0]]]
    
    subgraph Testbench
        TBCLK[Clock] --> TBCOUNTER
        TBRST[Reset] --> TBCOUNTER
        TBEN[Enable] --> TBCOUNTER
        TBCOUNTER(4-bit Counter)
        TBCOUNTER --> TBCOUNT[[Count[3:0]]]
    end
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module counter(
    input wire clk,
    input wire rst_n,
    input wire enable,
    output reg [3:0] count
);

always @(posedge clk or negedge rst_n) begin
    if (!rst_n)
        count <= 4'b0000;
    else if (enable)
        count <= count + 1'b1;
end

endmodule

module testbench;
    reg clk, rst_n, enable;
    wire [3:0] count;
    
    counter dut (
        .clk(clk),
        .rst_n(rst_n),
        .enable(enable),
        .count(count)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst_n = 1'b0;
        enable = 1'b0;
        
        #20 rst_n = 1'b1;
        #10 enable = 1'b1;
        #100 enable = 1'b0;
        #20 rst_n = 1'b0;
        #20 rst_n = 1'b1;
        #50 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b enable=%b count=%d"", 
                 $time, clk, rst_n, enable, count);
    end
endmodule",True,52,True,True,True,False,0.3,False,4.1089019775390625,12.355804204940796,tie,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,Combinational,simple,"Create a full adder with inputs a, b, cin and outputs sum, cout. Include testbench with all 8 cases.",claude,"`timescale 1ns/1ps

module full_adder(
    input wire a,
    input wire b,
    input wire cin,
    output wire sum,
    output wire cout
);

assign sum = a ^ b ^ cin;
assign cout = (a & b) | (b & cin) | (a & cin);

endmodule

module testbench;
    reg a, b, cin;
    wire sum, cout;
    
    full_adder dut(
        .a(a),
        .b(b),
        .cin(cin),
        .sum(sum),
        .cout(cout)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        // Test all 8 cases
        {a, b, cin} = 3'b000; #10;
        {a, b, cin} = 3'b001; #10;
        {a, b, cin} = 3'b010; #10;
        {a, b, cin} = 3'b011; #10;
        {a, b, cin} = 3'b100; #10;
        {a, b, cin} = 3'b101; #10;
        {a, b, cin} = 3'b110; #10;
        {a, b, cin} = 3'b111; #10;
        
        $finish;
    end
    
    initial begin
        $monitor(""Time=%0t a=%b b=%b cin=%b sum=%b cout=%b"",
                 $time, a, b, cin, sum, cout);
    end
    
endmodule",True,50,True,True,True,False,0.4,False,5.158293962478638,6.670504808425903,"graph LR
    A[A Input] --> FA(Full Adder)
    B[B Input] --> FA
    CIN[Carry In] --> FA
    FA --> SUM[Sum Output]
    FA --> COUT[Carry Out]
    TB[[Test Cases]]
    TB --> |000|T1[S:0 C:0]
    TB --> |001|T2[S:1 C:0]
    TB --> |010|T3[S:1 C:0]
    TB --> |011|T4[S:0 C:1]
    TB --> |100|T5[S:1 C:0]
    TB --> |101|T6[S:0 C:1]
    TB --> |110|T7[S:0 C:1]
    TB --> |111|T8[S:1 C:1]","`timescale 1ns/1ps

module full_adder(
    input wire a,
    input wire b,
    input wire cin,
    output wire sum,
    output wire cout
);

assign sum = a ^ b ^ cin;
assign cout = (a & b) | (b & cin) | (a & cin);

endmodule

module testbench;
    reg a, b, cin;
    wire sum, cout;
    
    full_adder dut (
        .a(a),
        .b(b),
        .cin(cin),
        .sum(sum),
        .cout(cout)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        // Test case 000
        a = 0; b = 0; cin = 0; #10;
        
        // Test case 001
        a = 0; b = 0; cin = 1; #10;
        
        // Test case 010
        a = 0; b = 1; cin = 0; #10;
        
        // Test case 011
        a = 0; b = 1; cin = 1; #10;
        
        // Test case 100
        a = 1; b = 0; cin = 0; #10;
        
        // Test case 101
        a = 1; b = 0; cin = 1; #10;
        
        // Test case 110
        a = 1; b = 1; cin = 0; #10;
        
        // Test case 111
        a = 1; b = 1; cin = 1; #10;
        
        $finish;
    end
    
    initial begin
        $monitor(""Time=%0t a=%b b=%b cin=%b sum=%b cout=%b"",
                 $time, a, b, cin, sum, cout);
    end
endmodule",True,63,True,True,True,False,0.4,False,9.08862853050232,7.924894332885742,"Create a full adder with inputs a, b, cin and outputs sum, cout. Include testbench with all 8 cases.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph LR
    A[A Input] --> FA(Full Adder)
    B[B Input] --> FA
    CIN[Carry In] --> FA
    FA --> SUM[Sum Output]
    FA --> COUT[Carry Out]
    TB[[Test Cases]]
    TB --> |000|T1[S:0 C:0]
    TB --> |001|T2[S:1 C:0]
    TB --> |010|T3[S:1 C:0]
    TB --> |011|T4[S:0 C:1]
    TB --> |100|T5[S:1 C:0]
    TB --> |101|T6[S:0 C:1]
    TB --> |110|T7[S:0 C:1]
    TB --> |111|T8[S:1 C:1]
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module full_adder(
    input wire a,
    input wire b,
    input wire cin,
    output wire sum,
    output wire cout
);

assign sum = a ^ b ^ cin;
assign cout = (a & b) | (b & cin) | (a & cin);

endmodule

module testbench;
    reg a, b, cin;
    wire sum, cout;

    full_adder dut(
        .a(a),
        .b(b),
        .cin(cin),
        .sum(sum),
        .cout(cout)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        // Test case 000
        a = 0; b = 0; cin = 0;
        #10;
        
        // Test case 001
        a = 0; b = 0; cin = 1;
        #10;
        
        // Test case 010
        a = 0; b = 1; cin = 0;
        #10;
        
        // Test case 011
        a = 0; b = 1; cin = 1;
        #10;
        
        // Test case 100
        a = 1; b = 0; cin = 0;
        #10;
        
        // Test case 101
        a = 1; b = 0; cin = 1;
        #10;
        
        // Test case 110
        a = 1; b = 1; cin = 0;
        #10;
        
        // Test case 111
        a = 1; b = 1; cin = 1;
        #10;
        
        $finish;
    end

    initial begin
        $monitor(""Time=%0t a=%b b=%b cin=%b sum=%b cout=%b"",
                 $time, a, b, cin, sum, cout);
    end

endmodule",True,72,True,True,True,False,0.4,False,5.933276653289795,6.998024940490723,tie,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,Combinational,simple,"Create a full adder with inputs a, b, cin and outputs sum, cout. Include testbench with all 8 cases.",gpt-4o,"`timescale 1ns/1ps

module full_adder(
    input wire a,
    input wire b,
    input wire cin,
    output wire sum,
    output wire cout
);

assign sum = a ^ b ^ cin;
assign cout = (a & b) | (b & cin) | (cin & a);

endmodule

module testbench;
    reg a, b, cin;
    wire sum, cout;

    full_adder dut (
        .a(a),
        .b(b),
        .cin(cin),
        .sum(sum),
        .cout(cout)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        $monitor(""Time=%0t a=%b b=%b cin=%b | sum=%b cout=%b"", 
                 $time, a, b, cin, sum, cout);

        // Test all 8 combinations of inputs
        a = 1'b0; b = 1'b0; cin = 1'b0; #10;
        a = 1'b0; b = 1'b0; cin = 1'b1; #10;
        a = 1'b0; b = 1'b1; cin = 1'b0; #10;
        a = 1'b0; b = 1'b1; cin = 1'b1; #10;
        a = 1'b1; b = 1'b0; cin = 1'b0; #10;
        a = 1'b1; b = 1'b0; cin = 1'b1; #10;
        a = 1'b1; b = 1'b1; cin = 1'b0; #10;
        a = 1'b1; b = 1'b1; cin = 1'b1; #10;

        $finish;
    end
endmodule",True,47,True,True,True,False,0.4,False,5.46655535697937,11.937524795532227,"graph LR
    A[a] --> XOR1
    B[b] --> XOR1
    CIN[cin] --> AND1
    XOR1(XOR Gate) --> XOR2
    CIN --> XOR2
    XOR1 --> AND2
    AND1(AND Gate) --> OR1
    XOR2(XOR Gate) --> SUM[sum]
    AND2(AND Gate) --> OR1
    OR1(OR Gate) --> COUT[cout]
    CIN --> AND1
    A --> AND2
    B --> AND2

    subgraph Testbench
        TB1[Test Case 1: a=0, b=0, cin=0] --> A
        TB1 --> B
        TB1 --> CIN
        TB2[Test Case 2: a=0, b=0, cin=1] --> A
        TB2 --> B
        TB2 --> CIN
        TB3[Test Case 3: a=0, b=1, cin=0] --> A
        TB3 --> B
        TB3 --> CIN
        TB4[Test Case 4: a=0, b=1, cin=1] --> A
        TB4 --> B
        TB4 --> CIN
        TB5[Test Case 5: a=1, b=0, cin=0] --> A
        TB5 --> B
        TB5 --> CIN
        TB6[Test Case 6: a=1, b=0, cin=1] --> A
        TB6 --> B
        TB6 --> CIN
        TB7[Test Case 7: a=1, b=1, cin=0] --> A
        TB7 --> B
        TB7 --> CIN
        TB8[Test Case 8: a=1, b=1, cin=1] --> A
        TB8 --> B
        TB8 --> CIN
    end","`timescale 1ns/1ps

module full_adder (
    input wire a,
    input wire b,
    input wire cin,
    output wire sum,
    output wire cout
);

wire xor1_out, and1_out, and2_out;

// XOR gate for a and b
assign xor1_out = a ^ b;

// XOR gate for xor1_out and cin
assign sum = xor1_out ^ cin;

// AND gate for cin and xor1_out
assign and1_out = cin & xor1_out;

// AND gate for a and b
assign and2_out = a & b;

// OR gate for and1_out and and2_out
assign cout = and1_out | and2_out;

endmodule

module testbench;

reg a, b, cin;
wire sum, cout;

full_adder dut (
    .a(a),
    .b(b),
    .cin(cin),
    .sum(sum),
    .cout(cout)
);

initial begin
    $dumpfile(""dump.vcd"");
    $dumpvars(0, testbench);
    
    // Test Case 1: a=0, b=0, cin=0
    a = 0; b = 0; cin = 0;
    #10;
    
    // Test Case 2: a=0, b=0, cin=1
    a = 0; b = 0; cin = 1;
    #10;
    
    // Test Case 3: a=0, b=1, cin=0
    a = 0; b = 1; cin = 0;
    #10;
    
    // Test Case 4: a=0, b=1, cin=1
    a = 0; b = 1; cin = 1;
    #10;
    
    // Test Case 5: a=1, b=0, cin=0
    a = 1; b = 0; cin = 0;
    #10;
    
    // Test Case 6: a=1, b=0, cin=1
    a = 1; b = 0; cin = 1;
    #10;
    
    // Test Case 7: a=1, b=1, cin=0
    a = 1; b = 1; cin = 0;
    #10;
    
    // Test Case 8: a=1, b=1, cin=1
    a = 1; b = 1; cin = 1;
    #10;
    
    $finish;
end

initial begin
    $monitor(""Time=%0t a=%b b=%b cin=%b | sum=%b cout=%b"", 
             $time, a, b, cin, sum, cout);
end

endmodule",True,87,True,True,True,False,0.4,False,14.661405801773071,12.678345680236816,"Create a full adder with inputs a, b, cin and outputs sum, cout. Include testbench with all 8 cases.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph LR
    A[a] --> XOR1
    B[b] --> XOR1
    CIN[cin] --> AND1
    XOR1(XOR Gate) --> XOR2
    CIN --> XOR2
    XOR1 --> AND2
    AND1(AND Gate) --> OR1
    XOR2(XOR Gate) --> SUM[sum]
    AND2(AND Gate) --> OR1
    OR1(OR Gate) --> COUT[cout]
    CIN --> AND1
    A --> AND2
    B --> AND2

    subgraph Testbench
        TB1[Test Case 1: a=0, b=0, cin=0] --> A
        TB1 --> B
        TB1 --> CIN
        TB2[Test Case 2: a=0, b=0, cin=1] --> A
        TB2 --> B
        TB2 --> CIN
        TB3[Test Case 3: a=0, b=1, cin=0] --> A
        TB3 --> B
        TB3 --> CIN
        TB4[Test Case 4: a=0, b=1, cin=1] --> A
        TB4 --> B
        TB4 --> CIN
        TB5[Test Case 5: a=1, b=0, cin=0] --> A
        TB5 --> B
        TB5 --> CIN
        TB6[Test Case 6: a=1, b=0, cin=1] --> A
        TB6 --> B
        TB6 --> CIN
        TB7[Test Case 7: a=1, b=1, cin=0] --> A
        TB7 --> B
        TB7 --> CIN
        TB8[Test Case 8: a=1, b=1, cin=1] --> A
        TB8 --> B
        TB8 --> CIN
    end
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module full_adder(
    input wire a,
    input wire b,
    input wire cin,
    output wire sum,
    output wire cout
);

    wire xor1_out, and1_out, and2_out;

    assign xor1_out = a ^ b;
    assign and1_out = cin & xor1_out;
    assign and2_out = a & b;
    assign sum = xor1_out ^ cin;
    assign cout = and1_out | and2_out;

endmodule

module testbench;
    reg a, b, cin;
    wire sum, cout;
    
    full_adder dut (
        .a(a),
        .b(b),
        .cin(cin),
        .sum(sum),
        .cout(cout)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        // Test Case 1: a=0, b=0, cin=0
        a = 0; b = 0; cin = 0;
        #10;

        // Test Case 2: a=0, b=0, cin=1
        a = 0; b = 0; cin = 1;
        #10;

        // Test Case 3: a=0, b=1, cin=0
        a = 0; b = 1; cin = 0;
        #10;

        // Test Case 4: a=0, b=1, cin=1
        a = 0; b = 1; cin = 1;
        #10;

        // Test Case 5: a=1, b=0, cin=0
        a = 1; b = 0; cin = 0;
        #10;

        // Test Case 6: a=1, b=0, cin=1
        a = 1; b = 0; cin = 1;
        #10;

        // Test Case 7: a=1, b=1, cin=0
        a = 1; b = 1; cin = 0;
        #10;

        // Test Case 8: a=1, b=1, cin=1
        a = 1; b = 1; cin = 1;
        #10;

        $finish;
    end

    initial begin
        $monitor(""Time=%0t a=%b b=%b cin=%b | sum=%b cout=%b"", $time, a, b, cin, sum, cout);
    end
endmodule",True,75,True,True,True,False,0.4,False,7.9356608390808105,10.91883897781372,tie,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,Combinational,simple,"Design a 2-bit comparator with inputs a[1:0], b[1:0] and outputs eq, gt, lt. Include testbench.",claude,"`timescale 1ns/1ps

module comparator(
    input wire [1:0] a,
    input wire [1:0] b,
    output reg eq,
    output reg gt,
    output reg lt
);

always @(*) begin
    eq = (a == b);
    gt = (a > b);
    lt = (a < b);
end

endmodule

module testbench;
    reg [1:0] a, b;
    wire eq, gt, lt;
    
    comparator dut (
        .a(a),
        .b(b),
        .eq(eq),
        .gt(gt),
        .lt(lt)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        // Test all combinations
        a = 2'b00; b = 2'b00; #10;
        a = 2'b00; b = 2'b01; #10;
        a = 2'b00; b = 2'b10; #10;
        a = 2'b00; b = 2'b11; #10;
        a = 2'b01; b = 2'b00; #10;
        a = 2'b01; b = 2'b01; #10;
        a = 2'b01; b = 2'b10; #10;
        a = 2'b01; b = 2'b11; #10;
        a = 2'b10; b = 2'b00; #10;
        a = 2'b10; b = 2'b01; #10;
        a = 2'b10; b = 2'b10; #10;
        a = 2'b10; b = 2'b11; #10;
        a = 2'b11; b = 2'b00; #10;
        a = 2'b11; b = 2'b01; #10;
        a = 2'b11; b = 2'b10; #10;
        a = 2'b11; b = 2'b11; #10;
        
        $finish;
    end
    
    initial begin
        $monitor(""Time=%0t a=%b b=%b eq=%b gt=%b lt=%b"",
                 $time, a, b, eq, gt, lt);
    end
endmodule",True,60,True,True,True,False,0.4,False,6.9359540939331055,7.455386400222778,"graph LR
    A0[a0] --> COMP((2-bit Comparator))
    A1[a1] --> COMP
    B0[b0] --> COMP
    B1[b1] --> COMP
    COMP --> EQ[eq]
    COMP --> GT[gt]
    COMP --> LT[lt]
    TB[Testbench] -.-> A0
    TB -.-> A1
    TB -.-> B0
    TB -.-> B1
    EQ -.-> VER{Verification}
    GT -.-> VER
    LT -.-> VER
    TB -.-> VER
    VER -.-> RES[Test Results]","`timescale 1ns/1ps

module comparator_2bit(
    input wire a1, a0, b1, b0,
    output reg eq, gt, lt
);

always @(*) begin
    eq = (a1 == b1) && (a0 == b0);
    gt = (a1 > b1) || ((a1 == b1) && (a0 > b0));
    lt = (a1 < b1) || ((a1 == b1) && (a0 < b0));
end

endmodule

module testbench;
    reg a1, a0, b1, b0;
    wire eq, gt, lt;

    comparator_2bit dut(
        .a1(a1),
        .a0(a0),
        .b1(b1),
        .b0(b0),
        .eq(eq),
        .gt(gt),
        .lt(lt)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        // Test all combinations
        {a1,a0,b1,b0} = 4'b0000; #10;
        {a1,a0,b1,b0} = 4'b0001; #10;
        {a1,a0,b1,b0} = 4'b0010; #10;
        {a1,a0,b1,b0} = 4'b0011; #10;
        {a1,a0,b1,b0} = 4'b0100; #10;
        {a1,a0,b1,b0} = 4'b0101; #10;
        {a1,a0,b1,b0} = 4'b0110; #10;
        {a1,a0,b1,b0} = 4'b0111; #10;
        {a1,a0,b1,b0} = 4'b1000; #10;
        {a1,a0,b1,b0} = 4'b1001; #10;
        {a1,a0,b1,b0} = 4'b1010; #10;
        {a1,a0,b1,b0} = 4'b1011; #10;
        {a1,a0,b1,b0} = 4'b1100; #10;
        {a1,a0,b1,b0} = 4'b1101; #10;
        {a1,a0,b1,b0} = 4'b1110; #10;
        {a1,a0,b1,b0} = 4'b1111; #10;

        $finish;
    end

    initial begin
        $monitor(""Time=%0t a=%b%b b=%b%b eq=%b gt=%b lt=%b"",
                 $time, a1, a0, b1, b0, eq, gt, lt);
    end
endmodule",True,59,True,True,True,False,0.4,False,12.41196894645691,7.1505467891693115,"Design a 2-bit comparator with inputs a[1:0], b[1:0] and outputs eq, gt, lt. Include testbench.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph LR
    A0[a0] --> COMP((2-bit Comparator))
    A1[a1] --> COMP
    B0[b0] --> COMP
    B1[b1] --> COMP
    COMP --> EQ[eq]
    COMP --> GT[gt]
    COMP --> LT[lt]
    TB[Testbench] -.-> A0
    TB -.-> A1
    TB -.-> B0
    TB -.-> B1
    EQ -.-> VER{Verification}
    GT -.-> VER
    LT -.-> VER
    TB -.-> VER
    VER -.-> RES[Test Results]
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module comparator(
    input wire [1:0] a,
    input wire [1:0] b,
    output wire eq,
    output wire gt,
    output wire lt
);

assign eq = (a == b);
assign gt = (a > b);
assign lt = (a < b);

endmodule

module testbench;
    reg [1:0] a;
    reg [1:0] b;
    wire eq, gt, lt;
    
    comparator dut (
        .a(a),
        .b(b),
        .eq(eq),
        .gt(gt),
        .lt(lt)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        // Test all combinations
        a = 2'b00; b = 2'b00; #10;
        a = 2'b00; b = 2'b01; #10;
        a = 2'b00; b = 2'b10; #10;
        a = 2'b00; b = 2'b11; #10;
        a = 2'b01; b = 2'b00; #10;
        a = 2'b01; b = 2'b01; #10;
        a = 2'b01; b = 2'b10; #10;
        a = 2'b01; b = 2'b11; #10;
        a = 2'b10; b = 2'b00; #10;
        a = 2'b10; b = 2'b01; #10;
        a = 2'b10; b = 2'b10; #10;
        a = 2'b10; b = 2'b11; #10;
        a = 2'b11; b = 2'b00; #10;
        a = 2'b11; b = 2'b01; #10;
        a = 2'b11; b = 2'b10; #10;
        a = 2'b11; b = 2'b11; #10;
        
        $finish;
    end
    
    initial begin
        $monitor(""Time=%0t a=%b b=%b eq=%b gt=%b lt=%b"",
                 $time, a, b, eq, gt, lt);
    end
endmodule",True,59,True,True,True,False,0.4,False,7.381410121917725,7.314756393432617,tie,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,Combinational,simple,"Design a 2-bit comparator with inputs a[1:0], b[1:0] and outputs eq, gt, lt. Include testbench.",gpt-4o,"`timescale 1ns/1ps

module comparator(
    input wire [1:0] a,
    input wire [1:0] b,
    output reg eq,
    output reg gt,
    output reg lt
);

always @(*) begin
    eq = (a == b);
    gt = (a > b);
    lt = (a < b);
end

endmodule

module testbench;
    reg [1:0] a, b;
    wire eq, gt, lt;
    
    comparator dut (
        .a(a),
        .b(b),
        .eq(eq),
        .gt(gt),
        .lt(lt)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        a = 2'b00; b = 2'b00;
        #10 a = 2'b01; b = 2'b00;
        #10 a = 2'b01; b = 2'b01;
        #10 a = 2'b10; b = 2'b11;
        #10 a = 2'b11; b = 2'b10;
        #10 a = 2'b11; b = 2'b11;
        #10 $finish;
    end
    
    initial begin
        $monitor(""Time=%0t a=%b b=%b eq=%b gt=%b lt=%b"", 
                 $time, a, b, eq, gt, lt);
    end
endmodule",True,48,True,True,True,False,0.4,False,84.86607098579407,8.08931851387024,"graph LR
    subgraph Comparator
        A1[a[1]] --> CMP[Comparator]
        A0[a[0]] --> CMP
        B1[b[1]] --> CMP
        B0[b[0]] --> CMP
        CMP --> EQ[eq]
        CMP --> GT[gt]
        CMP --> LT[lt]
    end
    
    subgraph Testbench
        TB_A1[a[1] Test Value] --> Comparator
        TB_A0[a[0] Test Value] --> Comparator
        TB_B1[b[1] Test Value] --> Comparator
        TB_B0[b[0] Test Value] --> Comparator
        EQ --> TB_EQ[eq Test Result]
        GT --> TB_GT[gt Test Result]
        LT --> TB_LT[lt Test Result]
    end","`timescale 1ns/1ps

module comparator(
    input wire clk,
    input wire [1:0] a,
    input wire [1:0] b,
    output reg eq,
    output reg gt,
    output reg lt
);

always @(posedge clk) begin
    if (a == b) begin
        eq <= 1'b1;
        gt <= 1'b0;
        lt <= 1'b0;
    end else if (a > b) begin
        eq <= 1'b0;
        gt <= 1'b1;
        lt <= 1'b0;
    end else begin
        eq <= 1'b0;
        gt <= 1'b0;
        lt <= 1'b1;
    end
end

endmodule

module testbench;
    reg clk;
    reg [1:0] a, b;
    wire eq, gt, lt;
    
    comparator dut (
        .clk(clk),
        .a(a),
        .b(b),
        .eq(eq),
        .gt(gt),
        .lt(lt)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        a = 2'b00;
        b = 2'b00;
        
        #10 a = 2'b01; b = 2'b01;
        #10 a = 2'b10; b = 2'b01;
        #10 a = 2'b01; b = 2'b10;
        #10 a = 2'b11; b = 2'b11;
        #10 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t clk=%b a=%b b=%b eq=%b gt=%b lt=%b"", 
                 $time, clk, a, b, eq, gt, lt);
    end
endmodule",True,65,True,True,True,False,0.3,False,10.857519388198853,13.94881296157837,"Design a 2-bit comparator with inputs a[1:0], b[1:0] and outputs eq, gt, lt. Include testbench.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph LR
    subgraph Comparator
        A1[a[1]] --> CMP[Comparator]
        A0[a[0]] --> CMP
        B1[b[1]] --> CMP
        B0[b[0]] --> CMP
        CMP --> EQ[eq]
        CMP --> GT[gt]
        CMP --> LT[lt]
    end
    
    subgraph Testbench
        TB_A1[a[1] Test Value] --> Comparator
        TB_A0[a[0] Test Value] --> Comparator
        TB_B1[b[1] Test Value] --> Comparator
        TB_B0[b[0] Test Value] --> Comparator
        EQ --> TB_EQ[eq Test Result]
        GT --> TB_GT[gt Test Result]
        LT --> TB_LT[lt Test Result]
    end
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module comparator(
    input wire [1:0] a,
    input wire [1:0] b,
    output reg eq,
    output reg gt,
    output reg lt
);

always @(*) begin
    if (a > b) begin
        gt = 1'b1;
        eq = 1'b0;
        lt = 1'b0;
    end else if (a < b) begin
        gt = 1'b0;
        eq = 1'b0;
        lt = 1'b1;
    end else begin
        gt = 1'b0;
        eq = 1'b1;
        lt = 1'b0;
    end
end

endmodule

module testbench;
    reg [1:0] a;
    reg [1:0] b;
    wire eq;
    wire gt;
    wire lt;

    comparator dut (
        .a(a),
        .b(b),
        .eq(eq),
        .gt(gt),
        .lt(lt)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        a = 2'b00; b = 2'b00; #10;
        a = 2'b01; b = 2'b00; #10;
        a = 2'b01; b = 2'b10; #10;
        a = 2'b11; b = 2'b10; #10;
        a = 2'b11; b = 2'b11; #10;
        
        $finish;
    end

    initial begin
        $monitor(""Time=%0t a=%b b=%b eq=%b gt=%b lt=%b"", 
                 $time, a, b, eq, gt, lt);
    end
endmodule",True,61,True,True,True,False,0.4,False,5.929670810699463,9.294528245925903,tie,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,Arithmetic,medium,"Design a 4-bit ALU supporting ADD, SUB, AND, OR operations. Inputs: a[3:0], b[3:0], op[1:0]. Outputs: result[3:0], zero. Include testbench.",claude,"`timescale 1ns/1ps

module alu(
    input wire [3:0] a,
    input wire [3:0] b,
    input wire [1:0] op,
    output reg [3:0] result,
    output wire zero
);

always @(*) begin
    case(op)
        2'b00: result = a + b;    // ADD
        2'b01: result = a - b;    // SUB
        2'b10: result = a & b;    // AND
        2'b11: result = a | b;    // OR
        default: result = 4'b0000;
    endcase
end

assign zero = (result == 4'b0000);

endmodule

module testbench;
    reg [3:0] a, b;
    reg [1:0] op;
    wire [3:0] result;
    wire zero;

    alu dut(
        .a(a),
        .b(b),
        .op(op),
        .result(result),
        .zero(zero)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        // Test ADD
        a = 4'b0011; b = 4'b0010; op = 2'b00;
        #10;

        // Test SUB
        a = 4'b0111; b = 4'b0011; op = 2'b01;
        #10;

        // Test AND
        a = 4'b1100; b = 4'b1010; op = 2'b10;
        #10;

        // Test OR
        a = 4'b1100; b = 4'b0011; op = 2'b11;
        #10;

        // Test zero flag
        a = 4'b0011; b = 4'b0011; op = 2'b01;
        #10;

        $finish;
    end

    initial begin
        $monitor(""Time=%0t a=%b b=%b op=%b result=%b zero=%b"",
                 $time, a, b, op, result, zero);
    end
endmodule",True,70,True,True,True,False,0.4,False,6.60631799697876,6.536689519882202,"graph LR
    A[a[3:0]] --> ALU((4-bit ALU))
    B[b[3:0]] --> ALU
    OP[op[1:0]] --> CTRL((Control Decoder))
    CTRL --> ALU
    
    ALU --> RES[result[3:0]]
    ALU --> ZERO{Zero Detect}
    ZERO --> Z[zero]
    
    TB1[[Testbench Stimulus]]-->A
    TB1-->B
    TB1-->OP
    
    RES --> TB2[[Testbench Monitor]]
    Z --> TB2
    
    subgraph Operations
    ADD((ADD))
    SUB((SUB))
    AND((AND))
    OR((OR))
    end
    
    CTRL -.-> Operations","`timescale 1ns/1ps

module alu(
    input wire clk,
    input wire rst_n,
    input wire [3:0] a,
    input wire [3:0] b,
    input wire [1:0] op,
    output reg [3:0] result,
    output wire zero
);

reg [3:0] alu_out;

// Zero detection
assign zero = (result == 4'b0000);

// ALU Operation
always @(*) begin
    case(op)
        2'b00: alu_out = a + b;    // ADD
        2'b01: alu_out = a - b;    // SUB
        2'b10: alu_out = a & b;    // AND
        2'b11: alu_out = a | b;    // OR
        default: alu_out = 4'b0000;
    endcase
end

// Register output
always @(posedge clk or negedge rst_n) begin
    if (!rst_n)
        result <= 4'b0000;
    else
        result <= alu_out;
end

endmodule

module testbench;
    reg clk, rst_n;
    reg [3:0] a, b;
    reg [1:0] op;
    wire [3:0] result;
    wire zero;

    alu dut (
        .clk(clk),
        .rst_n(rst_n),
        .a(a),
        .b(b),
        .op(op),
        .result(result),
        .zero(zero)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 0;
        rst_n = 0;
        a = 0;
        b = 0;
        op = 0;
        
        #10 rst_n = 1;
        
        // Test ADD
        #10 a = 4'h3; b = 4'h4; op = 2'b00;
        
        // Test SUB
        #10 a = 4'h5; b = 4'h3; op = 2'b01;
        
        // Test AND
        #10 a = 4'h7; b = 4'h3; op = 2'b10;
        
        // Test OR
        #10 a = 4'h5; b = 4'h2; op = 2'b11;
        
        // Test zero detection
        #10 a = 4'h0; b = 4'h0; op = 2'b00;
        
        #10 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t a=%h b=%h op=%b result=%h zero=%b"",
                 $time, a, b, op, result, zero);
    end
endmodule",True,92,True,True,True,False,0.4,False,12.699911117553711,6.519524812698364,"Design a 4-bit ALU supporting ADD, SUB, AND, OR operations. Inputs: a[3:0], b[3:0], op[1:0]. Outputs: result[3:0], zero. Include testbench.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph LR
    A[a[3:0]] --> ALU((4-bit ALU))
    B[b[3:0]] --> ALU
    OP[op[1:0]] --> CTRL((Control Decoder))
    CTRL --> ALU
    
    ALU --> RES[result[3:0]]
    ALU --> ZERO{Zero Detect}
    ZERO --> Z[zero]
    
    TB1[[Testbench Stimulus]]-->A
    TB1-->B
    TB1-->OP
    
    RES --> TB2[[Testbench Monitor]]
    Z --> TB2
    
    subgraph Operations
    ADD((ADD))
    SUB((SUB))
    AND((AND))
    OR((OR))
    end
    
    CTRL -.-> Operations
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module alu4bit(
    input wire [3:0] a,
    input wire [3:0] b,
    input wire [1:0] op,
    output reg [3:0] result,
    output wire zero
);

always @(*) begin
    case(op)
        2'b00: result = a + b;    // ADD
        2'b01: result = a - b;    // SUB
        2'b10: result = a & b;    // AND
        2'b11: result = a | b;    // OR
        default: result = 4'b0000;
    endcase
end

assign zero = (result == 4'b0000);

endmodule

module testbench;
    reg [3:0] a;
    reg [3:0] b;
    reg [1:0] op;
    wire [3:0] result;
    wire zero;

    alu4bit dut (
        .a(a),
        .b(b),
        .op(op),
        .result(result),
        .zero(zero)
    );

    initial begin
        $dumpfile(""alu.vcd"");
        $dumpvars(0, testbench);

        // Test ADD
        a = 4'h3; b = 4'h4; op = 2'b00;
        #10;
        
        // Test SUB
        a = 4'h5; b = 4'h5; op = 2'b01;
        #10;
        
        // Test AND
        a = 4'h7; b = 4'h3; op = 2'b10;
        #10;
        
        // Test OR
        a = 4'h6; b = 4'h9; op = 2'b11;
        #10;
        
        // Test zero detection
        a = 4'h0; b = 4'h0; op = 2'b00;
        #10;

        $finish;
    end

    initial begin
        $monitor(""Time=%0t a=%h b=%h op=%b result=%h zero=%b"",
                 $time, a, b, op, result, zero);
    end
endmodule",True,71,True,True,True,,0.0,,6.736657619476318,0.015372514724731445,tie,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,Arithmetic,medium,"Design a 4-bit ALU supporting ADD, SUB, AND, OR operations. Inputs: a[3:0], b[3:0], op[1:0]. Outputs: result[3:0], zero. Include testbench.",gpt-4o,"`timescale 1ns/1ps

module alu(
    input wire [3:0] a,
    input wire [3:0] b,
    input wire [1:0] op,
    output reg [3:0] result,
    output wire zero
);

always @(a or b or op) begin
    case (op)
        2'b00: result = a + b;   // ADD
        2'b01: result = a - b;   // SUB
        2'b10: result = a & b;   // AND
        2'b11: result = a | b;   // OR
        default: result = 4'b0000;
    endcase
end

assign zero = (result == 4'b0000);

endmodule

module testbench;
    reg [3:0] a, b;
    reg [1:0] op;
    wire [3:0] result;
    wire zero;
    
    alu dut (
        .a(a),
        .b(b),
        .op(op),
        .result(result),
        .zero(zero)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        a = 4'b0000; b = 4'b0000; op = 2'b00;
        #10 a = 4'b0010; b = 4'b0011; op = 2'b00;  // ADD
        #10 a = 4'b0100; b = 4'b0010; op = 2'b01;  // SUB
        #10 a = 4'b0101; b = 4'b0011; op = 2'b10;  // AND
        #10 a = 4'b0101; b = 4'b0011; op = 2'b11;  // OR
        #10 a = 4'b0000; b = 4'b0000; op = 2'b00;  // Check zero
        #10 $finish;
    end
    
    initial begin
        $monitor(""Time=%0t a=%b b=%b op=%b result=%b zero=%b"", 
                 $time, a, b, op, result, zero);
    end
endmodule",True,56,True,True,True,False,0.4,False,6.974602937698364,14.778677940368652,"graph TD
    A[a[3:0]] --> ALU
    B[b[3:0]] --> ALU
    OP[op[1:0]] --> ALU
    ALU(4-bit ALU)
    ALU --> RESULT[result[3:0]]
    ALU --> ZERO[zero]
    TESTBENCH[[Testbench]] --> A
    TESTBENCH --> B
    TESTBENCH --> OP
    RESULT --> TESTBENCH
    ZERO --> TESTBENCH","`timescale 1ns/1ps

module alu_4bit (
    input wire [3:0] a,
    input wire [3:0] b,
    input wire [1:0] op,
    output reg [3:0] result,
    output reg zero
);
    always @(*) begin
        case (op)
            2'b00: result = a + b; // Addition
            2'b01: result = a - b; // Subtraction
            2'b10: result = a & b; // Bitwise AND
            2'b11: result = a | b; // Bitwise OR
            default: result = 4'b0000;
        endcase
        zero = (result == 4'b0000);
    end
endmodule

module testbench;
    reg [3:0] a;
    reg [3:0] b;
    reg [1:0] op;
    wire [3:0] result;
    wire zero;
    reg clk;
    
    alu_4bit dut (
        .a(a),
        .b(b),
        .op(op),
        .result(result),
        .zero(zero)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        // Initialize inputs
        a = 4'b0000;
        b = 4'b0000;
        op = 2'b00;
        clk = 1'b0;
        
        // Test addition
        #10 a = 4'b0011; b = 4'b0101; op = 2'b00;
        #10 a = 4'b0110; b = 4'b0010; op = 2'b00;
        
        // Test subtraction
        #10 a = 4'b1000; b = 4'b0011; op = 2'b01;
        
        // Test AND
        #10 a = 4'b1100; b = 4'b1010; op = 2'b10;
        
        // Test OR
        #10 a = 4'b1100; b = 4'b1010; op = 2'b11;
        
        #50 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t a=%b b=%b op=%b result=%b zero=%b"", 
                 $time, a, b, op, result, zero);
    end
endmodule",True,70,True,True,True,False,0.4,False,12.844778537750244,14.477672338485718,"Design a 4-bit ALU supporting ADD, SUB, AND, OR operations. Inputs: a[3:0], b[3:0], op[1:0]. Outputs: result[3:0], zero. Include testbench.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph TD
    A[a[3:0]] --> ALU
    B[b[3:0]] --> ALU
    OP[op[1:0]] --> ALU
    ALU(4-bit ALU)
    ALU --> RESULT[result[3:0]]
    ALU --> ZERO[zero]
    TESTBENCH[[Testbench]] --> A
    TESTBENCH --> B
    TESTBENCH --> OP
    RESULT --> TESTBENCH
    ZERO --> TESTBENCH
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module alu(
    input wire [3:0] a,
    input wire [3:0] b,
    input wire [1:0] op,
    output reg [3:0] result,
    output wire zero
);

always @(*) begin
    case(op)
        2'b00: result = a + b; // ADD operation
        2'b01: result = a - b; // SUB operation
        2'b10: result = a & b; // AND operation
        2'b11: result = a | b; // OR operation
        default: result = 4'b0000;
    endcase
end

assign zero = (result == 4'b0000) ? 1'b1 : 1'b0;

endmodule

module testbench;
    reg [3:0] a;
    reg [3:0] b;
    reg [1:0] op;
    wire [3:0] result;
    wire zero;

    alu dut (
        .a(a),
        .b(b),
        .op(op),
        .result(result),
        .zero(zero)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        a = 4'b0000;
        b = 4'b0000;
        op = 2'b00;

        #10 a = 4'b0101; b = 4'b0011; op = 2'b00; // ADD
        #10 a = 4'b0101; b = 4'b0011; op = 2'b01; // SUB
        #10 a = 4'b0101; b = 4'b0011; op = 2'b10; // AND
        #10 a = 4'b0101; b = 4'b0011; op = 2'b11; // OR
        #10 a = 4'b1111; b = 4'b1111; op = 2'b00; // ADD resulting in zero
        #10 $finish;
    end

    initial begin
        $monitor(""Time=%0t a=%b b=%b op=%b result=%b zero=%b"", 
                 $time, a, b, op, result, zero);
    end
endmodule",True,60,True,True,True,False,0.4,False,10.104605436325073,13.856295824050903,tie,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,Combinational,medium,"Create an 8:1 multiplexer with input data[7:0], select sel[2:0], and output out. Include testbench.",claude,"`timescale 1ns/1ps

module mux_8to1(
    input wire [7:0] data,
    input wire [2:0] sel,
    output reg out
);

always @(*) begin
    case (sel)
        3'b000: out = data[0];
        3'b001: out = data[1];
        3'b010: out = data[2];
        3'b011: out = data[3];
        3'b100: out = data[4];
        3'b101: out = data[5];
        3'b110: out = data[6];
        3'b111: out = data[7];
        default: out = 1'b0;
    endcase
end

endmodule

module testbench;
    reg [7:0] data;
    reg [2:0] sel;
    wire out;
    
    mux_8to1 dut (
        .data(data),
        .sel(sel),
        .out(out)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        data = 8'b10101010;
        sel = 3'b000;
        #10;
        
        repeat(8) begin
            #10 sel = sel + 1;
        end
        
        data = 8'b11001100;
        sel = 3'b000;
        #10;
        
        repeat(8) begin
            #10 sel = sel + 1;
        end
        
        #10 $finish;
    end
    
    initial begin
        $monitor(""Time=%0t data=%b sel=%b out=%b"", 
                 $time, data, sel, out);
    end
endmodule",True,63,True,True,True,False,0.4,False,5.603056192398071,8.113476514816284,"graph LR
    D0[data0] --> MUX{8:1 MUX}
    D1[data1] --> MUX
    D2[data2] --> MUX
    D3[data3] --> MUX
    D4[data4] --> MUX
    D5[data5] --> MUX
    D6[data6] --> MUX
    D7[data7] --> MUX
    S0[sel0] --> MUX
    S1[sel1] --> MUX
    S2[sel2] --> MUX
    MUX --> OUT[out]
    TB[[Testbench]]
    TB --> D0
    TB --> D1
    TB --> D2
    TB --> D3
    TB --> D4
    TB --> D5
    TB --> D6
    TB --> D7
    TB --> S0
    TB --> S1
    TB --> S2
    OUT --> TB","`timescale 1ns/1ps

module mux8to1 (
    input wire clk,
    input wire [7:0] data0,
    input wire [7:0] data1,
    input wire [7:0] data2,
    input wire [7:0] data3,
    input wire [7:0] data4,
    input wire [7:0] data5,
    input wire [7:0] data6,
    input wire [7:0] data7,
    input wire [2:0] sel,
    output reg [7:0] out
);

always @(posedge clk) begin
    case(sel)
        3'b000: out <= data0;
        3'b001: out <= data1;
        3'b010: out <= data2;
        3'b011: out <= data3;
        3'b100: out <= data4;
        3'b101: out <= data5;
        3'b110: out <= data6;
        3'b111: out <= data7;
        default: out <= data0;
    endcase
end

endmodule

module testbench;
    reg clk;
    reg [7:0] data0, data1, data2, data3, data4, data5, data6, data7;
    reg [2:0] sel;
    wire [7:0] out;

    mux8to1 dut (
        .clk(clk),
        .data0(data0),
        .data1(data1),
        .data2(data2),
        .data3(data3),
        .data4(data4),
        .data5(data5),
        .data6(data6),
        .data7(data7),
        .sel(sel),
        .out(out)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 0;
        data0 = 8'h00;
        data1 = 8'h11;
        data2 = 8'h22;
        data3 = 8'h33;
        data4 = 8'h44;
        data5 = 8'h55;
        data6 = 8'h66;
        data7 = 8'h77;
        sel = 3'b000;

        #10 sel = 3'b001;
        #10 sel = 3'b010;
        #10 sel = 3'b011;
        #10 sel = 3'b100;
        #10 sel = 3'b101;
        #10 sel = 3'b110;
        #10 sel = 3'b111;
        #10 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t sel=%b out=%h"", $time, sel, out);
    end
endmodule",True,83,True,True,True,False,0.4,False,11.702557802200317,7.734453439712524,"Create an 8:1 multiplexer with input data[7:0], select sel[2:0], and output out. Include testbench.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph LR
    D0[data0] --> MUX{8:1 MUX}
    D1[data1] --> MUX
    D2[data2] --> MUX
    D3[data3] --> MUX
    D4[data4] --> MUX
    D5[data5] --> MUX
    D6[data6] --> MUX
    D7[data7] --> MUX
    S0[sel0] --> MUX
    S1[sel1] --> MUX
    S2[sel2] --> MUX
    MUX --> OUT[out]
    TB[[Testbench]]
    TB --> D0
    TB --> D1
    TB --> D2
    TB --> D3
    TB --> D4
    TB --> D5
    TB --> D6
    TB --> D7
    TB --> S0
    TB --> S1
    TB --> S2
    OUT --> TB
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module mux8to1 (
    input wire [7:0] data,
    input wire [2:0] sel,
    output reg out
);

always @(*) begin
    case (sel)
        3'b000: out = data[0];
        3'b001: out = data[1];
        3'b010: out = data[2];
        3'b011: out = data[3];
        3'b100: out = data[4];
        3'b101: out = data[5];
        3'b110: out = data[6];
        3'b111: out = data[7];
        default: out = 1'b0;
    endcase
end

endmodule

module testbench;
    reg [7:0] data;
    reg [2:0] sel;
    wire out;

    mux8to1 dut (
        .data(data),
        .sel(sel),
        .out(out)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        data = 8'b10101010;
        sel = 3'b000;
        #10;

        sel = 3'b001;
        #10;

        sel = 3'b010;
        #10;

        data = 8'b11001100;
        sel = 3'b011;
        #10;

        sel = 3'b100;
        #10;

        sel = 3'b101;
        #10;

        sel = 3'b110;
        #10;

        sel = 3'b111;
        #10;

        $finish;
    end

    initial begin
        $monitor(""Time=%0t data=%b sel=%b out=%b"", $time, data, sel, out);
    end

endmodule",True,73,True,True,True,False,0.4,False,5.398196458816528,6.761485815048218,tie,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,Combinational,medium,"Create an 8:1 multiplexer with input data[7:0], select sel[2:0], and output out. Include testbench.",gpt-4o,"`timescale 1ns/1ps

module mux_8to1(
    input wire [7:0] data,
    input wire [2:0] sel,
    output reg out
);

always @(*) begin
    case (sel)
        3'b000: out = data[0];
        3'b001: out = data[1];
        3'b010: out = data[2];
        3'b011: out = data[3];
        3'b100: out = data[4];
        3'b101: out = data[5];
        3'b110: out = data[6];
        3'b111: out = data[7];
        default: out = 1'b0;
    endcase
end

endmodule

module testbench;
    reg [7:0] data;
    reg [2:0] sel;
    wire out;
    
    mux_8to1 dut (
        .data(data),
        .sel(sel),
        .out(out)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        data = 8'b10101010;
        sel = 3'b000;
        
        #10 sel = 3'b001;
        #10 sel = 3'b010;
        #10 sel = 3'b011;
        #10 sel = 3'b100;
        #10 sel = 3'b101;
        #10 sel = 3'b110;
        #10 sel = 3'b111;
        #10 $finish;
    end
    
    initial begin
        $monitor(""Time=%0t sel=%b out=%b"", $time, sel, out);
    end
endmodule",True,56,True,True,True,False,0.4,False,3.7523815631866455,6.692143201828003,"graph TD
    CLK[Clock] --> MUX{8:1 Multiplexer}
    RST[Reset] --> TB[Testbench]
    DATA[Input Data 7:0] --> MUX
    SEL[Select 2:0] --> MUX
    MUX --> OUT[Output]
    TB --> DATA
    TB --> SEL
    TB --> CLK
    TB --> RST
    OUT --> TB","`timescale 1ns/1ps

module multiplexer(
    input wire clk,
    input wire rst_n,
    input wire [7:0] data,
    input wire [2:0] sel,
    output reg [7:0] out
);

always @(posedge clk or negedge rst_n) begin
    if (!rst_n)
        out <= 8'b00000000;
    else
        case (sel)
            3'b000: out <= data;
            3'b001: out <= data;
            3'b010: out <= data;
            3'b011: out <= data;
            3'b100: out <= data;
            3'b101: out <= data;
            3'b110: out <= data;
            3'b111: out <= data;
            default: out <= 8'b00000000;
        endcase
end

endmodule

module testbench;
    reg clk, rst_n;
    reg [7:0] data;
    reg [2:0] sel;
    wire [7:0] out;
    
    multiplexer dut (
        .clk(clk),
        .rst_n(rst_n),
        .data(data),
        .sel(sel),
        .out(out)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst_n = 1'b0;
        data = 8'b00000000;
        sel = 3'b000;
        
        #20 rst_n = 1'b1;
        #10 data = 8'b10101010;
            sel = 3'b010;
        #50 sel = 3'b111;
        #50 data = 8'b11001100;
        #50 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b data=%b sel=%b out=%b"", 
                 $time, clk, rst_n, data, sel, out);
    end
endmodule",True,67,True,True,True,True,0.7,True,8.2412748336792,14.043398380279541,"Create an 8:1 multiplexer with input data[7:0], select sel[2:0], and output out. Include testbench.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph TD
    CLK[Clock] --> MUX{8:1 Multiplexer}
    RST[Reset] --> TB[Testbench]
    DATA[Input Data 7:0] --> MUX
    SEL[Select 2:0] --> MUX
    MUX --> OUT[Output]
    TB --> DATA
    TB --> SEL
    TB --> CLK
    TB --> RST
    OUT --> TB
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module multiplexer_8to1(
    input wire [7:0] data,
    input wire [2:0] sel,
    output reg out
);

always @(*) begin
    case (sel)
        3'b000: out = data[0];
        3'b001: out = data[1];
        3'b010: out = data[2];
        3'b011: out = data[3];
        3'b100: out = data[4];
        3'b101: out = data[5];
        3'b110: out = data[6];
        3'b111: out = data[7];
        default: out = 1'b0;
    endcase
end

endmodule

module testbench;
    reg clk, rst;
    reg [7:0] data;
    reg [2:0] sel;
    wire out;

    multiplexer_8to1 uut (
        .data(data),
        .sel(sel),
        .out(out)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 1'b0;
        rst = 1'b0;
        data = 8'b00000000;
        sel = 3'b000;

        #10 rst = 1'b1;
        #10 data = 8'b10101010;
        #10 sel = 3'b000;
        #10 sel = 3'b001;
        #10 sel = 3'b010;
        #10 sel = 3'b011;
        #10 sel = 3'b100;
        #10 sel = 3'b101;
        #10 sel = 3'b110;
        #10 sel = 3'b111;
        #50 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t clk=%b rst=%b data=%b sel=%b out=%b"", 
                 $time, clk, rst, data, sel, out);
    end
endmodule",True,65,True,True,True,False,0.4,False,5.93610143661499,18.159596920013428,tie,prompt_only > combined > mermaid_only,prompt_only > mermaid_only > combined
combined,State Machine,medium,Design an FSM detecting pattern 1011 in serial input with overlapping detection. Include testbench with sequence: 10110111011.,claude,"`timescale 1ns/1ps

module pattern_detector(
    input wire clk,
    input wire rst_n,
    input wire data_in,
    output reg pattern_found
);

reg [2:0] state;
reg [2:0] next_state;

parameter S0 = 3'b000;
parameter S1 = 3'b001;
parameter S2 = 3'b010;
parameter S3 = 3'b011;
parameter S4 = 3'b100;

always @(posedge clk or negedge rst_n) begin
    if (!rst_n)
        state <= S0;
    else
        state <= next_state;
end

always @(*) begin
    case (state)
        S0: next_state = (data_in) ? S1 : S0;
        S1: next_state = (data_in) ? S1 : S2;
        S2: next_state = (data_in) ? S3 : S0;
        S3: next_state = (data_in) ? S4 : S2;
        S4: next_state = (data_in) ? S1 : S2;
        default: next_state = S0;
    endcase
end

always @(posedge clk or negedge rst_n) begin
    if (!rst_n)
        pattern_found <= 1'b0;
    else
        pattern_found <= (state == S3 && data_in == 1'b1);
end

endmodule

module testbench;
    reg clk;
    reg rst_n;
    reg data_in;
    wire pattern_found;

    pattern_detector dut (
        .clk(clk),
        .rst_n(rst_n),
        .data_in(data_in),
        .pattern_found(pattern_found)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 0;
        rst_n = 0;
        data_in = 0;
        
        #10 rst_n = 1;
        
        // Test sequence: 10110111011
        #10 data_in = 1;
        #10 data_in = 0;
        #10 data_in = 1;
        #10 data_in = 1;
        #10 data_in = 0;
        #10 data_in = 1;
        #10 data_in = 1;
        #10 data_in = 1;
        #10 data_in = 0;
        #10 data_in = 1;
        #10 data_in = 1;
        
        #20 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t rst_n=%b data_in=%b pattern_found=%b"",
                 $time, rst_n, data_in, pattern_found);
    end
endmodule",True,91,True,True,True,False,0.3,False,8.782349348068237,7.21335768699646,"graph LR
    CLK[Clock] --> FSM((FSM Core))
    RST[Reset] --> FSM
    IN[Serial Input] --> FSM
    FSM --> DET[Pattern Detected]
    FSM --> ST[[Current State]]
    
    TB_IN[10110111011] --> TST((Test Sequence))
    TST --> EXP[[Expected: 1 at positions 4,8]]
    
    subgraph States
        S0((Idle))
        S1((Got 1))
        S2((Got 10))
        S3((Got 101))
        S4((Got 1011))
    end
    
    S0 --> |1| S1
    S1 --> |0| S2
    S2 --> |1| S3
    S3 --> |1| S4
    S4 --> |1| S1
    S4 --> |0| S2
    S3 --> |0| S0
    S2 --> |0| S0
    S1 --> |1| S1
    S0 --> |0| S0","`timescale 1ns/1ps

module pattern_detect(
    input wire clk,
    input wire rst,
    input wire in,
    output reg detected,
    output reg [2:0] state
);

parameter S0 = 3'b000;  // Idle
parameter S1 = 3'b001;  // Got 1
parameter S2 = 3'b010;  // Got 10
parameter S3 = 3'b011;  // Got 101
parameter S4 = 3'b100;  // Got 1011

always @(posedge clk or posedge rst) begin
    if (rst) begin
        state <= S0;
        detected <= 1'b0;
    end
    else begin
        case (state)
            S0: state <= (in) ? S1 : S0;
            S1: state <= (in) ? S1 : S2;
            S2: state <= (in) ? S3 : S0;
            S3: state <= (in) ? S4 : S0;
            S4: state <= (in) ? S1 : S2;
            default: state <= S0;
        endcase
        
        detected <= (state == S4 && in);
    end
end

endmodule

module testbench;
    reg clk;
    reg rst;
    reg in;
    wire detected;
    wire [2:0] state;
    
    pattern_detect dut(
        .clk(clk),
        .rst(rst),
        .in(in),
        .detected(detected),
        .state(state)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 0;
        rst = 1;
        in = 0;
        
        #10 rst = 0;
        
        // Test sequence: 10110111011
        #10 in = 1;
        #10 in = 0;
        #10 in = 1;
        #10 in = 1;
        #10 in = 0;
        #10 in = 1;
        #10 in = 1;
        #10 in = 1;
        #10 in = 0;
        #10 in = 1;
        #10 in = 1;
        
        #20 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t rst=%b in=%b state=%b detected=%b"",
                 $time, rst, in, state, detected);
    end
endmodule",True,85,True,True,True,True,0.8,True,12.750372171401978,7.144635200500488,"Design an FSM detecting pattern 1011 in serial input with overlapping detection. Include testbench with sequence: 10110111011.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph LR
    CLK[Clock] --> FSM((FSM Core))
    RST[Reset] --> FSM
    IN[Serial Input] --> FSM
    FSM --> DET[Pattern Detected]
    FSM --> ST[[Current State]]
    
    TB_IN[10110111011] --> TST((Test Sequence))
    TST --> EXP[[Expected: 1 at positions 4,8]]
    
    subgraph States
        S0((Idle))
        S1((Got 1))
        S2((Got 10))
        S3((Got 101))
        S4((Got 1011))
    end
    
    S0 --> |1| S1
    S1 --> |0| S2
    S2 --> |1| S3
    S3 --> |1| S4
    S4 --> |1| S1
    S4 --> |0| S2
    S3 --> |0| S0
    S2 --> |0| S0
    S1 --> |1| S1
    S0 --> |0| S0
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module pattern_detector (
    input wire clk,
    input wire rst,
    input wire serial_in,
    output reg pattern_detected,
    output reg [2:0] current_state
);

// State encoding
parameter S0 = 3'd0;  // Idle
parameter S1 = 3'd1;  // Got 1
parameter S2 = 3'd2;  // Got 10
parameter S3 = 3'd3;  // Got 101
parameter S4 = 3'd4;  // Got 1011

reg [2:0] next_state;

always @(posedge clk or posedge rst) begin
    if (rst) begin
        current_state <= S0;
        pattern_detected <= 1'b0;
    end
    else begin
        current_state <= next_state;
        pattern_detected <= (current_state == S4);
    end
end

always @(*) begin
    case (current_state)
        S0: next_state = serial_in ? S1 : S0;
        S1: next_state = serial_in ? S1 : S2;
        S2: next_state = serial_in ? S3 : S0;
        S3: next_state = serial_in ? S4 : S0;
        S4: next_state = serial_in ? S1 : S2;
        default: next_state = S0;
    endcase
end

endmodule

module testbench;
    reg clk;
    reg rst;
    reg serial_in;
    wire pattern_detected;
    wire [2:0] current_state;
    
    reg [10:0] test_sequence = 11'b10110111011;
    integer i;
    
    pattern_detector dut (
        .clk(clk),
        .rst(rst),
        .serial_in(serial_in),
        .pattern_detected(pattern_detected),
        .current_state(current_state)
    );
    
    initial begin
        $dumpfile(""pattern_detector.vcd"");
        $dumpvars(0, testbench);
        
        clk = 0;
        rst = 1;
        serial_in = 0;
        
        #10 rst = 0;
        
        for (i = 10; i >= 0; i = i - 1) begin
            serial_in = test_sequence[i];
            #10;
        end
        
        #10 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t rst=%b input=%b state=%d detected=%b"", 
                 $time, rst, serial_in, current_state, pattern_detected);
    end
endmodule",True,86,True,True,True,,0.0,,8.385368347167969,0.012627840042114258,prompt_only,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,State Machine,medium,Design an FSM detecting pattern 1011 in serial input with overlapping detection. Include testbench with sequence: 10110111011.,gpt-4o,"`timescale 1ns/1ps

module fsm_1011_detector(
    input wire clk,
    input wire rst_n,
    input wire serial_in,
    output reg pattern_detected
);

    // State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        S1   = 3'b001,
        S10  = 3'b010,
        S101 = 3'b011,
        S1011 = 3'b100
    } state_t;

    reg [2:0] state, next_state;

    // State transition logic
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n)
            state <= IDLE;
        else
            state <= next_state;
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE:   next_state = (serial_in) ? S1 : IDLE;
            S1:     next_state = (serial_in) ? S1 : S10;
            S10:    next_state = (serial_in) ? S101 : IDLE;
            S101:   next_state = (serial_in) ? S1 : S1011;
            S1011:  next_state = (serial_in) ? S1 : S10;
            default: next_state = IDLE;
        endcase
    end

    // Output logic
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n)
            pattern_detected <= 1'b0;
        else if (state == S1011 && !serial_in)
            pattern_detected <= 1'b1;
        else
            pattern_detected <= 1'b0;
    end

endmodule

module testbench;
    reg clk, rst_n, serial_in;
    wire pattern_detected;

    fsm_1011_detector dut (
        .clk(clk),
        .rst_n(rst_n),
        .serial_in(serial_in),
        .pattern_detected(pattern_detected)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 1'b0;
        rst_n = 1'b0;
        serial_in = 1'b0;

        #20 rst_n = 1'b1;

        // Test sequence: 10110111011
        #10 serial_in = 1'b1;
        #10 serial_in = 1'b0;
        #10 serial_in = 1'b1;
        #10 serial_in = 1'b1;
        #10 serial_in = 1'b0;
        #10 serial_in = 1'b1;
        #10 serial_in = 1'b1;
        #10 serial_in = 1'b1;
        #10 serial_in = 1'b0;
        #10 serial_in = 1'b1;
        #10 serial_in = 1'b1;
        #10 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b serial_in=%b pattern_detected=%b"", 
                 $time, clk, rst_n, serial_in, pattern_detected);
    end
endmodule",True,95,True,True,True,True,0.9,True,11.206910848617554,14.111618757247925,"graph LR
    CLK[Clock] --> FSM((FSM Logic))
    RST[Reset] --> FSM
    IN[Serial Input] --> FSM
    FSM --> OUT[Pattern Detected]
    
    subgraph Testbench
        sequence[Input Sequence: 10110111011] --> IN
    end","`timescale 1ns/1ps

module fsm(
    input wire clk,
    input wire rst,
    input wire serial_in,
    output reg pattern_detected
);

    reg state, next_state;
    
    always @(posedge clk or posedge rst) begin
        if (rst)
            state <= 1'b0;
        else
            state <= next_state;
    end
    
    always @(state or serial_in) begin
        next_state = state;
        pattern_detected = 1'b0;
        
        case (state)
            1'b0: begin
                if (serial_in == 1'b1)
                    next_state = 1'b1;
            end
            1'b1: begin
                pattern_detected = 1'b1;
                next_state = 1'b0;
            end
        endcase
    end
    
endmodule

module testbench;
    reg clk, rst;
    reg serial_in;
    wire pattern_detected;
    
    fsm dut (
        .clk(clk),
        .rst(rst),
        .serial_in(serial_in),
        .pattern_detected(pattern_detected)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst = 1'b1;
        serial_in = 1'b0;
        
        #10 rst = 1'b0;
        
        #10 serial_in = 1'b1;
        #10 serial_in = 1'b0;
        #10 serial_in = 1'b1;
        #10 serial_in = 1'b1;
        #10 serial_in = 1'b0;
        #10 serial_in = 1'b1;
        #10 serial_in = 1'b1;
        #10 serial_in = 1'b0;
        #10 serial_in = 1'b1;
        #10 serial_in = 1'b1;
        #10 serial_in = 1'b1;
        
        #10 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t clk=%b rst=%b serial_in=%b pattern_detected=%b"", 
                 $time, clk, rst, serial_in, pattern_detected);
    end
endmodule",True,80,True,True,True,True,0.7,True,9.798222303390503,15.942340850830078,"Design an FSM detecting pattern 1011 in serial input with overlapping detection. Include testbench with sequence: 10110111011.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph LR
    CLK[Clock] --> FSM((FSM Logic))
    RST[Reset] --> FSM
    IN[Serial Input] --> FSM
    FSM --> OUT[Pattern Detected]
    
    subgraph Testbench
        sequence[Input Sequence: 10110111011] --> IN
    end
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module fsm_pattern_detector (
    input wire clk,
    input wire rst,
    input wire serial_in,
    output reg pattern_detected
);

    reg [2:0] state, next_state;

    // State encoding
    localparam S0 = 3'b000,
               S1 = 3'b001,
               S2 = 3'b010,
               S3 = 3'b011,
               S4 = 3'b100;

    // State transition logic
    always @(posedge clk or posedge rst) begin
        if (rst)
            state <= S0;
        else
            state <= next_state;
    end

    // Next state logic and output logic
    always @(*) begin
        next_state = state;
        pattern_detected = 1'b0;
        case (state)
            S0: begin
                if (serial_in == 1'b1)
                    next_state = S1;
            end
            S1: begin
                if (serial_in == 1'b0)
                    next_state = S2;
                else
                    next_state = S1;
            end
            S2: begin
                if (serial_in == 1'b1)
                    next_state = S3;
                else
                    next_state = S0;
            end
            S3: begin
                if (serial_in == 1'b1) begin
                    next_state = S4;
                    pattern_detected = 1'b1;
                end
                else
                    next_state = S2;
            end
            S4: begin
                if (serial_in == 1'b0)
                    next_state = S2;
                else
                    next_state = S1;
            end
            default: next_state = S0;
        endcase
    end

endmodule

module testbench;
    reg clk, rst, serial_in;
    wire pattern_detected;

    fsm_pattern_detector dut (
        .clk(clk),
        .rst(rst),
        .serial_in(serial_in),
        .pattern_detected(pattern_detected)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 1'b0;
        rst = 1'b1;
        serial_in = 1'b0;

        #10 rst = 1'b0;

        // Input sequence: 10110111011
        #10 serial_in = 1'b1;
        #10 serial_in = 1'b0;
        #10 serial_in = 1'b1;
        #10 serial_in = 1'b1;
        #10 serial_in = 1'b0;
        #10 serial_in = 1'b1;
        #10 serial_in = 1'b1;
        #10 serial_in = 1'b1;
        #10 serial_in = 1'b0;
        #10 serial_in = 1'b1;
        #10 serial_in = 1'b1;

        #20 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t clk=%b rst=%b serial_in=%b pattern_detected=%b"", 
                 $time, clk, rst, serial_in, pattern_detected);
    end
endmodule",True,111,True,True,True,True,0.7,True,8.959638595581055,11.989604711532593,prompt_only,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,Sequential,medium,"Create a 4-bit PISO shift register with clock, reset, load, parallel input[3:0], and serial output. Include testbench.",claude,"`timescale 1ns/1ps

module piso_shift_register(
    input wire clk,
    input wire rst_n,
    input wire load,
    input wire [3:0] parallel_in,
    output reg serial_out
);

reg [3:0] shift_reg;

always @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
        shift_reg <= 4'b0000;
        serial_out <= 1'b0;
    end
    else if (load) begin
        shift_reg <= parallel_in;
        serial_out <= parallel_in[3];
    end
    else begin
        shift_reg <= {shift_reg[2:0], 1'b0};
        serial_out <= shift_reg[3];
    end
end

endmodule

module testbench;
    reg clk, rst_n, load;
    reg [3:0] parallel_in;
    wire serial_out;

    piso_shift_register dut (
        .clk(clk),
        .rst_n(rst_n),
        .load(load),
        .parallel_in(parallel_in),
        .serial_out(serial_out)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 0;
        rst_n = 0;
        load = 0;
        parallel_in = 4'b0000;

        #10 rst_n = 1;
        #10 parallel_in = 4'b1101;
        #10 load = 1;
        #10 load = 0;
        #40 parallel_in = 4'b1010;
        #10 load = 1;
        #10 load = 0;
        #40 rst_n = 0;
        #20 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t rst_n=%b load=%b parallel_in=%b serial_out=%b"",
                 $time, rst_n, load, parallel_in, serial_out);
    end
endmodule",True,69,True,True,True,True,0.7,True,6.231063604354858,7.64715051651001,"graph LR
    CLK[Clock] --> REG[[4-bit Register]]
    RST[Reset] --> REG
    LOAD[Load] --> MUX
    PIN0[Parallel In 0] --> MUX{MUX}
    PIN1[Parallel In 1] --> MUX
    PIN2[Parallel In 2] --> MUX
    PIN3[Parallel In 3] --> MUX
    MUX --> REG
    REG --> SOUT[Serial Out]
    REG --> FB(Feedback Path)
    FB --> MUX
    TB[Testbench] --> PIN0
    TB --> PIN1
    TB --> PIN2
    TB --> PIN3
    TB --> CLK
    TB --> RST
    TB --> LOAD
    SOUT --> TB","`timescale 1ns/1ps

module piso_reg(
    input wire clk,
    input wire rst,
    input wire load,
    input wire [3:0] parallel_in,
    output wire serial_out
);

reg [3:0] shift_reg;
wire [3:0] mux_out;

assign mux_out = load ? parallel_in : {shift_reg[2:0], shift_reg[3]};
assign serial_out = shift_reg[3];

always @(posedge clk or posedge rst) begin
    if (rst)
        shift_reg <= 4'b0000;
    else
        shift_reg <= mux_out;
end

endmodule

module testbench;
    reg clk, rst, load;
    reg [3:0] parallel_in;
    wire serial_out;
    
    piso_reg dut (
        .clk(clk),
        .rst(rst),
        .load(load),
        .parallel_in(parallel_in),
        .serial_out(serial_out)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 0;
        rst = 1;
        load = 0;
        parallel_in = 4'b0000;
        
        #10 rst = 0;
        
        #10 load = 1;
        parallel_in = 4'b1010;
        
        #10 load = 0;
        
        #40 load = 1;
        parallel_in = 4'b1111;
        
        #10 load = 0;
        
        #40 rst = 1;
        #10 rst = 0;
        
        #20 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t rst=%b load=%b pin=%b sout=%b"", 
                 $time, rst, load, parallel_in, serial_out);
    end
endmodule",True,72,True,True,True,False,0.4,False,10.176824808120728,8.457867860794067,"Create a 4-bit PISO shift register with clock, reset, load, parallel input[3:0], and serial output. Include testbench.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph LR
    CLK[Clock] --> REG[[4-bit Register]]
    RST[Reset] --> REG
    LOAD[Load] --> MUX
    PIN0[Parallel In 0] --> MUX{MUX}
    PIN1[Parallel In 1] --> MUX
    PIN2[Parallel In 2] --> MUX
    PIN3[Parallel In 3] --> MUX
    MUX --> REG
    REG --> SOUT[Serial Out]
    REG --> FB(Feedback Path)
    FB --> MUX
    TB[Testbench] --> PIN0
    TB --> PIN1
    TB --> PIN2
    TB --> PIN3
    TB --> CLK
    TB --> RST
    TB --> LOAD
    SOUT --> TB
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module piso_register(
    input wire clk,
    input wire rst,
    input wire load,
    input wire [3:0] parallel_in,
    output wire serial_out
);

reg [3:0] shift_reg;

assign serial_out = shift_reg[3];

always @(posedge clk or posedge rst) begin
    if (rst)
        shift_reg <= 4'b0000;
    else if (load)
        shift_reg <= parallel_in;
    else
        shift_reg <= {shift_reg[2:0], shift_reg[3]};
end

endmodule

module testbench;
    reg clk;
    reg rst;
    reg load;
    reg [3:0] parallel_in;
    wire serial_out;

    piso_register dut (
        .clk(clk),
        .rst(rst),
        .load(load),
        .parallel_in(parallel_in),
        .serial_out(serial_out)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 0;
        rst = 1;
        load = 0;
        parallel_in = 4'b0000;

        #10 rst = 0;
        
        #10 parallel_in = 4'b1010;
        load = 1;
        #10 load = 0;
        
        #40;
        
        parallel_in = 4'b1111;
        load = 1;
        #10 load = 0;
        
        #40;
        
        rst = 1;
        #10 rst = 0;
        
        #20 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t rst=%b load=%b parallel_in=%b serial_out=%b"", 
                 $time, rst, load, parallel_in, serial_out);
    end
endmodule",True,76,True,True,True,False,0.4,False,6.19243311882019,7.673872709274292,tie,mermaid_only > combined > prompt_only,prompt_only > mermaid_only > combined
combined,Sequential,medium,"Create a 4-bit PISO shift register with clock, reset, load, parallel input[3:0], and serial output. Include testbench.",gpt-4o,"`timescale 1ns/1ps

module piso_shift_register(
    input wire clk,
    input wire rst_n,
    input wire load,
    input wire [3:0] parallel_in,
    output reg serial_out
);

reg [3:0] shift_reg;

always @(posedge clk or negedge rst_n) begin
    if (!rst_n)
        shift_reg <= 4'b0000;
    else if (load)
        shift_reg <= parallel_in;
    else begin
        serial_out <= shift_reg[0];
        shift_reg <= {1'b0, shift_reg[3:1]};
    end
end

endmodule

module testbench;
    reg clk, rst_n, load;
    reg [3:0] parallel_in;
    wire serial_out;
    
    piso_shift_register dut (
        .clk(clk),
        .rst_n(rst_n),
        .load(load),
        .parallel_in(parallel_in),
        .serial_out(serial_out)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst_n = 1'b0;
        load = 1'b0;
        parallel_in = 4'b0000;
        
        #20 rst_n = 1'b1;
        #10 load = 1'b1; parallel_in = 4'b1010;
        #10 load = 1'b0;
        #40 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b load=%b parallel_in=%b serial_out=%b"", 
                 $time, clk, rst_n, load, parallel_in, serial_out);
    end
endmodule",True,60,True,True,True,True,0.7,True,4.487365245819092,13.063496589660645,"graph LR
    CLK[Clock] --> PISO(4-bit PISO Shift Register)
    RST[Reset] --> PISO
    LOAD[Load] --> PISO
    PI[Parallel Input[3:0]] --> PISO
    PISO --> SO[Serial Output]
    
    subgraph Testbench
        CLK_TB[Clock] --> PISO_TB(4-bit PISO Shift Register)
        RST_TB[Reset] --> PISO_TB
        LOAD_TB[Load] --> PISO_TB
        PI_TB[Parallel Input[3:0]] --> PISO_TB
        PISO_TB --> SO_TB[Serial Output]
    end","`timescale 1ns/1ps

module piso_shift_register(
    input wire clk,
    input wire rst,
    input wire load,
    input wire [3:0] pi,
    output reg so
);

reg [3:0] shift_reg;

always @(posedge clk or posedge rst) begin
    if (rst) begin
        shift_reg <= 4'b0000;
        so <= 1'b0;
    end else if (load) begin
        shift_reg <= pi;
    end else begin
        so <= shift_reg[3];
        shift_reg <= {shift_reg[2:0], 1'b0};
    end
end

endmodule

module testbench;
    reg clk, rst, load;
    reg [3:0] pi;
    wire so;

    piso_shift_register piso_tb (
        .clk(clk),
        .rst(rst),
        .load(load),
        .pi(pi),
        .so(so)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 1'b0;
        rst = 1'b0;
        load = 1'b0;
        pi = 4'b0000;

        #20 rst = 1'b1;
        #10 rst = 1'b0;
        #10 load = 1'b1; pi = 4'b1010;
        #10 load = 1'b0;
        #100 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t clk=%b rst=%b load=%b pi=%b so=%b"", 
                 $time, clk, rst, load, pi, so);
    end
endmodule",True,62,True,True,True,True,0.7,True,12.91197919845581,7.952112197875977,"Create a 4-bit PISO shift register with clock, reset, load, parallel input[3:0], and serial output. Include testbench.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph LR
    CLK[Clock] --> PISO(4-bit PISO Shift Register)
    RST[Reset] --> PISO
    LOAD[Load] --> PISO
    PI[Parallel Input[3:0]] --> PISO
    PISO --> SO[Serial Output]
    
    subgraph Testbench
        CLK_TB[Clock] --> PISO_TB(4-bit PISO Shift Register)
        RST_TB[Reset] --> PISO_TB
        LOAD_TB[Load] --> PISO_TB
        PI_TB[Parallel Input[3:0]] --> PISO_TB
        PISO_TB --> SO_TB[Serial Output]
    end
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module piso_shift_register(
    input wire clk,
    input wire rst_n,
    input wire load,
    input wire [3:0] parallel_in,
    output reg serial_out
);
    reg [3:0] shift_reg;

    always @(posedge clk or negedge rst_n) begin
        if (!rst_n)
            shift_reg <= 4'b0000;
        else if (load)
            shift_reg <= parallel_in;
        else
            shift_reg <= {shift_reg[2:0], 1'b0};
    end

    always @* begin
        serial_out = shift_reg[3];
    end
endmodule

module testbench;
    reg clk, rst_n, load;
    reg [3:0] parallel_in;
    wire serial_out;

    piso_shift_register dut (
        .clk(clk),
        .rst_n(rst_n),
        .load(load),
        .parallel_in(parallel_in),
        .serial_out(serial_out)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 1'b0;
        rst_n = 1'b0;
        load = 1'b0;
        parallel_in = 4'b0000;

        #20 rst_n = 1'b1;
        #10 load = 1'b1; parallel_in = 4'b1010;
        #10 load = 1'b0;
        #40 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b load=%b parallel_in=%b serial_out=%b"", 
                 $time, clk, rst_n, load, parallel_in, serial_out);
    end
endmodule",True,60,True,True,True,True,0.7,True,5.202696084976196,20.11896562576294,prompt_only,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,Combinational,medium,"Design a 4-to-2 priority encoder with input in[3:0], output out[1:0], and valid bit. Highest bit has priority. Include testbench.",claude,"`timescale 1ns/1ps

module priority_encoder(
    input wire [3:0] in,
    output reg [1:0] out,
    output reg valid
);

always @(*) begin
    if (in[3]) begin
        out = 2'b11;
        valid = 1'b1;
    end
    else if (in[2]) begin
        out = 2'b10;
        valid = 1'b1;
    end
    else if (in[1]) begin
        out = 2'b01;
        valid = 1'b1;
    end
    else if (in[0]) begin
        out = 2'b00;
        valid = 1'b1;
    end
    else begin
        out = 2'b00;
        valid = 1'b0;
    end
end

endmodule

module testbench;
    reg [3:0] in;
    wire [1:0] out;
    wire valid;

    priority_encoder dut (
        .in(in),
        .out(out),
        .valid(valid)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        in = 4'b0000;
        #10;
        in = 4'b0001;
        #10;
        in = 4'b0010;
        #10;
        in = 4'b0100;
        #10;
        in = 4'b1000;
        #10;
        in = 4'b1111;
        #10;
        in = 4'b0011;
        #10;
        in = 4'b0000;
        #10;
        $finish;
    end

    initial begin
        $monitor(""Time=%0t in=%b out=%b valid=%b"", 
                 $time, in, out, valid);
    end
endmodule",True,72,True,True,True,False,0.4,False,5.859422922134399,6.911490201950073,"graph LR
    In0[in[0]] --> ENC
    In1[in[1]] --> ENC
    In2[in[2]] --> ENC
    In3[in[3]] --> ENC
    ENC{Priority Encoder} --> OUT[out[1:0]]
    ENC --> VALID[valid]
    TB1[Testbench Stimulus] -.-> In0
    TB1 -.-> In1
    TB1 -.-> In2
    TB1 -.-> In3
    OUT -.-> TB2[Testbench Monitor]
    VALID -.-> TB2
    TB3[Test Vectors<br>4'b0000<br>4'b0001<br>4'b0010<br>4'b0100<br>4'b1000<br>4'b1111] -.-> TB1","`timescale 1ns/1ps

module priority_encoder(
    input wire clk,
    input wire rst_n,
    input wire [3:0] in,
    output reg [1:0] out,
    output reg valid
);

always @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
        out <= 2'b00;
        valid <= 1'b0;
    end
    else begin
        valid <= |in;
        if (in[3])
            out <= 2'b11;
        else if (in[2])
            out <= 2'b10;
        else if (in[1])
            out <= 2'b01;
        else if (in[0])
            out <= 2'b00;
        else
            out <= 2'b00;
    end
end

endmodule

module testbench;
    reg clk, rst_n;
    reg [3:0] in;
    wire [1:0] out;
    wire valid;

    priority_encoder dut (
        .clk(clk),
        .rst_n(rst_n),
        .in(in),
        .out(out),
        .valid(valid)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 0;
        rst_n = 0;
        in = 4'b0000;
        
        #10 rst_n = 1;
        
        #10 in = 4'b0000;
        #10 in = 4'b0001;
        #10 in = 4'b0010;
        #10 in = 4'b0100;
        #10 in = 4'b1000;
        #10 in = 4'b1111;
        
        #10 rst_n = 0;
        #10 rst_n = 1;
        
        #10 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t rst_n=%b in=%b out=%b valid=%b"", 
                 $time, rst_n, in, out, valid);
    end
endmodule",True,76,True,True,True,True,0.8,True,10.51275897026062,8.721157312393188,"Design a 4-to-2 priority encoder with input in[3:0], output out[1:0], and valid bit. Highest bit has priority. Include testbench.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph LR
    In0[in[0]] --> ENC
    In1[in[1]] --> ENC
    In2[in[2]] --> ENC
    In3[in[3]] --> ENC
    ENC{Priority Encoder} --> OUT[out[1:0]]
    ENC --> VALID[valid]
    TB1[Testbench Stimulus] -.-> In0
    TB1 -.-> In1
    TB1 -.-> In2
    TB1 -.-> In3
    OUT -.-> TB2[Testbench Monitor]
    VALID -.-> TB2
    TB3[Test Vectors<br>4'b0000<br>4'b0001<br>4'b0010<br>4'b0100<br>4'b1000<br>4'b1111] -.-> TB1
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module priority_encoder(
    input wire [3:0] in,
    output reg [1:0] out,
    output reg valid
);

always @(*) begin
    if (in[3]) begin
        out = 2'b11;
        valid = 1'b1;
    end
    else if (in[2]) begin
        out = 2'b10;
        valid = 1'b1;
    end
    else if (in[1]) begin
        out = 2'b01;
        valid = 1'b1;
    end
    else if (in[0]) begin
        out = 2'b00;
        valid = 1'b1;
    end
    else begin
        out = 2'b00;
        valid = 1'b0;
    end
end

endmodule

module testbench;
    reg [3:0] in;
    wire [1:0] out;
    wire valid;

    priority_encoder dut (
        .in(in),
        .out(out),
        .valid(valid)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        // Test vectors
        in = 4'b0000; #10;
        in = 4'b0001; #10;
        in = 4'b0010; #10;
        in = 4'b0100; #10;
        in = 4'b1000; #10;
        in = 4'b1111; #10;
        
        $finish;
    end

    initial begin
        $monitor(""Time=%0t in=%b out=%b valid=%b"", 
                 $time, in, out, valid);
    end

endmodule",True,65,True,True,True,False,0.4,False,5.200803518295288,6.497504949569702,tie,prompt_only > combined > mermaid_only,prompt_only > mermaid_only > combined
combined,Combinational,medium,"Design a 4-to-2 priority encoder with input in[3:0], output out[1:0], and valid bit. Highest bit has priority. Include testbench.",gpt-4o,"`timescale 1ns/1ps

module priority_encoder(
    input wire [3:0] in,
    output reg [1:0] out,
    output reg valid
);

always @(*) begin
    if (in[3]) begin
        out = 2'b11;
        valid = 1'b1;
    end else if (in[2]) begin
        out = 2'b10;
        valid = 1'b1;
    end else if (in[1]) begin
        out = 2'b01;
        valid = 1'b1;
    end else if (in[0]) begin
        out = 2'b00;
        valid = 1'b1;
    end else begin
        out = 2'b00;
        valid = 1'b0;
    end
end

endmodule

module testbench;
    reg [3:0] in;
    wire [1:0] out;
    wire valid;
    
    priority_encoder dut (
        .in(in),
        .out(out),
        .valid(valid)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        in = 4'b0000;
        #10 in = 4'b0001;
        #10 in = 4'b0010;
        #10 in = 4'b0100;
        #10 in = 4'b1000;
        #10 in = 4'b1100;
        #10 in = 4'b1010;
        #10 in = 4'b1001;
        #10 in = 4'b1111;
        #10 $finish;
    end
    
    initial begin
        $monitor(""Time=%0t in=%b out=%b valid=%b"", 
                 $time, in, out, valid);
    end
endmodule",True,61,True,True,True,False,0.4,False,5.419401168823242,19.552462100982666,"graph TD
    IN0[in[0]] --> ENC(4-to-2 Priority Encoder)
    IN1[in[1]] --> ENC
    IN2[in[2]] --> ENC
    IN3[in[3]] --> ENC
    ENC --> OUT0[out[0]]
    ENC --> OUT1[out[1]]
    ENC --> VALID[Valid Bit]

    %% Testbench
    TB[Testbench]
    TB --> IN0
    TB --> IN1
    TB --> IN2
    TB --> IN3
    TB --> CLK[Clock]
    TB --> RST[Reset]
    OUT0 --> TB
    OUT1 --> TB
    VALID --> TB","`timescale 1ns/1ps

module priority_encoder_4to2 (
    input wire [3:0] in,
    output reg [1:0] out,
    output reg valid
);

always @(*) begin
    if (in[3]) begin
        out = 2'b11;
        valid = 1'b1;
    end else if (in[2]) begin
        out = 2'b10;
        valid = 1'b1;
    end else if (in[1]) begin
        out = 2'b01;
        valid = 1'b1;
    end else if (in[0]) begin
        out = 2'b00;
        valid = 1'b1;
    end else begin
        out = 2'b00;
        valid = 1'b0;
    end
end

endmodule

module priority_encoder_4to2_pipeline (
    input wire clk,
    input wire rst_n,
    input wire [3:0] in,
    output reg [1:0] out,
    output reg valid
);

wire [1:0] enc_out;
wire enc_valid;

priority_encoder_4to2 encoder (
    .in(in),
    .out(enc_out),
    .valid(enc_valid)
);

always @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
        out <= 2'b00;
        valid <= 1'b0;
    end else begin
        out <= enc_out;
        valid <= enc_valid;
    end
end

endmodule

module testbench;
    reg clk, rst_n;
    reg [3:0] in;
    wire [1:0] out;
    wire valid;

    priority_encoder_4to2_pipeline dut (
        .clk(clk),
        .rst_n(rst_n),
        .in(in),
        .out(out),
        .valid(valid)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 1'b0;
        rst_n = 1'b0;
        in = 4'b0000;

        #20 rst_n = 1'b1;
        #10 in = 4'b0001;
        #10 in = 4'b0010;
        #10 in = 4'b0100;
        #10 in = 4'b1000;
        #10 in = 4'b0000;
        #10 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b in=%b out=%b valid=%b"", 
                 $time, clk, rst_n, in, out, valid);
    end
endmodule",True,96,True,True,True,False,0.4,False,13.992446660995483,16.287029504776,"Design a 4-to-2 priority encoder with input in[3:0], output out[1:0], and valid bit. Highest bit has priority. Include testbench.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph TD
    IN0[in[0]] --> ENC(4-to-2 Priority Encoder)
    IN1[in[1]] --> ENC
    IN2[in[2]] --> ENC
    IN3[in[3]] --> ENC
    ENC --> OUT0[out[0]]
    ENC --> OUT1[out[1]]
    ENC --> VALID[Valid Bit]

    %% Testbench
    TB[Testbench]
    TB --> IN0
    TB --> IN1
    TB --> IN2
    TB --> IN3
    TB --> CLK[Clock]
    TB --> RST[Reset]
    OUT0 --> TB
    OUT1 --> TB
    VALID --> TB
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module priority_encoder_4to2 (
    input wire [3:0] in,
    output reg [1:0] out,
    output reg valid
);

always @(*) begin
    if (in[3]) begin
        out = 2'b11;
        valid = 1'b1;
    end else if (in[2]) begin
        out = 2'b10;
        valid = 1'b1;
    end else if (in[1]) begin
        out = 2'b01;
        valid = 1'b1;
    end else if (in[0]) begin
        out = 2'b00;
        valid = 1'b1;
    end else begin
        out = 2'b00;
        valid = 1'b0;
    end
end

endmodule

module testbench;
    reg [3:0] in;
    wire [1:0] out;
    wire valid;
    reg clk, rst;

    priority_encoder_4to2 dut (
        .in(in),
        .out(out),
        .valid(valid)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 1'b0;
        rst = 1'b0;
        in = 4'b0000;

        #20 rst = 1'b1;
        #10 in = 4'b0001;
        #10 in = 4'b0010;
        #10 in = 4'b0100;
        #10 in = 4'b1000;
        #10 in = 4'b0000;
        #10 in = 4'b1010;
        #10 in = 4'b0110;
        #10 in = 4'b0011;
        #10 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t in=%b out=%b valid=%b"", 
                 $time, in, out, valid);
    end
endmodule",True,68,True,True,True,False,0.4,False,8.334308624267578,12.631039381027222,tie,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,State Machine,complex,"Design a traffic light FSM with 4 states: NS_GREEN, NS_YELLOW, EW_GREEN, EW_YELLOW. Inputs: clk, rst, emergency. Outputs: ns_light[1:0], ew_light[1:0]. Timing: GREEN=8 cycles, YELLOW=2 cycles. Emergency makes both RED. Include testbench.",claude,"`timescale 1ns/1ps

module traffic_light(
    input wire clk,
    input wire rst,
    input wire emergency,
    output reg [1:0] ns_light,
    output reg [1:0] ew_light
);

parameter [1:0] RED = 2'b00;
parameter [1:0] YELLOW = 2'b01;
parameter [1:0] GREEN = 2'b10;

parameter [1:0] NS_GREEN = 2'b00;
parameter [1:0] NS_YELLOW = 2'b01;
parameter [1:0] EW_GREEN = 2'b10;
parameter [1:0] EW_YELLOW = 2'b11;

reg [1:0] state;
reg [3:0] timer;

always @(posedge clk or posedge rst) begin
    if (rst) begin
        state <= NS_GREEN;
        timer <= 4'd0;
        ns_light <= GREEN;
        ew_light <= RED;
    end
    else if (emergency) begin
        ns_light <= RED;
        ew_light <= RED;
    end
    else begin
        case (state)
            NS_GREEN: begin
                if (timer == 4'd7) begin
                    state <= NS_YELLOW;
                    timer <= 4'd0;
                    ns_light <= YELLOW;
                end
                else begin
                    timer <= timer + 1'b1;
                    ns_light <= GREEN;
                    ew_light <= RED;
                end
            end
            
            NS_YELLOW: begin
                if (timer == 4'd1) begin
                    state <= EW_GREEN;
                    timer <= 4'd0;
                    ns_light <= RED;
                    ew_light <= GREEN;
                end
                else begin
                    timer <= timer + 1'b1;
                end
            end
            
            EW_GREEN: begin
                if (timer == 4'd7) begin
                    state <= EW_YELLOW;
                    timer <= 4'd0;
                    ew_light <= YELLOW;
                end
                else begin
                    timer <= timer + 1'b1;
                    ns_light <= RED;
                    ew_light <= GREEN;
                end
            end
            
            EW_YELLOW: begin
                if (timer == 4'd1) begin
                    state <= NS_GREEN;
                    timer <= 4'd0;
                    ns_light <= GREEN;
                    ew_light <= RED;
                end
                else begin
                    timer <= timer + 1'b1;
                end
            end
        endcase
    end
end

endmodule

module testbench;
    reg clk;
    reg rst;
    reg emergency;
    wire [1:0] ns_light;
    wire [1:0] ew_light;
    
    traffic_light dut (
        .clk(clk),
        .rst(rst),
        .emergency(emergency),
        .ns_light(ns_light),
        .ew_light(ew_light)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 0;
        rst = 1;
        emergency = 0;
        
        #10 rst = 0;
        
        // Normal operation
        #100;
        
        // Test emergency
        emergency = 1;
        #20;
        emergency = 0;
        
        // Continue normal operation
        #100;
        
        $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t ns_light=%b ew_light=%b emergency=%b"",
                 $time, ns_light, ew_light, emergency);
    end
endmodule",True,136,True,True,True,False,0.4,False,10.977325439453125,8.173614025115967,"graph TD
    CLK[Clock] --> FSM[[Traffic Light FSM]]
    RST[Reset] --> FSM
    EMERG[Emergency] --> FSM
    
    FSM --> STATE_REG[[State Register]]
    STATE_REG --> FSM
    
    FSM --> COUNTER[[Cycle Counter]]
    COUNTER --> FSM
    CLK --> COUNTER
    RST --> COUNTER
    
    FSM --> NS_OUT[NS_Light[1:0]]
    FSM --> EW_OUT[EW_Light[1:0]]
    
    subgraph States
        NS_G[NS_GREEN]
        NS_Y[NS_YELLOW]
        EW_G[EW_GREEN]
        EW_Y[EW_YELLOW]
    end
    
    subgraph TestBench
        TB_CLK[TB Clock Gen]
        TB_RST[TB Reset Gen]
        TB_EMERG[TB Emergency Gen]
        TB_CHECK(Output Checker)
    end
    
    TB_CLK --> FSM
    TB_RST --> FSM
    TB_EMERG --> FSM
    NS_OUT --> TB_CHECK
    EW_OUT --> TB_CHECK","`timescale 1ns/1ps

module traffic_light_fsm (
    input wire clk,
    input wire rst,
    input wire emergency,
    output reg [1:0] ns_light,
    output reg [1:0] ew_light
);

// State definitions
parameter NS_GREEN  = 2'b00;
parameter NS_YELLOW = 2'b01;
parameter EW_GREEN  = 2'b10;
parameter EW_YELLOW = 2'b11;

reg [1:0] state, next_state;
reg [3:0] counter;

// State register
always @(posedge clk or posedge rst) begin
    if (rst)
        state <= NS_GREEN;
    else
        state <= next_state;
end

// Counter logic
always @(posedge clk or posedge rst) begin
    if (rst)
        counter <= 4'd0;
    else if (counter == 4'd15)
        counter <= 4'd0;
    else
        counter <= counter + 1'b1;
end

// Next state logic
always @(*) begin
    case (state)
        NS_GREEN: begin
            if (emergency || counter == 4'd15)
                next_state = NS_YELLOW;
            else
                next_state = NS_GREEN;
        end
        NS_YELLOW: begin
            if (counter == 4'd4)
                next_state = EW_GREEN;
            else
                next_state = NS_YELLOW;
        end
        EW_GREEN: begin
            if (emergency || counter == 4'd15)
                next_state = EW_YELLOW;
            else
                next_state = EW_GREEN;
        end
        EW_YELLOW: begin
            if (counter == 4'd4)
                next_state = NS_GREEN;
            else
                next_state = EW_YELLOW;
        end
        default: next_state = NS_GREEN;
    endcase
end

// Output logic
always @(*) begin
    case (state)
        NS_GREEN: begin
            ns_light = 2'b10;  // Green
            ew_light = 2'b00;  // Red
        end
        NS_YELLOW: begin
            ns_light = 2'b01;  // Yellow
            ew_light = 2'b00;  // Red
        end
        EW_GREEN: begin
            ns_light = 2'b00;  // Red
            ew_light = 2'b10;  // Green
        end
        EW_YELLOW: begin
            ns_light = 2'b00;  // Red
            ew_light = 2'b01;  // Yellow
        end
        default: begin
            ns_light = 2'b00;  // Red
            ew_light = 2'b00;  // Red
        end
    endcase
end

endmodule

module testbench;
    reg clk, rst, emergency;
    wire [1:0] ns_light, ew_light;
    
    traffic_light_fsm dut (
        .clk(clk),
        .rst(rst),
        .emergency(emergency),
        .ns_light(ns_light),
        .ew_light(ew_light)
    );
    
    initial begin
        $dumpfile(""traffic.vcd"");
        $dumpvars(0, testbench);
        
        clk = 0;
        rst = 1;
        emergency = 0;
        
        #20 rst = 0;
        #100 emergency = 1;
        #10 emergency = 0;
        #200 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t rst=%b emergency=%b ns_light=%b ew_light=%b"", 
                 $time, rst, emergency, ns_light, ew_light);
    end
endmodule",True,129,True,True,True,,0.0,,15.737030267715454,0.01663994789123535,"Design a traffic light FSM with 4 states: NS_GREEN, NS_YELLOW, EW_GREEN, EW_YELLOW. Inputs: clk, rst, emergency. Outputs: ns_light[1:0], ew_light[1:0]. Timing: GREEN=8 cycles, YELLOW=2 cycles. Emergency makes both RED. Include testbench.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph TD
    CLK[Clock] --> FSM[[Traffic Light FSM]]
    RST[Reset] --> FSM
    EMERG[Emergency] --> FSM
    
    FSM --> STATE_REG[[State Register]]
    STATE_REG --> FSM
    
    FSM --> COUNTER[[Cycle Counter]]
    COUNTER --> FSM
    CLK --> COUNTER
    RST --> COUNTER
    
    FSM --> NS_OUT[NS_Light[1:0]]
    FSM --> EW_OUT[EW_Light[1:0]]
    
    subgraph States
        NS_G[NS_GREEN]
        NS_Y[NS_YELLOW]
        EW_G[EW_GREEN]
        EW_Y[EW_YELLOW]
    end
    
    subgraph TestBench
        TB_CLK[TB Clock Gen]
        TB_RST[TB Reset Gen]
        TB_EMERG[TB Emergency Gen]
        TB_CHECK(Output Checker)
    end
    
    TB_CLK --> FSM
    TB_RST --> FSM
    TB_EMERG --> FSM
    NS_OUT --> TB_CHECK
    EW_OUT --> TB_CHECK
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module traffic_fsm (
    input wire clk,
    input wire rst,
    input wire emergency,
    output reg [1:0] ns_light,
    output reg [1:0] ew_light
);

parameter [1:0] NS_GREEN = 2'b00;
parameter [1:0] NS_YELLOW = 2'b01;
parameter [1:0] EW_GREEN = 2'b10;
parameter [1:0] EW_YELLOW = 2'b11;

parameter [1:0] RED = 2'b00;
parameter [1:0] YELLOW = 2'b01;
parameter [1:0] GREEN = 2'b10;

reg [1:0] state, next_state;
reg [3:0] counter;

always @(posedge clk or posedge rst) begin
    if (rst)
        state <= NS_GREEN;
    else
        state <= next_state;
end

always @(posedge clk or posedge rst) begin
    if (rst)
        counter <= 4'd0;
    else if (emergency)
        counter <= 4'd0;
    else if ((state == NS_GREEN || state == EW_GREEN) && counter == 4'd7)
        counter <= 4'd0;
    else if ((state == NS_YELLOW || state == EW_YELLOW) && counter == 4'd1)
        counter <= 4'd0;
    else
        counter <= counter + 1'b1;
end

always @(*) begin
    if (emergency) begin
        next_state = state;
        ns_light = RED;
        ew_light = RED;
    end else begin
        case (state)
            NS_GREEN: begin
                ns_light = GREEN;
                ew_light = RED;
                if (counter == 4'd7)
                    next_state = NS_YELLOW;
                else
                    next_state = NS_GREEN;
            end
            
            NS_YELLOW: begin
                ns_light = YELLOW;
                ew_light = RED;
                if (counter == 4'd1)
                    next_state = EW_GREEN;
                else
                    next_state = NS_YELLOW;
            end
            
            EW_GREEN: begin
                ns_light = RED;
                ew_light = GREEN;
                if (counter == 4'd7)
                    next_state = EW_YELLOW;
                else
                    next_state = EW_GREEN;
            end
            
            EW_YELLOW: begin
                ns_light = RED;
                ew_light = YELLOW;
                if (counter == 4'd1)
                    next_state = NS_GREEN;
                else
                    next_state = EW_YELLOW;
            end
            
            default: begin
                next_state = NS_GREEN;
                ns_light = RED;
                ew_light = RED;
            end
        endcase
    end
end

endmodule

module testbench;
    reg clk, rst, emergency;
    wire [1:0] ns_light, ew_light;
    
    traffic_fsm dut (
        .clk(clk),
        .rst(rst),
        .emergency(emergency),
        .ns_light(ns_light),
        .ew_light(ew_light)
    );
    
    initial begin
        $dumpfile(""traffic.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst = 1'b1;
        emergency = 1'b0;
        
        #10 rst = 1'b0;
        
        // Normal operation
        #200;
        
        // Test emergency
        emergency = 1'b1;
        #40;
        emergency = 1'b0;
        
        // Continue normal operation
        #200;
        
        $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t rst=%b emergency=%b ns_light=%b ew_light=%b"",
                 $time, rst, emergency, ns_light, ew_light);
    end
endmodule",True,139,True,True,True,,0.0,,12.711254596710205,0.018279314041137695,prompt_only,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,State Machine,complex,"Design a traffic light FSM with 4 states: NS_GREEN, NS_YELLOW, EW_GREEN, EW_YELLOW. Inputs: clk, rst, emergency. Outputs: ns_light[1:0], ew_light[1:0]. Timing: GREEN=8 cycles, YELLOW=2 cycles. Emergency makes both RED. Include testbench.",gpt-4o,"`timescale 1ns/1ps

module traffic_light_fsm(
    input wire clk,
    input wire rst,
    input wire emergency,
    output reg [1:0] ns_light,
    output reg [1:0] ew_light
);

    // State encoding
    parameter NS_GREEN = 2'b00;
    parameter NS_YELLOW = 2'b01;
    parameter EW_GREEN = 2'b10;
    parameter EW_YELLOW = 2'b11;

    // Light encoding
    parameter GREEN = 2'b01;
    parameter YELLOW = 2'b10;
    parameter RED = 2'b00;

    reg [1:0] state;
    reg [3:0] timer;

    // State Transition
    always @(posedge clk or posedge rst) begin
        if (rst) begin
            state <= NS_GREEN;
            timer <= 4'd0;
        end else if (emergency) begin
            state <= NS_GREEN; // Force RED lights
            ns_light <= RED;
            ew_light <= RED;
        end else begin
            case (state)
                NS_GREEN: begin
                    if (timer < 4'd7) begin
                        timer <= timer + 1'b1;
                    end else begin
                        state <= NS_YELLOW;
                        timer <= 4'd0;
                    end
                end
                NS_YELLOW: begin
                    if (timer < 4'd1) begin
                        timer <= timer + 1'b1;
                    end else begin
                        state <= EW_GREEN;
                        timer <= 4'd0;
                    end
                end
                EW_GREEN: begin
                    if (timer < 4'd7) begin
                        timer <= timer + 1'b1;
                    end else begin
                        state <= EW_YELLOW;
                        timer <= 4'd0;
                    end
                end
                EW_YELLOW: begin
                    if (timer < 4'd1) begin
                        timer <= timer + 1'b1;
                    end else begin
                        state <= NS_GREEN;
                        timer <= 4'd0;
                    end
                end
            endcase
        end
    end

    // Output Logic
    always @(state) begin
        case (state)
            NS_GREEN: begin
                ns_light = GREEN;
                ew_light = RED;
            end
            NS_YELLOW: begin
                ns_light = YELLOW;
                ew_light = RED;
            end
            EW_GREEN: begin
                ns_light = RED;
                ew_light = GREEN;
            end
            EW_YELLOW: begin
                ns_light = RED;
                ew_light = YELLOW;
            end
            default: begin
                ns_light = RED;
                ew_light = RED;
            end
        endcase
    end

endmodule

module testbench;
    reg clk, rst, emergency;
    wire [1:0] ns_light, ew_light;
    
    traffic_light_fsm dut (
        .clk(clk),
        .rst(rst),
        .emergency(emergency),
        .ns_light(ns_light),
        .ew_light(ew_light)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 1'b0;
        rst = 1'b1;
        emergency = 1'b0;

        #20 rst = 1'b0;
        #160 emergency = 1'b1;
        #20 emergency = 1'b0;
        #200 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t clk=%b rst=%b emergency=%b ns_light=%b ew_light=%b"", 
                 $time, clk, rst, emergency, ns_light, ew_light);
    end
endmodule",True,132,True,True,True,False,0.3,False,13.536030292510986,17.302256107330322,"graph LR
    CLK[clk] --> FSM((FSM))
    RST[rst] --> FSM
    EMERGENCY[emergency] --> FSM
    FSM --> NS_STATE[[NS_LIGHT[1:0]]]
    FSM --> EW_STATE[[EW_LIGHT[1:0]]]

    FSM --> NS_GREEN((NS_GREEN))
    FSM --> NS_YELLOW((NS_YELLOW))
    FSM --> EW_GREEN((EW_GREEN))
    FSM --> EW_YELLOW((EW_YELLOW))

    NS_GREEN -- 8 cycles --> NS_YELLOW
    NS_YELLOW -- 2 cycles --> EW_GREEN
    EW_GREEN -- 8 cycles --> EW_YELLOW
    EW_YELLOW -- 2 cycles --> NS_GREEN

    {Emergency Check} -->|emergency=1| EMERGENCY_RED((EMERGENCY_RED))
    EMERGENCY --> {Emergency Check}

    NS_GREEN & NS_YELLOW -->|normal| NS_STATE
    EW_GREEN & EW_YELLOW -->|normal| EW_STATE

    EMERGENCY_RED --> NS_STATE
    EMERGENCY_RED --> EW_STATE

    TB[Testbench] --> FSM","`timescale 1ns/1ps

module fsm(
    input wire clk,
    input wire rst,
    input wire emergency,
    output reg [1:0] ns_light,
    output reg [1:0] ew_light
);

    // State encoding
    localparam [2:0] NS_GREEN = 3'b000,
                     NS_YELLOW = 3'b001,
                     EW_GREEN = 3'b010,
                     EW_YELLOW = 3'b011,
                     EMERGENCY_RED = 3'b100;
   
    reg [2:0] current_state, next_state;
    reg [3:0] cycle_count;

    always @(posedge clk or posedge rst) begin
        if (rst) begin
            current_state <= NS_GREEN;
            cycle_count <= 4'd0;
        end else begin
            current_state <= next_state;
            cycle_count <= cycle_count + 1'b1;
        end
    end

    always @(*) begin
        next_state = current_state; // Default to hold state
        case (current_state)
            NS_GREEN: 
                if (cycle_count == 8) begin
                    next_state = NS_YELLOW;
                    cycle_count = 1'b0;
                end
            NS_YELLOW: 
                if (cycle_count == 2) begin
                    next_state = EW_GREEN;
                    cycle_count = 1'b0;
                end
            EW_GREEN: 
                if (cycle_count == 8) begin
                    next_state = EW_YELLOW;
                    cycle_count = 1'b0;
                end
            EW_YELLOW: 
                if (cycle_count == 2) begin
                    next_state = NS_GREEN;
                    cycle_count = 1'b0;
                end
            EMERGENCY_RED: 
                if (!emergency) begin
                    next_state = NS_GREEN;
                end
            default: next_state = NS_GREEN;
        endcase
    end

    always @(*) begin
        ns_light = 2'b00; // Default: Red
        ew_light = 2'b00; // Default: Red
        case (current_state)
            NS_GREEN: ns_light = 2'b01; // Green
            NS_YELLOW: ns_light = 2'b10; // Yellow
            EW_GREEN: ew_light = 2'b01; // Green
            EW_YELLOW: ew_light = 2'b10; // Yellow
            EMERGENCY_RED: begin
                ns_light = 2'b00; // Red
                ew_light = 2'b00; // Red
            end
        endcase
    end

    always @(posedge clk) begin
        if (emergency) begin
            next_state <= EMERGENCY_RED;
        end
    end

endmodule

module testbench;
    reg clk, rst, emergency;
    wire [1:0] ns_light, ew_light;
    
    fsm dut (
        .clk(clk),
        .rst(rst),
        .emergency(emergency),
        .ns_light(ns_light),
        .ew_light(ew_light)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst = 1'b1;
        emergency = 1'b0;
        
        #20 rst = 1'b0;
        #150 emergency = 1'b1;
        #50 emergency = 1'b0;
        #200 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t clk=%b rst=%b emergency=%b ns_light=%b ew_light=%b"", 
                 $time, clk, rst, emergency, ns_light, ew_light);
    end
endmodule",True,117,True,True,True,False,0.3,False,25.309900522232056,9.764384269714355,"Design a traffic light FSM with 4 states: NS_GREEN, NS_YELLOW, EW_GREEN, EW_YELLOW. Inputs: clk, rst, emergency. Outputs: ns_light[1:0], ew_light[1:0]. Timing: GREEN=8 cycles, YELLOW=2 cycles. Emergency makes both RED. Include testbench.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph LR
    CLK[clk] --> FSM((FSM))
    RST[rst] --> FSM
    EMERGENCY[emergency] --> FSM
    FSM --> NS_STATE[[NS_LIGHT[1:0]]]
    FSM --> EW_STATE[[EW_LIGHT[1:0]]]

    FSM --> NS_GREEN((NS_GREEN))
    FSM --> NS_YELLOW((NS_YELLOW))
    FSM --> EW_GREEN((EW_GREEN))
    FSM --> EW_YELLOW((EW_YELLOW))

    NS_GREEN -- 8 cycles --> NS_YELLOW
    NS_YELLOW -- 2 cycles --> EW_GREEN
    EW_GREEN -- 8 cycles --> EW_YELLOW
    EW_YELLOW -- 2 cycles --> NS_GREEN

    {Emergency Check} -->|emergency=1| EMERGENCY_RED((EMERGENCY_RED))
    EMERGENCY --> {Emergency Check}

    NS_GREEN & NS_YELLOW -->|normal| NS_STATE
    EW_GREEN & EW_YELLOW -->|normal| EW_STATE

    EMERGENCY_RED --> NS_STATE
    EMERGENCY_RED --> EW_STATE

    TB[Testbench] --> FSM
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module traffic_light_fsm(
    input wire clk,
    input wire rst,
    input wire emergency,
    output reg [1:0] ns_light,
    output reg [1:0] ew_light
);

    typedef enum reg [1:0] {
        NS_GREEN = 2'b00,
        NS_YELLOW = 2'b01,
        EW_GREEN = 2'b10,
        EW_YELLOW = 2'b11
    } state_t;

    state_t current_state, next_state;

    reg [3:0] cycle_counter;

    always @(posedge clk or posedge rst) begin
        if (rst) begin
            current_state <= NS_GREEN;
            cycle_counter <= 4'b0000;
        end else begin
            current_state <= next_state;
            if (emergency)
                cycle_counter <= 4'b0000;
            else
                cycle_counter <= cycle_counter + 1'b1;
        end
    end

    always @(*) begin
        case (current_state)
            NS_GREEN: begin
                ns_light = 2'b01; // Green
                ew_light = 2'b00; // Red
                if (emergency)
                    next_state = EW_YELLOW;
                else if (cycle_counter == 4'd8)
                    next_state = NS_YELLOW;
                else
                    next_state = NS_GREEN;
            end
            NS_YELLOW: begin
                ns_light = 2'b10; // Yellow
                ew_light = 2'b00; // Red
                if (emergency)
                    next_state = EW_YELLOW;
                else if (cycle_counter == 4'd2)
                    next_state = EW_GREEN;
                else
                    next_state = NS_YELLOW;
            end
            EW_GREEN: begin
                ns_light = 2'b00; // Red
                ew_light = 2'b01; // Green
                if (emergency)
                    next_state = EW_YELLOW;
                else if (cycle_counter == 4'd8)
                    next_state = EW_YELLOW;
                else
                    next_state = EW_GREEN;
            end
            EW_YELLOW: begin
                ns_light = 2'b00; // Red
                ew_light = 2'b10; // Yellow
                if (emergency)
                    next_state = EW_YELLOW;
                else if (cycle_counter == 4'd2)
                    next_state = NS_GREEN;
                else
                    next_state = EW_YELLOW;
            end
            default: begin
                ns_light = 2'b00; // Red
                ew_light = 2'b00; // Red
                next_state = NS_GREEN;
            end
        endcase
    end

endmodule

module testbench;
    reg clk, rst, emergency;
    wire [1:0] ns_light;
    wire [1:0] ew_light;

    traffic_light_fsm dut (
        .clk(clk),
        .rst(rst),
        .emergency(emergency),
        .ns_light(ns_light),
        .ew_light(ew_light)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 1'b0;
        rst = 1'b1;
        emergency = 1'b0;

        #10 rst = 1'b0;
        #100 emergency = 1'b1;
        #20 emergency = 1'b0;
        #100 rst = 1'b1;
        #10 rst = 1'b0;
        #50 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t clk=%b rst=%b emergency=%b ns_light=%b ew_light=%b"", 
                 $time, clk, rst, emergency, ns_light, ew_light);
    end
endmodule",True,122,True,True,True,False,0.3,False,22.468318223953247,15.983805418014526,tie,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,State Machine,complex,"Design UART transmitter with states: IDLE, START, DATA, STOP. Protocol: START(0), 8 data bits LSB-first, STOP(1). Baud rate divider. Include testbench.",claude,"`timescale 1ns/1ps

module uart_tx(
    input wire clk,
    input wire rst_n,
    input wire tx_start,
    input wire [7:0] tx_data,
    output reg tx_out,
    output reg tx_done
);

parameter CLKS_PER_BIT = 16;
parameter IDLE = 2'b00;
parameter START = 2'b01;
parameter DATA = 2'b10;
parameter STOP = 2'b11;

reg [1:0] state;
reg [3:0] bit_counter;
reg [7:0] shift_reg;
reg [4:0] clk_counter;

always @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
        state <= IDLE;
        tx_out <= 1'b1;
        tx_done <= 1'b0;
        bit_counter <= 4'b0;
        shift_reg <= 8'b0;
        clk_counter <= 5'b0;
    end else begin
        case (state)
            IDLE: begin
                tx_out <= 1'b1;
                tx_done <= 1'b0;
                bit_counter <= 4'b0;
                clk_counter <= 5'b0;
                if (tx_start) begin
                    state <= START;
                    shift_reg <= tx_data;
                end
            end

            START: begin
                tx_out <= 1'b0;
                if (clk_counter == CLKS_PER_BIT-1) begin
                    state <= DATA;
                    clk_counter <= 5'b0;
                end else
                    clk_counter <= clk_counter + 1'b1;
            end

            DATA: begin
                tx_out <= shift_reg[0];
                if (clk_counter == CLKS_PER_BIT-1) begin
                    clk_counter <= 5'b0;
                    if (bit_counter == 7) begin
                        state <= STOP;
                    end else begin
                        bit_counter <= bit_counter + 1'b1;
                        shift_reg <= {1'b0, shift_reg[7:1]};
                    end
                end else
                    clk_counter <= clk_counter + 1'b1;
            end

            STOP: begin
                tx_out <= 1'b1;
                if (clk_counter == CLKS_PER_BIT-1) begin
                    state <= IDLE;
                    tx_done <= 1'b1;
                    clk_counter <= 5'b0;
                end else
                    clk_counter <= clk_counter + 1'b1;
            end
        endcase
    end
end

endmodule

module testbench;
    reg clk;
    reg rst_n;
    reg tx_start;
    reg [7:0] tx_data;
    wire tx_out;
    wire tx_done;

    uart_tx #(.CLKS_PER_BIT(16)) dut (
        .clk(clk),
        .rst_n(rst_n),
        .tx_start(tx_start),
        .tx_data(tx_data),
        .tx_out(tx_out),
        .tx_done(tx_done)
    );

    initial begin
        $dumpfile(""uart_tx.vcd"");
        $dumpvars(0, testbench);

        clk = 1'b0;
        rst_n = 1'b0;
        tx_start = 1'b0;
        tx_data = 1'b0;

        #20 rst_n = 1'b1;
        #20 tx_data = 8'b10101010;
        #10 tx_start = 1'b1;
        #10 tx_start = 1'b0;

        #1000;

        tx_data = 8'b11110000;
        tx_start = 1'b1;
        #10 tx_start = 1'b0;

        #1000 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t rst_n=%b tx_start=%b tx_data=%b tx_out=%b tx_done=%b"",
                 $time, rst_n, tx_start, tx_data, tx_out, tx_done);
    end

endmodule",True,129,True,True,True,,0.0,,13.22760534286499,0.013446569442749023,"graph LR
    CLK[Clock] --> UART_TX(UART TX FSM)
    RST[Reset] --> UART_TX
    DATA[TX Data] --> BAUDGEN[[Baud Generator]]
    BAUDGEN --> UART_TX
    UART_TX --> TX_OUT[TX Output]

    subgraph FSM_STATES
        IDLE{IDLE State}
        START{START State}
        DATA_ST{DATA State}
        STOP{STOP State}
    end

    subgraph CONTROLS
        TX_EN[TX Enable] --> UART_TX
        BAUD_DIV[Baud Divider] --> BAUDGEN
        BIT_CNT[[Bit Counter]] --> UART_TX
    end

    subgraph TESTBENCH
        TB_CLK[TB Clock] --> TB_CTRL(Test Controller)
        TB_RST[TB Reset] --> TB_CTRL
        TB_DATA[Test Data] --> TB_CTRL
        TB_CTRL --> UART_TX
        TX_OUT --> TB_MON(Test Monitor)
    end","`timescale 1ns/1ps

// UART Transmitter with Baud Generator
module uart_tx (
    input wire clk,
    input wire rst_n,
    input wire tx_en,
    input wire [7:0] tx_data,
    input wire baud_tick,
    output reg tx_out
);

// State definitions
localparam IDLE = 2'b00;
localparam START = 2'b01;
localparam DATA = 2'b10;
localparam STOP = 2'b11;

reg [1:0] state, next_state;
reg [2:0] bit_cnt;
reg [7:0] tx_shift;

// State machine
always @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
        state <= IDLE;
        bit_cnt <= 0;
        tx_shift <= 8'h00;
        tx_out <= 1'b1;
    end
    else begin
        case (state)
            IDLE: begin
                if (tx_en) begin
                    state <= START;
                    tx_shift <= tx_data;
                    tx_out <= 1'b0;
                end
            end
            
            START: begin
                if (baud_tick) begin
                    state <= DATA;
                    bit_cnt <= 0;
                    tx_out <= tx_shift[0];
                    tx_shift <= {1'b0, tx_shift[7:1]};
                end
            end
            
            DATA: begin
                if (baud_tick) begin
                    if (bit_cnt == 3'b111) begin
                        state <= STOP;
                        tx_out <= 1'b1;
                    end
                    else begin
                        bit_cnt <= bit_cnt + 1'b1;
                        tx_out <= tx_shift[0];
                        tx_shift <= {1'b0, tx_shift[7:1]};
                    end
                end
            end
            
            STOP: begin
                if (baud_tick) begin
                    state <= IDLE;
                end
            end
        endcase
    end
end

endmodule

// Baud Generator
module baud_gen (
    input wire clk,
    input wire rst_n,
    input wire [15:0] baud_div,
    output reg baud_tick
);

reg [15:0] count;

always @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
        count <= 16'h0000;
        baud_tick <= 1'b0;
    end
    else begin
        if (count == baud_div) begin
            count <= 16'h0000;
            baud_tick <= 1'b1;
        end
        else begin
            count <= count + 1'b1;
            baud_tick <= 1'b0;
        end
    end
end

endmodule

// Testbench
module testbench;
    reg clk, rst_n, tx_en;
    reg [7:0] tx_data;
    reg [15:0] baud_div;
    wire tx_out, baud_tick;

    // Instantiate modules
    uart_tx uart (
        .clk(clk),
        .rst_n(rst_n),
        .tx_en(tx_en),
        .tx_data(tx_data),
        .baud_tick(baud_tick),
        .tx_out(tx_out)
    );

    baud_gen baudgen (
        .clk(clk),
        .rst_n(rst_n),
        .baud_div(baud_div),
        .baud_tick(baud_tick)
    );

    // Clock generation
    initial clk = 0;
    always #5 clk = ~clk;

    // Test stimulus
    initial begin
        $dumpfile(""uart_tx.vcd"");
        $dumpvars(0, testbench);

        rst_n = 0;
        tx_en = 0;
        tx_data = 8'h00;
        baud_div = 16'd10;

        #20 rst_n = 1;
        #20 tx_data = 8'h55;
        #10 tx_en = 1;
        #10 tx_en = 0;

        #1000 $finish;
    end

    // Monitor
    initial begin
        $monitor(""Time=%0t tx_out=%b"", $time, tx_out);
    end

endmodule",True,155,True,True,True,,0.0,,18.100938081741333,0.018789052963256836,"Design UART transmitter with states: IDLE, START, DATA, STOP. Protocol: START(0), 8 data bits LSB-first, STOP(1). Baud rate divider. Include testbench.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph LR
    CLK[Clock] --> UART_TX(UART TX FSM)
    RST[Reset] --> UART_TX
    DATA[TX Data] --> BAUDGEN[[Baud Generator]]
    BAUDGEN --> UART_TX
    UART_TX --> TX_OUT[TX Output]

    subgraph FSM_STATES
        IDLE{IDLE State}
        START{START State}
        DATA_ST{DATA State}
        STOP{STOP State}
    end

    subgraph CONTROLS
        TX_EN[TX Enable] --> UART_TX
        BAUD_DIV[Baud Divider] --> BAUDGEN
        BIT_CNT[[Bit Counter]] --> UART_TX
    end

    subgraph TESTBENCH
        TB_CLK[TB Clock] --> TB_CTRL(Test Controller)
        TB_RST[TB Reset] --> TB_CTRL
        TB_DATA[Test Data] --> TB_CTRL
        TB_CTRL --> UART_TX
        TX_OUT --> TB_MON(Test Monitor)
    end
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

// Baud Generator
module baud_gen (
    input wire clk,
    input wire rst_n,
    input wire [15:0] baud_div,
    output reg baud_tick
);

reg [15:0] count;

always @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
        count <= 16'd0;
        baud_tick <= 1'b0;
    end else begin
        if (count >= baud_div) begin
            count <= 16'd0;
            baud_tick <= 1'b1;
        end else begin
            count <= count + 1'b1;
            baud_tick <= 1'b0;
        end
    end
end

endmodule

// UART Transmitter
module uart_tx (
    input wire clk,
    input wire rst_n,
    input wire tx_en,
    input wire [7:0] tx_data,
    input wire baud_tick,
    output reg tx_out
);

parameter IDLE = 2'b00;
parameter START = 2'b01;
parameter DATA = 2'b10;
parameter STOP = 2'b11;

reg [1:0] state;
reg [2:0] bit_count;
reg [7:0] tx_shift;

always @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
        state <= IDLE;
        bit_count <= 3'd0;
        tx_shift <= 8'd0;
        tx_out <= 1'b1;
    end else if (baud_tick) begin
        case (state)
            IDLE: begin
                if (tx_en) begin
                    state <= START;
                    tx_shift <= tx_data;
                    tx_out <= 1'b0;
                end else begin
                    tx_out <= 1'b1;
                end
            end
            
            START: begin
                state <= DATA;
                bit_count <= 3'd0;
                tx_out <= tx_shift[0];
                tx_shift <= {1'b0, tx_shift[7:1]};
            end
            
            DATA: begin
                if (bit_count == 3'd7) begin
                    state <= STOP;
                    tx_out <= 1'b1;
                end else begin
                    bit_count <= bit_count + 1'b1;
                    tx_out <= tx_shift[0];
                    tx_shift <= {1'b0, tx_shift[7:1]};
                end
            end
            
            STOP: begin
                state <= IDLE;
                tx_out <= 1'b1;
            end
            
            default: state <= IDLE;
        endcase
    end
end

endmodule

// Testbench
module testbench;
    reg clk;
    reg rst_n;
    reg tx_en;
    reg [7:0] tx_data;
    reg [15:0] baud_div;
    wire tx_out;
    wire baud_tick;

    baud_gen bg (
        .clk(clk),
        .rst_n(rst_n),
        .baud_div(baud_div),
        .baud_tick(baud_tick)
    );

    uart_tx tx (
        .clk(clk),
        .rst_n(rst_n),
        .tx_en(tx_en),
        .tx_data(tx_data),
        .baud_tick(baud_tick),
        .tx_out(tx_out)
    );

    initial begin
        $dumpfile(""uart_tx.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst_n = 1'b0;
        tx_en = 1'b0;
        tx_data = 1'b0;
        baud_div = 16'd4; // Fast baud rate for simulation
        
        #20 rst_n = 1'b1;
        #20 tx_data = 8'h55;
        #10 tx_en = 1'b1;
        #10 tx_en = 1'b0;
        
        #500 tx_data = 8'hAA;
        #10 tx_en = 1'b1;
        #10 tx_en = 1'b0;
        
        #500 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t rst_n=%b tx_en=%b tx_data=%h tx_out=%b"",
                 $time, rst_n, tx_en, tx_data, tx_out);
    end
endmodule",True,151,True,True,True,,0.0,,14.859493255615234,0.01564502716064453,prompt_only,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,State Machine,complex,"Design UART transmitter with states: IDLE, START, DATA, STOP. Protocol: START(0), 8 data bits LSB-first, STOP(1). Baud rate divider. Include testbench.",gpt-4o,"`timescale 1ns/1ps

module uart_tx(
    input wire clk,
    input wire rst_n,
    input wire tx_start,
    input wire [7:0] data_in,
    output reg tx,
    output reg tx_busy
);

    reg [3:0] state, next_state;
    reg [3:0] bit_count;
    reg [7:0] shift_reg;
    reg [15:0] baud_count;

    localparam IDLE = 4'd0;
    localparam START = 4'd1;
    localparam DATA = 4'd2;
    localparam STOP = 4'd3;

    localparam BAUD_DIV = 16'd5208; // Assuming 50 MHz clock for 9600 baud

    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            state <= IDLE;
            tx <= 1'b1;
            tx_busy <= 1'b0;
            bit_count <= 4'd0;
            shift_reg <= 8'b0;
            baud_count <= 16'b0;
        end else begin
            state <= next_state;
            case (state)
                IDLE: begin
                    tx <= 1'b1;
                    tx_busy <= 1'b0;
                    bit_count <= 4'd0;
                    baud_count <= 16'b0;
                    if (tx_start) begin
                        shift_reg <= data_in;
                    end
                end
                START: begin
                    tx <= 1'b0;
                    tx_busy <= 1'b1;
                    baud_count <= baud_count + 1'b1;
                    if (baud_count == BAUD_DIV) begin
                        baud_count <= 16'b0;
                        bit_count <= 4'd0;
                    end
                end
                DATA: begin
                    baud_count <= baud_count + 1'b1;
                    if (baud_count == BAUD_DIV) begin
                        baud_count <= 16'b0;
                        bit_count <= bit_count + 1'b1;
                        tx <= shift_reg[0];
                        shift_reg <= shift_reg >> 1;
                    end
                end
                STOP: begin
                    tx <= 1'b1;
                    baud_count <= baud_count + 1'b1;
                    if (baud_count == BAUD_DIV) begin
                        baud_count <= 16'b0;
                    end
                end
            endcase
        end
    end

    always @(*) begin
        case (state)
            IDLE: begin
                if (tx_start) begin
                    next_state = START;
                end else begin
                    next_state = IDLE;
                end
            end
            START: begin
                if (baud_count == BAUD_DIV) begin
                    next_state = DATA;
                end else begin
                    next_state = START;
                end
            end
            DATA: begin
                if (bit_count == 4'd8 && baud_count == BAUD_DIV) begin
                    next_state = STOP;
                end else begin
                    next_state = DATA;
                end
            end
            STOP: begin
                if (baud_count == BAUD_DIV) begin
                    next_state = IDLE;
                end else begin
                    next_state = STOP;
                end
            end
            default: next_state = IDLE;
        endcase
    end

endmodule

module testbench;
    reg clk, rst_n, tx_start;
    reg [7:0] data_in;
    wire tx, tx_busy;
    
    uart_tx dut (
        .clk(clk),
        .rst_n(rst_n),
        .tx_start(tx_start),
        .data_in(data_in),
        .tx(tx),
        .tx_busy(tx_busy)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst_n = 1'b0;
        tx_start = 1'b0;
        data_in = 8'b0;
        
        #20 rst_n = 1'b1;
        #10 data_in = 8'hA5; // Example data
        #10 tx_start = 1'b1;
        #10 tx_start = 1'b0;
        #1000 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b tx_start=%b data_in=%h tx=%b tx_busy=%b"", 
                 $time, clk, rst_n, tx_start, data_in, tx, tx_busy);
    end
endmodule",True,145,True,True,True,True,0.7,True,14.324400663375854,13.221509218215942,"graph TD
    CLK[Clock] --> BAUD[Baud Rate Divider]
    RST[Reset] --> STATE(Idle State Machine)
    DATA_IN[8-bit Data Input] --> STATE
    BAUD -- Clock Enable --> STATE

    STATE -->|IDLE| IDLE_STATE{IDLE}
    STATE -->|START| START_STATE{START}
    STATE -->|DATA| DATA_STATE{DATA}
    STATE -->|STOP| STOP_STATE{STOP}

    IDLE_STATE -->|Wait for Start| START_STATE
    START_STATE -->|Transmit Start Bit| DATA_STATE
    DATA_STATE -->|Transmit 8 Data Bits LSB-first| STOP_STATE
    STOP_STATE -->|Transmit Stop Bit| IDLE_STATE

    STATE --> DATA_OUT[Serial Data Output]
    STATE --> TX_READY[Transmission Ready]
    BAUD --> BAUD_TICK[Baud Tick]

    TESTBENCH[[Testbench]]
    TESTBENCH --> CLK
    TESTBENCH --> RST
    TESTBENCH --> DATA_IN
    TESTBENCH -->|Monitor| DATA_OUT
    TESTBENCH -->|Monitor| TX_READY","`timescale 1ns/1ps

module uart_tx(
    input wire clk,
    input wire rst,
    input wire [7:0] data_in,
    input wire baud_tick,
    output reg data_out,
    output reg tx_ready
);

typedef enum reg [1:0] {IDLE = 2'b00, START = 2'b01, DATA = 2'b10, STOP = 2'b11} state_t;
state_t state, next_state;

reg [2:0] bit_count;
reg [7:0] shift_reg;

always @(posedge clk or posedge rst) begin
    if (rst) begin
        state <= IDLE;
        bit_count <= 3'b000;
        shift_reg <= 8'b00000000;
        data_out <= 1'b1;
        tx_ready <= 1'b1;
    end else if (baud_tick) begin
        state <= next_state;
        case (state)
            IDLE: begin
                if (!tx_ready) begin
                    shift_reg <= data_in;
                    data_out <= 1'b0; // Start bit
                    bit_count <= 3'b000;
                end
            end
            START: begin
                data_out <= 1'b0; // Start bit
            end
            DATA: begin
                data_out <= shift_reg[0];
                shift_reg <= shift_reg >> 1;
                bit_count <= bit_count + 1'b1;
            end
            STOP: begin
                data_out <= 1'b1; // Stop bit
                tx_ready <= 1'b1;
            end
        endcase
    end
end

always @(*) begin
    next_state = state;
    case (state)
        IDLE: if (!tx_ready) next_state = START;
        START: next_state = DATA;
        DATA: if (bit_count == 3'b111) next_state = STOP;
        STOP: next_state = IDLE;
        default: next_state = IDLE;
    endcase
end

endmodule

module testbench;
    reg clk, rst;
    reg [7:0] data_in;
    reg baud_tick;
    wire data_out;
    wire tx_ready;

    uart_tx dut (
        .clk(clk),
        .rst(rst),
        .data_in(data_in),
        .baud_tick(baud_tick),
        .data_out(data_out),
        .tx_ready(tx_ready)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 1'b0;
        rst = 1'b1;
        baud_tick = 1'b0;
        data_in = 8'b10101010;

        #20 rst = 1'b0;
        #10 baud_tick = 1'b1;
        #10 baud_tick = 1'b0;
        #1000 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t clk=%b rst=%b data_in=%b data_out=%b tx_ready=%b"", 
                 $time, clk, rst, data_in, data_out, tx_ready);
    end
endmodule",True,101,True,True,True,True,0.9,True,17.23202347755432,12.643113374710083,"Design UART transmitter with states: IDLE, START, DATA, STOP. Protocol: START(0), 8 data bits LSB-first, STOP(1). Baud rate divider. Include testbench.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph TD
    CLK[Clock] --> BAUD[Baud Rate Divider]
    RST[Reset] --> STATE(Idle State Machine)
    DATA_IN[8-bit Data Input] --> STATE
    BAUD -- Clock Enable --> STATE

    STATE -->|IDLE| IDLE_STATE{IDLE}
    STATE -->|START| START_STATE{START}
    STATE -->|DATA| DATA_STATE{DATA}
    STATE -->|STOP| STOP_STATE{STOP}

    IDLE_STATE -->|Wait for Start| START_STATE
    START_STATE -->|Transmit Start Bit| DATA_STATE
    DATA_STATE -->|Transmit 8 Data Bits LSB-first| STOP_STATE
    STOP_STATE -->|Transmit Stop Bit| IDLE_STATE

    STATE --> DATA_OUT[Serial Data Output]
    STATE --> TX_READY[Transmission Ready]
    BAUD --> BAUD_TICK[Baud Tick]

    TESTBENCH[[Testbench]]
    TESTBENCH --> CLK
    TESTBENCH --> RST
    TESTBENCH --> DATA_IN
    TESTBENCH -->|Monitor| DATA_OUT
    TESTBENCH -->|Monitor| TX_READY
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module uart_tx(
    input wire clk,
    input wire rst_n,
    input wire [7:0] data_in,
    output reg data_out,
    output reg tx_ready
);

    reg [3:0] state;
    reg [3:0] bit_index;
    reg [7:0] shift_reg;
    wire baud_tick;
    wire enable;

    localparam IDLE  = 4'b0000;
    localparam START = 4'b0001;
    localparam DATA  = 4'b0010;
    localparam STOP  = 4'b0011;

    assign enable = (state != IDLE);
    
    baud_rate_divider baud_div (
        .clk(clk),
        .rst_n(rst_n),
        .enable(enable),
        .baud_tick(baud_tick)
    );

    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            state <= IDLE;
            data_out <= 1'b1;
            tx_ready <= 1'b1;
            shift_reg <= 8'b0;
            bit_index <= 4'b0;
        end
        else if (baud_tick) begin
            case (state)
                IDLE: begin
                    tx_ready <= 1'b1;
                    data_out <= 1'b1;
                    if (!tx_ready) begin
                        state <= START;
                        shift_reg <= data_in;
                        tx_ready <= 1'b0;
                    end
                end
                START: begin
                    data_out <= 1'b0;
                    state <= DATA;
                    bit_index <= 4'b0;
                end
                DATA: begin
                    data_out <= shift_reg[bit_index];
                    bit_index <= bit_index + 1'b1;
                    if (bit_index == 4'b0111) state <= STOP;
                end
                STOP: begin
                    data_out <= 1'b1;
                    state <= IDLE;
                end
                default: state <= IDLE;
            endcase
        end
    end

endmodule

module baud_rate_divider(
    input wire clk,
    input wire rst_n,
    input wire enable,
    output reg baud_tick
);

    reg [15:0] counter;

    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            counter <= 16'b0;
            baud_tick <= 1'b0;
        end
        else if (enable) begin
            if (counter == 16'd434) begin
                baud_tick <= 1'b1;
                counter <= 16'b0;
            end
            else begin
                baud_tick <= 1'b0;
                counter <= counter + 1'b1;
            end
        end
    end

endmodule

module testbench;
    reg clk, rst_n;
    reg [7:0] data_in;
    wire data_out, tx_ready;
    
    uart_tx dut (
        .clk(clk),
        .rst_n(rst_n),
        .data_in(data_in),
        .data_out(data_out),
        .tx_ready(tx_ready)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst_n = 1'b0;
        data_in = 8'b00000000;
        
        #20 rst_n = 1'b1;
        #10 data_in = 8'b10101010;
        #100 data_in = 8'b11001100;
        #200 data_in = 8'b11110000;
        #300 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b data_in=%b data_out=%b tx_ready=%b"", 
                 $time, clk, rst_n, data_in, data_out, tx_ready);
    end
endmodule",True,133,True,True,True,True,0.9,True,11.702462196350098,12.569623231887817,prompt_only,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,CPU Component,complex,Create 8-register  8-bit register file with dual read ports and single write port. Include testbench with simultaneous operations.,claude,"`timescale 1ns/1ps

module reg_file(
    input wire clk,
    input wire rst_n,
    input wire write_en,
    input wire [2:0] write_addr,
    input wire [7:0] write_data,
    input wire [2:0] read_addr1,
    input wire [2:0] read_addr2,
    output wire [7:0] read_data1,
    output wire [7:0] read_data2
);

reg [7:0] registers [0:7];
integer i;

assign read_data1 = registers[read_addr1];
assign read_data2 = registers[read_addr2];

always @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
        for (i = 0; i < 8; i = i + 1)
            registers[i] <= 8'h00;
    end
    else if (write_en) begin
        registers[write_addr] <= write_data;
    end
end

endmodule

module testbench;
    reg clk;
    reg rst_n;
    reg write_en;
    reg [2:0] write_addr;
    reg [7:0] write_data;
    reg [2:0] read_addr1;
    reg [2:0] read_addr2;
    wire [7:0] read_data1;
    wire [7:0] read_data2;

    reg_file dut (
        .clk(clk),
        .rst_n(rst_n),
        .write_en(write_en),
        .write_addr(write_addr),
        .write_data(write_data),
        .read_addr1(read_addr1),
        .read_addr2(read_addr2),
        .read_data1(read_data1),
        .read_data2(read_data2)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 0;
        rst_n = 0;
        write_en = 0;
        write_addr = 0;
        write_data = 0;
        read_addr1 = 0;
        read_addr2 = 0;

        #10 rst_n = 1;

        // Write some data
        #10 write_en = 1;
        write_addr = 3'h0; write_data = 8'h11;
        #10 write_addr = 3'h1; write_data = 8'h22;
        #10 write_addr = 3'h2; write_data = 8'h33;
        #10 write_addr = 3'h3; write_data = 8'h44;

        // Read while writing
        #10 write_addr = 3'h4; write_data = 8'h55;
        read_addr1 = 3'h1; read_addr2 = 3'h2;

        #10 write_en = 0;
        read_addr1 = 3'h3; read_addr2 = 3'h4;

        #20 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t rd1=%h rd2=%h"", $time, read_data1, read_data2);
    end
endmodule",True,92,True,True,True,False,0.4,False,9.73471999168396,7.0171802043914795,"graph LR
    CLK[Clock] --> RF[[8x8 Register File]]
    RST[Reset] --> RF
    WD[Write Data 8-bit] --> RF
    WA[Write Address 3-bit] --> RF
    WE[Write Enable] --> RF
    RA1[Read Address 1] --> RF
    RA2[Read Address 2] --> RF
    RF --> RD1[Read Data 1 8-bit]
    RF --> RD2[Read Data 2 8-bit]
    subgraph TB[Testbench]
        WS([Write Stimulus]) --> WD
        WS --> WA
        WS --> WE
        RS([Read Stimulus]) --> RA1
        RS --> RA2
        RD1 --> RC([Read Checker])
        RD2 --> RC
    end
    CLK --> TB
    RST --> TB","`timescale 1ns/1ps

module register_file(
    input wire clk,
    input wire rst,
    input wire [7:0] write_data,
    input wire [2:0] write_addr,
    input wire write_en,
    input wire [2:0] read_addr1,
    input wire [2:0] read_addr2,
    output reg [7:0] read_data1,
    output reg [7:0] read_data2
);

reg [7:0] registers [0:7];
integer i;

always @(posedge clk or posedge rst) begin
    if (rst) begin
        for (i = 0; i < 8; i = i + 1) begin
            registers[i] <= 8'b0;
        end
    end
    else begin
        if (write_en)
            registers[write_addr] <= write_data;
    end
end

always @(*) begin
    read_data1 = registers[read_addr1];
    read_data2 = registers[read_addr2];
end

endmodule

module testbench;
    reg clk, rst;
    reg [7:0] write_data;
    reg [2:0] write_addr;
    reg write_en;
    reg [2:0] read_addr1, read_addr2;
    wire [7:0] read_data1, read_data2;

    register_file dut (
        .clk(clk),
        .rst(rst),
        .write_data(write_data),
        .write_addr(write_addr),
        .write_en(write_en),
        .read_addr1(read_addr1),
        .read_addr2(read_addr2),
        .read_data1(read_data1),
        .read_data2(read_data2)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 0;
        rst = 1;
        write_data = 0;
        write_addr = 0;
        write_en = 0;
        read_addr1 = 0;
        read_addr2 = 0;

        #10 rst = 0;

        // Write test
        #10 write_en = 1;
        write_addr = 3'd1;
        write_data = 8'hAA;
        
        #10 write_addr = 3'd2;
        write_data = 8'hBB;

        // Read test
        #10 write_en = 0;
        read_addr1 = 3'd1;
        read_addr2 = 3'd2;

        #50 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t rd1=%h rd2=%h"", $time, read_data1, read_data2);
    end
endmodule",True,92,True,True,True,False,0.4,False,12.300991296768188,7.465949296951294,"Create 8-register  8-bit register file with dual read ports and single write port. Include testbench with simultaneous operations.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph LR
    CLK[Clock] --> RF[[8x8 Register File]]
    RST[Reset] --> RF
    WD[Write Data 8-bit] --> RF
    WA[Write Address 3-bit] --> RF
    WE[Write Enable] --> RF
    RA1[Read Address 1] --> RF
    RA2[Read Address 2] --> RF
    RF --> RD1[Read Data 1 8-bit]
    RF --> RD2[Read Data 2 8-bit]
    subgraph TB[Testbench]
        WS([Write Stimulus]) --> WD
        WS --> WA
        WS --> WE
        RS([Read Stimulus]) --> RA1
        RS --> RA2
        RD1 --> RC([Read Checker])
        RD2 --> RC
    end
    CLK --> TB
    RST --> TB
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module register_file (
    input wire clk,
    input wire rst,
    input wire we,
    input wire [2:0] wa,
    input wire [7:0] wd,
    input wire [2:0] ra1,
    input wire [2:0] ra2,
    output wire [7:0] rd1,
    output wire [7:0] rd2
);

reg [7:0] registers [0:7];
integer i;

always @(posedge clk or posedge rst) begin
    if (rst) begin
        for (i = 0; i < 8; i = i + 1)
            registers[i] <= 8'h00;
    end
    else if (we) begin
        registers[wa] <= wd;
    end
end

assign rd1 = registers[ra1];
assign rd2 = registers[ra2];

endmodule

module testbench;
    reg clk, rst, we;
    reg [2:0] wa, ra1, ra2;
    reg [7:0] wd;
    wire [7:0] rd1, rd2;

    register_file dut (
        .clk(clk),
        .rst(rst),
        .we(we),
        .wa(wa),
        .wd(wd),
        .ra1(ra1),
        .ra2(ra2),
        .rd1(rd1),
        .rd2(rd2)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 0;
        rst = 1;
        we = 0;
        wa = 0;
        wd = 0;
        ra1 = 0;
        ra2 = 0;

        #10 rst = 0;

        // Write test pattern
        #10;
        we = 1;
        wa = 3'h0; wd = 8'h11;
        #10;
        wa = 3'h1; wd = 8'h22;
        #10;
        wa = 3'h2; wd = 8'h33;
        #10;
        we = 0;

        // Read test
        ra1 = 3'h0;
        ra2 = 3'h1;
        #10;
        ra1 = 3'h1;
        ra2 = 3'h2;
        #10;

        #20 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t rst=%b we=%b wa=%h wd=%h ra1=%h rd1=%h ra2=%h rd2=%h"",
                 $time, rst, we, wa, wd, ra1, rd1, ra2, rd2);
    end
endmodule",True,93,True,True,True,False,0.4,False,9.485244989395142,7.770794630050659,tie,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,CPU Component,complex,Create 8-register  8-bit register file with dual read ports and single write port. Include testbench with simultaneous operations.,gpt-4o,"`timescale 1ns/1ps

module register_file(
    input wire clk,
    input wire rst_n,
    input wire [2:0] read_addr1,
    input wire [2:0] read_addr2,
    input wire [2:0] write_addr,
    input wire [7:0] write_data,
    input wire write_enable,
    output wire [7:0] read_data1,
    output wire [7:0] read_data2
);
    
    reg [7:0] registers [0:7];
    integer i;

    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            for (i = 1'b0; i < 8; i = i + 1)
                registers[i] <= 8'b0;
        end else if (write_enable) begin
            registers[write_addr] <= write_data;
        end
    end

    assign read_data1 = registers[read_addr1];
    assign read_data2 = registers[read_addr2];

endmodule

module testbench;
    reg clk;
    reg rst_n;
    reg [2:0] read_addr1;
    reg [2:0] read_addr2;
    reg [2:0] write_addr;
    reg [7:0] write_data;
    reg write_enable;
    wire [7:0] read_data1;
    wire [7:0] read_data2;

    register_file dut (
        .clk(clk),
        .rst_n(rst_n),
        .read_addr1(read_addr1),
        .read_addr2(read_addr2),
        .write_addr(write_addr),
        .write_data(write_data),
        .write_enable(write_enable),
        .read_data1(read_data1),
        .read_data2(read_data2)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 1'b0;
        rst_n = 1'b0;
        write_enable = 1'b0;
        read_addr1 = 3'b000;
        read_addr2 = 3'b001;
        write_addr = 3'b000;
        write_data = 8'b0;

        #20 rst_n = 1'b1;
        #10 write_enable = 1'b1; write_addr = 3'b000; write_data = 8'hAA;
        #10 write_addr = 3'b001; write_data = 8'hBB;
        #10 write_enable = 1'b0;
        #10 read_addr1 = 3'b000; read_addr2 = 3'b001;
        #50 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b write_enable=%b write_addr=%b write_data=%h read_addr1=%b read_data1=%h read_addr2=%b read_data2=%h"", 
                 $time, clk, rst_n, write_enable, write_addr, write_data, read_addr1, read_data1, read_addr2, read_data2);
    end
endmodule",True,81,True,True,True,True,0.75,True,11.269590616226196,10.915257453918457,"graph TD
    CLK[Clock] --> [[Register File]]
    RST[Reset] --> [[Register File]]
    
    subgraph Register_File
        direction LR
        [[Register File]] --> RD1[Read Data 1]
        [[Register File]] --> RD2[Read Data 2]
        WR[Write Data] --> [[Register File]]
        RA1[Read Address 1] --> [[Register File]]
        RA2[Read Address 2] --> [[Register File]]
        WA[Write Address] --> [[Register File]]
        WE[Write Enable] --> [[Register File]]
    end
    
    subgraph Testbench
        direction LR
        TB_CLK[Clock] --> [[Register File]]
        TB_RST[Reset] --> [[Register File]]
        
        TB_WR[Write Data] --> WR
        TB_RA1[Read Address 1] --> RA1
        TB_RA2[Read Address 2] --> RA2
        TB_WA[Write Address] --> WA
        TB_WE[Write Enable] --> WE
        
        RD1 --> TB_RD1[Read Data 1 Output]
        RD2 --> TB_RD2[Read Data 2 Output]
    end","`timescale 1ns/1ps

module register_file (
    input wire clk,
    input wire rst,
    input wire [3:0] write_data,
    input wire [1:0] read_address1,
    input wire [1:0] read_address2,
    input wire [1:0] write_address,
    input wire write_enable,
    output reg [3:0] read_data1,
    output reg [3:0] read_data2
);
    reg [3:0] registers [3:0];

    always @(posedge clk or posedge rst) begin
        if (rst) begin
            registers[0] <= 4'b0000;
            registers[1] <= 4'b0000;
            registers[2] <= 4'b0000;
            registers[3] <= 4'b0000;
        end else if (write_enable) begin
            registers[write_address] <= write_data;
        end
    end

    always @(*) begin
        read_data1 = registers[read_address1];
        read_data2 = registers[read_address2];
    end
endmodule

module testbench;
    reg tb_clk;
    reg tb_rst;
    reg [3:0] tb_write_data;
    reg [1:0] tb_read_address1;
    reg [1:0] tb_read_address2;
    reg [1:0] tb_write_address;
    reg tb_write_enable;
    wire [3:0] tb_read_data1;
    wire [3:0] tb_read_data2;

    register_file dut (
        .clk(tb_clk),
        .rst(tb_rst),
        .write_data(tb_write_data),
        .read_address1(tb_read_address1),
        .read_address2(tb_read_address2),
        .write_address(tb_write_address),
        .write_enable(tb_write_enable),
        .read_data1(tb_read_data1),
        .read_data2(tb_read_data2)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        tb_clk = 1'b0;
        tb_rst = 1'b1;
        tb_write_data = 4'b0000;
        tb_read_address1 = 2'b00;
        tb_read_address2 = 2'b01;
        tb_write_address = 2'b00;
        tb_write_enable = 1'b0;

        #10 tb_rst = 1'b0;
        #10 tb_write_data = 4'b1010; tb_write_address = 2'b00; tb_write_enable = 1'b1;
        #10 tb_write_data = 4'b1100; tb_write_address = 2'b01; tb_write_enable = 1'b1;
        #10 tb_write_enable = 1'b0;
        #10 tb_read_address1 = 2'b00; tb_read_address2 = 2'b01;
        #20 $finish;
    end

    always #5 tb_clk = ~tb_clk;

    initial begin
        $monitor(""Time=%0t tb_clk=%b tb_rst=%b tb_write_enable=%b tb_write_data=%b tb_read_data1=%b tb_read_data2=%b"", 
                 $time, tb_clk, tb_rst, tb_write_enable, tb_write_data, tb_read_data1, tb_read_data2);
    end
endmodule",True,82,True,True,True,True,0.7,True,14.112343311309814,9.51051926612854,"Create 8-register  8-bit register file with dual read ports and single write port. Include testbench with simultaneous operations.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph TD
    CLK[Clock] --> [[Register File]]
    RST[Reset] --> [[Register File]]
    
    subgraph Register_File
        direction LR
        [[Register File]] --> RD1[Read Data 1]
        [[Register File]] --> RD2[Read Data 2]
        WR[Write Data] --> [[Register File]]
        RA1[Read Address 1] --> [[Register File]]
        RA2[Read Address 2] --> [[Register File]]
        WA[Write Address] --> [[Register File]]
        WE[Write Enable] --> [[Register File]]
    end
    
    subgraph Testbench
        direction LR
        TB_CLK[Clock] --> [[Register File]]
        TB_RST[Reset] --> [[Register File]]
        
        TB_WR[Write Data] --> WR
        TB_RA1[Read Address 1] --> RA1
        TB_RA2[Read Address 2] --> RA2
        TB_WA[Write Address] --> WA
        TB_WE[Write Enable] --> WE
        
        RD1 --> TB_RD1[Read Data 1 Output]
        RD2 --> TB_RD2[Read Data 2 Output]
    end
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module register_file (
    input wire clk,
    input wire rst_n,
    input wire [7:0] write_data,
    input wire [2:0] read_addr1,
    input wire [2:0] read_addr2,
    input wire [2:0] write_addr,
    input wire write_enable,
    output reg [7:0] read_data1,
    output reg [7:0] read_data2
);

    reg [7:0] registers [0:7];

    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            integer i;
            for (i = 1'b0; i < 8; i = i + 1) begin
                registers[i] <= 8'b0;
            end
        end else if (write_enable) begin
            registers[write_addr] <= write_data;
        end
    end

    always @(*) begin
        read_data1 = registers[read_addr1];
        read_data2 = registers[read_addr2];
    end

endmodule

module testbench;
    reg tb_clk;
    reg tb_rst_n;
    reg [7:0] tb_write_data;
    reg [2:0] tb_read_addr1;
    reg [2:0] tb_read_addr2;
    reg [2:0] tb_write_addr;
    reg tb_write_enable;
    wire [7:0] tb_read_data1;
    wire [7:0] tb_read_data2;

    register_file dut (
        .clk(tb_clk),
        .rst_n(tb_rst_n),
        .write_data(tb_write_data),
        .read_addr1(tb_read_addr1),
        .read_addr2(tb_read_addr2),
        .write_addr(tb_write_addr),
        .write_enable(tb_write_enable),
        .read_data1(tb_read_data1),
        .read_data2(tb_read_data2)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        tb_clk = 1'b0;
        tb_rst_n = 1'b0;
        tb_write_data = 8'b0;
        tb_read_addr1 = 3'b0;
        tb_read_addr2 = 3'b0;
        tb_write_addr = 3'b0;
        tb_write_enable = 1'b0;

        #20 tb_rst_n = 1'b1;
        #10 tb_write_data = 8'b10101010; tb_write_addr = 3'b001; tb_write_enable = 1'b1;
        #10 tb_write_enable = 1'b0;
        #10 tb_read_addr1 = 3'b001; tb_read_addr2 = 3'b000;
        #20 tb_write_data = 8'b11001100; tb_write_addr = 3'b010; tb_write_enable = 1'b1;
        #10 tb_write_enable = 1'b0; tb_read_addr2 = 3'b010;
        #50 $finish;
    end

    always #5 tb_clk = ~tb_clk;

    initial begin
        $monitor(""Time=%0t tb_clk=%b tb_rst_n=%b tb_write_enable=%b tb_write_addr=%b tb_write_data=%b tb_read_addr1=%b tb_read_addr2=%b tb_read_data1=%b tb_read_data2=%b"",
                 $time, tb_clk, tb_rst_n, tb_write_enable, tb_write_addr, tb_write_data, tb_read_addr1, tb_read_addr2, tb_read_data1, tb_read_data2);
    end
endmodule",True,85,True,False,False,,0.0,,11.907013416290283,0.012464284896850586,prompt_only,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,Advanced Sequential,complex,"Design 8-bit resolution PWM generator with configurable duty cycle. Include testbench with duty cycles: 0%, 25%, 50%, 75%, 100%.",claude,"`timescale 1ns/1ps

module pwm (
    input wire clk,
    input wire rst_n,
    input wire [7:0] duty_cycle,
    output reg pwm_out
);

reg [7:0] counter;

always @(posedge clk or negedge rst_n) begin
    if (!rst_n)
        counter <= 8'h00;
    else
        counter <= counter + 1'b1;
end

always @(posedge clk or negedge rst_n) begin
    if (!rst_n)
        pwm_out <= 1'b0;
    else
        pwm_out <= (counter < duty_cycle);
end

endmodule

module testbench;
    reg clk;
    reg rst_n;
    reg [7:0] duty_cycle;
    wire pwm_out;

    pwm dut (
        .clk(clk),
        .rst_n(rst_n),
        .duty_cycle(duty_cycle),
        .pwm_out(pwm_out)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 0;
        rst_n = 0;
        duty_cycle = 8'h00;

        #20 rst_n = 1;

        // Test 0% duty cycle
        #100 duty_cycle = 8'h00;

        // Test 25% duty cycle
        #1000 duty_cycle = 8'h40;

        // Test 50% duty cycle
        #1000 duty_cycle = 8'h80;

        // Test 75% duty cycle
        #1000 duty_cycle = 8'hC0;

        // Test 100% duty cycle
        #1000 duty_cycle = 8'hFF;

        #1000 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t rst_n=%b duty_cycle=%h pwm_out=%b"",
                 $time, rst_n, duty_cycle, pwm_out);
    end
endmodule",True,75,True,True,True,False,0.4,False,6.430186748504639,6.761643409729004,"graph LR
    CLK[Clock Input] --> COUNTER((8-bit Counter))
    RST[Reset] --> COUNTER
    DC[[Duty Cycle Register]] --> COMP
    COUNTER --> COMP((Comparator))
    COMP --> PWM[PWM Output]
    
    CFG[Config Input] --> DC
    TB{TestBench MUX} --> DC
    TB_SEL[Test Select] --> TB
    
    D0([0% DC]) --> TB
    D25([25% DC]) --> TB
    D50([50% DC]) --> TB
    D75([75% DC]) --> TB
    D100([100% DC]) --> TB
    
    CLK --> COMP
    RST --> COMP","`timescale 1ns/1ps

module pwm (
    input wire clk,
    input wire rst,
    input wire [2:0] tb_sel,
    input wire [7:0] cfg_duty,
    output wire pwm_out
);

reg [7:0] counter;
reg [7:0] duty_reg;
reg pwm_reg;

// Counter
always @(posedge clk or posedge rst) begin
    if (rst)
        counter <= 8'd0;
    else
        counter <= counter + 1'b1;
end

// Duty cycle mux and register
always @(posedge clk or posedge rst) begin
    if (rst)
        duty_reg <= 8'd0;
    else
        case (tb_sel)
            3'd0: duty_reg <= 8'd0;    // 0%
            3'd1: duty_reg <= 8'd64;   // 25%
            3'd2: duty_reg <= 8'd128;  // 50%
            3'd3: duty_reg <= 8'd192;  // 75%
            3'd4: duty_reg <= 8'd255;  // 100%
            default: duty_reg <= cfg_duty;
        endcase
end

// PWM Comparator
always @(posedge clk or posedge rst) begin
    if (rst)
        pwm_reg <= 1'b0;
    else
        pwm_reg <= (counter < duty_reg);
end

assign pwm_out = pwm_reg;

endmodule

module testbench;
    reg clk;
    reg rst;
    reg [2:0] tb_sel;
    reg [7:0] cfg_duty;
    wire pwm_out;

    pwm dut (
        .clk(clk),
        .rst(rst),
        .tb_sel(tb_sel),
        .cfg_duty(cfg_duty),
        .pwm_out(pwm_out)
    );

    initial begin
        $dumpfile(""pwm.vcd"");
        $dumpvars(0, testbench);

        clk = 0;
        rst = 1;
        tb_sel = 0;
        cfg_duty = 8'd128;

        #20 rst = 0;

        // Test each duty cycle
        #256 tb_sel = 0;  // 0%
        #256 tb_sel = 1;  // 25%
        #256 tb_sel = 2;  // 50%
        #256 tb_sel = 3;  // 75%
        #256 tb_sel = 4;  // 100%
        #256 tb_sel = 5;  // Config value

        #256 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t rst=%b tb_sel=%d duty_cycle=%d pwm=%b"",
                 $time, rst, tb_sel, cfg_duty, pwm_out);
    end
endmodule",True,93,True,True,True,,0.0,,12.87209963798523,0.014668941497802734,"Design 8-bit resolution PWM generator with configurable duty cycle. Include testbench with duty cycles: 0%, 25%, 50%, 75%, 100%.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph LR
    CLK[Clock Input] --> COUNTER((8-bit Counter))
    RST[Reset] --> COUNTER
    DC[[Duty Cycle Register]] --> COMP
    COUNTER --> COMP((Comparator))
    COMP --> PWM[PWM Output]
    
    CFG[Config Input] --> DC
    TB{TestBench MUX} --> DC
    TB_SEL[Test Select] --> TB
    
    D0([0% DC]) --> TB
    D25([25% DC]) --> TB
    D50([50% DC]) --> TB
    D75([75% DC]) --> TB
    D100([100% DC]) --> TB
    
    CLK --> COMP
    RST --> COMP
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module pwm_generator(
    input wire clk,
    input wire rst,
    input wire [7:0] cfg,
    output wire pwm_out
);

    reg [7:0] counter;
    reg [7:0] duty_cycle;
    
    always @(posedge clk or posedge rst) begin
        if (rst)
            counter <= 8'h00;
        else
            counter <= counter + 1'b1;
    end
    
    always @(posedge clk or posedge rst) begin
        if (rst)
            duty_cycle <= 8'h00;
        else
            duty_cycle <= cfg;
    end
    
    assign pwm_out = (counter < duty_cycle);

endmodule

module testbench;
    reg clk, rst;
    reg [7:0] cfg;
    reg [2:0] tb_sel;
    wire pwm_out;
    
    pwm_generator dut(
        .clk(clk),
        .rst(rst),
        .cfg(cfg),
        .pwm_out(pwm_out)
    );
    
    always @(*) begin
        case(tb_sel)
            3'd0: cfg = 8'd0;    // 0%
            3'd1: cfg = 8'd64;   // 25%
            3'd2: cfg = 8'd128;  // 50%
            3'd3: cfg = 8'd192;  // 75%
            3'd4: cfg = 8'd255;  // 100%
            default: cfg = 8'd0;
        endcase
    end
    
    initial begin
        $dumpfile(""pwm.vcd"");
        $dumpvars(0, testbench);
        
        clk = 0;
        rst = 1;
        tb_sel = 0;
        
        #20 rst = 0;
        
        #256 tb_sel = 1;
        #256 tb_sel = 2;
        #256 tb_sel = 3;
        #256 tb_sel = 4;
        
        #256 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t rst=%b tb_sel=%d duty_cycle=%d pwm=%b"",
                 $time, rst, tb_sel, cfg, pwm_out);
    end
endmodule",True,79,True,True,True,,0.0,,7.852477312088013,0.014863729476928711,prompt_only,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,Advanced Sequential,complex,"Design 8-bit resolution PWM generator with configurable duty cycle. Include testbench with duty cycles: 0%, 25%, 50%, 75%, 100%.",gpt-4o,"`timescale 1ns/1ps

module pwm_generator(
    input wire clk,
    input wire rst_n,
    input wire [7:0] duty_cycle,
    output reg pwm_out
);
    reg [7:0] counter;

    always @(posedge clk or negedge rst_n) begin
        if (!rst_n)
            counter <= 8'b00000000;
        else
            counter <= counter + 1'b1;
    end

    always @(posedge clk or negedge rst_n) begin
        if (!rst_n)
            pwm_out <= 1'b0;
        else if (counter < duty_cycle)
            pwm_out <= 1'b1;
        else
            pwm_out <= 1'b0;
    end
endmodule

module testbench;
    reg clk, rst_n;
    reg [7:0] duty_cycle;
    wire pwm_out;
    
    pwm_generator dut (
        .clk(clk),
        .rst_n(rst_n),
        .duty_cycle(duty_cycle),
        .pwm_out(pwm_out)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst_n = 1'b0;
        duty_cycle = 8'd0;
        
        #20 rst_n = 1'b1;
        #10 duty_cycle = 8'd0;   // 0%
        #100 duty_cycle = 8'd64; // 25%
        #100 duty_cycle = 8'd128; // 50%
        #100 duty_cycle = 8'd192; // 75%
        #100 duty_cycle = 8'd255; // 100%
        #50 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b duty_cycle=%d pwm_out=%b"", 
                 $time, clk, rst_n, duty_cycle, pwm_out);
    end
endmodule",True,63,True,True,True,False,0.3,False,4.828725337982178,9.98841404914856,"graph LR
    CLK[Clock] --> CNT(Counter)
    RST[Reset] --> CNT
    CNT --> CMP(Comparator)
    Duty_Cycle[Duty Cycle Input] --> CMP
    CMP --> PWM_OUT[PWM Output]
    
    subgraph Testbench
        0PCT[0% Duty Cycle] --> Duty_Cycle
        25PCT[25% Duty Cycle] --> Duty_Cycle
        50PCT[50% Duty Cycle] --> Duty_Cycle
        75PCT[75% Duty Cycle] --> Duty_Cycle
        100PCT[100% Duty Cycle] --> Duty_Cycle
    end","`timescale 1ns/1ps

module counter(
    input wire clk,
    input wire rst,
    output reg [7:0] count
);

always @(posedge clk or posedge rst) begin
    if (rst)
        count <= 8'b00000000;
    else
        count <= count + 1'b1;
end

endmodule

module comparator(
    input wire [7:0] count,
    input wire [7:0] duty_cycle,
    output wire pwm_out
);

assign pwm_out = (count < duty_cycle) ? 1'b1 : 1'b0;

endmodule

module pwm(
    input wire clk,
    input wire rst,
    input wire [7:0] duty_cycle,
    output wire pwm_out
);

wire [7:0] count;

counter u_counter (
    .clk(clk),
    .rst(rst),
    .count(count)
);

comparator u_comparator (
    .count(count),
    .duty_cycle(duty_cycle),
    .pwm_out(pwm_out)
);

endmodule

module testbench;
    reg clk, rst;
    reg [7:0] duty_cycle;
    wire pwm_out;

    pwm dut (
        .clk(clk),
        .rst(rst),
        .duty_cycle(duty_cycle),
        .pwm_out(pwm_out)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 1'b0;
        rst = 1'b1;
        duty_cycle = 8'd0;
        #10 rst = 1'b0;

        #20 duty_cycle = 8'd0;   // 0% Duty Cycle
        #100 duty_cycle = 8'd64; // 25% Duty Cycle
        #100 duty_cycle = 8'd128; // 50% Duty Cycle
        #100 duty_cycle = 8'd192; // 75% Duty Cycle
        #100 duty_cycle = 8'd255; // 100% Duty Cycle
        #100 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t clk=%b rst=%b duty_cycle=%d pwm_out=%b"", 
                 $time, clk, rst, duty_cycle, pwm_out);
    end
endmodule",True,86,True,True,True,False,0.3,False,21.984643697738647,12.399526834487915,"Design 8-bit resolution PWM generator with configurable duty cycle. Include testbench with duty cycles: 0%, 25%, 50%, 75%, 100%.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph LR
    CLK[Clock] --> CNT(Counter)
    RST[Reset] --> CNT
    CNT --> CMP(Comparator)
    Duty_Cycle[Duty Cycle Input] --> CMP
    CMP --> PWM_OUT[PWM Output]
    
    subgraph Testbench
        0PCT[0% Duty Cycle] --> Duty_Cycle
        25PCT[25% Duty Cycle] --> Duty_Cycle
        50PCT[50% Duty Cycle] --> Duty_Cycle
        75PCT[75% Duty Cycle] --> Duty_Cycle
        100PCT[100% Duty Cycle] --> Duty_Cycle
    end
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module pwm_generator(
    input wire clk,
    input wire rst_n,
    input wire [7:0] duty_cycle,
    output wire pwm_out
);

    reg [7:0] counter;
    reg pwm_out_reg;

    always @(posedge clk or negedge rst_n) begin
        if (!rst_n)
            counter <= 8'b0;
        else
            counter <= counter + 1'b1;
    end

    always @(*) begin
        if (counter < duty_cycle)
            pwm_out_reg = 1'b1;
        else
            pwm_out_reg = 1'b0;
    end

    assign pwm_out = pwm_out_reg;

endmodule

module testbench;
    reg clk, rst_n;
    reg [7:0] duty_cycle;
    wire pwm_out;

    pwm_generator dut (
        .clk(clk),
        .rst_n(rst_n),
        .duty_cycle(duty_cycle),
        .pwm_out(pwm_out)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 1'b0;
        rst_n = 1'b0;
        duty_cycle = 8'd0;

        #20 rst_n = 1'b1;
        #10 duty_cycle = 8'd0;  // 0% Duty Cycle
        #100 duty_cycle = 8'd64; // 25% Duty Cycle
        #100 duty_cycle = 8'd128; // 50% Duty Cycle
        #100 duty_cycle = 8'd192; // 75% Duty Cycle
        #100 duty_cycle = 8'd255; // 100% Duty Cycle
        #100 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b duty_cycle=%d pwm_out=%b"", 
                 $time, clk, rst_n, duty_cycle, pwm_out);
    end
endmodule",True,66,True,True,True,False,0.4,False,6.369652271270752,11.042850494384766,tie,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,Protocol,complex,"Design SPI master supporting mode 0 (CPOL=0, CPHA=0). Include SCLK generation, MOSI/MISO handling. Include testbench.",claude,"`timescale 1ns/1ps

module spi_master (
    input wire clk,
    input wire rst_n,
    input wire start,
    input wire [7:0] data_in,
    input wire miso,
    output reg sclk,
    output reg mosi,
    output reg busy,
    output reg [7:0] data_out
);

reg [3:0] bit_count;
reg [7:0] shift_reg_tx;
reg [7:0] shift_reg_rx;
reg sclk_en;

// SCLK generation
always @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
        sclk <= 1'b0;
        sclk_en <= 1'b0;
    end else if (busy) begin
        sclk <= ~sclk;
    end else begin
        sclk <= 1'b0;
        sclk_en <= 1'b0;
    end
end

// Bit counter and control
always @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
        bit_count <= 4'd0;
        busy <= 1'b0;
        shift_reg_tx <= 8'd0;
        shift_reg_rx <= 8'd0;
        mosi <= 1'b0;
        data_out <= 8'd0;
    end else begin
        if (start && !busy) begin
            busy <= 1'b1;
            bit_count <= 4'd0;
            shift_reg_tx <= data_in;
            mosi <= data_in[7];
        end else if (busy && sclk && bit_count < 4'd8) begin
            shift_reg_tx <= {shift_reg_tx[6:0], 1'b0};
            shift_reg_rx <= {shift_reg_rx[6:0], miso};
            mosi <= shift_reg_tx[6];
            bit_count <= bit_count + 1'b1;
            if (bit_count == 4'd7) begin
                busy <= 1'b0;
                data_out <= {shift_reg_rx[6:0], miso};
            end
        end
    end
end

endmodule

module testbench;
    reg clk;
    reg rst_n;
    reg start;
    reg [7:0] data_in;
    reg miso;
    wire sclk;
    wire mosi;
    wire busy;
    wire [7:0] data_out;

    spi_master dut (
        .clk(clk),
        .rst_n(rst_n),
        .start(start),
        .data_in(data_in),
        .miso(miso),
        .sclk(sclk),
        .mosi(mosi),
        .busy(busy),
        .data_out(data_out)
    );

    initial begin
        $dumpfile(""spi_master.vcd"");
        $dumpvars(0, testbench);

        clk = 1'b0;
        rst_n = 1'b0;
        start = 1'b0;
        data_in = 1'b0;
        miso = 1'b0;

        #10 rst_n = 1'b1;
        #10 data_in = 8'hA5;
        start = 1'b1;
        #10 start = 1'b0;
        
        // Simulate MISO input
        repeat(8) begin
            #10 miso = ~miso;
        end

        #100 data_in = 8'h5A;
        start = 1'b1;
        #10 start = 1'b0;

        repeat(8) begin
            #10 miso = ~miso;
        end

        #100 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t rst_n=%b start=%b data_in=%h miso=%b sclk=%b mosi=%b busy=%b data_out=%h"",
                 $time, rst_n, start, data_in, miso, sclk, mosi, busy, data_out);
    end
endmodule",True,123,True,True,True,,0.0,,12.609830856323242,0.014943361282348633,"graph TD
    CLK[Clock] --> SCLK_GEN(SCLK Generator)
    RST[Reset] --> SCLK_GEN
    RST --> CTRL(SPI Controller)
    CLK --> CTRL
    
    START[Start Transaction] --> CTRL
    DATA_IN[TX Data] --> TX_REG[[TX Register]]
    TX_REG --> MOSI_CTRL(MOSI Control)
    CTRL --> MOSI_CTRL
    MOSI_CTRL --> MOSI[MOSI Pin]
    
    MISO[MISO Pin] --> MISO_CTRL(MISO Control)
    MISO_CTRL --> RX_REG[[RX Register]]
    CTRL --> MISO_CTRL
    RX_REG --> DATA_OUT[RX Data]
    
    SCLK_GEN --> SCLK[SCLK Pin]
    CTRL --> CS[CS Pin]
    
    TB_CLK[TB Clock] -.-> CLK
    TB_RST[TB Reset] -.-> RST
    TB_DATA[TB Test Data] -.-> DATA_IN
    DATA_OUT -.-> TB_CHECK{TB Checker}
    
    CTRL --> BUSY[Busy Flag]
    CTRL --> DONE[Done Flag]","`timescale 1ns/1ps

module spi_controller (
    input wire clk,
    input wire rst,
    input wire start,
    input wire [7:0] data_in,
    input wire miso,
    output wire mosi,
    output wire sclk,
    output wire cs_n,
    output wire busy,
    output wire done,
    output wire [7:0] data_out
);

reg [7:0] tx_reg;
reg [7:0] rx_reg;
reg [2:0] bit_count;
reg sclk_en;
reg mosi_reg;
reg cs_n_reg;
reg busy_reg;
reg done_reg;

// SCLK Generator
reg sclk_reg;
always @(posedge clk or posedge rst) begin
    if (rst)
        sclk_reg <= 1'b0;
    else if (sclk_en)
        sclk_reg <= ~sclk_reg;
end

// Main Control Logic
always @(posedge clk or posedge rst) begin
    if (rst) begin
        tx_reg <= 8'h00;
        rx_reg <= 8'h00;
        bit_count <= 3'b000;
        sclk_en <= 1'b0;
        mosi_reg <= 1'b0;
        cs_n_reg <= 1'b1;
        busy_reg <= 1'b0;
        done_reg <= 1'b0;
    end
    else begin
        if (start && !busy_reg) begin
            tx_reg <= data_in;
            bit_count <= 3'b000;
            sclk_en <= 1'b1;
            cs_n_reg <= 1'b0;
            busy_reg <= 1'b1;
            done_reg <= 1'b0;
        end
        else if (busy_reg) begin
            if (bit_count == 3'b111 && sclk_reg) begin
                sclk_en <= 1'b0;
                cs_n_reg <= 1'b1;
                busy_reg <= 1'b0;
                done_reg <= 1'b1;
            end
            else if (sclk_reg) begin
                bit_count <= bit_count + 1'b1;
            end
        end
    end
end

// MOSI Control
always @(posedge clk or posedge rst) begin
    if (rst)
        mosi_reg <= 1'b0;
    else if (busy_reg)
        mosi_reg <= tx_reg[7-bit_count];
end

// MISO Sampling
always @(posedge clk or posedge rst) begin
    if (rst)
        rx_reg <= 8'h00;
    else if (busy_reg && !sclk_reg)
        rx_reg[7-bit_count] <= miso;
end

assign sclk = sclk_reg;
assign mosi = mosi_reg;
assign cs_n = cs_n_reg;
assign busy = busy_reg;
assign done = done_reg;
assign data_out = rx_reg;

endmodule

module testbench;
    reg clk, rst, start;
    reg [7:0] data_in;
    reg miso;
    wire mosi, sclk, cs_n, busy, done;
    wire [7:0] data_out;

    spi_controller dut (
        .clk(clk),
        .rst(rst),
        .start(start),
        .data_in(data_in),
        .miso(miso),
        .mosi(mosi),
        .sclk(sclk),
        .cs_n(cs_n),
        .busy(busy),
        .done(done),
        .data_out(data_out)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 0;
        rst = 1;
        start = 0;
        data_in = 0;
        miso = 0;

        #20 rst = 0;
        #10 data_in = 8'hA5;
        #10 start = 1;
        #10 start = 0;
        miso = 1;

        wait(done);
        #100 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t rst=%b start=%b data_in=%h miso=%b mosi=%b sclk=%b cs_n=%b busy=%b done=%b data_out=%h"",
                 $time, rst, start, data_in, miso, mosi, sclk, cs_n, busy, done, data_out);
    end
endmodule",True,142,True,True,True,False,0.4,False,20.247364044189453,7.455538272857666,"Design SPI master supporting mode 0 (CPOL=0, CPHA=0). Include SCLK generation, MOSI/MISO handling. Include testbench.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph TD
    CLK[Clock] --> SCLK_GEN(SCLK Generator)
    RST[Reset] --> SCLK_GEN
    RST --> CTRL(SPI Controller)
    CLK --> CTRL
    
    START[Start Transaction] --> CTRL
    DATA_IN[TX Data] --> TX_REG[[TX Register]]
    TX_REG --> MOSI_CTRL(MOSI Control)
    CTRL --> MOSI_CTRL
    MOSI_CTRL --> MOSI[MOSI Pin]
    
    MISO[MISO Pin] --> MISO_CTRL(MISO Control)
    MISO_CTRL --> RX_REG[[RX Register]]
    CTRL --> MISO_CTRL
    RX_REG --> DATA_OUT[RX Data]
    
    SCLK_GEN --> SCLK[SCLK Pin]
    CTRL --> CS[CS Pin]
    
    TB_CLK[TB Clock] -.-> CLK
    TB_RST[TB Reset] -.-> RST
    TB_DATA[TB Test Data] -.-> DATA_IN
    DATA_OUT -.-> TB_CHECK{TB Checker}
    
    CTRL --> BUSY[Busy Flag]
    CTRL --> DONE[Done Flag]
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module spi_master (
    input wire clk,
    input wire rst,
    input wire start,
    input wire [7:0] data_in,
    input wire miso,
    output wire mosi,
    output wire sclk,
    output wire cs,
    output wire busy,
    output wire done,
    output wire [7:0] data_out
);

reg [7:0] tx_reg;
reg [7:0] rx_reg;
reg [3:0] bit_count;
reg [2:0] state;
reg sclk_en;
reg mosi_reg;
reg cs_reg;
reg busy_reg;
reg done_reg;

localparam IDLE = 3'b000;
localparam SETUP = 3'b001;
localparam TRANSMIT = 3'b010;
localparam FINISH = 3'b011;

reg [3:0] sclk_div;
reg sclk_reg;

always @(posedge clk or posedge rst) begin
    if (rst) begin
        sclk_div <= 4'b0000;
        sclk_reg <= 1'b0;
    end
    else if (sclk_en) begin
        sclk_div <= sclk_div + 1'b1;
        if (sclk_div == 4'b1111)
            sclk_reg <= ~sclk_reg;
    end
    else begin
        sclk_reg <= 1'b0;
        sclk_div <= 4'b0000;
    end
end

always @(posedge clk or posedge rst) begin
    if (rst) begin
        state <= IDLE;
        bit_count <= 4'b0000;
        tx_reg <= 8'h00;
        rx_reg <= 8'h00;
        mosi_reg <= 1'b0;
        cs_reg <= 1'b1;
        busy_reg <= 1'b0;
        done_reg <= 1'b0;
        sclk_en <= 1'b0;
    end
    else begin
        case (state)
            IDLE: begin
                if (start) begin
                    state <= SETUP;
                    tx_reg <= data_in;
                    bit_count <= 4'b0000;
                    busy_reg <= 1'b1;
                    done_reg <= 1'b0;
                    cs_reg <= 1'b0;
                    sclk_en <= 1'b1;
                end
            end
            
            SETUP: begin
                state <= TRANSMIT;
                mosi_reg <= tx_reg[7];
            end
            
            TRANSMIT: begin
                if (!sclk_reg && sclk_div == 4'b1111) begin
                    if (bit_count == 4'b0111) begin
                        state <= FINISH;
                    end
                    else begin
                        bit_count <= bit_count + 1'b1;
                        tx_reg <= {tx_reg[6:0], 1'b0};
                        mosi_reg <= tx_reg[6];
                    end
                end
                else if (sclk_reg && sclk_div == 4'b1111) begin
                    rx_reg <= {rx_reg[6:0], miso};
                end
            end
            
            FINISH: begin
                state <= IDLE;
                cs_reg <= 1'b1;
                busy_reg <= 1'b0;
                done_reg <= 1'b1;
                sclk_en <= 1'b0;
            end
            
            default: state <= IDLE;
        endcase
    end
end

assign sclk = sclk_reg;
assign mosi = mosi_reg;
assign cs = cs_reg;
assign busy = busy_reg;
assign done = done_reg;
assign data_out = rx_reg;

endmodule

module spi_master_tb;
    reg clk;
    reg rst;
    reg start;
    reg [7:0] data_in;
    reg miso;
    wire mosi;
    wire sclk;
    wire cs;
    wire busy;
    wire done;
    wire [7:0] data_out;

    spi_master dut (
        .clk(clk),
        .rst(rst),
        .start(start),
        .data_in(data_in),
        .miso(miso),
        .mosi(mosi),
        .sclk(sclk),
        .cs(cs),
        .busy(busy),
        .done(done),
        .data_out(data_out)
    );

    initial begin
        $dumpfile(""spi_master.vcd"");
        $dumpvars(0, spi_master_tb);
        
        clk = 0;
        rst = 1;
        start = 0;
        data_in = 8'h00;
        miso = 0;
        
        #20 rst = 0;
        
        #20 data_in = 8'hA5;
        #10 start = 1;
        #10 start = 0;
        
        // Simulate MISO response
        repeat(8) begin
            #32 miso = ~miso;
        end
        
        #100;
        
        // Second transaction
        data_in = 8'h5A;
        #10 start = 1;
        #10 start = 0;
        
        repeat(8) begin
            #32 miso = ~miso;
        end
        
        #100 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t rst=%b start=%b data_in=%h miso=%b mosi=%b sclk=%b cs=%b busy=%b done=%b data_out=%h"",
                 $time, rst, start, data_in, miso, mosi, sclk, cs, busy, done, data_out);
    end
endmodule",True,188,False,True,True,,0.0,,18.25476360321045,0.016147375106811523,mermaid_only,mermaid_only > prompt_only > combined,prompt_only > mermaid_only > combined
combined,Protocol,complex,"Design SPI master supporting mode 0 (CPOL=0, CPHA=0). Include SCLK generation, MOSI/MISO handling. Include testbench.",gpt-4o,"`timescale 1ns/1ps

module spi_master(
    input wire clk,
    input wire rst_n,
    input wire mosi,
    output wire miso,
    output wire sclk,
    input wire [7:0] data_in,
    output reg [7:0] data_out,
    input wire start,
    output reg done
);

reg [2:0] bit_count;
reg [7:0] shift_reg;
reg sclk_reg;
reg miso_reg;

assign sclk = sclk_reg;
assign miso = miso_reg;

always @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
        bit_count <= 3'b000;
        shift_reg <= 8'b00000000;
        sclk_reg <= 1'b0;
        miso_reg <= 1'b0;
        done <= 1'b0;
    end else if (start) begin
        if (bit_count == 3'b000) begin
            shift_reg <= data_in;
            done <= 1'b0;
        end
        sclk_reg <= ~sclk_reg;
        
        if (sclk_reg) begin
            miso_reg <= shift_reg[7];
            shift_reg <= {shift_reg[6:0], mosi};
            bit_count <= bit_count + 1'b1;
        end
        
        if (bit_count == 3'b111 && sclk_reg) begin
            data_out <= shift_reg;
            done <= 1'b1;
            bit_count <= 3'b000;
        end
    end
end

endmodule

module testbench;
    reg clk, rst_n, start;
    reg mosi;
    reg [7:0] data_in;
    wire miso, sclk;
    wire [7:0] data_out;
    wire done;
    
    spi_master dut (
        .clk(clk),
        .rst_n(rst_n),
        .mosi(mosi),
        .miso(miso),
        .sclk(sclk),
        .data_in(data_in),
        .data_out(data_out),
        .start(start),
        .done(done)
    );
    
    initial begin
        $dumpfile(""spi_dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst_n = 1'b0;
        start = 1'b0;
        mosi = 1'b0;
        data_in = 8'b10101010;
        
        #20 rst_n = 1'b1;
        #10 start = 1'b1;
        #160 start = 1'b0;
        #20 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b start=%b miso=%b sclk=%b data_out=%b done=%b"", 
                 $time, clk, rst_n, start, miso, sclk, data_out, done);
    end
endmodule",True,95,True,True,True,,0.0,,11.254917621612549,0.013630390167236328,"graph TD
    CLK[Clock] --> SCLK_GEN(SCLK Generator)
    RST[Reset] --> SCLK_GEN
    MOSI[Master Out Slave In] --> SPI_CTRL(SPI Control Block)
    MISO[Master In Slave Out] --> SPI_CTRL
    SPI_CTRL --> MOSI_OUT[MOSI Output]
    SPI_CTRL --> MISO_IN[MISO Input]
    SCLK_GEN --> SPI_CTRL
    SPI_CTRL --> SCLK_OUT[SCLK Output]
    TB[Testbench] --> CLK
    TB --> RST
    TB --> MOSI
    TB --> MISO
    MOSI_OUT --> TB
    MISO_IN --> TB
    SCLK_OUT --> TB","`timescale 1ns/1ps

module sclk_generator(
    input wire clk,
    input wire rst,
    output reg sclk
);
    always @(posedge clk or posedge rst) begin
        if (rst)
            sclk <= 1'b0;
        else
            sclk <= ~sclk;
    end
endmodule

module spi_control_block(
    input wire sclk,
    input wire mosi,
    input wire miso,
    output reg mosi_out,
    output reg miso_in,
    output reg sclk_out
);
    always @(posedge sclk) begin
        mosi_out <= mosi;
        miso_in <= miso;
        sclk_out <= sclk;
    end
endmodule

module testbench;
    reg clk, rst, mosi, miso;
    wire mosi_out, miso_in, sclk_out;
    wire sclk;

    sclk_generator sclk_gen (
        .clk(clk),
        .rst(rst),
        .sclk(sclk)
    );

    spi_control_block spi_ctrl (
        .sclk(sclk),
        .mosi(mosi),
        .miso(miso),
        .mosi_out(mosi_out),
        .miso_in(miso_in),
        .sclk_out(sclk_out)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 1'b0;
        rst = 1'b1;
        mosi = 1'b0;
        miso = 1'b0;

        #10 rst = 1'b0;
        #20 mosi = 1'b1;
        #40 miso = 1'b1;
        #80 mosi = 1'b0;
        #160 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t clk=%b rst=%b mosi=%b miso=%b mosi_out=%b miso_in=%b sclk_out=%b"", 
                 $time, clk, rst, mosi, miso, mosi_out, miso_in, sclk_out);
    end
endmodule",True,73,True,True,True,True,0.7,True,11.885977268218994,20.242614269256592,"Design SPI master supporting mode 0 (CPOL=0, CPHA=0). Include SCLK generation, MOSI/MISO handling. Include testbench.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph TD
    CLK[Clock] --> SCLK_GEN(SCLK Generator)
    RST[Reset] --> SCLK_GEN
    MOSI[Master Out Slave In] --> SPI_CTRL(SPI Control Block)
    MISO[Master In Slave Out] --> SPI_CTRL
    SPI_CTRL --> MOSI_OUT[MOSI Output]
    SPI_CTRL --> MISO_IN[MISO Input]
    SCLK_GEN --> SPI_CTRL
    SPI_CTRL --> SCLK_OUT[SCLK Output]
    TB[Testbench] --> CLK
    TB --> RST
    TB --> MOSI
    TB --> MISO
    MOSI_OUT --> TB
    MISO_IN --> TB
    SCLK_OUT --> TB
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module sclk_gen(
    input wire clk,
    input wire rst,
    output reg sclk
);
    
    always @(posedge clk or posedge rst) begin
        if (rst)
            sclk <= 1'b0;
        else
            sclk <= ~sclk;
    end

endmodule

module spi_ctrl(
    input wire clk,
    input wire rst,
    input wire mosi,
    input wire miso,
    input wire sclk,
    output reg mosi_out,
    output reg miso_in,
    output reg sclk_out
);

    always @(posedge clk or posedge rst) begin
        if (rst) begin
            mosi_out <= 1'b0;
            miso_in <= 1'b0;
            sclk_out <= 1'b0;
        end else begin
            mosi_out <= mosi;
            miso_in <= miso;
            sclk_out <= sclk;
        end
    end

endmodule

module testbench;
    reg clk, rst, mosi, miso;
    wire mosi_out, miso_in, sclk_out;
    wire sclk;

    sclk_gen sclk_gen_inst (
        .clk(clk),
        .rst(rst),
        .sclk(sclk)
    );

    spi_ctrl spi_ctrl_inst (
        .clk(clk),
        .rst(rst),
        .mosi(mosi),
        .miso(miso),
        .sclk(sclk),
        .mosi_out(mosi_out),
        .miso_in(miso_in),
        .sclk_out(sclk_out)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst = 1'b1;
        mosi = 1'b0;
        miso = 1'b1;
        
        #15 rst = 1'b0;
        #10 mosi = 1'b1;
        #20 mosi = 1'b0;
        #30 miso = 1'b0;
        #40 miso = 1'b1;
        #100 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t clk=%b rst=%b mosi=%b miso=%b mosi_out=%b miso_in=%b sclk_out=%b"", 
                 $time, clk, rst, mosi, miso, mosi_out, miso_in, sclk_out);
    end
endmodule",True,88,True,True,True,True,0.7,True,8.429282426834106,16.802799463272095,prompt_only,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
