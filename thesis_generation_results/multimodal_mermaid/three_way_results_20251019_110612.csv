circuit_name,category,complexity,original_prompt,model,prompt_only_verilog,prompt_only_generation_success,prompt_only_lines_of_code,prompt_only_has_testbench,prompt_only_compilation_success,prompt_only_simulation_success,prompt_only_vae_verdict,prompt_only_vae_confidence,prompt_only_consensus_anomalous,prompt_only_generation_time,prompt_only_simulation_time,mermaid_only_mermaid,mermaid_only_verilog,mermaid_only_generation_success,mermaid_only_lines_of_code,mermaid_only_has_testbench,mermaid_only_compilation_success,mermaid_only_simulation_success,mermaid_only_vae_verdict,mermaid_only_vae_confidence,mermaid_only_consensus_anomalous,mermaid_only_generation_time,mermaid_only_simulation_time,combined_prompt,combined_verilog,combined_generation_success,combined_lines_of_code,combined_has_testbench,combined_compilation_success,combined_simulation_success,combined_vae_verdict,combined_vae_confidence,combined_consensus_anomalous,combined_generation_time,combined_simulation_time,best_approach,correctness_ranking,simulation_ranking
combined,Combinational,simple,"Design a 2-to-1 multiplexer with inputs a, b, select sel, and output out. Include testbench testing all combinations.",claude,"`timescale 1ns/1ps

module mux2to1(
    input wire a,
    input wire b,
    input wire sel,
    output reg out
);

always @(*) begin
    out = sel ? b : a;
end

endmodule

module testbench;
    reg a, b, sel;
    wire out;
    
    mux2to1 dut (
        .a(a),
        .b(b),
        .sel(sel),
        .out(out)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        // Test all combinations
        a = 0; b = 0; sel = 0; #10;
        a = 0; b = 0; sel = 1; #10;
        a = 0; b = 1; sel = 0; #10;
        a = 0; b = 1; sel = 1; #10;
        a = 1; b = 0; sel = 0; #10;
        a = 1; b = 0; sel = 1; #10;
        a = 1; b = 1; sel = 0; #10;
        a = 1; b = 1; sel = 1; #10;
        
        $finish;
    end
    
    initial begin
        $monitor(""Time=%0t a=%b b=%b sel=%b out=%b"",
                 $time, a, b, sel, out);
    end
endmodule",True,48,True,True,True,False,0.4,False,4.7819414138793945,7.419193983078003,"graph LR
    A[Input A] --> MUX{2:1 MUX}
    B[Input B] --> MUX
    SEL[Select] --> MUX
    MUX --> OUT[Output]
    TB1[Test: sel=0, a=0, b=0] --> TEST((Testbench))
    TB2[Test: sel=0, a=0, b=1] --> TEST
    TB3[Test: sel=0, a=1, b=0] --> TEST
    TB4[Test: sel=0, a=1, b=1] --> TEST
    TB5[Test: sel=1, a=0, b=0] --> TEST
    TB6[Test: sel=1, a=0, b=1] --> TEST
    TB7[Test: sel=1, a=1, b=0] --> TEST
    TB8[Test: sel=1, a=1, b=1] --> TEST
    TEST --> MUX","`timescale 1ns/1ps

module mux2to1(
    input wire clk,
    input wire rst_n,
    input wire a,
    input wire b,
    input wire sel,
    output reg out
);

always @(posedge clk or negedge rst_n) begin
    if (!rst_n)
        out <= 1'b0;
    else
        out <= sel ? b : a;
end

endmodule

module testbench;
    reg clk, rst_n;
    reg a, b, sel;
    wire out;

    mux2to1 dut (
        .clk(clk),
        .rst_n(rst_n),
        .a(a),
        .b(b),
        .sel(sel),
        .out(out)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 0;
        rst_n = 0;
        a = 0;
        b = 0;
        sel = 0;

        #10 rst_n = 1;

        // Test: sel=0, a=0, b=0
        #10 sel = 0; a = 0; b = 0;
        
        // Test: sel=0, a=0, b=1
        #10 sel = 0; a = 0; b = 1;
        
        // Test: sel=0, a=1, b=0
        #10 sel = 0; a = 1; b = 0;
        
        // Test: sel=0, a=1, b=1
        #10 sel = 0; a = 1; b = 1;
        
        // Test: sel=1, a=0, b=0
        #10 sel = 1; a = 0; b = 0;
        
        // Test: sel=1, a=0, b=1
        #10 sel = 1; a = 0; b = 1;
        
        // Test: sel=1, a=1, b=0
        #10 sel = 1; a = 1; b = 0;
        
        // Test: sel=1, a=1, b=1
        #10 sel = 1; a = 1; b = 1;

        #10 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t sel=%b a=%b b=%b out=%b"",
                 $time, sel, a, b, out);
    end
endmodule",True,80,True,True,True,False,0.3,False,11.05846619606018,7.993278503417969,"Design a 2-to-1 multiplexer with inputs a, b, select sel, and output out. Include testbench testing all combinations.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph LR
    A[Input A] --> MUX{2:1 MUX}
    B[Input B] --> MUX
    SEL[Select] --> MUX
    MUX --> OUT[Output]
    TB1[Test: sel=0, a=0, b=0] --> TEST((Testbench))
    TB2[Test: sel=0, a=0, b=1] --> TEST
    TB3[Test: sel=0, a=1, b=0] --> TEST
    TB4[Test: sel=0, a=1, b=1] --> TEST
    TB5[Test: sel=1, a=0, b=0] --> TEST
    TB6[Test: sel=1, a=0, b=1] --> TEST
    TB7[Test: sel=1, a=1, b=0] --> TEST
    TB8[Test: sel=1, a=1, b=1] --> TEST
    TEST --> MUX
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module mux_2to1 (
    input wire a,
    input wire b,
    input wire sel,
    output reg out
);

always @(*) begin
    case (sel)
        1'b0: out = a;
        1'b1: out = b;
        default: out = 1'b0;
    endcase
end

endmodule

module testbench;
    reg a, b, sel;
    wire out;
    
    mux_2to1 dut (
        .a(a),
        .b(b),
        .sel(sel),
        .out(out)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        // Test case 1: sel=0, a=0, b=0
        sel = 0; a = 0; b = 0; #10;
        
        // Test case 2: sel=0, a=0, b=1
        sel = 0; a = 0; b = 1; #10;
        
        // Test case 3: sel=0, a=1, b=0
        sel = 0; a = 1; b = 0; #10;
        
        // Test case 4: sel=0, a=1, b=1
        sel = 0; a = 1; b = 1; #10;
        
        // Test case 5: sel=1, a=0, b=0
        sel = 1; a = 0; b = 0; #10;
        
        // Test case 6: sel=1, a=0, b=1
        sel = 1; a = 0; b = 1; #10;
        
        // Test case 7: sel=1, a=1, b=0
        sel = 1; a = 1; b = 0; #10;
        
        // Test case 8: sel=1, a=1, b=1
        sel = 1; a = 1; b = 1; #10;
        
        $finish;
    end
    
    initial begin
        $monitor(""Time=%0t sel=%b a=%b b=%b out=%b"", 
                 $time, sel, a, b, out);
    end
endmodule",True,66,True,True,True,False,0.4,False,6.632200241088867,7.439584255218506,tie,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,Combinational,simple,"Design a 2-to-1 multiplexer with inputs a, b, select sel, and output out. Include testbench testing all combinations.",gpt-4o,"`timescale 1ns/1ps

module mux2to1(
    input wire a,
    input wire b,
    input wire sel,
    output wire out
);

assign out = (sel) ? b : a;

endmodule

module testbench;
    reg a, b, sel;
    wire out;
    
    mux2to1 dut (
        .a(a),
        .b(b),
        .sel(sel),
        .out(out)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        a = 0; b = 0; sel = 0;
        #10 sel = 1;
        #10 b = 1; sel = 0;
        #10 sel = 1;
        #10 a = 1; b = 0; sel = 0;
        #10 sel = 1;
        #10 b = 1; sel = 0;
        #10 sel = 1;
        #10 $finish;
    end
    
    initial begin
        $monitor(""Time=%0t a=%b b=%b sel=%b out=%b"", 
                 $time, a, b, sel, out);
    end
endmodule",True,44,True,True,True,False,0.4,False,2.511235475540161,6.538182497024536,"graph TD
    A[a] --> MUX{2-to-1 Mux}
    B[b] --> MUX
    SEL[sel] --> MUX
    MUX --> OUT[out]

    subgraph Testbench
        TB_SEL[sel Test] --> TB_MUX{2-to-1 Mux}
        TB_A[a Test] --> TB_MUX
        TB_B[b Test] --> TB_MUX
        TB_MUX --> TB_OUT[out Test]
    end","`timescale 1ns/1ps

module mux_2to1 (
    input wire a,
    input wire b,
    input wire sel,
    output wire out
);
    assign out = sel ? b : a;
endmodule

module testbench;
    reg a, b, sel;
    wire out;
    
    mux_2to1 dut (
        .a(a),
        .b(b),
        .sel(sel),
        .out(out)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        a = 1'b0;
        b = 1'b0;
        sel = 1'b0;
        
        #10 a = 1'b1;
        #10 b = 1'b1;
        #10 sel = 1'b1;
        #10 a = 1'b0;
        #10 b = 1'b0;
        #10 sel = 1'b0;
        #20 $finish;
    end
    
    initial begin
        $monitor(""Time=%0t a=%b b=%b sel=%b out=%b"", $time, a, b, sel, out);
    end
endmodule",True,43,True,True,True,False,0.4,False,3.99458384513855,8.072478532791138,"Design a 2-to-1 multiplexer with inputs a, b, select sel, and output out. Include testbench testing all combinations.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph TD
    A[a] --> MUX{2-to-1 Mux}
    B[b] --> MUX
    SEL[sel] --> MUX
    MUX --> OUT[out]

    subgraph Testbench
        TB_SEL[sel Test] --> TB_MUX{2-to-1 Mux}
        TB_A[a Test] --> TB_MUX
        TB_B[b Test] --> TB_MUX
        TB_MUX --> TB_OUT[out Test]
    end
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module mux_2to1(
    input wire a,
    input wire b,
    input wire sel,
    output wire out
);
    assign out = sel ? b : a;
endmodule

module testbench;
    reg a, b, sel;
    wire out;

    mux_2to1 dut (
        .a(a),
        .b(b),
        .sel(sel),
        .out(out)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        // Test all combinations of a, b, sel
        a = 0; b = 0; sel = 0; #10;
        a = 0; b = 0; sel = 1; #10;
        a = 0; b = 1; sel = 0; #10;
        a = 0; b = 1; sel = 1; #10;
        a = 1; b = 0; sel = 0; #10;
        a = 1; b = 0; sel = 1; #10;
        a = 1; b = 1; sel = 0; #10;
        a = 1; b = 1; sel = 1; #10;

        $finish;
    end

    initial begin
        $monitor(""Time=%0t a=%b b=%b sel=%b out=%b"", $time, a, b, sel, out);
    end
endmodule",True,43,True,True,True,False,0.4,False,4.864802598953247,8.825833797454834,tie,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,Sequential,simple,"Create a D flip-flop with clock, reset, input d, and output q. Include testbench with timing verification.",claude,"`timescale 1ns/1ps

module dff(
    input wire clk,
    input wire rst_n,
    input wire d,
    output reg q
);

always @(posedge clk or negedge rst_n) begin
    if (!rst_n)
        q <= 1'b0;
    else
        q <= d;
end

endmodule

module testbench;
    reg clk, rst_n, d;
    wire q;
    
    dff dut (
        .clk(clk),
        .rst_n(rst_n),
        .d(d),
        .q(q)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst_n = 1'b0;
        d = 1'b0;
        
        #20 rst_n = 1'b1;
        #10 d = 1'b1;
        #10 d = 1'b0;
        #10 d = 1'b1;
        #20 rst_n = 1'b0;
        #20 rst_n = 1'b1;
        #50 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b d=%b q=%b"", 
                 $time, clk, rst_n, d, q);
    end
endmodule",True,53,True,True,True,True,0.7,True,4.6303489208221436,7.046162366867065,"graph TD
    CLK[Clock] --> DFF[[D Flip-Flop]]
    RST[Reset] --> DFF
    D[Input D] --> DFF
    DFF --> Q[Output Q]
    TB[Testbench] --> TV{Timing Verification}
    CLK --> TV
    D --> TV
    Q --> TV
    RST --> TV
    TV --> TC[Setup Time Check]
    TV --> TH[Hold Time Check]
    TV --> TR[Reset Timing]
    TV --> TP[Clock Period]
    TC --> PASS[Verification Status]
    TH --> PASS
    TR --> PASS
    TP --> PASS","`timescale 1ns/1ps

module dff(
    input wire clk,
    input wire rst,
    input wire d,
    output reg q
);

always @(posedge clk or posedge rst) begin
    if (rst)
        q <= 1'b0;
    else
        q <= d;
end

endmodule

module testbench;
    reg clk, rst, d;
    wire q;
    reg [31:0] setup_time = 2;
    reg [31:0] hold_time = 1;
    reg [31:0] reset_time = 3;
    reg [31:0] clock_period = 10;
    
    dff dut (
        .clk(clk),
        .rst(rst),
        .d(d),
        .q(q)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 0;
        rst = 1;
        d = 0;
        
        #20 rst = 0;
        
        // Test data transitions
        #10 d = 1;
        #10 d = 0;
        #10 d = 1;
        
        // Test reset during operation
        #10 rst = 1;
        #10 rst = 0;
        
        // Setup/Hold timing checks
        @(posedge clk);
        #(setup_time) d = 0;
        #(clock_period - setup_time) d = 1;
        
        // Additional transitions
        repeat(5) begin
            #10 d = ~d;
        end
        
        #50 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t rst=%b d=%b q=%b"", $time, rst, d, q);
    end
    
endmodule",True,72,True,True,True,False,0.3,False,9.864099502563477,7.469547748565674,"Create a D flip-flop with clock, reset, input d, and output q. Include testbench with timing verification.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph TD
    CLK[Clock] --> DFF[[D Flip-Flop]]
    RST[Reset] --> DFF
    D[Input D] --> DFF
    DFF --> Q[Output Q]
    TB[Testbench] --> TV{Timing Verification}
    CLK --> TV
    D --> TV
    Q --> TV
    RST --> TV
    TV --> TC[Setup Time Check]
    TV --> TH[Hold Time Check]
    TV --> TR[Reset Timing]
    TV --> TP[Clock Period]
    TC --> PASS[Verification Status]
    TH --> PASS
    TR --> PASS
    TP --> PASS
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module dff(
    input wire clk,
    input wire rst,
    input wire d,
    output reg q
);

always @(posedge clk or posedge rst) begin
    if (rst)
        q <= 1'b0;
    else
        q <= d;
end

endmodule

module testbench;
    reg clk, rst, d;
    wire q;
    
    // Timing parameters
    parameter CLOCK_PERIOD = 10;
    parameter SETUP_TIME = 2;
    parameter HOLD_TIME = 1;
    parameter RST_RELEASE = 2;
    
    dff dut (
        .clk(clk),
        .rst(rst),
        .d(d),
        .q(q)
    );
    
    initial begin
        $dumpfile(""dff_test.vcd"");
        $dumpvars(0, testbench);
        
        // Initialize signals
        clk = 0;
        rst = 1;
        d = 0;
        
        // Reset sequence
        #(RST_RELEASE);
        rst = 0;
        
        // Test sequence
        repeat(5) begin
            @(negedge clk);
            #(CLOCK_PERIOD - SETUP_TIME) d = ~d;
            #(SETUP_TIME + HOLD_TIME);
        end
        
        // Additional timing checks
        @(negedge clk);
        #(CLOCK_PERIOD/2) rst = 1;
        #(CLOCK_PERIOD/2) rst = 0;
        
        // Complete test
        #(CLOCK_PERIOD * 2);
        $finish;
    end
    
    // Clock generation
    always #(CLOCK_PERIOD/2) clk = ~clk;
    
    // Timing checks
    always @(posedge clk) begin
        $setup(d, clk, SETUP_TIME);
        $hold(clk, d, HOLD_TIME);
    end
    
    initial begin
        $monitor(""Time=%0t rst=%b clk=%b d=%b q=%b"",
                 $time, rst, clk, d, q);
    end
endmodule",True,79,True,False,False,,0.0,,7.512827634811401,82.40362548828125,mermaid_only,mermaid_only > prompt_only > combined,prompt_only > mermaid_only > combined
combined,Sequential,simple,"Create a D flip-flop with clock, reset, input d, and output q. Include testbench with timing verification.",gpt-4o,"`timescale 1ns/1ps

module dff(
    input wire clk,
    input wire rst_n,
    input wire d,
    output reg q
);

always @(posedge clk or negedge rst_n) begin
    if (!rst_n)
        q <= 1'b0;
    else
        q <= d;
end

endmodule

module testbench;
    reg clk, rst_n, d;
    wire q;
    
    dff dut (
        .clk(clk),
        .rst_n(rst_n),
        .d(d),
        .q(q)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst_n = 1'b0;
        d = 1'b0;
        
        #20 rst_n = 1'b1;
        #10 d = 1'b1;
        #30 d = 1'b0;
        #20 rst_n = 1'b0;
        #20 rst_n = 1'b1;
        #50 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b d=%b q=%b"", 
                 $time, clk, rst_n, d, q);
    end
endmodule",True,52,True,True,True,True,0.7,True,3.7259082794189453,8.804006576538086,"graph TD
    CLK[Clock] --> DFF[[D Flip-Flop]]
    RST[Reset] --> DFF
    D[Input D] --> DFF
    DFF --> Q[Output Q]
    subgraph Testbench
        TBCLK[Testbench Clock] --> DFF
        TBRST[Testbench Reset] --> DFF
        TBDATA[Testbench Input D] --> DFF
        DFF --> TBQ[Testbench Output Q]
    end","`timescale 1ns/1ps

module d_flip_flop(
    input wire clk,
    input wire rst,
    input wire d,
    output reg q
);

always @(posedge clk or posedge rst) begin
    if (rst)
        q <= 1'b0;
    else
        q <= d;
end

endmodule

module testbench;
    reg tbclk, tbrst, tbdata;
    wire tbq;
    
    d_flip_flop dff_inst (
        .clk(tbclk),
        .rst(tbrst),
        .d(tbdata),
        .q(tbq)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        tbclk = 1'b0;
        tbrst = 1'b0;
        tbdata = 1'b0;
        
        #10 tbrst = 1'b1; 
        #10 tbrst = 1'b0; 
        #10 tbdata = 1'b1; 
        #20 tbdata = 1'b0; 
        #30 tbdata = 1'b1; 
        #50 $finish;
    end
    
    always #5 tbclk = ~tbclk;
    
    initial begin
        $monitor(""Time=%0t tbclk=%b tbrst=%b tbdata=%b tbq=%b"", 
                 $time, tbclk, tbrst, tbdata, tbq);
    end
endmodule",True,52,True,True,True,True,0.7,True,4.492211818695068,8.004387617111206,"Create a D flip-flop with clock, reset, input d, and output q. Include testbench with timing verification.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph TD
    CLK[Clock] --> DFF[[D Flip-Flop]]
    RST[Reset] --> DFF
    D[Input D] --> DFF
    DFF --> Q[Output Q]
    subgraph Testbench
        TBCLK[Testbench Clock] --> DFF
        TBRST[Testbench Reset] --> DFF
        TBDATA[Testbench Input D] --> DFF
        DFF --> TBQ[Testbench Output Q]
    end
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module d_flip_flop(
    input wire clk,
    input wire rst,
    input wire d,
    output reg q
);

always @(posedge clk or posedge rst) begin
    if (rst)
        q <= 1'b0;
    else
        q <= d;
end

endmodule

module testbench;
    reg tbclk, tbrst, tbdata;
    wire tbq;

    d_flip_flop dut (
        .clk(tbclk),
        .rst(tbrst),
        .d(tbdata),
        .q(tbq)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        tbclk = 1'b0;
        tbrst = 1'b0;
        tbdata = 1'b0;

        #20 tbrst = 1'b1;
        #10 tbrst = 1'b0;
        #10 tbdata = 1'b1;
        #50 tbdata = 1'b0;
        #30 tbdata = 1'b1;
        #50 $finish;
    end

    always #5 tbclk = ~tbclk;

    initial begin
        $monitor(""Time=%0t tbclk=%b tbrst=%b tbdata=%b tbq=%b"", 
                 $time, tbclk, tbrst, tbdata, tbq);
    end
endmodule",True,52,True,True,True,True,0.7,True,2.694563627243042,6.54198145866394,prompt_only,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,Sequential,simple,"Design a 4-bit synchronous counter with clock, reset, enable, and count[3:0]. Include testbench.",claude,"`timescale 1ns/1ps

module counter(
    input wire clk,
    input wire rst_n,
    input wire enable,
    output reg [3:0] count
);

always @(posedge clk or negedge rst_n) begin
    if (!rst_n)
        count <= 4'b0000;
    else if (enable)
        count <= count + 1'b1;
end

endmodule

module testbench;
    reg clk, rst_n, enable;
    wire [3:0] count;
    
    counter dut (
        .clk(clk),
        .rst_n(rst_n),
        .enable(enable),
        .count(count)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst_n = 1'b0;
        enable = 1'b0;
        
        #20 rst_n = 1'b1;
        #10 enable = 1'b1;
        #100 enable = 1'b0;
        #20 rst_n = 1'b0;
        #20 rst_n = 1'b1;
        #50 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b enable=%b count=%d"", 
                 $time, clk, rst_n, enable, count);
    end
endmodule",True,52,True,True,True,False,0.3,False,4.533825397491455,8.75605583190918,"graph TD
    CLK[Clock] --> CNT[[4-bit Counter]]
    RST[Reset] --> CNT
    EN[Enable] --> CNT
    
    CNT --> Q0[Count[0]]
    CNT --> Q1[Count[1]]
    CNT --> Q2[Count[2]]
    CNT --> Q3[Count[3]]
    
    CLK --> TB((Testbench))
    RST --> TB
    EN --> TB
    Q0 --> TB
    Q1 --> TB
    Q2 --> TB
    Q3 --> TB
    
    TB --> SIG{Signal Monitor}
    SIG --> WAV[Waveform Display]
    SIG --> ERR[Error Check]
    
    CLK -.-> CLK_GEN([Clock Generator])
    RST -.-> RST_GEN([Reset Generator])
    EN -.-> EN_GEN([Enable Generator])","`timescale 1ns/1ps

module counter(
    input wire clk,
    input wire rst_n,
    input wire enable,
    output reg [3:0] count
);

always @(posedge clk or negedge rst_n) begin
    if (!rst_n)
        count <= 4'b0000;
    else if (enable)
        count <= count + 1'b1;
end

endmodule

module testbench;
    reg clk, rst_n, enable;
    wire [3:0] count;
    
    counter dut (
        .clk(clk),
        .rst_n(rst_n),
        .enable(enable),
        .count(count)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst_n = 1'b0;
        enable = 1'b0;
        
        #20 rst_n = 1'b1;
        #10 enable = 1'b1;
        #100 enable = 1'b0;
        #20 rst_n = 1'b0;
        #20 rst_n = 1'b1;
        #50 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b enable=%b count=%b"", 
                 $time, clk, rst_n, enable, count);
    end
    
    initial begin
        if ($test$plusargs(""wave"")) begin
            $display(""Waveform dumping enabled"");
        end
    end
endmodule",True,58,True,True,True,True,0.7,True,8.83657431602478,7.34490704536438,"Design a 4-bit synchronous counter with clock, reset, enable, and count[3:0]. Include testbench.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph TD
    CLK[Clock] --> CNT[[4-bit Counter]]
    RST[Reset] --> CNT
    EN[Enable] --> CNT
    
    CNT --> Q0[Count[0]]
    CNT --> Q1[Count[1]]
    CNT --> Q2[Count[2]]
    CNT --> Q3[Count[3]]
    
    CLK --> TB((Testbench))
    RST --> TB
    EN --> TB
    Q0 --> TB
    Q1 --> TB
    Q2 --> TB
    Q3 --> TB
    
    TB --> SIG{Signal Monitor}
    SIG --> WAV[Waveform Display]
    SIG --> ERR[Error Check]
    
    CLK -.-> CLK_GEN([Clock Generator])
    RST -.-> RST_GEN([Reset Generator])
    EN -.-> EN_GEN([Enable Generator])
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module counter(
    input wire clk,
    input wire rst_n,
    input wire enable,
    output reg [3:0] count
);

always @(posedge clk or negedge rst_n) begin
    if (!rst_n)
        count <= 4'b0000;
    else if (enable)
        count <= count + 1'b1;
end

endmodule

module testbench;
    reg clk, rst_n, enable;
    wire [3:0] count;
    
    counter dut (
        .clk(clk),
        .rst_n(rst_n),
        .enable(enable),
        .count(count)
    );
    
    // Clock Generator
    initial begin
        clk = 0;
        forever #5 clk = ~clk;
    end
    
    // Reset Generator
    initial begin
        rst_n = 0;
        #20 rst_n = 1;
        #160 rst_n = 0;
        #20 rst_n = 1;
    end
    
    // Enable Generator
    initial begin
        enable = 0;
        #30 enable = 1;
        #100 enable = 0;
        #50 enable = 1;
        #20 enable = 0;
    end
    
    // Signal Monitor and Waveform Display
    initial begin
        $dumpfile(""counter.vcd"");
        $dumpvars(0, testbench);
        
        $monitor(""Time=%0t rst_n=%b enable=%b count=%b"", 
                 $time, rst_n, enable, count);
                 
        #250 $finish;
    end
    
    // Error Check
    always @(posedge clk) begin
        if (enable && rst_n && count == 4'b1111)
            $display(""Counter reached maximum value at time %0t"", $time);
    end
    
endmodule",True,70,True,True,True,,0.0,,6.070331573486328,0.01646566390991211,prompt_only,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,Sequential,simple,"Design a 4-bit synchronous counter with clock, reset, enable, and count[3:0]. Include testbench.",gpt-4o,"`timescale 1ns/1ps

module counter(
    input wire clk,
    input wire rst_n,
    input wire enable,
    output reg [3:0] count
);

always @(posedge clk or negedge rst_n) begin
    if (!rst_n)
        count <= 4'b0000;
    else if (enable)
        count <= count + 1'b1;
end

endmodule

module testbench;
    reg clk, rst_n, enable;
    wire [3:0] count;
    
    counter dut (
        .clk(clk),
        .rst_n(rst_n),
        .enable(enable),
        .count(count)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst_n = 1'b0;
        enable = 1'b0;
        
        #20 rst_n = 1'b1;
        #10 enable = 1'b1;
        #100 enable = 1'b0;
        #20 rst_n = 1'b0;
        #20 rst_n = 1'b1;
        #50 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b enable=%b count=%d"", 
                 $time, clk, rst_n, enable, count);
    end
endmodule",True,52,True,True,True,False,0.3,False,2.800450325012207,8.472763776779175,"graph TD
    CLK[Clock] --> COUNTER(4-bit Counter)
    RST[Reset] --> COUNTER
    EN[Enable] --> COUNTER
    COUNTER --> COUNT[[Count[3:0]]]
    subgraph Testbench
        TB_CLK[Clock] --> COUNTER
        TB_RST[Reset] --> COUNTER
        TB_EN[Enable] --> COUNTER
        COUNT --> TB_OUT[Output Verification]
    end","`timescale 1ns/1ps

module counter(
    input wire clk,
    input wire rst_n,
    input wire enable,
    output reg [3:0] count
);

always @(posedge clk or negedge rst_n) begin
    if (!rst_n)
        count <= 4'b0000;
    else if (enable)
        count <= count + 1'b1;
end

endmodule

module testbench;
    reg clk, rst_n, enable;
    wire [3:0] count;
    
    counter dut (
        .clk(clk),
        .rst_n(rst_n),
        .enable(enable),
        .count(count)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst_n = 1'b0;
        enable = 1'b0;
        
        #20 rst_n = 1'b1;
        #10 enable = 1'b1;
        #100 enable = 1'b0;
        #20 rst_n = 1'b0;
        #20 rst_n = 1'b1;
        #50 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b enable=%b count=%d"", 
                 $time, clk, rst_n, enable, count);
    end
endmodule",True,52,True,True,True,False,0.3,False,3.920543670654297,11.695560693740845,"Design a 4-bit synchronous counter with clock, reset, enable, and count[3:0]. Include testbench.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph TD
    CLK[Clock] --> COUNTER(4-bit Counter)
    RST[Reset] --> COUNTER
    EN[Enable] --> COUNTER
    COUNTER --> COUNT[[Count[3:0]]]
    subgraph Testbench
        TB_CLK[Clock] --> COUNTER
        TB_RST[Reset] --> COUNTER
        TB_EN[Enable] --> COUNTER
        COUNT --> TB_OUT[Output Verification]
    end
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module counter(
    input wire clk,
    input wire rst_n,
    input wire enable,
    output reg [3:0] count
);

always @(posedge clk or negedge rst_n) begin
    if (!rst_n)
        count <= 4'b0000;
    else if (enable)
        count <= count + 1'b1;
end

endmodule

module testbench;
    reg clk, rst_n, enable;
    wire [3:0] count;
    
    counter dut (
        .clk(clk),
        .rst_n(rst_n),
        .enable(enable),
        .count(count)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst_n = 1'b0;
        enable = 1'b0;
        
        #20 rst_n = 1'b1;
        #10 enable = 1'b1;
        #100 enable = 1'b0;
        #20 rst_n = 1'b0;
        #20 rst_n = 1'b1;
        #50 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b enable=%b count=%d"", 
                 $time, clk, rst_n, enable, count);
    end
endmodule",True,52,True,True,True,False,0.3,False,1.719853401184082,6.97843861579895,tie,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,Combinational,simple,"Create a full adder with inputs a, b, cin and outputs sum, cout. Include testbench with all 8 cases.",claude,"`timescale 1ns/1ps

module full_adder(
    input wire a,
    input wire b,
    input wire cin,
    output wire sum,
    output wire cout
);

assign sum = a ^ b ^ cin;
assign cout = (a & b) | (b & cin) | (a & cin);

endmodule

module testbench;
    reg a, b, cin;
    wire sum, cout;
    
    full_adder dut(
        .a(a),
        .b(b),
        .cin(cin),
        .sum(sum),
        .cout(cout)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        // Test all 8 combinations
        {a, b, cin} = 3'b000; #10;
        {a, b, cin} = 3'b001; #10;
        {a, b, cin} = 3'b010; #10;
        {a, b, cin} = 3'b011; #10;
        {a, b, cin} = 3'b100; #10;
        {a, b, cin} = 3'b101; #10;
        {a, b, cin} = 3'b110; #10;
        {a, b, cin} = 3'b111; #10;
        
        $finish;
    end
    
    initial begin
        $monitor(""Time=%0t a=%b b=%b cin=%b sum=%b cout=%b"",
                 $time, a, b, cin, sum, cout);
    end
endmodule",True,49,True,True,True,False,0.4,False,4.9003143310546875,7.313425064086914,"graph LR
    A[a] --> FA((Full Adder))
    B[b] --> FA
    CIN[cin] --> FA
    FA --> SUM[sum]
    FA --> COUT[cout]
    TB[[Test Cases]]
    TB --> |0,0,0|T1{0,0}
    TB --> |0,0,1|T2{0,1}
    TB --> |0,1,0|T3{0,1}
    TB --> |0,1,1|T4{1,0}
    TB --> |1,0,0|T5{0,1}
    TB --> |1,0,1|T6{1,0}
    TB --> |1,1,0|T7{1,0}
    TB --> |1,1,1|T8{1,1}
    T1 --> |sum,cout|R1[Result]
    T2 --> |sum,cout|R2[Result]
    T3 --> |sum,cout|R3[Result]
    T4 --> |sum,cout|R4[Result]
    T5 --> |sum,cout|R5[Result]
    T6 --> |sum,cout|R6[Result]
    T7 --> |sum,cout|R7[Result]
    T8 --> |sum,cout|R8[Result]","`timescale 1ns/1ps

module full_adder(
    input wire a,
    input wire b, 
    input wire cin,
    output reg sum,
    output reg cout
);

always @(*) begin
    sum = a ^ b ^ cin;
    cout = (a & b) | (b & cin) | (a & cin);
end

endmodule

module testbench;
    reg a, b, cin;
    wire sum, cout;
    
    full_adder dut(
        .a(a),
        .b(b),
        .cin(cin),
        .sum(sum),
        .cout(cout)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        // Test case 1: 0,0,0
        a = 0; b = 0; cin = 0; #10;
        
        // Test case 2: 0,0,1
        a = 0; b = 0; cin = 1; #10;
        
        // Test case 3: 0,1,0
        a = 0; b = 1; cin = 0; #10;
        
        // Test case 4: 0,1,1
        a = 0; b = 1; cin = 1; #10;
        
        // Test case 5: 1,0,0
        a = 1; b = 0; cin = 0; #10;
        
        // Test case 6: 1,0,1
        a = 1; b = 0; cin = 1; #10;
        
        // Test case 7: 1,1,0
        a = 1; b = 1; cin = 0; #10;
        
        // Test case 8: 1,1,1
        a = 1; b = 1; cin = 1; #10;
        
        $finish;
    end
    
    initial begin
        $monitor(""Time=%0t a=%b b=%b cin=%b sum=%b cout=%b"",
                 $time, a, b, cin, sum, cout);
    end
endmodule",True,65,True,True,True,False,0.4,False,10.885563373565674,6.749826431274414,"Create a full adder with inputs a, b, cin and outputs sum, cout. Include testbench with all 8 cases.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph LR
    A[a] --> FA((Full Adder))
    B[b] --> FA
    CIN[cin] --> FA
    FA --> SUM[sum]
    FA --> COUT[cout]
    TB[[Test Cases]]
    TB --> |0,0,0|T1{0,0}
    TB --> |0,0,1|T2{0,1}
    TB --> |0,1,0|T3{0,1}
    TB --> |0,1,1|T4{1,0}
    TB --> |1,0,0|T5{0,1}
    TB --> |1,0,1|T6{1,0}
    TB --> |1,1,0|T7{1,0}
    TB --> |1,1,1|T8{1,1}
    T1 --> |sum,cout|R1[Result]
    T2 --> |sum,cout|R2[Result]
    T3 --> |sum,cout|R3[Result]
    T4 --> |sum,cout|R4[Result]
    T5 --> |sum,cout|R5[Result]
    T6 --> |sum,cout|R6[Result]
    T7 --> |sum,cout|R7[Result]
    T8 --> |sum,cout|R8[Result]
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module full_adder(
    input wire a,
    input wire b,
    input wire cin,
    output wire sum,
    output wire cout
);

assign sum = a ^ b ^ cin;
assign cout = (a & b) | (b & cin) | (a & cin);

endmodule

module testbench;
    reg a, b, cin;
    wire sum, cout;

    full_adder dut (
        .a(a),
        .b(b),
        .cin(cin),
        .sum(sum),
        .cout(cout)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        // Test Case 1: 0,0,0
        a = 0; b = 0; cin = 0;
        #10;

        // Test Case 2: 0,0,1
        a = 0; b = 0; cin = 1;
        #10;

        // Test Case 3: 0,1,0
        a = 0; b = 1; cin = 0;
        #10;

        // Test Case 4: 0,1,1
        a = 0; b = 1; cin = 1;
        #10;

        // Test Case 5: 1,0,0
        a = 1; b = 0; cin = 0;
        #10;

        // Test Case 6: 1,0,1
        a = 1; b = 0; cin = 1;
        #10;

        // Test Case 7: 1,1,0
        a = 1; b = 1; cin = 0;
        #10;

        // Test Case 8: 1,1,1
        a = 1; b = 1; cin = 1;
        #10;

        $finish;
    end

    initial begin
        $monitor(""Time=%0t a=%b b=%b cin=%b sum=%b cout=%b"",
                 $time, a, b, cin, sum, cout);
    end
endmodule",True,71,True,True,True,False,0.4,False,6.19698691368103,7.561085224151611,tie,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,Combinational,simple,"Create a full adder with inputs a, b, cin and outputs sum, cout. Include testbench with all 8 cases.",gpt-4o,"`timescale 1ns/1ps

module full_adder(
    input wire a,
    input wire b,
    input wire cin,
    output wire sum,
    output wire cout
);

assign sum = a ^ b ^ cin;
assign cout = (a & b) | (b & cin) | (a & cin);

endmodule

module testbench;
    reg a, b, cin;
    wire sum, cout;

    full_adder dut (
        .a(a),
        .b(b),
        .cin(cin),
        .sum(sum),
        .cout(cout)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        // Test all 8 input combinations
        a = 0; b = 0; cin = 0; #10;
        a = 0; b = 0; cin = 1; #10;
        a = 0; b = 1; cin = 0; #10;
        a = 0; b = 1; cin = 1; #10;
        a = 1; b = 0; cin = 0; #10;
        a = 1; b = 0; cin = 1; #10;
        a = 1; b = 1; cin = 0; #10;
        a = 1; b = 1; cin = 1; #10;

        $finish;
    end

    initial begin
        $monitor(""Time=%0t a=%b b=%b cin=%b sum=%b cout=%b"", 
                 $time, a, b, cin, sum, cout);
    end
endmodule",True,49,True,True,True,False,0.4,False,3.3554880619049072,5.767148494720459,"graph LR
    A[a] --> FA(FULL ADDER)
    B[b] --> FA
    CIN[cin] --> FA
    FA --> SUM[sum]
    FA --> COUT[cout]
    
    subgraph Testbench
        A1[Test case 0] --> TB1
        B1 --> TB1
        CIN1 --> TB1
        TB1 --> FA
        
        A2[Test case 1] --> TB2
        B2 --> TB2
        CIN2 --> TB2
        TB2 --> FA
        
        A3[Test case 2] --> TB3
        B3 --> TB3
        CIN3 --> TB3
        TB3 --> FA
        
        A4[Test case 3] --> TB4
        B4 --> TB4
        CIN4 --> TB4
        TB4 --> FA
        
        A5[Test case 4] --> TB5
        B5 --> TB5
        CIN5 --> TB5
        TB5 --> FA
        
        A6[Test case 5] --> TB6
        B6 --> TB6
        CIN6 --> TB6
        TB6 --> FA
        
        A7[Test case 6] --> TB7
        B7 --> TB7
        CIN7 --> TB7
        TB7 --> FA
        
        A8[Test case 7] --> TB8
        B8 --> TB8
        CIN8 --> TB8
        TB8 --> FA
    end","`timescale 1ns/1ps

module full_adder(
    input wire a,
    input wire b,
    input wire cin,
    output wire sum,
    output wire cout
);
    assign sum = a ^ b ^ cin;
    assign cout = (a & b) | (b & cin) | (a & cin);
endmodule

module testbench;
    reg a, b, cin;
    wire sum, cout;

    full_adder fa(
        .a(a),
        .b(b),
        .cin(cin),
        .sum(sum),
        .cout(cout)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        // Test case 0
        a = 0; b = 0; cin = 0;
        #10;

        // Test case 1
        a = 0; b = 0; cin = 1;
        #10;

        // Test case 2
        a = 0; b = 1; cin = 0;
        #10;

        // Test case 3
        a = 0; b = 1; cin = 1;
        #10;

        // Test case 4
        a = 1; b = 0; cin = 0;
        #10;

        // Test case 5
        a = 1; b = 0; cin = 1;
        #10;

        // Test case 6
        a = 1; b = 1; cin = 0;
        #10;

        // Test case 7
        a = 1; b = 1; cin = 1;
        #10;

        $finish;
    end

    initial begin
        $monitor(""Time=%0t a=%b b=%b cin=%b sum=%b cout=%b"", 
                 $time, a, b, cin, sum, cout);
    end
endmodule",True,69,True,True,True,False,0.4,False,6.439157009124756,6.511742830276489,"Create a full adder with inputs a, b, cin and outputs sum, cout. Include testbench with all 8 cases.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph LR
    A[a] --> FA(FULL ADDER)
    B[b] --> FA
    CIN[cin] --> FA
    FA --> SUM[sum]
    FA --> COUT[cout]
    
    subgraph Testbench
        A1[Test case 0] --> TB1
        B1 --> TB1
        CIN1 --> TB1
        TB1 --> FA
        
        A2[Test case 1] --> TB2
        B2 --> TB2
        CIN2 --> TB2
        TB2 --> FA
        
        A3[Test case 2] --> TB3
        B3 --> TB3
        CIN3 --> TB3
        TB3 --> FA
        
        A4[Test case 3] --> TB4
        B4 --> TB4
        CIN4 --> TB4
        TB4 --> FA
        
        A5[Test case 4] --> TB5
        B5 --> TB5
        CIN5 --> TB5
        TB5 --> FA
        
        A6[Test case 5] --> TB6
        B6 --> TB6
        CIN6 --> TB6
        TB6 --> FA
        
        A7[Test case 6] --> TB7
        B7 --> TB7
        CIN7 --> TB7
        TB7 --> FA
        
        A8[Test case 7] --> TB8
        B8 --> TB8
        CIN8 --> TB8
        TB8 --> FA
    end
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module full_adder(
    input wire a,
    input wire b,
    input wire cin,
    output wire sum,
    output wire cout
);
    assign sum = a ^ b ^ cin;
    assign cout = (a & b) | (b & cin) | (a & cin);
endmodule

module testbench;
    reg a, b, cin;
    wire sum, cout;
    
    full_adder dut (
        .a(a),
        .b(b),
        .cin(cin),
        .sum(sum),
        .cout(cout)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        // Test case 0
        a = 0; b = 0; cin = 0;
        #10;
        
        // Test case 1
        a = 0; b = 0; cin = 1;
        #10;
        
        // Test case 2
        a = 0; b = 1; cin = 0;
        #10;
        
        // Test case 3
        a = 0; b = 1; cin = 1;
        #10;
        
        // Test case 4
        a = 1; b = 0; cin = 0;
        #10;
        
        // Test case 5
        a = 1; b = 0; cin = 1;
        #10;
        
        // Test case 6
        a = 1; b = 1; cin = 0;
        #10;
        
        // Test case 7
        a = 1; b = 1; cin = 1;
        #10;
        
        $finish;
    end
    
    initial begin
        $monitor(""Time=%0t a=%b b=%b cin=%b | sum=%b cout=%b"", $time, a, b, cin, sum, cout);
    end
endmodule",True,68,True,True,True,False,0.4,False,2.9107234477996826,7.549058675765991,tie,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,Combinational,simple,"Design a 2-bit comparator with inputs a[1:0], b[1:0] and outputs eq, gt, lt. Include testbench.",claude,"`timescale 1ns/1ps

module comparator(
    input wire [1:0] a,
    input wire [1:0] b,
    output reg eq,
    output reg gt,
    output reg lt
);

always @(*) begin
    if (a == b) begin
        eq = 1'b1;
        gt = 1'b0;
        lt = 1'b0;
    end
    else if (a > b) begin
        eq = 1'b0;
        gt = 1'b1;
        lt = 1'b0;
    end
    else begin
        eq = 1'b0;
        gt = 1'b0;
        lt = 1'b1;
    end
end

endmodule

module testbench;
    reg [1:0] a;
    reg [1:0] b;
    wire eq, gt, lt;
    
    comparator dut (
        .a(a),
        .b(b),
        .eq(eq),
        .gt(gt),
        .lt(lt)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        // Test all combinations
        a = 2'b00; b = 2'b00; #10;
        a = 2'b00; b = 2'b01; #10;
        a = 2'b00; b = 2'b10; #10;
        a = 2'b00; b = 2'b11; #10;
        a = 2'b01; b = 2'b00; #10;
        a = 2'b01; b = 2'b01; #10;
        a = 2'b01; b = 2'b10; #10;
        a = 2'b01; b = 2'b11; #10;
        a = 2'b10; b = 2'b00; #10;
        a = 2'b10; b = 2'b01; #10;
        a = 2'b10; b = 2'b10; #10;
        a = 2'b10; b = 2'b11; #10;
        a = 2'b11; b = 2'b00; #10;
        a = 2'b11; b = 2'b01; #10;
        a = 2'b11; b = 2'b10; #10;
        a = 2'b11; b = 2'b11; #10;
        
        $finish;
    end
    
    initial begin
        $monitor(""Time=%0t a=%b b=%b eq=%b gt=%b lt=%b"",
                 $time, a, b, eq, gt, lt);
    end
endmodule",True,73,True,True,True,False,0.4,False,7.679189443588257,7.278924465179443,"graph LR
    A0[a0] --> CMP1((2-bit Comparator))
    A1[a1] --> CMP1
    B0[b0] --> CMP1
    B1[b1] --> CMP1
    CMP1 --> EQ[eq]
    CMP1 --> GT[gt]
    CMP1 --> LT[lt]
    TB[TestBench] --> |test vectors| CMP1
    TB --> |verify| RES{Results}
    EQ --> RES
    GT --> RES
    LT --> RES
    CLK[Clock] --> TB
    RST[Reset] --> TB
    RES --> |pass/fail| STATUS[Test Status]","`timescale 1ns/1ps

module comparator_2bit(
    input wire a1, a0, b1, b0,
    output reg eq, gt, lt
);

always @(*) begin
    if ({a1,a0} > {b1,b0}) begin
        eq = 1'b0;
        gt = 1'b1;
        lt = 1'b0;
    end
    else if ({a1,a0} < {b1,b0}) begin
        eq = 1'b0;
        gt = 1'b0;
        lt = 1'b1;
    end
    else begin
        eq = 1'b1;
        gt = 1'b0;
        lt = 1'b0;
    end
end

endmodule

module testbench;
    reg a1, a0, b1, b0;
    reg clk, rst_n;
    wire eq, gt, lt;
    
    comparator_2bit dut(
        .a1(a1),
        .a0(a0),
        .b1(b1),
        .b0(b0),
        .eq(eq),
        .gt(gt),
        .lt(lt)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 0;
        rst_n = 0;
        
        // Test vectors
        {a1,a0,b1,b0} = 4'b0000;
        #10 {a1,a0,b1,b0} = 4'b0001;
        #10 {a1,a0,b1,b0} = 4'b0010;
        #10 {a1,a0,b1,b0} = 4'b0011;
        #10 {a1,a0,b1,b0} = 4'b1100;
        #10 {a1,a0,b1,b0} = 4'b1111;
        #10 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t a=%b%b b=%b%b eq=%b gt=%b lt=%b"",
                 $time, a1,a0, b1,b0, eq, gt, lt);
    end
endmodule",True,66,True,True,True,False,0.4,False,10.509396076202393,6.27675461769104,"Design a 2-bit comparator with inputs a[1:0], b[1:0] and outputs eq, gt, lt. Include testbench.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph LR
    A0[a0] --> CMP1((2-bit Comparator))
    A1[a1] --> CMP1
    B0[b0] --> CMP1
    B1[b1] --> CMP1
    CMP1 --> EQ[eq]
    CMP1 --> GT[gt]
    CMP1 --> LT[lt]
    TB[TestBench] --> |test vectors| CMP1
    TB --> |verify| RES{Results}
    EQ --> RES
    GT --> RES
    LT --> RES
    CLK[Clock] --> TB
    RST[Reset] --> TB
    RES --> |pass/fail| STATUS[Test Status]
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module comparator_2bit(
    input wire [1:0] a,
    input wire [1:0] b,
    output reg eq,
    output reg gt,
    output reg lt
);

always @(*) begin
    eq = (a == b);
    gt = (a > b);
    lt = (a < b);
end

endmodule

module testbench;
    reg clk;
    reg rst_n;
    reg [1:0] a;
    reg [1:0] b;
    wire eq, gt, lt;
    
    comparator_2bit dut(
        .a(a),
        .b(b),
        .eq(eq),
        .gt(gt),
        .lt(lt)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 0;
        rst_n = 0;
        a = 2'b00;
        b = 2'b00;
        
        #10 rst_n = 1;
        
        // Test all combinations
        #10 a = 2'b00; b = 2'b00;
        #10 a = 2'b00; b = 2'b01;
        #10 a = 2'b00; b = 2'b10;
        #10 a = 2'b00; b = 2'b11;
        #10 a = 2'b01; b = 2'b00;
        #10 a = 2'b01; b = 2'b01;
        #10 a = 2'b01; b = 2'b10;
        #10 a = 2'b01; b = 2'b11;
        #10 a = 2'b10; b = 2'b00;
        #10 a = 2'b10; b = 2'b01;
        #10 a = 2'b10; b = 2'b10;
        #10 a = 2'b10; b = 2'b11;
        #10 a = 2'b11; b = 2'b00;
        #10 a = 2'b11; b = 2'b01;
        #10 a = 2'b11; b = 2'b10;
        #10 a = 2'b11; b = 2'b11;
        
        #10 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t a=%b b=%b eq=%b gt=%b lt=%b"",
                 $time, a, b, eq, gt, lt);
    end
endmodule",True,72,True,True,True,False,0.4,False,7.985776662826538,7.729969501495361,tie,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,Combinational,simple,"Design a 2-bit comparator with inputs a[1:0], b[1:0] and outputs eq, gt, lt. Include testbench.",gpt-4o,"`timescale 1ns/1ps

module comparator_2bit(
    input wire [1:0] a,
    input wire [1:0] b,
    output reg eq,
    output reg gt,
    output reg lt
);

always @(*) begin
    if (a == b) begin
        eq = 1'b1;
        gt = 1'b0;
        lt = 1'b0;
    end else if (a > b) begin
        eq = 1'b0;
        gt = 1'b1;
        lt = 1'b0;
    end else begin
        eq = 1'b0;
        gt = 1'b0;
        lt = 1'b1;
    end
end

endmodule

module testbench;
    reg [1:0] a;
    reg [1:0] b;
    wire eq;
    wire gt;
    wire lt;

    comparator_2bit dut (
        .a(a),
        .b(b),
        .eq(eq),
        .gt(gt),
        .lt(lt)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        a = 2'b00; b = 2'b00;
        #10 a = 2'b01; b = 2'b00;
        #10 a = 2'b10; b = 2'b11;
        #10 a = 2'b11; b = 2'b11;
        #10 a = 2'b10; b = 2'b01;
        #10 $finish;
    end

    initial begin
        $monitor(""Time=%0t a=%b b=%b eq=%b gt=%b lt=%b"", 
                 $time, a, b, eq, gt, lt);
    end
endmodule",True,60,True,True,True,False,0.4,False,3.750709056854248,7.264919996261597,"graph LR
    A[a[1:0]] --> COMP(Comparator)
    B[b[1:0]] --> COMP
    COMP --> EQ[eq]
    COMP --> GT[gt]
    COMP --> LT[lt]

    subgraph Testbench
        TB_CLK[Clock] --> TB_COMP
        TB_RST[Reset] --> TB_COMP
        TB_A[Test a[1:0]] --> TB_COMP
        TB_B[Test b[1:0]] --> TB_COMP
        TB_COMP(Comparator)
        TB_COMP --> TB_EQ[Test eq]
        TB_COMP --> TB_GT[Test gt]
        TB_COMP --> TB_LT[Test lt]
    end","`timescale 1ns/1ps

module comparator(
    input wire [1:0] a,
    input wire [1:0] b,
    output reg eq,
    output reg gt,
    output reg lt
);

always @(*) begin
    if (a == b) begin
        eq = 1'b1;
        gt = 1'b0;
        lt = 1'b0;
    end else if (a > b) begin
        eq = 1'b0;
        gt = 1'b1;
        lt = 1'b0;
    end else begin
        eq = 1'b0;
        gt = 1'b0;
        lt = 1'b1;
    end
end

endmodule

module testbench;
    reg clk, rst_n;
    reg [1:0] a, b;
    wire eq, gt, lt;
    
    comparator dut (
        .a(a),
        .b(b),
        .eq(eq),
        .gt(gt),
        .lt(lt)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst_n = 1'b0;
        a = 2'b00;
        b = 2'b00;
        
        #20 rst_n = 1'b1;
        #10 a = 2'b01; b = 2'b10;
        #10 a = 2'b10; b = 2'b01;
        #10 a = 2'b11; b = 2'b11;
        #50 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b a=%b b=%b eq=%b gt=%b lt=%b"", 
                 $time, clk, rst_n, a, b, eq, gt, lt);
    end
endmodule",True,64,True,True,True,False,0.4,False,7.886395215988159,6.992146968841553,"Design a 2-bit comparator with inputs a[1:0], b[1:0] and outputs eq, gt, lt. Include testbench.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph LR
    A[a[1:0]] --> COMP(Comparator)
    B[b[1:0]] --> COMP
    COMP --> EQ[eq]
    COMP --> GT[gt]
    COMP --> LT[lt]

    subgraph Testbench
        TB_CLK[Clock] --> TB_COMP
        TB_RST[Reset] --> TB_COMP
        TB_A[Test a[1:0]] --> TB_COMP
        TB_B[Test b[1:0]] --> TB_COMP
        TB_COMP(Comparator)
        TB_COMP --> TB_EQ[Test eq]
        TB_COMP --> TB_GT[Test gt]
        TB_COMP --> TB_LT[Test lt]
    end
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module comparator(
    input wire [1:0] a,
    input wire [1:0] b,
    output reg eq,
    output reg gt,
    output reg lt
);

always @(*) begin
    if (a == b) begin
        eq = 1'b1;
        gt = 1'b0;
        lt = 1'b0;
    end else if (a > b) begin
        eq = 1'b0;
        gt = 1'b1;
        lt = 1'b0;
    end else begin
        eq = 1'b0;
        gt = 1'b0;
        lt = 1'b1;
    end
end

endmodule

module testbench;
    reg [1:0] a, b;
    wire eq, gt, lt;
    reg clk, rst;

    comparator uut (
        .a(a),
        .b(b),
        .eq(eq),
        .gt(gt),
        .lt(lt)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 1'b0;
        rst = 1'b0;
        a = 2'b00;
        b = 2'b00;

        #10 rst = 1'b1;
        #10 a = 2'b01; b = 2'b00;
        #10 a = 2'b10; b = 2'b10;
        #10 a = 2'b11; b = 2'b10;
        #10 a = 2'b00; b = 2'b11;
        #50 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t a=%b b=%b eq=%b gt=%b lt=%b"", 
                 $time, a, b, eq, gt, lt);
    end
endmodule",True,65,True,True,True,False,0.4,False,4.991760969161987,5.290876626968384,tie,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,Arithmetic,medium,"Design a 4-bit ALU supporting ADD, SUB, AND, OR operations. Inputs: a[3:0], b[3:0], op[1:0]. Outputs: result[3:0], zero. Include testbench.",claude,"`timescale 1ns/1ps

module alu(
    input wire [3:0] a,
    input wire [3:0] b,
    input wire [1:0] op,
    output reg [3:0] result,
    output wire zero
);

assign zero = (result == 4'b0000);

always @(*) begin
    case(op)
        2'b00: result = a + b;    // ADD
        2'b01: result = a - b;    // SUB
        2'b10: result = a & b;    // AND
        2'b11: result = a | b;    // OR
        default: result = 4'b0000;
    endcase
end

endmodule

module testbench;
    reg [3:0] a, b;
    reg [1:0] op;
    wire [3:0] result;
    wire zero;

    alu dut(
        .a(a),
        .b(b),
        .op(op),
        .result(result),
        .zero(zero)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        // Test ADD
        a = 4'b0011; b = 4'b0010; op = 2'b00;
        #10;

        // Test SUB
        a = 4'b0110; b = 4'b0011; op = 2'b01;
        #10;

        // Test AND
        a = 4'b1100; b = 4'b1010; op = 2'b10;
        #10;

        // Test OR
        a = 4'b1100; b = 4'b0011; op = 2'b11;
        #10;

        // Test zero flag
        a = 4'b0011; b = 4'b0011; op = 2'b01;
        #10;

        $finish;
    end

    initial begin
        $monitor(""Time=%0t a=%b b=%b op=%b result=%b zero=%b"",
                 $time, a, b, op, result, zero);
    end

endmodule",True,71,True,True,True,False,0.4,False,7.051755666732788,6.786912202835083,"graph LR
    A[a[3:0]] --> ALU((ALU Core))
    B[b[3:0]] --> ALU
    OP[op[1:0]] --> CTRL((Control Unit))
    CTRL --> ALU
    ALU --> RES[result[3:0]]
    ALU --> ZDET((Zero Detector))
    ZDET --> Z[zero]
    TB[Testbench] --> |Test Vectors| A
    TB --> |Test Vectors| B
    TB --> |Operation Select| OP
    TB --> |Expected Results| CMP((Comparator))
    RES --> CMP
    Z --> CMP
    CLK[Clock] --> TB
    RST[Reset] --> TB
    CMP --> PASS[Pass/Fail]","`timescale 1ns/1ps

// ALU Module
module alu(
    input wire [3:0] a,
    input wire [3:0] b,
    input wire [1:0] op,
    output reg [3:0] result,
    output wire zero
);

always @(*) begin
    case(op)
        2'b00: result = a + b;
        2'b01: result = a - b;
        2'b10: result = a & b;
        2'b11: result = a | b;
    endcase
end

assign zero = (result == 4'b0000);

endmodule

module testbench;
    reg clk;
    reg rst_n;
    reg [3:0] a;
    reg [3:0] b;
    reg [1:0] op;
    wire [3:0] result;
    wire zero;
    reg [4:0] test_vector;
    reg [3:0] expected_result;
    reg expected_zero;
    
    alu dut (
        .a(a),
        .b(b),
        .op(op),
        .result(result),
        .zero(zero)
    );
    
    initial begin
        $dumpfile(""alu.vcd"");
        $dumpvars(0, testbench);
        
        clk = 0;
        rst_n = 0;
        test_vector = 0;
        
        #10 rst_n = 1;
        
        // Test cases
        #10;
        a = 4'h5; b = 4'h3; op = 2'b00; // Add
        #10;
        a = 4'h6; b = 4'h2; op = 2'b01; // Subtract
        #10;
        a = 4'hF; b = 4'h3; op = 2'b10; // AND
        #10;
        a = 4'h5; b = 4'h3; op = 2'b11; // OR
        #10;
        
        $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t a=%h b=%h op=%b result=%h zero=%b"",
                 $time, a, b, op, result, zero);
    end
endmodule",True,75,True,True,True,,0.0,,10.997779846191406,0.02646946907043457,"Design a 4-bit ALU supporting ADD, SUB, AND, OR operations. Inputs: a[3:0], b[3:0], op[1:0]. Outputs: result[3:0], zero. Include testbench.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph LR
    A[a[3:0]] --> ALU((ALU Core))
    B[b[3:0]] --> ALU
    OP[op[1:0]] --> CTRL((Control Unit))
    CTRL --> ALU
    ALU --> RES[result[3:0]]
    ALU --> ZDET((Zero Detector))
    ZDET --> Z[zero]
    TB[Testbench] --> |Test Vectors| A
    TB --> |Test Vectors| B
    TB --> |Operation Select| OP
    TB --> |Expected Results| CMP((Comparator))
    RES --> CMP
    Z --> CMP
    CLK[Clock] --> TB
    RST[Reset] --> TB
    CMP --> PASS[Pass/Fail]
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module alu_core(
    input wire [3:0] a,
    input wire [3:0] b,
    input wire [1:0] op,
    output reg [3:0] result,
    output wire zero
);

always @(*) begin
    case(op)
        2'b00: result = a + b;    // ADD
        2'b01: result = a - b;    // SUB
        2'b10: result = a & b;    // AND
        2'b11: result = a | b;    // OR
        default: result = 4'b0000;
    endcase
end

assign zero = (result == 4'b0000);

endmodule

module testbench;
    reg clk;
    reg rst_n;
    reg [3:0] a;
    reg [3:0] b;
    reg [1:0] op;
    wire [3:0] result;
    wire zero;
    reg pass;
    reg [3:0] expected_result;
    reg expected_zero;

    alu_core dut (
        .a(a),
        .b(b),
        .op(op),
        .result(result),
        .zero(zero)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 0;
        rst_n = 0;
        pass = 1;
        
        // Test case 1: ADD
        #10 rst_n = 1;
        a = 4'b0011;
        b = 4'b0010;
        op = 2'b00;
        expected_result = 4'b0101;
        expected_zero = 0;
        #10 check_result;

        // Test case 2: SUB
        #10;
        a = 4'b0011;
        b = 4'b0011;
        op = 2'b01;
        expected_result = 4'b0000;
        expected_zero = 1;
        #10 check_result;

        // Test case 3: AND
        #10;
        a = 4'b1100;
        b = 4'b1010;
        op = 2'b10;
        expected_result = 4'b1000;
        expected_zero = 0;
        #10 check_result;

        // Test case 4: OR
        #10;
        a = 4'b1100;
        b = 4'b0011;
        op = 2'b11;
        expected_result = 4'b1111;
        expected_zero = 0;
        #10 check_result;

        #10;
        $display(""Test completed! Pass status: %b"", pass);
        $finish;
    end

    always #5 clk = ~clk;

    task check_result;
        begin
            if (result !== expected_result || zero !== expected_zero) begin
                $display(""Error at time %t"", $time);
                $display(""Expected: result=%b, zero=%b"", expected_result, expected_zero);
                $display(""Got: result=%b, zero=%b"", result, zero);
                pass = 0;
            end
        end
    endtask

    initial begin
        $monitor(""Time=%0t a=%b b=%b op=%b result=%b zero=%b"",
                 $time, a, b, op, result, zero);
    end

endmodule",True,112,True,True,True,False,0.4,False,10.639902830123901,7.459484577178955,tie,prompt_only > combined > mermaid_only,prompt_only > mermaid_only > combined
combined,Arithmetic,medium,"Design a 4-bit ALU supporting ADD, SUB, AND, OR operations. Inputs: a[3:0], b[3:0], op[1:0]. Outputs: result[3:0], zero. Include testbench.",gpt-4o,"`timescale 1ns/1ps

module alu(
    input wire [3:0] a,
    input wire [3:0] b,
    input wire [1:0] op,
    output reg [3:0] result,
    output reg zero
);

always @(*) begin
    case (op)
        2'b00: result = a + b;    // ADD
        2'b01: result = a - b;    // SUB
        2'b10: result = a & b;    // AND
        2'b11: result = a | b;    // OR
        default: result = 4'b0000;
    endcase
    zero = (result == 4'b0000) ? 1'b1 : 1'b0;
end

endmodule

module testbench;
    reg [3:0] a, b;
    reg [1:0] op;
    wire [3:0] result;
    wire zero;

    alu dut (
        .a(a),
        .b(b),
        .op(op),
        .result(result),
        .zero(zero)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        a = 4'b0001; b = 4'b0001; op = 2'b00; // Test ADD
        #10 a = 4'b0010; b = 4'b0001; op = 2'b01; // Test SUB
        #10 a = 4'b0101; b = 4'b0011; op = 2'b10; // Test AND
        #10 a = 4'b0101; b = 4'b0011; op = 2'b11; // Test OR
        #10 $finish;
    end

    initial begin
        $monitor(""Time=%0t a=%b b=%b op=%b result=%b zero=%b"",
                 $time, a, b, op, result, zero);
    end
endmodule",True,53,True,True,True,True,0.9,True,3.0833709239959717,7.417194604873657,"graph LR
    A[a[3:0]] --> ALU
    B[b[3:0]] --> ALU
    OP[op[1:0]] --> ALU
    ALU(4-bit ALU) --> RESULT[result[3:0]]
    ALU --> ZERO[zero]
    
    subgraph ALU
        ADDER(Adder)
        SUBTRACTOR(Subtractor)
        ANDGATE(AND Gate)
        ORGATE(OR Gate)
        MUX{Operation Selector}
        ADDER --> MUX
        SUBTRACTOR --> MUX
        ANDGATE --> MUX
        ORGATE --> MUX
        MUX --> RESULT
        
        A --> ADDER
        B --> ADDER
        A --> SUBTRACTOR
        B --> SUBTRACTOR
        A --> ANDGATE
        B --> ANDGATE
        A --> ORGATE
        B --> ORGATE
        OP --> MUX
    end
    
    TESTBENCH[4-bit ALU Testbench]
    TESTBENCH --> A
    TESTBENCH --> B
    TESTBENCH --> OP
    RESULT --> TESTBENCH
    ZERO --> TESTBENCH","`timescale 1ns/1ps

module alu_4bit(
    input wire [3:0] a,
    input wire [3:0] b,
    input wire [1:0] op,
    output reg [3:0] result,
    output reg zero
);

    wire [3:0] add_result, sub_result, and_result, or_result;
    reg [3:0] alu_out;

    // Adder
    assign add_result = a + b;
    
    // Subtractor
    assign sub_result = a - b;
    
    // AND Gate
    assign and_result = a & b;
    
    // OR Gate
    assign or_result = a | b;
    
    // Operation Selector
    always @(*) begin
        case(op)
            2'b00: alu_out = add_result;
            2'b01: alu_out = sub_result;
            2'b10: alu_out = and_result;
            2'b11: alu_out = or_result;
            default: alu_out = 4'b0000;
        endcase
    end

    // Output assignment
    always @(*) begin
        result = alu_out;
        zero = (alu_out == 4'b0000) ? 1'b1 : 1'b0;
    end

endmodule

module tb_alu_4bit;
    reg [3:0] a;
    reg [3:0] b;
    reg [1:0] op;
    wire [3:0] result;
    wire zero;

    alu_4bit uut (
        .a(a),
        .b(b),
        .op(op),
        .result(result),
        .zero(zero)
    );

    initial begin
        $dumpfile(""alu_4bit.vcd"");
        $dumpvars(0, tb_alu_4bit);

        // Initialize inputs
        a = 4'b0000;
        b = 4'b0000;
        op = 2'b00;

        // Test all operations
        #10 a = 4'b0101; b = 4'b0011; op = 2'b00; // Add
        #10 a = 4'b0101; b = 4'b0011; op = 2'b01; // Subtract
        #10 a = 4'b0101; b = 4'b0011; op = 2'b10; // AND
        #10 a = 4'b0101; b = 4'b0011; op = 2'b11; // OR

        #10 $finish;
    end

    initial begin
        $monitor(""Time=%0t a=%b b=%b op=%b result=%b zero=%b"", $time, a, b, op, result, zero);
    end
endmodule",True,81,False,True,True,,0.0,,8.061139822006226,0.015650510787963867,"Design a 4-bit ALU supporting ADD, SUB, AND, OR operations. Inputs: a[3:0], b[3:0], op[1:0]. Outputs: result[3:0], zero. Include testbench.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph LR
    A[a[3:0]] --> ALU
    B[b[3:0]] --> ALU
    OP[op[1:0]] --> ALU
    ALU(4-bit ALU) --> RESULT[result[3:0]]
    ALU --> ZERO[zero]
    
    subgraph ALU
        ADDER(Adder)
        SUBTRACTOR(Subtractor)
        ANDGATE(AND Gate)
        ORGATE(OR Gate)
        MUX{Operation Selector}
        ADDER --> MUX
        SUBTRACTOR --> MUX
        ANDGATE --> MUX
        ORGATE --> MUX
        MUX --> RESULT
        
        A --> ADDER
        B --> ADDER
        A --> SUBTRACTOR
        B --> SUBTRACTOR
        A --> ANDGATE
        B --> ANDGATE
        A --> ORGATE
        B --> ORGATE
        OP --> MUX
    end
    
    TESTBENCH[4-bit ALU Testbench]
    TESTBENCH --> A
    TESTBENCH --> B
    TESTBENCH --> OP
    RESULT --> TESTBENCH
    ZERO --> TESTBENCH
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module alu(
    input wire [3:0] a,
    input wire [3:0] b,
    input wire [1:0] op,
    output reg [3:0] result,
    output wire zero
);

wire [3:0] add_out, sub_out, and_out, or_out;
reg [3:0] mux_out;

assign add_out = a + b;
assign sub_out = a - b;
assign and_out = a & b;
assign or_out = a | b;

always @(*) begin
    case(op)
        2'b00: mux_out = add_out;
        2'b01: mux_out = sub_out;
        2'b10: mux_out = and_out;
        2'b11: mux_out = or_out;
        default: mux_out = 4'b0000;
    endcase
end

assign zero = (mux_out == 4'b0000);
assign result = mux_out;

endmodule

module testbench;
    reg [3:0] a, b;
    reg [1:0] op;
    wire [3:0] result;
    wire zero;
    
    alu dut (
        .a(a),
        .b(b),
        .op(op),
        .result(result),
        .zero(zero)
    );
    
    initial begin
        $dumpfile(""alu_tb.vcd"");
        $dumpvars(0, testbench);
        
        a = 4'b0000; b = 4'b0000; op = 2'b00;
        #10 a = 4'b0010; b = 4'b0011; op = 2'b00; // Test ADD
        #10 a = 4'b0100; b = 4'b0010; op = 2'b01; // Test SUB
        #10 a = 4'b0101; b = 4'b0011; op = 2'b10; // Test AND
        #10 a = 4'b0101; b = 4'b0010; op = 2'b11; // Test OR
        #10 a = 4'b0000; b = 4'b0000; op = 2'b00; // Test ZERO
        #10 $finish;
    end
    
    initial begin
        $monitor(""Time=%0t a=%b b=%b op=%b result=%b zero=%b"", 
                 $time, a, b, op, result, zero);
    end
endmodule",True,65,True,False,False,,0.0,,4.36592960357666,0.011477470397949219,prompt_only,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,Combinational,medium,"Create an 8:1 multiplexer with input data[7:0], select sel[2:0], and output out. Include testbench.",claude,"`timescale 1ns/1ps

module mux8to1(
    input wire [7:0] data,
    input wire [2:0] sel,
    output reg out
);

always @(*) begin
    case (sel)
        3'b000: out = data[0];
        3'b001: out = data[1];
        3'b010: out = data[2];
        3'b011: out = data[3];
        3'b100: out = data[4];
        3'b101: out = data[5];
        3'b110: out = data[6];
        3'b111: out = data[7];
        default: out = 1'b0;
    endcase
end

endmodule

module testbench;
    reg [7:0] data;
    reg [2:0] sel;
    wire out;

    mux8to1 dut (
        .data(data),
        .sel(sel),
        .out(out)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        data = 8'b10101010;
        
        sel = 3'b000; #10;
        sel = 3'b001; #10;
        sel = 3'b010; #10;
        sel = 3'b011; #10;
        sel = 3'b100; #10;
        sel = 3'b101; #10;
        sel = 3'b110; #10;
        sel = 3'b111; #10;

        data = 8'b11001100;
        
        sel = 3'b000; #10;
        sel = 3'b011; #10;
        sel = 3'b111; #10;

        $finish;
    end

    initial begin
        $monitor(""Time=%0t data=%b sel=%b out=%b"", 
                 $time, data, sel, out);
    end
endmodule",True,64,True,True,True,False,0.4,False,6.006500244140625,7.206167221069336,"graph LR
    D0[Data0] --> MUX{8:1 MUX}
    D1[Data1] --> MUX
    D2[Data2] --> MUX
    D3[Data3] --> MUX
    D4[Data4] --> MUX
    D5[Data5] --> MUX
    D6[Data6] --> MUX
    D7[Data7] --> MUX
    S0[Sel0] --> DEC((Decoder))
    S1[Sel1] --> DEC
    S2[Sel2] --> DEC
    DEC --> MUX
    MUX --> OUT[Output]
    TB[[Testbench]]
    TB -.-> D0
    TB -.-> D1
    TB -.-> D2
    TB -.-> D3
    TB -.-> D4
    TB -.-> D5
    TB -.-> D6
    TB -.-> D7
    TB -.-> S0
    TB -.-> S1
    TB -.-> S2
    OUT -.-> TB","`timescale 1ns/1ps

module mux8to1(
    input wire clk,
    input wire rst_n,
    input wire [7:0] data_in0,
    input wire [7:0] data_in1,
    input wire [7:0] data_in2,
    input wire [7:0] data_in3,
    input wire [7:0] data_in4,
    input wire [7:0] data_in5,
    input wire [7:0] data_in6,
    input wire [7:0] data_in7,
    input wire [2:0] sel,
    output reg [7:0] data_out
);

always @(posedge clk or negedge rst_n) begin
    if (!rst_n)
        data_out <= 8'b0;
    else
        case (sel)
            3'b000: data_out <= data_in0;
            3'b001: data_out <= data_in1;
            3'b010: data_out <= data_in2;
            3'b011: data_out <= data_in3;
            3'b100: data_out <= data_in4;
            3'b101: data_out <= data_in5;
            3'b110: data_out <= data_in6;
            3'b111: data_out <= data_in7;
            default: data_out <= 8'b0;
        endcase
end

endmodule

module testbench;
    reg clk, rst_n;
    reg [7:0] data_in0, data_in1, data_in2, data_in3;
    reg [7:0] data_in4, data_in5, data_in6, data_in7;
    reg [2:0] sel;
    wire [7:0] data_out;

    mux8to1 dut (
        .clk(clk),
        .rst_n(rst_n),
        .data_in0(data_in0),
        .data_in1(data_in1),
        .data_in2(data_in2),
        .data_in3(data_in3),
        .data_in4(data_in4),
        .data_in5(data_in5),
        .data_in6(data_in6),
        .data_in7(data_in7),
        .sel(sel),
        .data_out(data_out)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 0;
        rst_n = 0;
        data_in0 = 8'h11;
        data_in1 = 8'h22;
        data_in2 = 8'h33;
        data_in3 = 8'h44;
        data_in4 = 8'h55;
        data_in5 = 8'h66;
        data_in6 = 8'h77;
        data_in7 = 8'h88;
        sel = 3'b000;

        #10 rst_n = 1;
        
        #10 sel = 3'b001;
        #10 sel = 3'b010;
        #10 sel = 3'b011;
        #10 sel = 3'b100;
        #10 sel = 3'b101;
        #10 sel = 3'b110;
        #10 sel = 3'b111;
        
        #10 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t sel=%b data_out=%h"", $time, sel, data_out);
    end
endmodule",True,93,True,True,True,False,0.4,False,14.185315608978271,6.994136810302734,"Create an 8:1 multiplexer with input data[7:0], select sel[2:0], and output out. Include testbench.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph LR
    D0[Data0] --> MUX{8:1 MUX}
    D1[Data1] --> MUX
    D2[Data2] --> MUX
    D3[Data3] --> MUX
    D4[Data4] --> MUX
    D5[Data5] --> MUX
    D6[Data6] --> MUX
    D7[Data7] --> MUX
    S0[Sel0] --> DEC((Decoder))
    S1[Sel1] --> DEC
    S2[Sel2] --> DEC
    DEC --> MUX
    MUX --> OUT[Output]
    TB[[Testbench]]
    TB -.-> D0
    TB -.-> D1
    TB -.-> D2
    TB -.-> D3
    TB -.-> D4
    TB -.-> D5
    TB -.-> D6
    TB -.-> D7
    TB -.-> S0
    TB -.-> S1
    TB -.-> S2
    OUT -.-> TB
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module mux_8to1 (
    input wire [7:0] data,
    input wire [2:0] sel,
    output reg out
);

always @(*) begin
    case (sel)
        3'b000: out = data[0];
        3'b001: out = data[1];
        3'b010: out = data[2];
        3'b011: out = data[3];
        3'b100: out = data[4];
        3'b101: out = data[5];
        3'b110: out = data[6];
        3'b111: out = data[7];
        default: out = data[0];
    endcase
end

endmodule

module testbench;
    reg [7:0] data;
    reg [2:0] sel;
    wire out;

    mux_8to1 dut (
        .data(data),
        .sel(sel),
        .out(out)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        data = 8'b00000000;
        sel = 3'b000;

        #10 data = 8'b10101010;
        #10 sel = 3'b001;
        #10 sel = 3'b010;
        #10 sel = 3'b011;
        #10 sel = 3'b100;
        #10 sel = 3'b101;
        #10 sel = 3'b110;
        #10 sel = 3'b111;

        #10 data = 8'b11110000;
        #10 sel = 3'b000;
        #10 sel = 3'b111;

        #10 $finish;
    end

    initial begin
        $monitor(""Time=%0t data=%b sel=%b out=%b"", 
                 $time, data, sel, out);
    end
endmodule",True,63,True,True,True,False,0.4,False,5.955198049545288,6.85475492477417,tie,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,Combinational,medium,"Create an 8:1 multiplexer with input data[7:0], select sel[2:0], and output out. Include testbench.",gpt-4o,"`timescale 1ns/1ps

module mux_8to1(
    input wire [7:0] data,
    input wire [2:0] sel,
    output reg out
);

always @(*) begin
    case (sel)
        3'b000: out = data[0];
        3'b001: out = data[1];
        3'b010: out = data[2];
        3'b011: out = data[3];
        3'b100: out = data[4];
        3'b101: out = data[5];
        3'b110: out = data[6];
        3'b111: out = data[7];
        default: out = 1'b0;
    endcase
end

endmodule

module testbench;
    reg [7:0] data;
    reg [2:0] sel;
    wire out;
    
    mux_8to1 dut (
        .data(data),
        .sel(sel),
        .out(out)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        data = 8'b10101010;
        sel = 3'b000;
        
        #10 sel = 3'b001;
        #10 sel = 3'b010;
        #10 sel = 3'b011;
        #10 sel = 3'b100;
        #10 sel = 3'b101;
        #10 sel = 3'b110;
        #10 sel = 3'b111;
        #10 $finish;
    end
    
    initial begin
        $monitor(""Time=%0t sel=%b out=%b"", $time, sel, out);
    end
endmodule",True,56,True,True,True,False,0.4,False,2.9208133220672607,5.594624757766724,"graph LR
    CLK[Clock] --> MUX{8:1 Multiplexer}
    RST[Reset] --> MUX
    D0[data[0]] --> MUX
    D1[data[1]] --> MUX
    D2[data[2]] --> MUX
    D3[data[3]] --> MUX
    D4[data[4]] --> MUX
    D5[data[5]] --> MUX
    D6[data[6]] --> MUX
    D7[data[7]] --> MUX
    SEL0[sel[0]] --> MUX
    SEL1[sel[1]] --> MUX
    SEL2[sel[2]] --> MUX
    MUX --> OUT[out]
    TB[Testbench] --> MUX
    TB --> D0
    TB --> D1
    TB --> D2
    TB --> D3
    TB --> D4
    TB --> D5
    TB --> D6
    TB --> D7
    TB --> SEL0
    TB --> SEL1
    TB --> SEL2
    TB --> CLK
    TB --> RST
    TB --> OUT","`timescale 1ns/1ps

module multiplexer_8to1(
    input wire clk,
    input wire rst_n,
    input wire [7:0] data,
    input wire [2:0] sel,
    output reg out
);
    
    reg [7:0] data_reg;
    reg [2:0] sel_reg;
    
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            data_reg <= 8'b0;
            sel_reg <= 3'b0;
            out <= 1'b0;
        end else begin
            data_reg <= data;
            sel_reg <= sel;
            case (sel_reg)
                3'b000: out <= data_reg[0];
                3'b001: out <= data_reg[1];
                3'b010: out <= data_reg[2];
                3'b011: out <= data_reg[3];
                3'b100: out <= data_reg[4];
                3'b101: out <= data_reg[5];
                3'b110: out <= data_reg[6];
                3'b111: out <= data_reg[7];
                default: out <= 1'b0;
            endcase
        end
    end
    
endmodule

module testbench;
    reg clk, rst_n;
    reg [7:0] data;
    reg [2:0] sel;
    wire out;
    
    multiplexer_8to1 dut (
        .clk(clk),
        .rst_n(rst_n),
        .data(data),
        .sel(sel),
        .out(out)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst_n = 1'b0;
        data = 8'b0;
        sel = 3'b0;
        
        #20 rst_n = 1'b1;
        #10 data = 8'b10101010;
        #10 sel = 3'b000;
        #10 sel = 3'b001;
        #10 sel = 3'b010;
        #10 sel = 3'b011;
        #10 sel = 3'b100;
        #10 sel = 3'b101;
        #10 sel = 3'b110;
        #10 sel = 3'b111;
        #50 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b data=%b sel=%b out=%b"", 
                 $time, clk, rst_n, data, sel, out);
    end
endmodule",True,80,True,True,True,True,0.7,True,6.1023476123809814,6.649199962615967,"Create an 8:1 multiplexer with input data[7:0], select sel[2:0], and output out. Include testbench.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph LR
    CLK[Clock] --> MUX{8:1 Multiplexer}
    RST[Reset] --> MUX
    D0[data[0]] --> MUX
    D1[data[1]] --> MUX
    D2[data[2]] --> MUX
    D3[data[3]] --> MUX
    D4[data[4]] --> MUX
    D5[data[5]] --> MUX
    D6[data[6]] --> MUX
    D7[data[7]] --> MUX
    SEL0[sel[0]] --> MUX
    SEL1[sel[1]] --> MUX
    SEL2[sel[2]] --> MUX
    MUX --> OUT[out]
    TB[Testbench] --> MUX
    TB --> D0
    TB --> D1
    TB --> D2
    TB --> D3
    TB --> D4
    TB --> D5
    TB --> D6
    TB --> D7
    TB --> SEL0
    TB --> SEL1
    TB --> SEL2
    TB --> CLK
    TB --> RST
    TB --> OUT
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module mux_8to1(
    input wire clk,
    input wire rst,
    input wire [7:0] data,
    input wire [2:0] sel,
    output reg out
);

always @(posedge clk or posedge rst) begin
    if (rst)
        out <= 1'b0;
    else begin
        case (sel)
            3'b000: out <= data[0];
            3'b001: out <= data[1];
            3'b010: out <= data[2];
            3'b011: out <= data[3];
            3'b100: out <= data[4];
            3'b101: out <= data[5];
            3'b110: out <= data[6];
            3'b111: out <= data[7];
            default: out <= 1'b0;
        endcase
    end
end

endmodule

module testbench;
    reg clk, rst;
    reg [7:0] data;
    reg [2:0] sel;
    wire out;
    
    mux_8to1 dut (
        .clk(clk),
        .rst(rst),
        .data(data),
        .sel(sel),
        .out(out)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst = 1'b0;
        data = 8'b00000000;
        sel = 3'b000;
        
        #20 rst = 1'b1;
        #10 rst = 1'b0;
        #10 data = 8'b10101010;
        #10 sel = 3'b001;
        #20 sel = 3'b010;
        #20 sel = 3'b011;
        #20 sel = 3'b100;
        #20 sel = 3'b101;
        #20 sel = 3'b110;
        #20 sel = 3'b111;
        #50 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t clk=%b rst=%b data=%b sel=%b out=%b"", 
                 $time, clk, rst, data, sel, out);
    end
endmodule",True,73,True,True,True,True,0.7,True,3.3546502590179443,8.7107412815094,prompt_only,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,State Machine,medium,Design an FSM detecting pattern 1011 in serial input with overlapping detection. Include testbench with sequence: 10110111011.,claude,"`timescale 1ns/1ps

module pattern_detect(
    input wire clk,
    input wire rst_n,
    input wire data_in,
    output reg pattern_found
);

reg [2:0] state;
reg [2:0] next_state;

parameter S0 = 3'b000;
parameter S1 = 3'b001;
parameter S2 = 3'b010;
parameter S3 = 3'b011;
parameter S4 = 3'b100;

always @(posedge clk or negedge rst_n) begin
    if (!rst_n)
        state <= S0;
    else
        state <= next_state;
end

always @(*) begin
    case (state)
        S0: next_state = (data_in) ? S1 : S0;
        S1: next_state = (data_in) ? S1 : S2;
        S2: next_state = (data_in) ? S3 : S0;
        S3: next_state = (data_in) ? S4 : S2;
        S4: next_state = (data_in) ? S1 : S2;
        default: next_state = S0;
    endcase
end

always @(posedge clk or negedge rst_n) begin
    if (!rst_n)
        pattern_found <= 1'b0;
    else
        pattern_found <= (state == S3 && data_in == 1'b1);
end

endmodule

module testbench;
    reg clk;
    reg rst_n;
    reg data_in;
    wire pattern_found;
    
    pattern_detect dut (
        .clk(clk),
        .rst_n(rst_n),
        .data_in(data_in),
        .pattern_found(pattern_found)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 0;
        rst_n = 0;
        data_in = 0;
        
        #10 rst_n = 1;
        
        // Test sequence: 10110111011
        #10 data_in = 1;
        #10 data_in = 0;
        #10 data_in = 1;
        #10 data_in = 1;
        #10 data_in = 0;
        #10 data_in = 1;
        #10 data_in = 1;
        #10 data_in = 1;
        #10 data_in = 0;
        #10 data_in = 1;
        #10 data_in = 1;
        
        #20 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t rst_n=%b data_in=%b pattern_found=%b state=%b"", 
                 $time, rst_n, data_in, pattern_found, dut.state);
    end
endmodule",True,91,True,True,True,True,0.8,True,9.164167165756226,7.412968873977661,"graph TD
    CLK[Clock] --> FSM((Pattern FSM))
    RST[Reset] --> FSM
    SIN[Serial In] --> FSM
    FSM --> DET[Pattern Detected]
    FSM --> S0((State S0))
    FSM --> S1((State S1))
    FSM --> S2((State S2))
    FSM --> S3((State S3))
    TB[Testbench] --> |10110111011| SIN
    FSM --> |Current State| ST[[State Register]]
    ST --> |Next State| FSM
    CLK --> ST
    RST --> ST
    subgraph States
        S0
        S1
        S2
        S3
    end
    subgraph Test_Sequence
        TB
    end
    subgraph Control
        CLK
        RST
    end","`timescale 1ns/1ps

module pattern_detector(
    input wire clk,
    input wire rst,
    input wire sin,
    output reg pattern_detected
);

// State encoding
localparam S0 = 2'b00;
localparam S1 = 2'b01;
localparam S2 = 2'b10;
localparam S3 = 2'b11;

reg [1:0] current_state, next_state;

// State register
always @(posedge clk or posedge rst) begin
    if (rst)
        current_state <= S0;
    else
        current_state <= next_state;
end

// Next state logic
always @(*) begin
    case (current_state)
        S0: next_state = (sin) ? S1 : S0;
        S1: next_state = (sin) ? S1 : S2;
        S2: next_state = (sin) ? S3 : S0;
        S3: next_state = (sin) ? S1 : S2;
        default: next_state = S0;
    endcase
end

// Output logic
always @(*) begin
    pattern_detected = (current_state == S3 && sin == 1'b1);
end

endmodule

module testbench;
    reg clk, rst, sin;
    wire pattern_detected;
    
    pattern_detector dut (
        .clk(clk),
        .rst(rst),
        .sin(sin),
        .pattern_detected(pattern_detected)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 0;
        rst = 1;
        sin = 0;
        
        #10 rst = 0;
        
        // Test sequence: 10110111011
        #10 sin = 1;
        #10 sin = 0;
        #10 sin = 1;
        #10 sin = 1;
        #10 sin = 0;
        #10 sin = 1;
        #10 sin = 1;
        #10 sin = 1;
        #10 sin = 0;
        #10 sin = 1;
        #10 sin = 1;
        
        #20 rst = 1;
        #10 rst = 0;
        #20 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t rst=%b sin=%b state=%b detected=%b"",
                 $time, rst, sin, dut.current_state, pattern_detected);
    end
endmodule",True,89,True,True,True,True,0.7,True,11.8498375415802,7.406234979629517,"Design an FSM detecting pattern 1011 in serial input with overlapping detection. Include testbench with sequence: 10110111011.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph TD
    CLK[Clock] --> FSM((Pattern FSM))
    RST[Reset] --> FSM
    SIN[Serial In] --> FSM
    FSM --> DET[Pattern Detected]
    FSM --> S0((State S0))
    FSM --> S1((State S1))
    FSM --> S2((State S2))
    FSM --> S3((State S3))
    TB[Testbench] --> |10110111011| SIN
    FSM --> |Current State| ST[[State Register]]
    ST --> |Next State| FSM
    CLK --> ST
    RST --> ST
    subgraph States
        S0
        S1
        S2
        S3
    end
    subgraph Test_Sequence
        TB
    end
    subgraph Control
        CLK
        RST
    end
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module pattern_detector (
    input wire clk,
    input wire rst,
    input wire sin,
    output reg detected
);

reg [1:0] current_state, next_state;
parameter S0 = 2'b00, S1 = 2'b01, S2 = 2'b10, S3 = 2'b11;

always @(posedge clk or posedge rst) begin
    if (rst)
        current_state <= S0;
    else
        current_state <= next_state;
end

always @(*) begin
    next_state = current_state;
    detected = 1'b0;
    
    case (current_state)
        S0: if (sin) next_state = S1;
        S1: if (!sin) next_state = S2;
        S2: if (sin) next_state = S3;
        S3: begin
            if (sin) begin
                next_state = S1;
                detected = 1'b1;
            end
            else begin
                next_state = S2;
            end
        end
        default: next_state = S0;
    endcase
end

endmodule

module testbench;
    reg clk, rst, sin;
    wire detected;
    
    pattern_detector dut (
        .clk(clk),
        .rst(rst),
        .sin(sin),
        .detected(detected)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 0;
        rst = 1;
        sin = 0;
        
        #10 rst = 0;
        
        // Test sequence: 10110111011
        #10 sin = 1;
        #10 sin = 0;
        #10 sin = 1;
        #10 sin = 1;
        #10 sin = 0;
        #10 sin = 1;
        #10 sin = 1;
        #10 sin = 1;
        #10 sin = 0;
        #10 sin = 1;
        #10 sin = 1;
        
        #20 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t rst=%b sin=%b detected=%b state=%b"", 
                 $time, rst, sin, detected, dut.current_state);
    end
endmodule",True,86,True,True,True,False,0.4,False,7.498303651809692,8.187493085861206,combined,combined > prompt_only > mermaid_only,prompt_only > mermaid_only > combined
combined,State Machine,medium,Design an FSM detecting pattern 1011 in serial input with overlapping detection. Include testbench with sequence: 10110111011.,gpt-4o,"`timescale 1ns/1ps

module fsm_1011_detector(
    input wire clk,
    input wire rst_n,
    input wire serial_in,
    output reg pattern_detected
);

    typedef enum reg [2:0] {
        S0 = 3'b000,
        S1 = 3'b001,
        S2 = 3'b010,
        S3 = 3'b011,
        S4 = 3'b100
    } state_t;

    reg [2:0] current_state, next_state;

    always @(posedge clk or negedge rst_n) begin
        if (!rst_n)
            current_state <= S0;
        else
            current_state <= next_state;
    end

    always @(*) begin
        case (current_state)
            S0: next_state = serial_in ? S1 : S0;
            S1: next_state = serial_in ? S1 : S2;
            S2: next_state = serial_in ? S3 : S0;
            S3: next_state = serial_in ? S4 : S2;
            S4: next_state = serial_in ? S1 : S2;
            default: next_state = S0;
        endcase
    end

    always @(posedge clk or negedge rst_n) begin
        if (!rst_n)
            pattern_detected <= 1'b0;
        else if (current_state == S4 && serial_in)
            pattern_detected <= 1'b1;
        else
            pattern_detected <= 1'b0;
    end

endmodule

module testbench;
    reg clk, rst_n, serial_in;
    wire pattern_detected;

    fsm_1011_detector dut (
        .clk(clk),
        .rst_n(rst_n),
        .serial_in(serial_in),
        .pattern_detected(pattern_detected)
    );

    initial begin
        $dumpfile(""fsm_1011.vcd"");
        $dumpvars(0, testbench);

        clk = 1'b0;
        rst_n = 1'b0;
        serial_in = 1'b0;

        #5 rst_n = 1'b1;
        #10 serial_in = 1'b1; // 1
        #10 serial_in = 1'b0; // 0
        #10 serial_in = 1'b1; // 1
        #10 serial_in = 1'b1; // 1 -> Detect
        #10 serial_in = 1'b0; // 0
        #10 serial_in = 1'b1; // 1
        #10 serial_in = 1'b1; // 1
        #10 serial_in = 1'b1; // 1 -> Detect
        #10 serial_in = 1'b0; // 0
        #10 serial_in = 1'b1; // 1
        #10 serial_in = 1'b1; // 1 -> Detect
        #10 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b serial_in=%b pattern_detected=%b"",
                 $time, clk, rst_n, serial_in, pattern_detected);
    end
endmodule",True,89,True,True,True,,0.0,,6.97469687461853,0.016863584518432617,"graph LR
    CLK[Clock] --> FSM((FSM Controller))
    RST[Reset] --> FSM
    IN[Serial Input] --> FSM

    FSM --> |Pattern Detected| OUT[Output]
    
    FSM -- S0 --> S1((State 1))
    FSM -- S1 --> S2((State 2))
    FSM -- S2 --> S3((State 3))
    FSM -- S3 --> S0

    S0 --> |0| S0
    S0 --> |1| S1
    S1 --> |0| S2
    S1 --> |1| S1
    S2 --> |0| S0
    S2 --> |1| S3
    S3 --> |0| S2
    S3 --> |1| S1

    FSM --> TB[Testbench]
    TB --> |Input Sequence: 10110111011| IN
    TB --> CLK
    TB --> RST","`timescale 1ns/1ps

module fsm_controller(
    input wire clk,
    input wire rst_n,
    input wire serial_in,
    output reg pattern_detected
);

    reg [1:0] state, next_state;
    localparam S0 = 2'b00, S1 = 2'b01, S2 = 2'b10, S3 = 2'b11;

    always @(posedge clk or negedge rst_n) begin
        if (!rst_n)
            state <= S0;
        else
            state <= next_state;
    end

    always @(*) begin
        pattern_detected = 1'b0;
        next_state = S0;
        case (state)
            S0: begin
                if (serial_in)
                    next_state = S1;
                else
                    next_state = S0;
            end
            S1: begin
                if (serial_in)
                    next_state = S1;
                else
                    next_state = S2;
            end
            S2: begin
                if (serial_in)
                    next_state = S3;
                else
                    next_state = S0;
            end
            S3: begin
                if (serial_in)
                    next_state = S1;
                else
                    next_state = S2;
                pattern_detected = 1'b1;
            end
            default: next_state = S0;
        endcase
    end

endmodule

module testbench;
    reg clk, rst_n, serial_in;
    wire pattern_detected;

    fsm_controller dut (
        .clk(clk),
        .rst_n(rst_n),
        .serial_in(serial_in),
        .pattern_detected(pattern_detected)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst_n = 1'b0;
        serial_in = 1'b0;
        
        #20 rst_n = 1'b1;
        #30 serial_in = 1'b1; // Input sequence: 10110111011
        #10 serial_in = 1'b0;
        #10 serial_in = 1'b1;
        #10 serial_in = 1'b1;
        #10 serial_in = 1'b0;
        #10 serial_in = 1'b1;
        #10 serial_in = 1'b1;
        #10 serial_in = 1'b1;
        #10 serial_in = 1'b0;
        #10 serial_in = 1'b1;
        #10 serial_in = 1'b1;
        #50 $finish;
    end
    
    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b serial_in=%b pattern_detected=%b"", 
                 $time, clk, rst_n, serial_in, pattern_detected);
    end
endmodule",True,95,True,True,True,True,0.7,True,7.845598936080933,7.788604736328125,"Design an FSM detecting pattern 1011 in serial input with overlapping detection. Include testbench with sequence: 10110111011.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph LR
    CLK[Clock] --> FSM((FSM Controller))
    RST[Reset] --> FSM
    IN[Serial Input] --> FSM

    FSM --> |Pattern Detected| OUT[Output]
    
    FSM -- S0 --> S1((State 1))
    FSM -- S1 --> S2((State 2))
    FSM -- S2 --> S3((State 3))
    FSM -- S3 --> S0

    S0 --> |0| S0
    S0 --> |1| S1
    S1 --> |0| S2
    S1 --> |1| S1
    S2 --> |0| S0
    S2 --> |1| S3
    S3 --> |0| S2
    S3 --> |1| S1

    FSM --> TB[Testbench]
    TB --> |Input Sequence: 10110111011| IN
    TB --> CLK
    TB --> RST
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module fsm_controller(
    input wire clk,
    input wire rst_n,
    input wire serial_in,
    output reg pattern_detected
);

    // State encoding
    typedef enum reg [1:0] {
        S0 = 2'b00,
        S1 = 2'b01,
        S2 = 2'b10,
        S3 = 2'b11
    } state_t;

    state_t current_state, next_state;

    // State transition
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n)
            current_state <= S0;
        else
            current_state <= next_state;
    end

    // Next state logic
    always @(*) begin
        case (current_state)
            S0: next_state = (serial_in) ? S1 : S0;
            S1: next_state = (serial_in) ? S1 : S2;
            S2: next_state = (serial_in) ? S3 : S0;
            S3: next_state = (serial_in) ? S1 : S2;
            default: next_state = S0;
        endcase
    end

    // Output logic
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n)
            pattern_detected <= 1'b0;
        else if (current_state == S3 && serial_in == 1'b1)
            pattern_detected <= 1'b1;
        else
            pattern_detected <= 1'b0;
    end

endmodule

module testbench;
    reg clk, rst_n, serial_in;
    wire pattern_detected;

    fsm_controller dut (
        .clk(clk),
        .rst_n(rst_n),
        .serial_in(serial_in),
        .pattern_detected(pattern_detected)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 1'b0;
        rst_n = 1'b0;
        serial_in = 1'b0;

        #10 rst_n = 1'b1;

        // Input sequence: 10110111011
        #10 serial_in = 1'b1; // 1
        #10 serial_in = 1'b0; // 0
        #10 serial_in = 1'b1; // 1
        #10 serial_in = 1'b1; // 1
        #10 serial_in = 1'b0; // 0
        #10 serial_in = 1'b1; // 1
        #10 serial_in = 1'b1; // 1
        #10 serial_in = 1'b1; // 1
        #10 serial_in = 1'b0; // 0
        #10 serial_in = 1'b1; // 1
        #10 serial_in = 1'b1; // 1

        #50 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b serial_in=%b pattern_detected=%b"", 
                 $time, clk, rst_n, serial_in, pattern_detected);
    end

endmodule",True,95,True,False,False,,0.0,,5.293464183807373,0.011717081069946289,prompt_only,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,Sequential,medium,"Create a 4-bit PISO shift register with clock, reset, load, parallel input[3:0], and serial output. Include testbench.",claude,"`timescale 1ns/1ps

module piso_shift_reg(
    input wire clk,
    input wire rst_n,
    input wire load,
    input wire [3:0] parallel_in,
    output wire serial_out
);

reg [3:0] shift_reg;

assign serial_out = shift_reg[3];

always @(posedge clk or negedge rst_n) begin
    if (!rst_n)
        shift_reg <= 4'b0000;
    else if (load)
        shift_reg <= parallel_in;
    else
        shift_reg <= {shift_reg[2:0], 1'b0};
end

endmodule

module testbench;
    reg clk, rst_n, load;
    reg [3:0] parallel_in;
    wire serial_out;
    
    piso_shift_reg dut (
        .clk(clk),
        .rst_n(rst_n),
        .load(load),
        .parallel_in(parallel_in),
        .serial_out(serial_out)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 0;
        rst_n = 0;
        load = 0;
        parallel_in = 4'b0000;
        
        #10 rst_n = 1;
        #10 parallel_in = 4'b1101;
        #10 load = 1;
        #10 load = 0;
        
        #80 parallel_in = 4'b1010;
        #10 load = 1;
        #10 load = 0;
        
        #80 rst_n = 0;
        #20 rst_n = 1;
        #40 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t rst_n=%b load=%b parallel_in=%b serial_out=%b"", 
                 $time, rst_n, load, parallel_in, serial_out);
    end
endmodule",True,68,True,True,True,False,0.4,False,6.40610671043396,7.382011890411377,"graph LR
    CLK[Clock] --> D0[[FF0]]
    CLK[Clock] --> D1[[FF1]]
    CLK[Clock] --> D2[[FF2]]
    CLK[Clock] --> D3[[FF3]]
    RST[Reset] --> D0
    RST --> D1
    RST --> D2
    RST --> D3
    LOAD[Load] --> M0{MUX0}
    LOAD --> M1{MUX1}
    LOAD --> M2{MUX2}
    LOAD --> M3{MUX3}
    P0[P_IN0] --> M0
    P1[P_IN1] --> M1
    P2[P_IN2] --> M2
    P3[P_IN3] --> M3
    M0 --> D0
    M1 --> D1
    M2 --> D2
    M3 --> D3
    D0 --> M1
    D1 --> M2
    D2 --> M3
    D3 --> OUT[Serial_Out]
    TB[Testbench] -.-> CLK
    TB -.-> RST
    TB -.-> LOAD
    TB -.-> P0
    TB -.-> P1
    TB -.-> P2
    TB -.-> P3","`timescale 1ns/1ps

module shift_register(
    input wire clk,
    input wire rst,
    input wire load,
    input wire [3:0] p_in,
    output wire serial_out
);

reg [3:0] ff;

always @(posedge clk or posedge rst) begin
    if (rst) begin
        ff <= 4'b0000;
    end
    else begin
        if (load)
            ff <= p_in;
        else
            ff <= {ff[2:0], ff[3]};
    end
end

assign serial_out = ff[3];

endmodule

module testbench;
    reg clk, rst, load;
    reg [3:0] p_in;
    wire serial_out;

    shift_register dut (
        .clk(clk),
        .rst(rst),
        .load(load),
        .p_in(p_in),
        .serial_out(serial_out)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 0;
        rst = 1;
        load = 0;
        p_in = 4'b0000;

        #10 rst = 0;
        #10 load = 1;
        p_in = 4'b1010;
        #10 load = 0;
        
        #40 load = 1;
        p_in = 4'b1111;
        #10 load = 0;
        
        #40 rst = 1;
        #10 rst = 0;
        
        #50 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t rst=%b load=%b p_in=%b serial_out=%b"", 
                 $time, rst, load, p_in, serial_out);
    end
endmodule",True,72,True,True,True,False,0.4,False,10.926386833190918,7.2616071701049805,"Create a 4-bit PISO shift register with clock, reset, load, parallel input[3:0], and serial output. Include testbench.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph LR
    CLK[Clock] --> D0[[FF0]]
    CLK[Clock] --> D1[[FF1]]
    CLK[Clock] --> D2[[FF2]]
    CLK[Clock] --> D3[[FF3]]
    RST[Reset] --> D0
    RST --> D1
    RST --> D2
    RST --> D3
    LOAD[Load] --> M0{MUX0}
    LOAD --> M1{MUX1}
    LOAD --> M2{MUX2}
    LOAD --> M3{MUX3}
    P0[P_IN0] --> M0
    P1[P_IN1] --> M1
    P2[P_IN2] --> M2
    P3[P_IN3] --> M3
    M0 --> D0
    M1 --> D1
    M2 --> D2
    M3 --> D3
    D0 --> M1
    D1 --> M2
    D2 --> M3
    D3 --> OUT[Serial_Out]
    TB[Testbench] -.-> CLK
    TB -.-> RST
    TB -.-> LOAD
    TB -.-> P0
    TB -.-> P1
    TB -.-> P2
    TB -.-> P3
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module piso_shift_register(
    input wire clk,
    input wire rst,
    input wire load,
    input wire [3:0] p_in,
    output wire serial_out
);

reg [3:0] ff;

always @(posedge clk or posedge rst) begin
    if (rst) begin
        ff <= 4'b0000;
    end else begin
        if (load)
            ff <= p_in;
        else
            ff <= {ff[2:0], 1'b0};
    end
end

assign serial_out = ff[3];

endmodule

module testbench;
    reg clk;
    reg rst;
    reg load;
    reg [3:0] p_in;
    wire serial_out;

    piso_shift_register dut (
        .clk(clk),
        .rst(rst),
        .load(load),
        .p_in(p_in),
        .serial_out(serial_out)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 1'b0;
        rst = 1'b1;
        load = 1'b0;
        p_in = 4'b0000;

        #10 rst = 1'b0;
        #10 p_in = 4'b1101;
        load = 1'b1;
        #10 load = 1'b0;
        #50;
        
        p_in = 4'b1010;
        load = 1'b1;
        #10 load = 1'b0;
        #50;

        rst = 1'b1;
        #10 rst = 1'b0;
        #20 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t rst=%b load=%b p_in=%b serial_out=%b"", 
                 $time, rst, load, p_in, serial_out);
    end
endmodule",True,74,True,True,True,False,0.4,False,6.276480674743652,7.849837064743042,tie,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,Sequential,medium,"Create a 4-bit PISO shift register with clock, reset, load, parallel input[3:0], and serial output. Include testbench.",gpt-4o,"`timescale 1ns/1ps

module piso_shift_register (
    input wire clk,
    input wire rst_n,
    input wire load,
    input wire [3:0] parallel_in,
    output reg serial_out
);
    reg [3:0] shift_reg;

    always @(posedge clk or negedge rst_n) begin
        if (!rst_n)
            shift_reg <= 4'b0000;
        else if (load)
            shift_reg <= parallel_in;
        else
            shift_reg <= {shift_reg[2:0], 1'b0};
    end

    always @(posedge clk or negedge rst_n) begin
        if (!rst_n)
            serial_out <= 1'b0;
        else
            serial_out <= shift_reg[3];
    end
endmodule

module testbench;
    reg clk, rst_n, load;
    reg [3:0] parallel_in;
    wire serial_out;
    
    piso_shift_register dut (
        .clk(clk),
        .rst_n(rst_n),
        .load(load),
        .parallel_in(parallel_in),
        .serial_out(serial_out)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst_n = 1'b0;
        load = 1'b0;
        parallel_in = 4'b1010;
        
        #20 rst_n = 1'b1;
        #10 load = 1'b1;
        #10 load = 1'b0;
        #80;
        #20 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b load=%b parallel_in=%b serial_out=%b"", 
                 $time, clk, rst_n, load, parallel_in, serial_out);
    end
endmodule",True,64,True,True,True,True,0.7,True,3.489236354827881,8.995185375213623,"graph LR
    CLK[Clock] --> LOAD(Load Control)
    RST[Reset] --> LOAD
    PIN[Parallel Input [3:0]] --> LOAD
    LOAD --> SHIFT[[Shift Register]]
    CLK --> SHIFT
    RST --> SHIFT
    SHIFT --> SOUT[Serial Output]
    TESTBENCH[Testbench] --> CLK
    TESTBENCH --> RST
    TESTBENCH --> PIN
    SOUT --> TESTBENCH
    LOAD --> SHIFT","`timescale 1ns/1ps

module shift_register(
    input wire clk,
    input wire rst_n,
    input wire load,
    input wire [3:0] pin,
    output reg sout
);

reg [3:0] shift_reg;

always @(posedge clk or negedge rst_n) begin
    if (!rst_n)
        shift_reg <= 4'b0000;
    else if (load)
        shift_reg <= pin;
    else
        shift_reg <= {shift_reg[2:0], 1'b0}; // Shift left, insert 0
end

always @(posedge clk or negedge rst_n) begin
    if (!rst_n)
        sout <= 1'b0;
    else
        sout <= shift_reg[3]; // Serial output from MSB
end

endmodule

module testbench;
    reg clk, rst_n, load;
    reg [3:0] pin;
    wire sout;
    
    shift_register dut (
        .clk(clk),
        .rst_n(rst_n),
        .load(load),
        .pin(pin),
        .sout(sout)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst_n = 1'b0;
        load = 1'b0;
        pin = 4'b0000;
        
        #15 rst_n = 1'b1;
        #10 load = 1'b1; pin = 4'b1010;
        #10 load = 1'b0;
        #40 load = 1'b1; pin = 4'b1100;
        #10 load = 1'b0;
        #50 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b load=%b pin=%b sout=%b"", 
                 $time, clk, rst_n, load, pin, sout);
    end
endmodule",True,67,True,True,True,True,0.7,True,6.900957107543945,9.492055416107178,"Create a 4-bit PISO shift register with clock, reset, load, parallel input[3:0], and serial output. Include testbench.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph LR
    CLK[Clock] --> LOAD(Load Control)
    RST[Reset] --> LOAD
    PIN[Parallel Input [3:0]] --> LOAD
    LOAD --> SHIFT[[Shift Register]]
    CLK --> SHIFT
    RST --> SHIFT
    SHIFT --> SOUT[Serial Output]
    TESTBENCH[Testbench] --> CLK
    TESTBENCH --> RST
    TESTBENCH --> PIN
    SOUT --> TESTBENCH
    LOAD --> SHIFT
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module piso_shift_register (
    input wire clk,
    input wire rst_n,
    input wire load,
    input wire [3:0] parallel_in,
    output reg serial_out
);

    reg [3:0] shift_reg;

    always @(posedge clk or negedge rst_n) begin
        if (!rst_n)
            shift_reg <= 4'b0000;
        else if (load)
            shift_reg <= parallel_in;
        else
            shift_reg <= {shift_reg[2:0], 1'b0};
    end

    always @(posedge clk or negedge rst_n) begin
        if (!rst_n)
            serial_out <= 1'b0;
        else
            serial_out <= shift_reg[3];
    end

endmodule

module testbench;
    reg clk, rst_n, load;
    reg [3:0] parallel_in;
    wire serial_out;

    piso_shift_register dut (
        .clk(clk),
        .rst_n(rst_n),
        .load(load),
        .parallel_in(parallel_in),
        .serial_out(serial_out)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 1'b0;
        rst_n = 1'b0;
        load = 1'b0;
        parallel_in = 4'b0000;

        #20 rst_n = 1'b1;
        #10 load = 1'b1; parallel_in = 4'b1010;
        #10 load = 1'b0;
        #40 parallel_in = 4'b1100; load = 1'b1;
        #10 load = 1'b0;
        #50 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b load=%b parallel_in=%b serial_out=%b"", 
                 $time, clk, rst_n, load, parallel_in, serial_out);
    end
endmodule",True,67,True,True,True,True,0.7,True,3.388583183288574,15.053961992263794,prompt_only,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,Combinational,medium,"Design a 4-to-2 priority encoder with input in[3:0], output out[1:0], and valid bit. Highest bit has priority. Include testbench.",claude,"`timescale 1ns/1ps

module priority_encoder(
    input wire [3:0] in,
    output reg [1:0] out,
    output reg valid
);

always @(*) begin
    if (in[3]) begin
        out = 2'b11;
        valid = 1'b1;
    end
    else if (in[2]) begin
        out = 2'b10;
        valid = 1'b1;
    end
    else if (in[1]) begin
        out = 2'b01;
        valid = 1'b1;
    end
    else if (in[0]) begin
        out = 2'b00;
        valid = 1'b1;
    end
    else begin
        out = 2'b00;
        valid = 1'b0;
    end
end

endmodule

module testbench;
    reg [3:0] in;
    wire [1:0] out;
    wire valid;

    priority_encoder dut (
        .in(in),
        .out(out),
        .valid(valid)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        in = 4'b0000;
        #10 in = 4'b0001;
        #10 in = 4'b0010;
        #10 in = 4'b0100;
        #10 in = 4'b1000;
        #10 in = 4'b1111;
        #10 in = 4'b0011;
        #10 in = 4'b0101;
        #10 in = 4'b1010;
        #10 in = 4'b0000;
        #10 $finish;
    end

    initial begin
        $monitor(""Time=%0t in=%b out=%b valid=%b"", 
                 $time, in, out, valid);
    end
endmodule",True,66,True,True,True,False,0.4,False,5.740246534347534,7.227614879608154,"graph LR
    IN[in[3:0]] --> PE(Priority Encoder Logic)
    PE --> OUT[out[1:0]]
    PE --> VALID[valid]
    SUBGRAPH[Priority Encoder Component]
    
    TB1[Testbench Stimulus] -.-> IN
    OUT -.-> TB2[Output Monitor]
    VALID -.-> TB2
    
    subgraph Logic Details
        PE --> |if in[3]=1| ENC1{2'b11}
        PE --> |if in[2]=1| ENC2{2'b10}
        PE --> |if in[1]=1| ENC3{2'b01}
        PE --> |if in[0]=1| ENC4{2'b00}
        PE --> |if all 0| VCHK{valid=0}
    end
    
    style SUBGRAPH fill:#f9f,stroke:#333
    style TB1 fill:#ddf,stroke:#333
    style TB2 fill:#ddf,stroke:#333","`timescale 1ns/1ps

module priority_encoder(
    input wire [3:0] in,
    output reg [1:0] out,
    output reg valid
);

always @(*) begin
    if (in[3])
        begin out = 2'b11; valid = 1'b1; end
    else if (in[2])
        begin out = 2'b10; valid = 1'b1; end
    else if (in[1])
        begin out = 2'b01; valid = 1'b1; end
    else if (in[0])
        begin out = 2'b00; valid = 1'b1; end
    else
        begin out = 2'b00; valid = 1'b0; end
end

endmodule

module testbench;
    reg [3:0] in;
    wire [1:0] out;
    wire valid;
    
    priority_encoder dut (
        .in(in),
        .out(out),
        .valid(valid)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        in = 4'b0000;
        #10 in = 4'b0001;
        #10 in = 4'b0010;
        #10 in = 4'b0100;
        #10 in = 4'b1000;
        #10 in = 4'b1100;
        #10 in = 4'b0000;
        #10 $finish;
    end
    
    initial begin
        $monitor(""Time=%0t in=%b out=%b valid=%b"", 
                 $time, in, out, valid);
    end
endmodule",True,53,True,True,True,False,0.4,False,10.036258697509766,7.12449312210083,"Design a 4-to-2 priority encoder with input in[3:0], output out[1:0], and valid bit. Highest bit has priority. Include testbench.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph LR
    IN[in[3:0]] --> PE(Priority Encoder Logic)
    PE --> OUT[out[1:0]]
    PE --> VALID[valid]
    SUBGRAPH[Priority Encoder Component]
    
    TB1[Testbench Stimulus] -.-> IN
    OUT -.-> TB2[Output Monitor]
    VALID -.-> TB2
    
    subgraph Logic Details
        PE --> |if in[3]=1| ENC1{2'b11}
        PE --> |if in[2]=1| ENC2{2'b10}
        PE --> |if in[1]=1| ENC3{2'b01}
        PE --> |if in[0]=1| ENC4{2'b00}
        PE --> |if all 0| VCHK{valid=0}
    end
    
    style SUBGRAPH fill:#f9f,stroke:#333
    style TB1 fill:#ddf,stroke:#333
    style TB2 fill:#ddf,stroke:#333
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module priority_encoder(
    input wire [3:0] in,
    output reg [1:0] out,
    output reg valid
);

always @(*) begin
    if (in[3]) begin
        out = 2'b11;
        valid = 1'b1;
    end
    else if (in[2]) begin
        out = 2'b10;
        valid = 1'b1;
    end
    else if (in[1]) begin
        out = 2'b01;
        valid = 1'b1;
    end
    else if (in[0]) begin
        out = 2'b00;
        valid = 1'b1;
    end
    else begin
        out = 2'b00;
        valid = 1'b0;
    end
end

endmodule

module testbench;
    reg [3:0] in;
    wire [1:0] out;
    wire valid;

    priority_encoder dut (
        .in(in),
        .out(out),
        .valid(valid)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        // Test all input combinations
        in = 4'b0000; #10;
        in = 4'b0001; #10;
        in = 4'b0010; #10;
        in = 4'b0100; #10;
        in = 4'b1000; #10;
        in = 4'b1111; #10;
        in = 4'b0011; #10;
        in = 4'b0111; #10;
        
        $finish;
    end

    initial begin
        $monitor(""Time=%0t in=%b out=%b valid=%b"", $time, in, out, valid);
    end

endmodule",True,66,True,True,True,False,0.4,False,5.544556379318237,8.871978998184204,tie,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,Combinational,medium,"Design a 4-to-2 priority encoder with input in[3:0], output out[1:0], and valid bit. Highest bit has priority. Include testbench.",gpt-4o,"`timescale 1ns/1ps

module priority_encoder_4to2(
    input wire [3:0] in,
    output reg [1:0] out,
    output reg valid
);

always @(in) begin
    valid = 1'b0;
    out = 2'b00;
    
    if (in[3]) begin
        valid = 1'b1;
        out = 2'b11;
    end else if (in[2]) begin
        valid = 1'b1;
        out = 2'b10;
    end else if (in[1]) begin
        valid = 1'b1;
        out = 2'b01;
    end else if (in[0]) begin
        valid = 1'b1;
        out = 2'b00;
    end
end

endmodule

module testbench;
    reg [3:0] in;
    wire [1:0] out;
    wire valid;
    
    priority_encoder_4to2 dut (
        .in(in),
        .out(out),
        .valid(valid)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        in = 4'b0000; #10;
        in = 4'b0001; #10;
        in = 4'b0010; #10;
        in = 4'b0100; #10;
        in = 4'b1000; #10;
        in = 4'b1100; #10;
        in = 4'b1010; #10;
        in = 4'b0110; #10;
        in = 4'b1111; #10;
        
        $finish;
    end
    
    initial begin
        $monitor(""Time=%0t in=%b out=%b valid=%b"", $time, in, out, valid);
    end
endmodule",True,61,True,True,True,False,0.4,False,3.8146631717681885,6.237420558929443,"graph TD
    IN0[in[0]] --> ENCODER
    IN1[in[1]] --> ENCODER
    IN2[in[2]] --> ENCODER
    IN3[in[3]] --> ENCODER
    
    ENCODER((4-to-2 Priority Encoder))
    
    ENCODER --> OUT0[out[0]]
    ENCODER --> OUT1[out[1]]
    ENCODER --> VALID[Valid Bit]
    
    TESTBENCH[[Testbench]]
    CLK[Clock] --> TESTBENCH
    RST[Reset] --> TESTBENCH
    
    TESTBENCH --> IN0
    TESTBENCH --> IN1
    TESTBENCH --> IN2
    TESTBENCH --> IN3
    OUT0 --> TESTBENCH
    OUT1 --> TESTBENCH
    VALID --> TESTBENCH","`timescale 1ns/1ps

module priority_encoder (
    input wire [3:0] in,
    output reg [1:0] out,
    output reg valid
);

always @(*) begin
    valid = 1'b0;
    out = 2'b00;
    if (in[3]) begin
        valid = 1'b1;
        out = 2'b11;
    end else if (in[2]) begin
        valid = 1'b1;
        out = 2'b10;
    end else if (in[1]) begin
        valid = 1'b1;
        out = 2'b01;
    end else if (in[0]) begin
        valid = 1'b1;
        out = 2'b00;
    end
end

endmodule

module testbench;
    reg [3:0] in;
    reg clk, rst;
    wire [1:0] out;
    wire valid;
    
    priority_encoder dut (
        .in(in),
        .out(out),
        .valid(valid)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst = 1'b0;
        in = 4'b0000;
        
        #20 rst = 1'b1;
        #10 in = 4'b1000;
        #10 in = 4'b0100;
        #10 in = 4'b0010;
        #10 in = 4'b0001;
        #10 in = 4'b0000;
        #50 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t clk=%b rst=%b in=%b out=%b valid=%b"", 
                 $time, clk, rst, in, out, valid);
    end
endmodule",True,64,True,True,True,False,0.4,False,7.009508371353149,7.305713653564453,"Design a 4-to-2 priority encoder with input in[3:0], output out[1:0], and valid bit. Highest bit has priority. Include testbench.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph TD
    IN0[in[0]] --> ENCODER
    IN1[in[1]] --> ENCODER
    IN2[in[2]] --> ENCODER
    IN3[in[3]] --> ENCODER
    
    ENCODER((4-to-2 Priority Encoder))
    
    ENCODER --> OUT0[out[0]]
    ENCODER --> OUT1[out[1]]
    ENCODER --> VALID[Valid Bit]
    
    TESTBENCH[[Testbench]]
    CLK[Clock] --> TESTBENCH
    RST[Reset] --> TESTBENCH
    
    TESTBENCH --> IN0
    TESTBENCH --> IN1
    TESTBENCH --> IN2
    TESTBENCH --> IN3
    OUT0 --> TESTBENCH
    OUT1 --> TESTBENCH
    VALID --> TESTBENCH
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module priority_encoder(
    input wire [3:0] in,
    output reg [1:0] out,
    output reg valid
);

always @(*) begin
    valid = 1'b0;
    out = 2'b00;
    if (in[3]) begin
        valid = 1'b1;
        out = 2'b11;
    end else if (in[2]) begin
        valid = 1'b1;
        out = 2'b10;
    end else if (in[1]) begin
        valid = 1'b1;
        out = 2'b01;
    end else if (in[0]) begin
        valid = 1'b1;
        out = 2'b00;
    end
end

endmodule

module testbench;
    reg [3:0] in;
    wire [1:0] out;
    wire valid;
    reg clk, rst;

    priority_encoder pe (
        .in(in),
        .out(out),
        .valid(valid)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 1'b0;
        rst = 1'b0;
        in = 4'b0000;

        #20 rst = 1'b1;
        #10 in = 4'b0001;
        #10 in = 4'b0010;
        #10 in = 4'b0100;
        #10 in = 4'b1000;
        #10 in = 4'b0110;
        #10 in = 4'b1110;
        #10 in = 4'b0000;
        #50 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t in=%b out=%b valid=%b"",
                 $time, in, out, valid);
    end
endmodule",True,66,True,True,True,False,0.4,False,4.570640563964844,9.029513835906982,tie,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,State Machine,complex,"Design a traffic light FSM with 4 states: NS_GREEN, NS_YELLOW, EW_GREEN, EW_YELLOW. Inputs: clk, rst, emergency. Outputs: ns_light[1:0], ew_light[1:0]. Timing: GREEN=8 cycles, YELLOW=2 cycles. Emergency makes both RED. Include testbench.",claude,"`timescale 1ns/1ps

module traffic_light(
    input wire clk,
    input wire rst,
    input wire emergency,
    output reg [1:0] ns_light,
    output reg [1:0] ew_light
);

parameter GREEN = 2'b00;
parameter YELLOW = 2'b01;
parameter RED = 2'b10;

parameter NS_GREEN_STATE = 2'b00;
parameter NS_YELLOW_STATE = 2'b01;
parameter EW_GREEN_STATE = 2'b10;
parameter EW_YELLOW_STATE = 2'b11;

reg [1:0] state;
reg [3:0] timer;

always @(posedge clk or posedge rst) begin
    if (rst) begin
        state <= NS_GREEN_STATE;
        timer <= 4'd0;
        ns_light <= GREEN;
        ew_light <= RED;
    end
    else if (emergency) begin
        ns_light <= RED;
        ew_light <= RED;
        state <= NS_GREEN_STATE;
        timer <= 4'd0;
    end
    else begin
        case (state)
            NS_GREEN_STATE: begin
                if (timer >= 4'd7) begin
                    state <= NS_YELLOW_STATE;
                    timer <= 4'd0;
                    ns_light <= YELLOW;
                end
                else begin
                    timer <= timer + 1'b1;
                    ns_light <= GREEN;
                    ew_light <= RED;
                end
            end
            
            NS_YELLOW_STATE: begin
                if (timer >= 4'd1) begin
                    state <= EW_GREEN_STATE;
                    timer <= 4'd0;
                    ns_light <= RED;
                    ew_light <= GREEN;
                end
                else begin
                    timer <= timer + 1'b1;
                    ew_light <= RED;
                end
            end
            
            EW_GREEN_STATE: begin
                if (timer >= 4'd7) begin
                    state <= EW_YELLOW_STATE;
                    timer <= 4'd0;
                    ew_light <= YELLOW;
                end
                else begin
                    timer <= timer + 1'b1;
                    ns_light <= RED;
                    ew_light <= GREEN;
                end
            end
            
            EW_YELLOW_STATE: begin
                if (timer >= 4'd1) begin
                    state <= NS_GREEN_STATE;
                    timer <= 4'd0;
                    ns_light <= GREEN;
                    ew_light <= RED;
                end
                else begin
                    timer <= timer + 1'b1;
                    ns_light <= RED;
                end
            end
        endcase
    end
end

endmodule

module testbench;
    reg clk;
    reg rst;
    reg emergency;
    wire [1:0] ns_light;
    wire [1:0] ew_light;
    
    traffic_light dut (
        .clk(clk),
        .rst(rst),
        .emergency(emergency),
        .ns_light(ns_light),
        .ew_light(ew_light)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 0;
        rst = 1;
        emergency = 0;
        
        #10 rst = 0;
        
        // Normal operation
        #100;
        
        // Test emergency
        emergency = 1;
        #20;
        emergency = 0;
        
        // Continue normal operation
        #100;
        
        $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t rst=%b emergency=%b ns_light=%b ew_light=%b"",
                 $time, rst, emergency, ns_light, ew_light);
    end
endmodule",True,140,True,True,True,False,0.3,False,11.350216150283813,8.50614595413208,"graph TD
    CLK[clk] --> FSM((FSM Controller))
    RST[rst] --> FSM
    EMG[emergency] --> FSM
    
    FSM --> CNT[[Counter]]
    CLK --> CNT
    CNT --> FSM
    
    FSM --> NSLGT[ns_light]
    FSM --> EWLGT[ew_light]
    
    FSM --> NS_STATE{State Logic}
    NS_STATE --> |00|RED([RED])
    NS_STATE --> |01|GREEN([GREEN 8cy])
    NS_STATE --> |10|YELLOW([YELLOW 2cy])
    
    subgraph States
    S1([NS_GREEN]) --> S2([NS_YELLOW])
    S2 --> S3([EW_GREEN])
    S3 --> S4([EW_YELLOW])
    S4 --> S1
    EMG --> |Override|RED
    end
    
    subgraph Testbench
    TB_CLK[Test Clock] --> TB[[Testbench FSM]]
    TB_RST[Test Reset] --> TB
    TB_EMG[Test Emergency] --> TB
    TB --> TB_CHECK{Compare}
    TB_CHECK --> TB_RES[Results]
    end","`timescale 1ns/1ps

// Traffic Light Controller
module traffic_controller (
    input wire clk,
    input wire rst,
    input wire emergency,
    output reg [1:0] ns_light,
    output reg [1:0] ew_light
);

// State definitions
parameter NS_GREEN = 2'b00;
parameter NS_YELLOW = 2'b01;
parameter EW_GREEN = 2'b10;
parameter EW_YELLOW = 2'b11;

// Light colors
parameter RED = 2'b00;
parameter YELLOW = 2'b01;
parameter GREEN = 2'b10;

reg [1:0] state, next_state;
reg [3:0] counter;

always @(posedge clk or posedge rst) begin
    if (rst) begin
        state <= NS_GREEN;
        counter <= 4'd0;
    end
    else begin
        state <= next_state;
        counter <= (counter == 4'd9) ? 4'd0 : counter + 4'd1;
    end
end

always @(*) begin
    if (emergency) begin
        next_state = NS_GREEN;
        ns_light = RED;
        ew_light = RED;
    end
    else begin
        case (state)
            NS_GREEN: begin
                if (counter >= 4'd7) begin
                    next_state = NS_YELLOW;
                end
                else begin
                    next_state = NS_GREEN;
                end
                ns_light = GREEN;
                ew_light = RED;
            end
            
            NS_YELLOW: begin
                if (counter >= 4'd1) begin
                    next_state = EW_GREEN;
                end
                else begin
                    next_state = NS_YELLOW;
                end
                ns_light = YELLOW;
                ew_light = RED;
            end
            
            EW_GREEN: begin
                if (counter >= 4'd7) begin
                    next_state = EW_YELLOW;
                end
                else begin
                    next_state = EW_GREEN;
                end
                ns_light = RED;
                ew_light = GREEN;
            end
            
            EW_YELLOW: begin
                if (counter >= 4'd1) begin
                    next_state = NS_GREEN;
                end
                else begin
                    next_state = EW_YELLOW;
                end
                ns_light = RED;
                ew_light = YELLOW;
            end
            
            default: begin
                next_state = NS_GREEN;
                ns_light = RED;
                ew_light = RED;
            end
        endcase
    end
end

endmodule

module testbench;
    reg clk, rst, emergency;
    wire [1:0] ns_light, ew_light;
    
    traffic_controller dut (
        .clk(clk),
        .rst(rst),
        .emergency(emergency),
        .ns_light(ns_light),
        .ew_light(ew_light)
    );
    
    initial begin
        $dumpfile(""traffic.vcd"");
        $dumpvars(0, testbench);
        
        clk = 0;
        rst = 1;
        emergency = 0;
        
        #10 rst = 0;
        #100 emergency = 1;
        #20 emergency = 0;
        #200 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t rst=%b emergency=%b ns_light=%b ew_light=%b"",
                 $time, rst, emergency, ns_light, ew_light);
    end
endmodule",True,132,True,True,True,,0.0,,16.17497730255127,0.014699220657348633,"Design a traffic light FSM with 4 states: NS_GREEN, NS_YELLOW, EW_GREEN, EW_YELLOW. Inputs: clk, rst, emergency. Outputs: ns_light[1:0], ew_light[1:0]. Timing: GREEN=8 cycles, YELLOW=2 cycles. Emergency makes both RED. Include testbench.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph TD
    CLK[clk] --> FSM((FSM Controller))
    RST[rst] --> FSM
    EMG[emergency] --> FSM
    
    FSM --> CNT[[Counter]]
    CLK --> CNT
    CNT --> FSM
    
    FSM --> NSLGT[ns_light]
    FSM --> EWLGT[ew_light]
    
    FSM --> NS_STATE{State Logic}
    NS_STATE --> |00|RED([RED])
    NS_STATE --> |01|GREEN([GREEN 8cy])
    NS_STATE --> |10|YELLOW([YELLOW 2cy])
    
    subgraph States
    S1([NS_GREEN]) --> S2([NS_YELLOW])
    S2 --> S3([EW_GREEN])
    S3 --> S4([EW_YELLOW])
    S4 --> S1
    EMG --> |Override|RED
    end
    
    subgraph Testbench
    TB_CLK[Test Clock] --> TB[[Testbench FSM]]
    TB_RST[Test Reset] --> TB
    TB_EMG[Test Emergency] --> TB
    TB --> TB_CHECK{Compare}
    TB_CHECK --> TB_RES[Results]
    end
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module traffic_fsm (
    input wire clk,
    input wire rst,
    input wire emergency,
    output reg [1:0] ns_light,
    output reg [1:0] ew_light
);

localparam [1:0] RED = 2'b00;
localparam [1:0] GREEN = 2'b01;
localparam [1:0] YELLOW = 2'b10;

localparam [1:0] NS_GREEN = 2'b00;
localparam [1:0] NS_YELLOW = 2'b01;
localparam [1:0] EW_GREEN = 2'b10;
localparam [1:0] EW_YELLOW = 2'b11;

reg [1:0] state, next_state;
reg [3:0] counter;

always @(posedge clk or posedge rst) begin
    if (rst) begin
        state <= NS_GREEN;
        counter <= 4'd0;
    end
    else begin
        state <= next_state;
        counter <= (next_state != state) ? 4'd0 : counter + 1'b1;
    end
end

always @(*) begin
    if (emergency) begin
        next_state = state;
        ns_light = RED;
        ew_light = RED;
    end
    else begin
        case (state)
            NS_GREEN: begin
                ns_light = GREEN;
                ew_light = RED;
                next_state = (counter == 4'd7) ? NS_YELLOW : NS_GREEN;
            end
            
            NS_YELLOW: begin
                ns_light = YELLOW;
                ew_light = RED;
                next_state = (counter == 4'd1) ? EW_GREEN : NS_YELLOW;
            end
            
            EW_GREEN: begin
                ns_light = RED;
                ew_light = GREEN;
                next_state = (counter == 4'd7) ? EW_YELLOW : EW_GREEN;
            end
            
            EW_YELLOW: begin
                ns_light = RED;
                ew_light = YELLOW;
                next_state = (counter == 4'd1) ? NS_GREEN : EW_YELLOW;
            end
            
            default: begin
                next_state = NS_GREEN;
                ns_light = RED;
                ew_light = RED;
            end
        endcase
    end
end

endmodule

module testbench;
    reg clk, rst, emergency;
    wire [1:0] ns_light, ew_light;
    
    traffic_fsm dut (
        .clk(clk),
        .rst(rst),
        .emergency(emergency),
        .ns_light(ns_light),
        .ew_light(ew_light)
    );
    
    initial begin
        $dumpfile(""traffic.vcd"");
        $dumpvars(0, testbench);
        
        clk = 0;
        rst = 1;
        emergency = 0;
        
        #10 rst = 0;
        
        // Test normal operation
        #100;
        
        // Test emergency
        emergency = 1;
        #30;
        emergency = 0;
        
        // Let it run through a few more cycles
        #200;
        
        $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t rst=%b emergency=%b ns_light=%b ew_light=%b"",
                 $time, rst, emergency, ns_light, ew_light);
    end
endmodule",True,119,True,True,True,,0.0,,10.771766901016235,0.014602184295654297,prompt_only,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,State Machine,complex,"Design a traffic light FSM with 4 states: NS_GREEN, NS_YELLOW, EW_GREEN, EW_YELLOW. Inputs: clk, rst, emergency. Outputs: ns_light[1:0], ew_light[1:0]. Timing: GREEN=8 cycles, YELLOW=2 cycles. Emergency makes both RED. Include testbench.",gpt-4o,"`timescale 1ns/1ps

module traffic_light_fsm(
    input wire clk,
    input wire rst,
    input wire emergency,
    output reg [1:0] ns_light,
    output reg [1:0] ew_light
);

    typedef enum reg [1:0] {
        NS_GREEN = 2'b00,
        NS_YELLOW = 2'b01,
        EW_GREEN = 2'b10,
        EW_YELLOW = 2'b11
    } state_t;

    reg [1:0] current_state, next_state;
    reg [3:0] timer;

    always @(posedge clk or posedge rst) begin
        if (rst) begin
            current_state <= NS_GREEN;
            timer <= 4'b0000;
        end else if (emergency) begin
            current_state <= NS_GREEN;
            timer <= 4'b0000;
        end else begin
            if (timer == 4'b1001) begin
                current_state <= next_state;
                timer <= 4'b0000;
            end else begin
                timer <= timer + 1'b1;
            end
        end
    end

    always @(current_state or timer or emergency) begin
        if (emergency) begin
            ns_light = 2'b11;
            ew_light = 2'b11;
            next_state = NS_GREEN;
        end else begin
            case (current_state)
                NS_GREEN: begin
                    ns_light = 2'b00; // Green
                    ew_light = 2'b11; // Red
                    if (timer == 4'b0111) begin
                        next_state = NS_YELLOW;
                    end else begin
                        next_state = NS_GREEN;
                    end
                end
                NS_YELLOW: begin
                    ns_light = 2'b01; // Yellow
                    ew_light = 2'b11; // Red
                    if (timer == 4'b0001) begin
                        next_state = EW_GREEN;
                    end else begin
                        next_state = NS_YELLOW;
                    end
                end
                EW_GREEN: begin
                    ns_light = 2'b11; // Red
                    ew_light = 2'b00; // Green
                    if (timer == 4'b0111) begin
                        next_state = EW_YELLOW;
                    end else begin
                        next_state = EW_GREEN;
                    end
                end
                EW_YELLOW: begin
                    ns_light = 2'b11; // Red
                    ew_light = 2'b01; // Yellow
                    if (timer == 4'b0001) begin
                        next_state = NS_GREEN;
                    end else begin
                        next_state = EW_YELLOW;
                    end
                end
                default: begin
                    ns_light = 2'b11; // Red
                    ew_light = 2'b11; // Red
                    next_state = NS_GREEN;
                end
            endcase
        end
    end
endmodule

module testbench;
    reg clk, rst, emergency;
    wire [1:0] ns_light, ew_light;
    
    traffic_light_fsm dut (
        .clk(clk),
        .rst(rst),
        .emergency(emergency),
        .ns_light(ns_light),
        .ew_light(ew_light)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst = 1'b1;
        emergency = 1'b0;
        
        #15 rst = 1'b0;
        #200 emergency = 1'b1;
        #20 emergency = 1'b0;
        #200 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t clk=%b rst=%b emergency=%b ns_light=%b ew_light=%b"", 
                 $time, clk, rst, emergency, ns_light, ew_light);
    end
endmodule",True,123,True,True,True,True,0.9,True,7.816883563995361,8.521955966949463,"graph LR
    CLK[Clock] --> FSM
    RST[Reset] --> FSM
    E[Emergency] --> FSM
    
    FSM(NS_GREEN)
    FSM -->|Clk 8 cycles| NS_YELLOW
    NS_YELLOW -->|Clk 2 cycles| EW_GREEN
    EW_GREEN -->|Clk 8 cycles| EW_YELLOW
    EW_YELLOW -->|Clk 2 cycles| NS_GREEN
    
    E -->|Emergency| EMERGENCY{Emergency?}
    EMERGENCY -->|Yes| ALL_RED
    EMERGENCY -->|No| FSM
    ALL_RED(RED)
    
    FSM --> NS_LIGHT[NS Light (ns_light[1:0])]
    FSM --> EW_LIGHT[EW Light (ew_light[1:0])]
    ALL_RED --> NS_LIGHT
    ALL_RED --> EW_LIGHT

    TB[[Testbench]]
    TB --> CLK
    TB --> RST
    TB --> E
    TB --> NS_LIGHT
    TB --> EW_LIGHT","`timescale 1ns/1ps

module traffic_light_fsm(
    input wire clk,
    input wire rst_n,
    input wire emergency,
    output reg [1:0] ns_light,
    output reg [1:0] ew_light
);

    // State encoding
    localparam NS_GREEN = 2'b00,
               NS_YELLOW = 2'b01,
               EW_GREEN = 2'b10,
               EW_YELLOW = 2'b11,
               ALL_RED = 2'b00;

    reg [1:0] state, next_state;
    reg [3:0] cycle_count;

    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            state <= NS_GREEN;
            cycle_count <= 4'b0000;
        end else if (emergency) begin
            state <= ALL_RED;
        end else begin
            state <= next_state;
            if (state == next_state) begin
                cycle_count <= cycle_count + 1'b1;
            end else begin
                cycle_count <= 4'b0000;
            end
        end
    end

    always @(*) begin
        case (state)
            NS_GREEN: begin
                ns_light = 2'b01; // Green
                ew_light = 2'b10; // Red
                if (cycle_count == 4'b1000) begin
                    next_state = NS_YELLOW;
                end else begin
                    next_state = NS_GREEN;
                end
            end
            NS_YELLOW: begin
                ns_light = 2'b10; // Yellow
                ew_light = 2'b10; // Red
                if (cycle_count == 4'b0010) begin
                    next_state = EW_GREEN;
                end else begin
                    next_state = NS_YELLOW;
                end
            end
            EW_GREEN: begin
                ns_light = 2'b10; // Red
                ew_light = 2'b01; // Green
                if (cycle_count == 4'b1000) begin
                    next_state = EW_YELLOW;
                end else begin
                    next_state = EW_GREEN;
                end
            end
            EW_YELLOW: begin
                ns_light = 2'b10; // Red
                ew_light = 2'b10; // Yellow
                if (cycle_count == 4'b0010) begin
                    next_state = NS_GREEN;
                end else begin
                    next_state = EW_YELLOW;
                end
            end
            ALL_RED: begin
                ns_light = 2'b10; // Red
                ew_light = 2'b10; // Red
                next_state = ALL_RED;
            end
            default: begin
                ns_light = 2'b10; // Red
                ew_light = 2'b10; // Red
                next_state = NS_GREEN;
            end
        endcase
    end
endmodule

module testbench;
    reg clk, rst_n, emergency;
    wire [1:0] ns_light, ew_light;

    traffic_light_fsm dut (
        .clk(clk),
        .rst_n(rst_n),
        .emergency(emergency),
        .ns_light(ns_light),
        .ew_light(ew_light)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 1'b0;
        rst_n = 1'b0;
        emergency = 1'b0;

        #20 rst_n = 1'b1;
        #80 emergency = 1'b1;
        #10 emergency = 1'b0;
        #200 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b emergency=%b ns_light=%b ew_light=%b"",
                 $time, clk, rst_n, emergency, ns_light, ew_light);
    end
endmodule",True,121,True,True,True,True,0.7,True,15.590109825134277,9.518812894821167,"Design a traffic light FSM with 4 states: NS_GREEN, NS_YELLOW, EW_GREEN, EW_YELLOW. Inputs: clk, rst, emergency. Outputs: ns_light[1:0], ew_light[1:0]. Timing: GREEN=8 cycles, YELLOW=2 cycles. Emergency makes both RED. Include testbench.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph LR
    CLK[Clock] --> FSM
    RST[Reset] --> FSM
    E[Emergency] --> FSM
    
    FSM(NS_GREEN)
    FSM -->|Clk 8 cycles| NS_YELLOW
    NS_YELLOW -->|Clk 2 cycles| EW_GREEN
    EW_GREEN -->|Clk 8 cycles| EW_YELLOW
    EW_YELLOW -->|Clk 2 cycles| NS_GREEN
    
    E -->|Emergency| EMERGENCY{Emergency?}
    EMERGENCY -->|Yes| ALL_RED
    EMERGENCY -->|No| FSM
    ALL_RED(RED)
    
    FSM --> NS_LIGHT[NS Light (ns_light[1:0])]
    FSM --> EW_LIGHT[EW Light (ew_light[1:0])]
    ALL_RED --> NS_LIGHT
    ALL_RED --> EW_LIGHT

    TB[[Testbench]]
    TB --> CLK
    TB --> RST
    TB --> E
    TB --> NS_LIGHT
    TB --> EW_LIGHT
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module traffic_light_fsm (
    input wire clk,
    input wire rst,
    input wire emergency,
    output reg [1:0] ns_light,
    output reg [1:0] ew_light
);

    // State encoding
    localparam NS_GREEN  = 2'b00,
               NS_YELLOW = 2'b01,
               EW_GREEN  = 2'b10,
               EW_YELLOW = 2'b11,
               ALL_RED   = 2'b00;

    // Output encoding
    localparam GREEN  = 2'b01,
               YELLOW = 2'b10,
               RED    = 2'b11;

    reg [1:0] state, next_state;
    reg [3:0] cycle_count;

    always @(posedge clk or posedge rst) begin
        if (rst) begin
            state <= NS_GREEN;
            cycle_count <= 4'b0000;
        end else if (emergency) begin
            state <= ALL_RED;
            cycle_count <= 4'b0000;
        end else begin
            state <= next_state;
            cycle_count <= (cycle_count == 4'b1001) ? 4'b0000 : cycle_count + 1'b1;
        end
    end

    always @(*) begin
        case (state)
            NS_GREEN: begin
                if (cycle_count == 4'b1000)
                    next_state = NS_YELLOW;
                else
                    next_state = NS_GREEN;
            end
            NS_YELLOW: begin
                if (cycle_count == 4'b0010)
                    next_state = EW_GREEN;
                else
                    next_state = NS_YELLOW;
            end
            EW_GREEN: begin
                if (cycle_count == 4'b1000)
                    next_state = EW_YELLOW;
                else
                    next_state = EW_GREEN;
            end
            EW_YELLOW: begin
                if (cycle_count == 4'b0010)
                    next_state = NS_GREEN;
                else
                    next_state = EW_YELLOW;
            end
            default: next_state = NS_GREEN;
        endcase
    end

    always @(*) begin
        case (state)
            NS_GREEN: begin
                ns_light = GREEN;
                ew_light = RED;
            end
            NS_YELLOW: begin
                ns_light = YELLOW;
                ew_light = RED;
            end
            EW_GREEN: begin
                ns_light = RED;
                ew_light = GREEN;
            end
            EW_YELLOW: begin
                ns_light = RED;
                ew_light = YELLOW;
            end
            ALL_RED: begin
                ns_light = RED;
                ew_light = RED;
            end
            default: begin
                ns_light = RED;
                ew_light = RED;
            end
        endcase
    end

endmodule

module testbench;
    reg clk, rst, emergency;
    wire [1:0] ns_light, ew_light;

    traffic_light_fsm dut (
        .clk(clk),
        .rst(rst),
        .emergency(emergency),
        .ns_light(ns_light),
        .ew_light(ew_light)
    );

    initial begin
        $dumpfile(""traffic_light_fsm.vcd"");
        $dumpvars(0, testbench);

        clk = 1'b0;
        rst = 1'b1;
        emergency = 1'b0;
        
        #20 rst = 1'b0;
        #160 emergency = 1'b1;
        #20 emergency = 1'b0;
        #100 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t clk=%b rst=%b emergency=%b ns_light=%b ew_light=%b"", 
                 $time, clk, rst, emergency, ns_light, ew_light);
    end
endmodule",True,132,True,True,True,,0.0,,7.133629322052002,0.015329122543334961,prompt_only,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,State Machine,complex,"Design UART transmitter with states: IDLE, START, DATA, STOP. Protocol: START(0), 8 data bits LSB-first, STOP(1). Baud rate divider. Include testbench.",claude,"`timescale 1ns/1ps

module uart_tx(
    input wire clk,
    input wire rst_n,
    input wire tx_start,
    input wire [7:0] tx_data,
    output reg tx_out,
    output reg tx_done
);

parameter BAUD_DIV = 16;
parameter IDLE = 2'b00;
parameter START = 2'b01;
parameter DATA = 2'b10;
parameter STOP = 2'b11;

reg [1:0] state;
reg [7:0] data_reg;
reg [2:0] bit_count;
reg [3:0] baud_count;

always @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
        state <= IDLE;
        tx_out <= 1'b1;
        tx_done <= 1'b0;
        data_reg <= 8'b0;
        bit_count <= 3'b0;
        baud_count <= 4'b0;
    end
    else begin
        case (state)
            IDLE: begin
                tx_out <= 1'b1;
                if (tx_start) begin
                    state <= START;
                    data_reg <= tx_data;
                    baud_count <= 4'b0;
                    tx_done <= 1'b0;
                end
            end
            
            START: begin
                tx_out <= 1'b0;
                if (baud_count == BAUD_DIV-1) begin
                    state <= DATA;
                    bit_count <= 3'b0;
                    baud_count <= 4'b0;
                end
                else
                    baud_count <= baud_count + 1'b1;
            end
            
            DATA: begin
                tx_out <= data_reg[bit_count];
                if (baud_count == BAUD_DIV-1) begin
                    baud_count <= 4'b0;
                    if (bit_count == 3'b111)
                        state <= STOP;
                    else
                        bit_count <= bit_count + 1'b1;
                end
                else
                    baud_count <= baud_count + 1'b1;
            end
            
            STOP: begin
                tx_out <= 1'b1;
                if (baud_count == BAUD_DIV-1) begin
                    state <= IDLE;
                    tx_done <= 1'b1;
                end
                else
                    baud_count <= baud_count + 1'b1;
            end
        endcase
    end
end

endmodule

module testbench;
    reg clk;
    reg rst_n;
    reg tx_start;
    reg [7:0] tx_data;
    wire tx_out;
    wire tx_done;
    
    uart_tx dut (
        .clk(clk),
        .rst_n(rst_n),
        .tx_start(tx_start),
        .tx_data(tx_data),
        .tx_out(tx_out),
        .tx_done(tx_done)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 0;
        rst_n = 0;
        tx_start = 0;
        tx_data = 0;
        
        #20 rst_n = 1;
        #20 tx_data = 8'hA5;
        #20 tx_start = 1;
        #20 tx_start = 0;
        
        #1000 tx_data = 8'h3C;
        #20 tx_start = 1;
        #20 tx_start = 0;
        
        #1000 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t tx_out=%b tx_done=%b"", $time, tx_out, tx_done);
    end
endmodule",True,126,True,True,True,False,0.3,False,11.845451354980469,7.094269037246704,"graph LR
    CLK[Clock Input] --> BAUDGEN(Baud Generator)
    CLK --> FSM(State Machine)
    RST[Reset] --> FSM
    BAUDGEN --> FSM
    
    TX_START[TX Start] --> FSM
    TX_DATA[TX Data<7:0>] --> SHIFTREG[[Shift Register]]
    
    FSM --> |State| SHIFTREG
    FSM --> |Control| MUX{Output MUX}
    SHIFTREG --> MUX
    
    subgraph States
        IDLE --> START
        START --> DATA
        DATA --> STOP
        STOP --> IDLE
    end
    
    MUX --> TX_OUT[TX Output]
    
    subgraph Testbench
        TB_CLK[TB Clock] --> TB_STIM(Stimulus Generator)
        TB_STIM --> TB_CHECK(Response Checker)
        TX_OUT --> TB_CHECK
    end","`timescale 1ns/1ps

module uart_tx (
    input wire clk,
    input wire rst,
    input wire tx_start,
    input wire [7:0] tx_data,
    input wire baud_tick,
    output reg tx_out
);

localparam IDLE = 2'b00;
localparam START = 2'b01;
localparam DATA = 2'b10;
localparam STOP = 2'b11;

reg [1:0] state, next_state;
reg [2:0] bit_count;
reg [7:0] shift_reg;

always @(posedge clk or posedge rst) begin
    if (rst) begin
        state <= IDLE;
        bit_count <= 3'b000;
        shift_reg <= 8'h00;
        tx_out <= 1'b1;
    end
    else begin
        if (baud_tick) begin
            state <= next_state;
            case (state)
                IDLE: begin
                    tx_out <= 1'b1;
                    if (tx_start)
                        shift_reg <= tx_data;
                end
                START: begin
                    tx_out <= 1'b0;
                end
                DATA: begin
                    tx_out <= shift_reg[0];
                    shift_reg <= {1'b0, shift_reg[7:1]};
                    bit_count <= bit_count + 1'b1;
                end
                STOP: begin
                    tx_out <= 1'b1;
                end
            endcase
        end
    end
end

always @(*) begin
    case (state)
        IDLE: next_state = tx_start ? START : IDLE;
        START: next_state = DATA;
        DATA: next_state = (bit_count == 3'b111) ? STOP : DATA;
        STOP: next_state = IDLE;
        default: next_state = IDLE;
    endcase
end

endmodule

module baud_gen (
    input wire clk,
    output reg baud_tick
);

reg [3:0] count;

always @(posedge clk) begin
    if (count == 4'd15) begin
        count <= 4'd0;
        baud_tick <= 1'b1;
    end
    else begin
        count <= count + 1'b1;
        baud_tick <= 1'b0;
    end
end

endmodule

module testbench;
    reg clk, rst, tx_start;
    reg [7:0] tx_data;
    wire tx_out, baud_tick;

    baud_gen baud_generator (
        .clk(clk),
        .baud_tick(baud_tick)
    );

    uart_tx uart_transmitter (
        .clk(clk),
        .rst(rst),
        .tx_start(tx_start),
        .tx_data(tx_data),
        .baud_tick(baud_tick),
        .tx_out(tx_out)
    );

    initial begin
        $dumpfile(""uart_tx.vcd"");
        $dumpvars(0, testbench);

        clk = 0;
        rst = 1;
        tx_start = 0;
        tx_data = 8'h00;

        #20 rst = 0;
        #20 tx_data = 8'h55;
        #10 tx_start = 1;
        #20 tx_start = 0;
        
        #1000 tx_data = 8'hAA;
        #10 tx_start = 1;
        #20 tx_start = 0;

        #1000 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t rst=%b tx_start=%b tx_data=%h tx_out=%b"",
                 $time, rst, tx_start, tx_data, tx_out);
    end
endmodule",True,131,True,True,True,,0.0,,15.999585628509521,0.014018774032592773,"Design UART transmitter with states: IDLE, START, DATA, STOP. Protocol: START(0), 8 data bits LSB-first, STOP(1). Baud rate divider. Include testbench.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph LR
    CLK[Clock Input] --> BAUDGEN(Baud Generator)
    CLK --> FSM(State Machine)
    RST[Reset] --> FSM
    BAUDGEN --> FSM
    
    TX_START[TX Start] --> FSM
    TX_DATA[TX Data<7:0>] --> SHIFTREG[[Shift Register]]
    
    FSM --> |State| SHIFTREG
    FSM --> |Control| MUX{Output MUX}
    SHIFTREG --> MUX
    
    subgraph States
        IDLE --> START
        START --> DATA
        DATA --> STOP
        STOP --> IDLE
    end
    
    MUX --> TX_OUT[TX Output]
    
    subgraph Testbench
        TB_CLK[TB Clock] --> TB_STIM(Stimulus Generator)
        TB_STIM --> TB_CHECK(Response Checker)
        TX_OUT --> TB_CHECK
    end
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module uart_tx (
    input wire clk,
    input wire rst,
    input wire tx_start,
    input wire [7:0] tx_data,
    input wire baud_tick,
    output reg tx_out
);

localparam IDLE = 2'b00;
localparam START = 2'b01;
localparam DATA = 2'b10;
localparam STOP = 2'b11;

reg [1:0] state, next_state;
reg [2:0] bit_count;
reg [7:0] shift_reg;

always @(posedge clk or posedge rst) begin
    if (rst) begin
        state <= IDLE;
        bit_count <= 3'b000;
        shift_reg <= 8'b0;
        tx_out <= 1'b1;
    end
    else if (baud_tick) begin
        state <= next_state;
        case (state)
            IDLE: begin
                if (tx_start) begin
                    shift_reg <= tx_data;
                    tx_out <= 1'b0;
                end
                else
                    tx_out <= 1'b1;
            end
            START: begin
                tx_out <= 1'b0;
                bit_count <= 3'b000;
            end
            DATA: begin
                tx_out <= shift_reg[0];
                shift_reg <= {1'b0, shift_reg[7:1]};
                bit_count <= bit_count + 1'b1;
            end
            STOP: begin
                tx_out <= 1'b1;
            end
        endcase
    end
end

always @(*) begin
    case (state)
        IDLE: next_state = tx_start ? START : IDLE;
        START: next_state = DATA;
        DATA: next_state = (bit_count == 3'b111) ? STOP : DATA;
        STOP: next_state = IDLE;
        default: next_state = IDLE;
    endcase
end

endmodule

module baud_gen #(
    parameter DIVISOR = 16
) (
    input wire clk,
    input wire rst,
    output reg baud_tick
);

reg [$clog2(DIVISOR)-1:0] counter;

always @(posedge clk or posedge rst) begin
    if (rst) begin
        counter <= 0;
        baud_tick <= 0;
    end
    else begin
        if (counter == DIVISOR-1) begin
            counter <= 0;
            baud_tick <= 1'b1;
        end
        else begin
            counter <= counter + 1'b1;
            baud_tick <= 1'b0;
        end
    end
end

endmodule

module uart_tx_top (
    input wire clk,
    input wire rst,
    input wire tx_start,
    input wire [7:0] tx_data,
    output wire tx_out
);

wire baud_tick;

baud_gen #(.DIVISOR(16)) baud_inst (
    .clk(clk),
    .rst(rst),
    .baud_tick(baud_tick)
);

uart_tx uart_inst (
    .clk(clk),
    .rst(rst),
    .tx_start(tx_start),
    .tx_data(tx_data),
    .baud_tick(baud_tick),
    .tx_out(tx_out)
);

endmodule

module testbench;
    reg clk;
    reg rst;
    reg tx_start;
    reg [7:0] tx_data;
    wire tx_out;

    uart_tx_top dut (
        .clk(clk),
        .rst(rst),
        .tx_start(tx_start),
        .tx_data(tx_data),
        .tx_out(tx_out)
    );

    initial begin
        $dumpfile(""uart_tx.vcd"");
        $dumpvars(0, testbench);

        clk = 0;
        rst = 1;
        tx_start = 0;
        tx_data = 0;

        #20 rst = 0;
        #20 tx_data = 8'h55;
        #20 tx_start = 1;
        #20 tx_start = 0;
        
        #2000 tx_data = 8'hAA;
        #20 tx_start = 1;
        #20 tx_start = 0;
        
        #2000 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t rst=%b tx_start=%b tx_data=%h tx_out=%b"",
                 $time, rst, tx_start, tx_data, tx_out);
    end
endmodule",True,165,True,True,True,,0.0,,13.785841941833496,0.014831781387329102,prompt_only,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,State Machine,complex,"Design UART transmitter with states: IDLE, START, DATA, STOP. Protocol: START(0), 8 data bits LSB-first, STOP(1). Baud rate divider. Include testbench.",gpt-4o,"`timescale 1ns/1ps

module uart_tx(
    input wire clk,
    input wire rst_n,
    input wire [7:0] data_in,
    input wire tx_start,
    output reg tx,
    output reg tx_busy
);

    reg [3:0] bit_cnt;
    reg [8:0] shift_reg;
    reg [12:0] baud_cnt;
    reg baud_tick;
    
    parameter IDLE = 2'b00, START = 2'b01, DATA = 2'b10, STOP = 2'b11;
    reg [1:0] state, next_state;
    
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            state <= IDLE;
            tx <= 1'b1;
            tx_busy <= 1'b0;
            bit_cnt <= 4'b0;
            shift_reg <= 9'b0;
            baud_cnt <= 13'b0;
            baud_tick <= 1'b0;
        end else begin
            state <= next_state;
            if (baud_tick) begin
                case (state)
                    IDLE: begin
                        if (tx_start) begin
                            shift_reg <= {data_in, 1'b0};
                            bit_cnt <= 4'd9;
                            tx_busy <= 1'b1;
                        end
                    end
                    START: begin
                        tx <= 1'b0;
                        bit_cnt <= bit_cnt - 1'b1;
                    end
                    DATA: begin
                        tx <= shift_reg[0];
                        shift_reg <= {1'b1, shift_reg[8:1]};
                        bit_cnt <= bit_cnt - 1'b1;
                    end
                    STOP: begin
                        tx <= 1'b1;
                        if (bit_cnt == 0) begin
                            tx_busy <= 1'b0;
                        end else begin
                            bit_cnt <= bit_cnt - 1'b1;
                        end
                    end
                endcase
            end
            baud_cnt <= baud_cnt + 1'b1;
            if (baud_cnt == 13'd5208) begin
                baud_cnt <= 13'b0;
                baud_tick <= 1'b1;
            end else begin
                baud_tick <= 1'b0;
            end
        end
    end
    
    always @(*) begin
        case (state)
            IDLE: begin
                if (tx_start) begin
                    next_state = START;
                end else begin
                    next_state = IDLE;
                end
            end
            START: begin
                if (bit_cnt == 0) begin
                    next_state = DATA;
                end else begin
                    next_state = START;
                end
            end
            DATA: begin
                if (bit_cnt == 0) begin
                    next_state = STOP;
                end else begin
                    next_state = DATA;
                end
            end
            STOP: begin
                if (bit_cnt == 0) begin
                    next_state = IDLE;
                end else begin
                    next_state = STOP;
                end
            end
        endcase
    end

endmodule

module testbench;
    reg clk, rst_n, tx_start;
    reg [7:0] data_in;
    wire tx, tx_busy;
    
    uart_tx dut (
        .clk(clk),
        .rst_n(rst_n),
        .data_in(data_in),
        .tx_start(tx_start),
        .tx(tx),
        .tx_busy(tx_busy)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst_n = 1'b0;
        tx_start = 1'b0;
        data_in = 8'b0;
        
        #20 rst_n = 1'b1;
        #10 tx_start = 1'b1; data_in = 8'hA5;
        #10 tx_start = 1'b0;
        #1000 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b tx_start=%b data_in=%h tx=%b tx_busy=%b"", 
                 $time, clk, rst_n, tx_start, data_in, tx, tx_busy);
    end
endmodule",True,139,True,True,True,True,0.9,True,14.765841484069824,10.999950885772705,"graph TD
    CLK[Clock] --> UART_TX(Processing Unit)
    RST[Reset] --> UART_TX
    DATA_IN[Input Data] --> UART_TX
    BAUD_DIVIDER[[Baud Rate Divider]] --> UART_TX
    
    UART_TX --> IDLE{State: IDLE}
    IDLE -->|START Condition| START{State: START}
    START --> DATA{State: DATA}
    DATA -->|8 Bits LSB-first| STOP{State: STOP}
    STOP -->|Transmission Complete| IDLE

    UART_TX --> TX_OUT[UART TX Output]
    
    TESTBENCH[UART Testbench] --> UART_TX
    TESTBENCH --> CLK
    TESTBENCH --> RST
    TESTBENCH --> DATA_IN","`timescale 1ns/1ps

module uart_tx(
    input wire clk,
    input wire rst,
    input wire [7:0] data_in,
    input wire [15:0] baud_divider,
    output reg tx_out
);

    reg [3:0] state;
    reg [3:0] bit_counter;
    reg [15:0] baud_counter;
    reg [7:0] shift_reg;

    localparam IDLE = 4'b0000;
    localparam START = 4'b0001;
    localparam DATA = 4'b0010;
    localparam STOP = 4'b0011;

    always @(posedge clk or posedge rst) begin
        if (rst) begin
            state <= IDLE;
            tx_out <= 1'b1;
            bit_counter <= 4'b0000;
            baud_counter <= 16'b0;
            shift_reg <= 8'b0;
        end else begin
            case (state)
                IDLE: begin
                    tx_out <= 1'b1;
                    baud_counter <= 16'b0;
                    bit_counter <= 4'b0000;
                    if (data_in[0] == 1'b0) begin
                        shift_reg <= data_in;
                        state <= START;
                    end
                end
                START: begin
                    if (baud_counter == baud_divider) begin
                        baud_counter <= 16'b0;
                        state <= DATA;
                        tx_out <= 1'b0;
                    end else begin
                        baud_counter <= baud_counter + 1'b1;
                    end
                end
                DATA: begin
                    if (baud_counter == baud_divider) begin
                        baud_counter <= 16'b0;
                        tx_out <= shift_reg[0];
                        shift_reg <= {1'b0, shift_reg[7:1]};
                        if (bit_counter == 4'b0111) begin
                            state <= STOP;
                        end else begin
                            bit_counter <= bit_counter + 1'b1;
                        end
                    end else begin
                        baud_counter <= baud_counter + 1'b1;
                    end
                end
                STOP: begin
                    if (baud_counter == baud_divider) begin
                        baud_counter <= 16'b0;
                        tx_out <= 1'b1;
                        state <= IDLE;
                    end else begin
                        baud_counter <= baud_counter + 1'b1;
                    end
                end
            endcase
        end
    end
endmodule

module testbench;
    reg clk, rst;
    reg [7:0] data_in;
    reg [15:0] baud_divider;
    wire tx_out;

    uart_tx dut (
        .clk(clk),
        .rst(rst),
        .data_in(data_in),
        .baud_divider(baud_divider),
        .tx_out(tx_out)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 1'b0;
        rst = 1'b1;
        data_in = 8'b11010101;
        baud_divider = 16'd10;

        #20 rst = 1'b0;
        #1000 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t clk=%b rst=%b data_in=%b tx_out=%b"",
                 $time, clk, rst, data_in, tx_out);
    end
endmodule",True,109,True,True,True,True,0.9,True,14.656317472457886,15.17867136001587,"Design UART transmitter with states: IDLE, START, DATA, STOP. Protocol: START(0), 8 data bits LSB-first, STOP(1). Baud rate divider. Include testbench.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph TD
    CLK[Clock] --> UART_TX(Processing Unit)
    RST[Reset] --> UART_TX
    DATA_IN[Input Data] --> UART_TX
    BAUD_DIVIDER[[Baud Rate Divider]] --> UART_TX
    
    UART_TX --> IDLE{State: IDLE}
    IDLE -->|START Condition| START{State: START}
    START --> DATA{State: DATA}
    DATA -->|8 Bits LSB-first| STOP{State: STOP}
    STOP -->|Transmission Complete| IDLE

    UART_TX --> TX_OUT[UART TX Output]
    
    TESTBENCH[UART Testbench] --> UART_TX
    TESTBENCH --> CLK
    TESTBENCH --> RST
    TESTBENCH --> DATA_IN
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module uart_tx(
    input wire clk,
    input wire rst,
    input wire [7:0] data_in,
    input wire [15:0] baud_divider,
    output reg tx_out
);

    reg [3:0] state;
    reg [7:0] shift_reg;
    reg [3:0] bit_count;
    reg [15:0] baud_count;

    localparam IDLE = 4'b0001;
    localparam START = 4'b0010;
    localparam DATA = 4'b0100;
    localparam STOP = 4'b1000;

    always @(posedge clk or posedge rst) begin
        if (rst) begin
            state <= IDLE;
            tx_out <= 1'b1;
            shift_reg <= 8'b0;
            bit_count <= 4'b0;
            baud_count <= 16'b0;
        end else begin
            case (state)
                IDLE: begin
                    tx_out <= 1'b1;
                    if (data_in[0] == 1'b0) begin
                        state <= START;
                        shift_reg <= data_in;
                        bit_count <= 4'b0;
                        baud_count <= 16'b0;
                    end
                end
                START: begin
                    tx_out <= 1'b0;
                    if (baud_count == baud_divider) begin
                        state <= DATA;
                        baud_count <= 16'b0;
                    end else begin
                        baud_count <= baud_count + 1'b1;
                    end
                end
                DATA: begin
                    if (baud_count == baud_divider) begin
                        tx_out <= shift_reg[0];
                        shift_reg <= shift_reg >> 1;
                        bit_count <= bit_count + 1'b1;
                        baud_count <= 16'b0;
                        
                        if (bit_count == 8) begin
                            state <= STOP;
                        end
                    end else begin
                        baud_count <= baud_count + 1'b1;
                    end
                end
                STOP: begin
                    tx_out <= 1'b1;
                    if (baud_count == baud_divider) begin
                        state <= IDLE;
                        baud_count <= 16'b0;
                    end else begin
                        baud_count <= baud_count + 1'b1;
                    end
                end
            endcase
        end
    end
endmodule

module uart_testbench;
    reg clk, rst;
    reg [7:0] data_in;
    reg [15:0] baud_divider;
    wire tx_out;

    uart_tx dut (
        .clk(clk),
        .rst(rst),
        .data_in(data_in),
        .baud_divider(baud_divider),
        .tx_out(tx_out)
    );

    initial begin
        $dumpfile(""uart_dump.vcd"");
        $dumpvars(0, uart_testbench);

        clk = 1'b0;
        rst = 1'b1;
        data_in = 8'b10101010;
        baud_divider = 16'd3;

        #10 rst = 1'b0;
        #1000 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t clk=%b rst=%b data_in=%b tx_out=%b"", 
                 $time, clk, rst, data_in, tx_out);
    end
endmodule",True,109,True,True,True,,0.0,,8.630429029464722,0.015219449996948242,prompt_only,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,CPU Component,complex,Create 8-register  8-bit register file with dual read ports and single write port. Include testbench with simultaneous operations.,claude,"`timescale 1ns/1ps

module reg_file(
    input wire clk,
    input wire rst_n,
    input wire write_en,
    input wire [2:0] write_addr,
    input wire [7:0] write_data,
    input wire [2:0] read_addr1,
    input wire [2:0] read_addr2,
    output wire [7:0] read_data1,
    output wire [7:0] read_data2
);

reg [7:0] registers [0:7];
integer i;

assign read_data1 = registers[read_addr1];
assign read_data2 = registers[read_addr2];

always @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
        for (i = 0; i < 8; i = i + 1)
            registers[i] <= 8'b0;
    end
    else if (write_en) begin
        registers[write_addr] <= write_data;
    end
end

endmodule

module testbench;
    reg clk;
    reg rst_n;
    reg write_en;
    reg [2:0] write_addr;
    reg [7:0] write_data;
    reg [2:0] read_addr1;
    reg [2:0] read_addr2;
    wire [7:0] read_data1;
    wire [7:0] read_data2;

    reg_file dut (
        .clk(clk),
        .rst_n(rst_n),
        .write_en(write_en),
        .write_addr(write_addr),
        .write_data(write_data),
        .read_addr1(read_addr1),
        .read_addr2(read_addr2),
        .read_data1(read_data1),
        .read_data2(read_data2)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 0;
        rst_n = 0;
        write_en = 0;
        write_addr = 0;
        write_data = 0;
        read_addr1 = 0;
        read_addr2 = 0;

        #10 rst_n = 1;

        // Write some data
        #10 write_en = 1;
        write_addr = 3'b001;
        write_data = 8'hAA;

        #10 write_addr = 3'b010;
        write_data = 8'hBB;

        #10 write_addr = 3'b011;
        write_data = 8'hCC;

        // Read while writing
        #10 write_addr = 3'b100;
        write_data = 8'hDD;
        read_addr1 = 3'b001;
        read_addr2 = 3'b010;

        #10 write_en = 0;
        read_addr1 = 3'b011;
        read_addr2 = 3'b100;

        #20 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t rd1=%h rd2=%h"", $time, read_data1, read_data2);
    end
endmodule",True,99,True,True,True,False,0.4,False,10.101220607757568,6.341425895690918,"graph TD
    CLK[Clock] --> RF[[8x8 Register File]]
    RST[Reset] --> RF
    WD[Write Data 8-bit] --> RF
    WA[Write Address 3-bit] --> RF
    WE[Write Enable] --> RF
    
    RA1[Read Address 1] --> RF
    RA2[Read Address 2] --> RF
    
    RF --> RD1[Read Data 1]
    RF --> RD2[Read Data 2]
    
    CLK --> TB((Testbench))
    RST --> TB
    TB --> WD
    TB --> WA
    TB --> WE
    TB --> RA1
    TB --> RA2
    RD1 --> TB
    RD2 --> TB
    
    TB --> MON{Monitor/Compare}
    MON --> RES[Test Results]","`timescale 1ns/1ps

module register_file (
    input wire clk,
    input wire rst,
    input wire we,
    input wire [2:0] wa,
    input wire [7:0] wd,
    input wire [2:0] ra1,
    input wire [2:0] ra2,
    output reg [7:0] rd1,
    output reg [7:0] rd2
);

reg [7:0] registers [0:7];
integer i;

always @(posedge clk or posedge rst) begin
    if (rst) begin
        for (i = 0; i < 8; i = i + 1)
            registers[i] <= 8'b0;
    end
    else begin
        if (we)
            registers[wa] <= wd;
    end
end

always @(*) begin
    rd1 = registers[ra1];
    rd2 = registers[ra2];
end

endmodule

module testbench;
    reg clk, rst, we;
    reg [2:0] wa, ra1, ra2;
    reg [7:0] wd;
    wire [7:0] rd1, rd2;

    register_file dut (
        .clk(clk),
        .rst(rst),
        .we(we),
        .wa(wa),
        .wd(wd),
        .ra1(ra1),
        .ra2(ra2),
        .rd1(rd1),
        .rd2(rd2)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 0;
        rst = 1;
        we = 0;
        wa = 0;
        wd = 0;
        ra1 = 0;
        ra2 = 0;

        #10 rst = 0;

        // Write test pattern
        #10 we = 1; wa = 3'h1; wd = 8'h55;
        #10 wa = 3'h2; wd = 8'hAA;
        #10 we = 0;

        // Read test pattern
        #10 ra1 = 3'h1; ra2 = 3'h2;
        #10;

        // Verify
        if (rd1 !== 8'h55 || rd2 !== 8'hAA)
            $display(""Test Failed!"");
        else
            $display(""Test Passed!"");

        #10 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t rst=%b we=%b wa=%h wd=%h ra1=%h ra2=%h rd1=%h rd2=%h"",
                 $time, rst, we, wa, wd, ra1, ra2, rd1, rd2);
    end
endmodule",True,92,True,True,True,False,0.4,False,12.467841148376465,7.908257246017456,"Create 8-register  8-bit register file with dual read ports and single write port. Include testbench with simultaneous operations.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph TD
    CLK[Clock] --> RF[[8x8 Register File]]
    RST[Reset] --> RF
    WD[Write Data 8-bit] --> RF
    WA[Write Address 3-bit] --> RF
    WE[Write Enable] --> RF
    
    RA1[Read Address 1] --> RF
    RA2[Read Address 2] --> RF
    
    RF --> RD1[Read Data 1]
    RF --> RD2[Read Data 2]
    
    CLK --> TB((Testbench))
    RST --> TB
    TB --> WD
    TB --> WA
    TB --> WE
    TB --> RA1
    TB --> RA2
    RD1 --> TB
    RD2 --> TB
    
    TB --> MON{Monitor/Compare}
    MON --> RES[Test Results]
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module register_file(
    input wire clk,
    input wire rst,
    input wire [7:0] write_data,
    input wire [2:0] write_addr,
    input wire write_en,
    input wire [2:0] read_addr1,
    input wire [2:0] read_addr2,
    output reg [7:0] read_data1,
    output reg [7:0] read_data2
);

reg [7:0] registers[0:7];
integer i;

always @(posedge clk or posedge rst) begin
    if (rst) begin
        for (i = 0; i < 8; i = i + 1)
            registers[i] <= 8'b0;
    end
    else if (write_en)
        registers[write_addr] <= write_data;
end

always @(*) begin
    read_data1 = registers[read_addr1];
    read_data2 = registers[read_addr2];
end

endmodule

module testbench;
    reg clk, rst;
    reg [7:0] write_data;
    reg [2:0] write_addr;
    reg write_en;
    reg [2:0] read_addr1, read_addr2;
    wire [7:0] read_data1, read_data2;

    register_file dut (
        .clk(clk),
        .rst(rst),
        .write_data(write_data),
        .write_addr(write_addr),
        .write_en(write_en),
        .read_addr1(read_addr1),
        .read_addr2(read_addr2),
        .read_data1(read_data1),
        .read_data2(read_data2)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 0;
        rst = 1;
        write_data = 0;
        write_addr = 0;
        write_en = 0;
        read_addr1 = 0;
        read_addr2 = 0;

        #10 rst = 0;

        // Write test pattern
        #10 write_en = 1;
        write_addr = 3'd0; write_data = 8'hAA;
        #10 write_addr = 3'd1; write_data = 8'hBB;
        #10 write_addr = 3'd2; write_data = 8'hCC;

        // Read test
        #10 write_en = 0;
        read_addr1 = 3'd0;
        read_addr2 = 3'd1;
        #10 read_addr1 = 3'd1;
        read_addr2 = 3'd2;

        #50 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t rd1=%h rd2=%h"", $time, read_data1, read_data2);
    end
endmodule",True,89,True,True,True,False,0.4,False,9.253911972045898,7.560315370559692,tie,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,CPU Component,complex,Create 8-register  8-bit register file with dual read ports and single write port. Include testbench with simultaneous operations.,gpt-4o,"`timescale 1ns/1ps

module register_file(
    input wire clk,
    input wire rst_n,
    input wire [2:0] read_addr1,
    input wire [2:0] read_addr2,
    input wire [2:0] write_addr,
    input wire [7:0] write_data,
    input wire write_enable,
    output reg [7:0] read_data1,
    output reg [7:0] read_data2
);

    reg [7:0] registers [7:0];
    integer i;

    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            for (i = 1'b0; i < 8; i = i + 1) begin
                registers[i] <= 8'b00000000;
            end
        end else if (write_enable) begin
            registers[write_addr] <= write_data;
        end
    end

    always @(*) begin
        read_data1 = registers[read_addr1];
        read_data2 = registers[read_addr2];
    end

endmodule

module testbench;
    reg clk, rst_n, write_enable;
    reg [2:0] read_addr1, read_addr2, write_addr;
    reg [7:0] write_data;
    wire [7:0] read_data1, read_data2;

    register_file dut (
        .clk(clk),
        .rst_n(rst_n),
        .read_addr1(read_addr1),
        .read_addr2(read_addr2),
        .write_addr(write_addr),
        .write_data(write_data),
        .write_enable(write_enable),
        .read_data1(read_data1),
        .read_data2(read_data2)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 1'b0;
        rst_n = 1'b0;
        write_enable = 1'b0;
        read_addr1 = 3'b000;
        read_addr2 = 3'b001;
        write_addr = 3'b000;
        write_data = 8'b00000000;

        #20 rst_n = 1'b1;
        #10 write_enable = 1'b1;
            write_addr = 3'b010;
            write_data = 8'b10101010;
        #10 write_enable = 1'b0;
        #10 read_addr1 = 3'b010;
        #10 read_addr2 = 3'b010;
        #50 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b write_enable=%b write_addr=%b write_data=%b read_addr1=%b read_data1=%b read_addr2=%b read_data2=%b"", 
                 $time, clk, rst_n, write_enable, write_addr, write_data, read_addr1, read_data1, read_addr2, read_data2);
    end
endmodule",True,81,True,True,True,True,0.75,True,6.710000991821289,6.578288793563843,"graph TD
    CLK[Clock] --> RF[[8x8 Register File]]
    RST[Reset] --> RF
    WD[Write Data (8-bit)] --> RF
    WA[Write Address (3-bit)] --> RF
    RA1[Read Address 1 (3-bit)] --> RF
    RA2[Read Address 2 (3-bit)] --> RF
    RF --> RD1[Read Data 1 (8-bit)]
    RF --> RD2[Read Data 2 (8-bit)]
    WE[Write Enable] --> RF

    subgraph Testbench
        CLK --> TB[Simultaneous Operations]
        RST --> TB
        RD1 --> TB
        RD2 --> TB
        WD --> TB
        WA --> TB
        RA1 --> TB
        RA2 --> TB
        WE --> TB
    end","`timescale 1ns/1ps

module register_file(
    input wire clk,
    input wire rst,
    input wire we,
    input wire [2:0] wa,
    input wire [2:0] ra1,
    input wire [2:0] ra2,
    input wire [7:0] wd,
    output reg [7:0] rd1,
    output reg [7:0] rd2
);
    reg [7:0] rf[7:0];

    always @(posedge clk or posedge rst) begin
        if (rst) begin
            rd1 <= 8'b00000000;
            rd2 <= 8'b00000000;
        end else begin
            if (we) begin
                rf[wa] <= wd;
            end
            rd1 <= rf[ra1];
            rd2 <= rf[ra2];
        end
    end
endmodule

module testbench;
    reg clk, rst, we;
    reg [7:0] wd;
    reg [2:0] wa, ra1, ra2;
    wire [7:0] rd1, rd2;

    register_file dut (
        .clk(clk),
        .rst(rst),
        .we(we),
        .wa(wa),
        .ra1(ra1),
        .ra2(ra2),
        .wd(wd),
        .rd1(rd1),
        .rd2(rd2)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 1'b0;
        rst = 1'b1;
        we = 1'b0;
        wd = 8'b00000000;
        wa = 3'b000;
        ra1 = 3'b000;
        ra2 = 3'b000;
        
        #10 rst = 1'b0;
        #10 we = 1'b1; wa = 3'b001; wd = 8'b10101010;
        #10 we = 1'b0;
        #10 ra1 = 3'b001; ra2 = 3'b001;
        #20 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t clk=%b rst=%b we=%b wa=%b ra1=%b ra2=%b wd=%b rd1=%b rd2=%b"", 
                 $time, clk, rst, we, wa, ra1, ra2, wd, rd1, rd2);
    end
endmodule",True,73,True,True,True,True,0.7,True,8.029766321182251,5.857684850692749,"Create 8-register  8-bit register file with dual read ports and single write port. Include testbench with simultaneous operations.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph TD
    CLK[Clock] --> RF[[8x8 Register File]]
    RST[Reset] --> RF
    WD[Write Data (8-bit)] --> RF
    WA[Write Address (3-bit)] --> RF
    RA1[Read Address 1 (3-bit)] --> RF
    RA2[Read Address 2 (3-bit)] --> RF
    RF --> RD1[Read Data 1 (8-bit)]
    RF --> RD2[Read Data 2 (8-bit)]
    WE[Write Enable] --> RF

    subgraph Testbench
        CLK --> TB[Simultaneous Operations]
        RST --> TB
        RD1 --> TB
        RD2 --> TB
        WD --> TB
        WA --> TB
        RA1 --> TB
        RA2 --> TB
        WE --> TB
    end
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module register_file(
    input wire clk,
    input wire rst,
    input wire we,
    input wire [7:0] wd,
    input wire [2:0] wa,
    input wire [2:0] ra1,
    input wire [2:0] ra2,
    output reg [7:0] rd1,
    output reg [7:0] rd2
);
    reg [7:0] registers [7:0];
    
    always @(posedge clk or posedge rst) begin
        if (rst) begin
            registers[0] <= 8'b0;
            registers[1] <= 8'b0;
            registers[2] <= 8'b0;
            registers[3] <= 8'b0;
            registers[4] <= 8'b0;
            registers[5] <= 8'b0;
            registers[6] <= 8'b0;
            registers[7] <= 8'b0;
        end else if (we) begin
            registers[wa] <= wd;
        end
    end
    
    always @(*) begin
        rd1 = registers[ra1];
        rd2 = registers[ra2];
    end
endmodule

module testbench;
    reg clk, rst, we;
    reg [7:0] wd;
    reg [2:0] wa, ra1, ra2;
    wire [7:0] rd1, rd2;
    
    register_file dut (
        .clk(clk),
        .rst(rst),
        .we(we),
        .wd(wd),
        .wa(wa),
        .ra1(ra1),
        .ra2(ra2),
        .rd1(rd1),
        .rd2(rd2)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst = 1'b1;
        we = 1'b0;
        wd = 8'b0;
        wa = 3'b0;
        ra1 = 3'b0;
        ra2 = 3'b0;
        
        #20 rst = 1'b0;
        #10 we = 1'b1; wd = 8'hAA; wa = 3'b001;
        #10 we = 1'b0; ra1 = 3'b001; ra2 = 3'b000;
        #10 we = 1'b1; wd = 8'h55; wa = 3'b010;
        #10 we = 1'b0; ra1 = 3'b010; ra2 = 3'b001;
        #50 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t clk=%b rst=%b we=%b wd=%h wa=%d ra1=%d ra2=%d rd1=%h rd2=%h"", 
                 $time, clk, rst, we, wd, wa, ra1, ra2, rd1, rd2);
    end
endmodule",True,81,True,True,True,True,0.7,True,5.63545036315918,11.92833924293518,prompt_only,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,Advanced Sequential,complex,"Design 8-bit resolution PWM generator with configurable duty cycle. Include testbench with duty cycles: 0%, 25%, 50%, 75%, 100%.",claude,"`timescale 1ns/1ps

module pwm_gen(
    input wire clk,
    input wire rst_n,
    input wire [7:0] duty_cycle,
    output reg pwm_out
);

reg [7:0] counter;

always @(posedge clk or negedge rst_n) begin
    if (!rst_n)
        counter <= 8'h00;
    else
        counter <= counter + 1'b1;
end

always @(posedge clk or negedge rst_n) begin
    if (!rst_n)
        pwm_out <= 1'b0;
    else
        pwm_out <= (counter < duty_cycle);
end

endmodule

module testbench;
    reg clk;
    reg rst_n;
    reg [7:0] duty_cycle;
    wire pwm_out;
    
    pwm_gen dut (
        .clk(clk),
        .rst_n(rst_n),
        .duty_cycle(duty_cycle),
        .pwm_out(pwm_out)
    );
    
    initial begin
        $dumpfile(""pwm.vcd"");
        $dumpvars(0, testbench);
        
        clk = 0;
        rst_n = 0;
        duty_cycle = 8'd0;
        
        #20 rst_n = 1;
        
        // Test 0% duty cycle
        #1000;
        
        // Test 25% duty cycle
        duty_cycle = 8'd64;
        #1000;
        
        // Test 50% duty cycle
        duty_cycle = 8'd128;
        #1000;
        
        // Test 75% duty cycle
        duty_cycle = 8'd192;
        #1000;
        
        // Test 100% duty cycle
        duty_cycle = 8'd255;
        #1000;
        
        $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t rst_n=%b duty_cycle=%d pwm_out=%b"", 
                 $time, rst_n, duty_cycle, pwm_out);
    end
endmodule",True,79,True,True,True,,0.0,,6.765928268432617,0.015475273132324219,"graph TD
    CLK[Clock Input] --> COUNTER((8-bit Counter))
    RST[Reset] --> COUNTER
    DC[Duty Cycle Input] --> COMP
    COUNTER --> COMP((Comparator))
    COMP --> PWM_OUT[PWM Output]
    TB_DC[[Test Duty Cycles:<br/>0%<br/>25%<br/>50%<br/>75%<br/>100%]] --> DC
    CLK --> COMP
    RST --> COMP
    subgraph PWM_Generator
        COUNTER
        COMP
    end
    subgraph Testbench
        TB_DC
    end","`timescale 1ns/1ps

module pwm_generator (
    input wire clk,
    input wire rst,
    input wire [7:0] duty_cycle,
    output reg pwm_out
);

reg [7:0] counter;

always @(posedge clk or posedge rst) begin
    if (rst)
        counter <= 8'b0;
    else
        counter <= counter + 1'b1;
end

always @(posedge clk or posedge rst) begin
    if (rst)
        pwm_out <= 1'b0;
    else
        pwm_out <= (counter < duty_cycle);
end

endmodule

module testbench;
    reg clk, rst;
    reg [7:0] duty_cycle;
    wire pwm_out;

    pwm_generator dut (
        .clk(clk),
        .rst(rst),
        .duty_cycle(duty_cycle),
        .pwm_out(pwm_out)
    );

    initial begin
        $dumpfile(""pwm.vcd"");
        $dumpvars(0, testbench);

        clk = 0;
        rst = 1;
        duty_cycle = 0;

        #20 rst = 0;

        // Test 0% duty cycle
        duty_cycle = 8'd0;
        #512;

        // Test 25% duty cycle
        duty_cycle = 8'd64;
        #512;

        // Test 50% duty cycle
        duty_cycle = 8'd128;
        #512;

        // Test 75% duty cycle
        duty_cycle = 8'd192;
        #512;

        // Test 100% duty cycle
        duty_cycle = 8'd255;
        #512;

        $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t rst=%b duty_cycle=%d pwm_out=%b"", 
                 $time, rst, duty_cycle, pwm_out);
    end

endmodule",True,80,True,True,True,,0.0,,9.272870063781738,0.013929605484008789,"Design 8-bit resolution PWM generator with configurable duty cycle. Include testbench with duty cycles: 0%, 25%, 50%, 75%, 100%.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph TD
    CLK[Clock Input] --> COUNTER((8-bit Counter))
    RST[Reset] --> COUNTER
    DC[Duty Cycle Input] --> COMP
    COUNTER --> COMP((Comparator))
    COMP --> PWM_OUT[PWM Output]
    TB_DC[[Test Duty Cycles:<br/>0%<br/>25%<br/>50%<br/>75%<br/>100%]] --> DC
    CLK --> COMP
    RST --> COMP
    subgraph PWM_Generator
        COUNTER
        COMP
    end
    subgraph Testbench
        TB_DC
    end
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module pwm_generator(
    input wire clk,
    input wire rst,
    input wire [7:0] duty_cycle,
    output reg pwm_out
);

reg [7:0] counter;

always @(posedge clk or posedge rst) begin
    if (rst)
        counter <= 8'b0;
    else
        counter <= counter + 1'b1;
end

always @(posedge clk or posedge rst) begin
    if (rst)
        pwm_out <= 1'b0;
    else
        pwm_out <= (counter < duty_cycle);
end

endmodule

module testbench;
    reg clk;
    reg rst;
    reg [7:0] duty_cycle;
    wire pwm_out;

    pwm_generator dut (
        .clk(clk),
        .rst(rst),
        .duty_cycle(duty_cycle),
        .pwm_out(pwm_out)
    );

    initial begin
        $dumpfile(""pwm.vcd"");
        $dumpvars(0, testbench);

        clk = 0;
        rst = 1;
        duty_cycle = 0;

        #20 rst = 0;

        // Test 0% duty cycle
        duty_cycle = 8'd0;
        #512;

        // Test 25% duty cycle
        duty_cycle = 8'd64;
        #512;

        // Test 50% duty cycle
        duty_cycle = 8'd128;
        #512;

        // Test 75% duty cycle
        duty_cycle = 8'd192;
        #512;

        // Test 100% duty cycle
        duty_cycle = 8'd255;
        #512;

        $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t rst=%b duty_cycle=%d pwm_out=%b"", 
                 $time, rst, duty_cycle, pwm_out);
    end
endmodule",True,80,True,True,True,,0.0,,6.247194290161133,0.014278650283813477,prompt_only,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,Advanced Sequential,complex,"Design 8-bit resolution PWM generator with configurable duty cycle. Include testbench with duty cycles: 0%, 25%, 50%, 75%, 100%.",gpt-4o,"`timescale 1ns/1ps

module pwm_generator(
    input wire clk,
    input wire rst_n,
    input wire [7:0] duty_cycle,
    output reg pwm_out
);
    reg [7:0] counter;

    always @(posedge clk or negedge rst_n) begin
        if (!rst_n)
            counter <= 8'b00000000;
        else
            counter <= counter + 1'b1;
    end

    always @(posedge clk or negedge rst_n) begin
        if (!rst_n)
            pwm_out <= 1'b0;
        else if (counter < duty_cycle)
            pwm_out <= 1'b1;
        else
            pwm_out <= 1'b0;
    end

endmodule

module testbench;
    reg clk, rst_n;
    reg [7:0] duty_cycle;
    wire pwm_out;

    pwm_generator dut (
        .clk(clk),
        .rst_n(rst_n),
        .duty_cycle(duty_cycle),
        .pwm_out(pwm_out)
    );

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);

        clk = 1'b0;
        rst_n = 1'b0;
        duty_cycle = 8'd0;

        #20 rst_n = 1'b1;
        #10 duty_cycle = 8'd0;   // 0%
        #100 duty_cycle = 8'd64; // 25%
        #100 duty_cycle = 8'd128;// 50%
        #100 duty_cycle = 8'd192;// 75%
        #100 duty_cycle = 8'd255;// 100%
        #100 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b duty_cycle=%d pwm_out=%b"", 
                 $time, clk, rst_n, duty_cycle, pwm_out);
    end
endmodule",True,64,True,True,True,False,0.3,False,3.294642448425293,7.343024492263794,"graph TD
    CLK[Clock] --> CNT(Counter)
    RST[Reset] --> CNT
    DC[Duty Cycle Input] --> CMP{Comparator}
    CNT --> CMP
    CMP --> PWM_OUT[PWM Output]
    subgraph Testbench
        DC1[0% Duty Cycle] --> DC
        DC2[25% Duty Cycle] --> DC
        DC3[50% Duty Cycle] --> DC
        DC4[75% Duty Cycle] --> DC
        DC5[100% Duty Cycle] --> DC
    end","`timescale 1ns/1ps

module pwm(
    input wire clk,
    input wire rst_n,
    input wire [7:0] duty_cycle,
    output wire pwm_out
);

    reg [7:0] counter;

    always @(posedge clk or negedge rst_n) begin
        if (!rst_n)
            counter <= 8'b00000000;
        else
            counter <= counter + 1'b1;
    end

    assign pwm_out = (counter < duty_cycle) ? 1'b1 : 1'b0;

endmodule

module testbench;
    reg clk, rst_n;
    reg [7:0] duty_cycle;
    wire pwm_out;
    
    pwm dut (
        .clk(clk),
        .rst_n(rst_n),
        .duty_cycle(duty_cycle),
        .pwm_out(pwm_out)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst_n = 1'b0;
        
        #20 rst_n = 1'b1;

        duty_cycle = 8'd0;
        #100 duty_cycle = 8'd64;  // 25% Duty Cycle
        #100 duty_cycle = 8'd128; // 50% Duty Cycle
        #100 duty_cycle = 8'd192; // 75% Duty Cycle
        #100 duty_cycle = 8'd255; // 100% Duty Cycle

        #50 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b duty_cycle=%d pwm_out=%b"", 
                 $time, clk, rst_n, duty_cycle, pwm_out);
    end
endmodule",True,59,True,True,True,False,0.4,False,6.856340169906616,7.663069248199463,"Design 8-bit resolution PWM generator with configurable duty cycle. Include testbench with duty cycles: 0%, 25%, 50%, 75%, 100%.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph TD
    CLK[Clock] --> CNT(Counter)
    RST[Reset] --> CNT
    DC[Duty Cycle Input] --> CMP{Comparator}
    CNT --> CMP
    CMP --> PWM_OUT[PWM Output]
    subgraph Testbench
        DC1[0% Duty Cycle] --> DC
        DC2[25% Duty Cycle] --> DC
        DC3[50% Duty Cycle] --> DC
        DC4[75% Duty Cycle] --> DC
        DC5[100% Duty Cycle] --> DC
    end
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module pwm_generator(
    input wire clk,
    input wire rst,
    input wire [7:0] duty_cycle,
    output reg pwm_out
);

reg [7:0] counter;

// 8-bit counter
always @(posedge clk or posedge rst) begin
    if (rst)
        counter <= 8'b0;
    else
        counter <= counter + 1'b1;
end

// Comparator for PWM
always @(posedge clk or posedge rst) begin
    if (rst)
        pwm_out <= 1'b0;
    else
        pwm_out <= (counter < duty_cycle) ? 1'b1 : 1'b0;
end

endmodule

module testbench;
    reg clk, rst;
    reg [7:0] duty_cycle;
    wire pwm_out;
    
    pwm_generator dut (
        .clk(clk),
        .rst(rst),
        .duty_cycle(duty_cycle),
        .pwm_out(pwm_out)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst = 1'b1;
        duty_cycle = 8'd0; // Start with 0% duty cycle
        
        #20 rst = 1'b0;
        
        // Testing different duty cycles
        #100 duty_cycle = 8'd0;   // 0%
        #100 duty_cycle = 8'd64;  // 25%
        #100 duty_cycle = 8'd128; // 50%
        #100 duty_cycle = 8'd192; // 75%
        #100 duty_cycle = 8'd255; // 100%
        
        #100 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t clk=%b rst=%b duty_cycle=%d pwm_out=%b"", 
                 $time, clk, rst, duty_cycle, pwm_out);
    end
endmodule",True,68,True,True,True,False,0.3,False,4.2314605712890625,9.39161729812622,tie,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,Protocol,complex,"Design SPI master supporting mode 0 (CPOL=0, CPHA=0). Include SCLK generation, MOSI/MISO handling. Include testbench.",claude,"`timescale 1ns/1ps

module spi_master (
    input wire clk,
    input wire rst_n,
    input wire [7:0] tx_data,
    input wire start,
    output reg sclk,
    output reg mosi,
    input wire miso,
    output reg done,
    output reg [7:0] rx_data
);

reg [3:0] bit_count;
reg [7:0] tx_shift;
reg [7:0] rx_shift;
reg busy;
reg [3:0] sclk_div;

always @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
        sclk <= 1'b0;
        mosi <= 1'b0;
        done <= 1'b0;
        bit_count <= 4'h0;
        tx_shift <= 8'h00;
        rx_shift <= 8'h00;
        busy <= 1'b0;
        sclk_div <= 4'h0;
        rx_data <= 8'h00;
    end else begin
        if (!busy && start) begin
            busy <= 1'b1;
            tx_shift <= tx_data;
            bit_count <= 4'h7;
            done <= 1'b0;
        end else if (busy) begin
            sclk_div <= sclk_div + 1'b1;
            if (sclk_div == 4'h0) begin
                sclk <= 1'b1;
                rx_shift[bit_count] <= miso;
            end else if (sclk_div == 4'h8) begin
                sclk <= 1'b0;
                if (bit_count == 4'h0) begin
                    busy <= 1'b0;
                    done <= 1'b1;
                    rx_data <= {rx_shift[6:0], miso};
                end else begin
                    bit_count <= bit_count - 1'b1;
                    mosi <= tx_shift[bit_count-1];
                end
            end
        end else begin
            sclk <= 1'b0;
            done <= 1'b0;
        end
    end
end

endmodule

module testbench;
    reg clk;
    reg rst_n;
    reg [7:0] tx_data;
    reg start;
    wire sclk;
    wire mosi;
    reg miso;
    wire done;
    wire [7:0] rx_data;

    spi_master dut (
        .clk(clk),
        .rst_n(rst_n),
        .tx_data(tx_data),
        .start(start),
        .sclk(sclk),
        .mosi(mosi),
        .miso(miso),
        .done(done),
        .rx_data(rx_data)
    );

    initial begin
        $dumpfile(""spi.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst_n = 1'b0;
        tx_data = 8'h55;
        start = 1'b0;
        miso = 1'b0;

        #20 rst_n = 1'b1;
        #20 start = 1'b1;
        #10 start = 1'b0;
        
        // Simulate MISO input
        #100 miso = 1'b1;
        #100 miso = 1'b0;
        
        #1000 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t done=%b rx_data=%h"", $time, done, rx_data);
    end
endmodule",True,112,True,True,True,,0.0,,11.171360492706299,0.014107465744018555,"graph TD
    CLK[Clock Input] --> CLKGEN(Clock Generator)
    RST[Reset] --> CTRL(Control Unit)
    START[Start] --> CTRL
    
    CLKGEN --> CTRL
    CLKGEN --> SCLK[SCLK Output]
    
    TXDATA[[TX Data Register]] --> SHIFTOUT(TX Shift Register)
    CTRL --> SHIFTOUT
    SHIFTOUT --> MOSI[MOSI Output]
    
    MISO[MISO Input] --> SHIFTIN(RX Shift Register)
    CTRL --> SHIFTIN
    SHIFTIN --> RXDATA[[RX Data Register]]
    
    CTRL --> BUSY[Busy Flag]
    
    DATAWIDTH[Data Width] --> CTRL
    CLK --> SHIFTOUT
    CLK --> SHIFTIN
    RST --> SHIFTOUT
    RST --> SHIFTIN
    
    TB_CLK[Test Clock] -.-> |Testbench|CLK
    TB_RST[Test Reset] -.-> |Testbench|RST
    TB_DATA[Test Data] -.-> |Testbench|TXDATA
    TB_START[Test Start] -.-> |Testbench|START
    MOSI -.-> |Testbench|TB_MOSI[Monitor MOSI]
    RXDATA -.-> |Testbench|TB_RX[Monitor RX]","`timescale 1ns/1ps

module spi (
    input wire clk,
    input wire rst,
    input wire start,
    input wire [7:0] tx_data,
    input wire miso,
    output wire sclk,
    output wire mosi,
    output reg busy,
    output reg [7:0] rx_data
);

reg [7:0] tx_shift_reg;
reg [7:0] rx_shift_reg;
reg [2:0] bit_count;
reg sclk_reg;
reg active;

assign sclk = active ? sclk_reg : 1'b0;
assign mosi = tx_shift_reg[7];

always @(posedge clk or posedge rst) begin
    if (rst) begin
        sclk_reg <= 1'b0;
        tx_shift_reg <= 8'h00;
        rx_shift_reg <= 8'h00;
        rx_data <= 8'h00;
        bit_count <= 3'b000;
        busy <= 1'b0;
        active <= 1'b0;
    end
    else begin
        if (start && !busy) begin
            tx_shift_reg <= tx_data;
            bit_count <= 3'b000;
            busy <= 1'b1;
            active <= 1'b1;
        end
        else if (busy) begin
            sclk_reg <= ~sclk_reg;
            if (sclk_reg) begin
                rx_shift_reg <= {rx_shift_reg[6:0], miso};
            end
            else begin
                tx_shift_reg <= {tx_shift_reg[6:0], 1'b0};
                if (bit_count == 3'b111) begin
                    busy <= 1'b0;
                    active <= 1'b0;
                    rx_data <= {rx_shift_reg[6:0], miso};
                end
                bit_count <= bit_count + 1'b1;
            end
        end
    end
end

endmodule

module testbench;
    reg clk, rst, start;
    reg [7:0] tx_data;
    reg miso;
    wire sclk, mosi;
    wire busy;
    wire [7:0] rx_data;

    spi dut (
        .clk(clk),
        .rst(rst),
        .start(start),
        .tx_data(tx_data),
        .miso(miso),
        .sclk(sclk),
        .mosi(mosi),
        .busy(busy),
        .rx_data(rx_data)
    );

    initial begin
        $dumpfile(""spi.vcd"");
        $dumpvars(0, testbench);

        clk = 0;
        rst = 1;
        start = 0;
        tx_data = 0;
        miso = 0;

        #20 rst = 0;
        #10 tx_data = 8'hA5;
        #10 start = 1;
        #10 start = 0;
        miso = 1;

        #200;
        #10 tx_data = 8'h5A;
        #10 start = 1;
        #10 start = 0;
        miso = 0;

        #200 $finish;
    end

    always #5 clk = ~clk;

    initial begin
        $monitor(""Time=%0t rst=%b start=%b tx_data=%h rx_data=%h busy=%b"",
                 $time, rst, start, tx_data, rx_data, busy);
    end
endmodule",True,112,True,True,True,,0.0,,16.454078674316406,0.014487981796264648,"Design SPI master supporting mode 0 (CPOL=0, CPHA=0). Include SCLK generation, MOSI/MISO handling. Include testbench.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph TD
    CLK[Clock Input] --> CLKGEN(Clock Generator)
    RST[Reset] --> CTRL(Control Unit)
    START[Start] --> CTRL
    
    CLKGEN --> CTRL
    CLKGEN --> SCLK[SCLK Output]
    
    TXDATA[[TX Data Register]] --> SHIFTOUT(TX Shift Register)
    CTRL --> SHIFTOUT
    SHIFTOUT --> MOSI[MOSI Output]
    
    MISO[MISO Input] --> SHIFTIN(RX Shift Register)
    CTRL --> SHIFTIN
    SHIFTIN --> RXDATA[[RX Data Register]]
    
    CTRL --> BUSY[Busy Flag]
    
    DATAWIDTH[Data Width] --> CTRL
    CLK --> SHIFTOUT
    CLK --> SHIFTIN
    RST --> SHIFTOUT
    RST --> SHIFTIN
    
    TB_CLK[Test Clock] -.-> |Testbench|CLK
    TB_RST[Test Reset] -.-> |Testbench|RST
    TB_DATA[Test Data] -.-> |Testbench|TXDATA
    TB_START[Test Start] -.-> |Testbench|START
    MOSI -.-> |Testbench|TB_MOSI[Monitor MOSI]
    RXDATA -.-> |Testbench|TB_RX[Monitor RX]
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module spi_master #(
    parameter DATA_WIDTH = 8
)(
    input wire clk,
    input wire rst,
    input wire start,
    input wire [DATA_WIDTH-1:0] tx_data,
    input wire miso,
    output wire sclk,
    output wire mosi,
    output wire busy,
    output reg [DATA_WIDTH-1:0] rx_data
);

reg [DATA_WIDTH-1:0] tx_shift_reg;
reg [DATA_WIDTH-1:0] rx_shift_reg;
reg [3:0] bit_count;
reg sclk_reg;
reg busy_reg;
reg state;

localparam IDLE = 1'b0;
localparam TRANSMIT = 1'b1;

assign sclk = (state == TRANSMIT) ? sclk_reg : 1'b0;
assign mosi = tx_shift_reg[DATA_WIDTH-1];
assign busy = busy_reg;

always @(posedge clk or posedge rst) begin
    if (rst) begin
        state <= IDLE;
        sclk_reg <= 1'b0;
        busy_reg <= 1'b0;
        bit_count <= 4'd0;
        tx_shift_reg <= {DATA_WIDTH{1'b0}};
        rx_shift_reg <= {DATA_WIDTH{1'b0}};
        rx_data <= {DATA_WIDTH{1'b0}};
    end
    else begin
        case (state)
            IDLE: begin
                sclk_reg <= 1'b0;
                if (start) begin
                    state <= TRANSMIT;
                    busy_reg <= 1'b1;
                    tx_shift_reg <= tx_data;
                    bit_count <= DATA_WIDTH-1;
                end
            end
            
            TRANSMIT: begin
                sclk_reg <= ~sclk_reg;
                if (sclk_reg) begin
                    if (bit_count == 0) begin
                        state <= IDLE;
                        busy_reg <= 1'b0;
                        rx_data <= rx_shift_reg;
                    end
                    else begin
                        bit_count <= bit_count - 1'b1;
                    end
                    tx_shift_reg <= {tx_shift_reg[DATA_WIDTH-2:0], 1'b0};
                end
                else begin
                    rx_shift_reg <= {rx_shift_reg[DATA_WIDTH-2:0], miso};
                end
            end
        endcase
    end
end

endmodule

module spi_master_tb;
    parameter DATA_WIDTH = 8;
    
    reg clk;
    reg rst;
    reg start;
    reg [DATA_WIDTH-1:0] tx_data;
    reg miso;
    wire sclk;
    wire mosi;
    wire busy;
    wire [DATA_WIDTH-1:0] rx_data;
    
    spi_master #(
        .DATA_WIDTH(DATA_WIDTH)
    ) dut (
        .clk(clk),
        .rst(rst),
        .start(start),
        .tx_data(tx_data),
        .miso(miso),
        .sclk(sclk),
        .mosi(mosi),
        .busy(busy),
        .rx_data(rx_data)
    );
    
    initial begin
        $dumpfile(""spi_master.vcd"");
        $dumpvars(0, spi_master_tb);
        
        clk = 0;
        rst = 1;
        start = 0;
        tx_data = 0;
        miso = 0;
        
        #20 rst = 0;
        #20 tx_data = 8'hA5;
        #20 start = 1;
        #20 start = 0;
        
        #500 tx_data = 8'h5A;
        #20 start = 1;
        #20 start = 0;
        
        #500 $finish;
    end
    
    always #5 clk = ~clk;
    
    always @(posedge sclk) begin
        miso <= $random;
    end
    
    initial begin
        $monitor(""Time=%0t rst=%b start=%b tx_data=%h rx_data=%h busy=%b"",
                 $time, rst, start, tx_data, rx_data, busy);
    end
endmodule",True,135,False,True,True,,0.0,,13.274701356887817,0.015692949295043945,prompt_only,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
combined,Protocol,complex,"Design SPI master supporting mode 0 (CPOL=0, CPHA=0). Include SCLK generation, MOSI/MISO handling. Include testbench.",gpt-4o,"`timescale 1ns/1ps

module spi_master(
    input wire clk,
    input wire rst_n,
    input wire miso,
    input wire start,
    input wire [7:0] data_in,
    output reg mosi,
    output reg sclk,
    output reg [7:0] data_out,
    output reg done
);

reg [2:0] bit_count;
reg [7:0] shift_reg;
reg state;

parameter IDLE = 1'b0, TRANSFER = 1'b1;

always @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
        sclk <= 1'b0;
        mosi <= 1'b0;
        data_out <= 8'b0;
        done <= 1'b0;
        bit_count <= 3'b0;
        shift_reg <= 8'b0;
        state <= IDLE;
    end else begin
        case (state)
            IDLE: begin
                if (start) begin
                    shift_reg <= data_in;
                    bit_count <= 3'b0;
                    done <= 1'b0;
                    state <= TRANSFER;
                end
            end
            
            TRANSFER: begin
                sclk <= ~sclk;
                if (!sclk) begin
                    mosi <= shift_reg[7];
                    shift_reg <= {shift_reg[6:0], miso};
                    bit_count <= bit_count + 1'b1;
                    
                    if (bit_count == 3'b111) begin
                        done <= 1'b1;
                        data_out <= {shift_reg[6:0], miso};
                        state <= IDLE;
                    end
                end
            end
        endcase
    end
end

endmodule

module testbench;
    reg clk, rst_n, miso, start;
    reg [7:0] data_in;
    wire mosi, sclk, done;
    wire [7:0] data_out;
    
    spi_master dut (
        .clk(clk),
        .rst_n(rst_n),
        .miso(miso),
        .start(start),
        .data_in(data_in),
        .mosi(mosi),
        .sclk(sclk),
        .data_out(data_out),
        .done(done)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst_n = 1'b0;
        start = 1'b0;
        miso = 1'b0;
        data_in = 8'b10101010;
        
        #20 rst_n = 1'b1;
        #10 start = 1'b1;
        #160 start = 1'b0;
        #50 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t clk=%b rst_n=%b start=%b miso=%b mosi=%b sclk=%b data_in=%b data_out=%b done=%b"", 
                 $time, clk, rst_n, start, miso, mosi, sclk, data_in, data_out, done);
    end
endmodule",True,101,True,True,True,True,0.9,True,11.149885654449463,11.3598473072052,"graph LR
    CLK[Clock] --> SCLK_GEN(SCLK Generator)
    RST[Reset] --> CTRL(Controller)
    CTRL --> SCLK_GEN
    SCLK_GEN --> SCLK[SCLK Output]

    DATA_IN[MOSI Input] --> SHIFT_REG(SPI Shift Register)
    SHIFT_REG --> MOSI[MOSI Output]
    MISO_INPUT[MISO Input] --> SHIFT_REG
    SHIFT_REG --> DATA_OUT[MISO Output]

    CTRL --> SHIFT_REG
    TESTBENCH(Testbench) --> CLK
    TESTBENCH --> RST
    TESTBENCH --> DATA_IN
    TESTBENCH --> MISO_INPUT
    TESTBENCH --> CTRL
    TESTBENCH --> SCLK
    MOSI --> TESTBENCH
    DATA_OUT --> TESTBENCH","`timescale 1ns/1ps

module sclk_generator(
    input wire clk,
    input wire rst,
    input wire ctrl,
    output reg sclk
);
    always @(posedge clk or posedge rst) begin
        if (rst)
            sclk <= 1'b0;
        else
            sclk <= ctrl;
    end
endmodule

module spi_shift_register(
    input wire clk,
    input wire rst,
    input wire ctrl,
    input wire mosi_in,
    input wire miso_in,
    output reg mosi_out,
    output reg miso_out
);
    reg mosi_reg;
    reg miso_reg;

    always @(posedge clk or posedge rst) begin
        if (rst) begin
            mosi_reg <= 1'b0;
            miso_reg <= 1'b0;
        end else if (ctrl) begin
            mosi_reg <= mosi_in;
            miso_reg <= miso_in;
        end
    end

    always @(*) begin
        mosi_out = mosi_reg;
        miso_out = miso_reg;
    end
endmodule

module controller(
    input wire rst,
    output reg ctrl
);
    always @(*) begin
        ctrl = ~rst;
    end
endmodule

module testbench;
    reg clk, rst;
    reg mosi_in, miso_in;
    wire sclk, ctrl;
    wire mosi_out, miso_out;
    
    sclk_generator sclk_gen_inst (
        .clk(clk),
        .rst(rst),
        .ctrl(ctrl),
        .sclk(sclk)
    );
    
    spi_shift_register shift_reg_inst (
        .clk(clk),
        .rst(rst),
        .ctrl(ctrl),
        .mosi_in(mosi_in),
        .miso_in(miso_in),
        .mosi_out(mosi_out),
        .miso_out(miso_out)
    );
    
    controller ctrl_inst (
        .rst(rst),
        .ctrl(ctrl)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst = 1'b1;
        mosi_in = 1'b0;
        miso_in = 1'b0;
        
        #20 rst = 1'b0;
        #100 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t clk=%b rst=%b mosi_in=%b miso_in=%b mosi_out=%b miso_out=%b"", 
                 $time, clk, rst, mosi_in, miso_in, mosi_out, miso_out);
    end
endmodule",True,101,True,True,True,True,0.9,True,12.233871459960938,10.101450681686401,"Design SPI master supporting mode 0 (CPOL=0, CPHA=0). Include SCLK generation, MOSI/MISO handling. Include testbench.

Here is the Mermaid diagram specification for this circuit:

```mermaid
graph LR
    CLK[Clock] --> SCLK_GEN(SCLK Generator)
    RST[Reset] --> CTRL(Controller)
    CTRL --> SCLK_GEN
    SCLK_GEN --> SCLK[SCLK Output]

    DATA_IN[MOSI Input] --> SHIFT_REG(SPI Shift Register)
    SHIFT_REG --> MOSI[MOSI Output]
    MISO_INPUT[MISO Input] --> SHIFT_REG
    SHIFT_REG --> DATA_OUT[MISO Output]

    CTRL --> SHIFT_REG
    TESTBENCH(Testbench) --> CLK
    TESTBENCH --> RST
    TESTBENCH --> DATA_IN
    TESTBENCH --> MISO_INPUT
    TESTBENCH --> CTRL
    TESTBENCH --> SCLK
    MOSI --> TESTBENCH
    DATA_OUT --> TESTBENCH
```

Generate Verilog code that implements this exact architecture shown in the Mermaid diagram.","`timescale 1ns/1ps

module spi_master(
    input wire clk,
    input wire rst,
    input wire mosi_in,
    input wire miso_in,
    output wire mosi_out,
    output wire miso_out,
    output wire sclk
);

    reg [7:0] shift_reg;
    reg sclk_reg;
    reg [2:0] ctrl_state;

    assign mosi_out = shift_reg[7];
    assign miso_out = shift_reg[0];
    assign sclk = sclk_reg;
    
    always @(posedge clk or posedge rst) begin
        if (rst) begin
            sclk_reg <= 1'b0;
            shift_reg <= 8'b0;
            ctrl_state <= 3'b0;
        end else begin
            case (ctrl_state)
                3'b000: begin
                    sclk_reg <= 1'b0;
                    shift_reg <= {shift_reg[6:0], miso_in};
                    ctrl_state <= 3'b001;
                end
                3'b001: begin
                    sclk_reg <= 1'b1;
                    ctrl_state <= 3'b010;
                end
                3'b010: begin
                    sclk_reg <= 1'b0;
                    shift_reg <= {shift_reg[6:0], miso_in};
                    ctrl_state <= 3'b011;
                end
                3'b011: begin
                    sclk_reg <= 1'b1;
                    ctrl_state <= 3'b100;
                end
                3'b100: begin
                    sclk_reg <= 1'b0;
                    shift_reg <= {shift_reg[6:0], miso_in};
                    ctrl_state <= 3'b101;
                end
                3'b101: begin
                    sclk_reg <= 1'b1;
                    ctrl_state <= 3'b110;
                end
                3'b110: begin
                    sclk_reg <= 1'b0;
                    shift_reg <= {shift_reg[6:0], miso_in};
                    ctrl_state <= 3'b111;
                end
                3'b111: begin
                    sclk_reg <= 1'b1;
                    ctrl_state <= 3'b000;
                end
            endcase
        end
    end

endmodule

module testbench;
    reg clk, rst, mosi_in, miso_in;
    wire mosi_out, miso_out, sclk;
    
    spi_master dut (
        .clk(clk),
        .rst(rst),
        .mosi_in(mosi_in),
        .miso_in(miso_in),
        .mosi_out(mosi_out),
        .miso_out(miso_out),
        .sclk(sclk)
    );
    
    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars(0, testbench);
        
        clk = 1'b0;
        rst = 1'b1;
        mosi_in = 1'b0;
        miso_in = 1'b0;
        
        #20 rst = 1'b0;
        #100 $finish;
    end
    
    always #5 clk = ~clk;
    
    initial begin
        $monitor(""Time=%0t clk=%b rst=%b mosi_in=%b miso_in=%b mosi_out=%b miso_out=%b sclk=%b"", 
                 $time, clk, rst, mosi_in, miso_in, mosi_out, miso_out, sclk);
    end
endmodule",True,103,True,True,True,True,0.9,True,12.332215547561646,6.168227910995483,prompt_only,prompt_only > mermaid_only > combined,prompt_only > mermaid_only > combined
